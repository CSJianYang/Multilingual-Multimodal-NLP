[
    {
        "title": "Permutations II",
        "question_content": "Given a collection of numbers, nums,&nbsp;that might contain duplicates, return all possible unique permutations in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10",
        "solutions": [
            {
                "id": 18594,
                "title": "really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote",
                "content": "Use an extra boolean array \" boolean[] used\"  to indicate whether the value is added to list. \\n\\nSort the array \"int[] nums\" to make sure we can skip the same value.\\n\\nwhen a number has the same value with its previous, we can use this number only if his previous is used\\n \\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }\\n    \\n        public void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res){\\n            if(list.size()==nums.length){\\n                res.add(new ArrayList<Integer>(list));\\n                return;\\n            }\\n            for(int i=0;i<nums.length;i++){\\n                if(used[i]) continue;\\n                if(i>0 &&nums[i-1]==nums[i] && !used[i-1]) continue;\\n                used[i]=true;\\n                list.add(nums[i]);\\n                dfs(nums,used,list,res);\\n                used[i]=false;\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            if(nums==null || nums.length==0) return res;\\n            boolean[] used = new boolean[nums.length];\\n            List<Integer> list = new ArrayList<Integer>();\\n            Arrays.sort(nums);\\n            dfs(nums, used, list, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18596,
                "title": "a-simple-c-solution-in-only-20-lines",
                "content": "    class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18602,
                "title": "9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others",
                "content": "Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number after any of its duplicates.\\n\\n    def permuteUnique(self, nums):\\n        ans = [[]]\\n        for n in nums:\\n            new_ans = []\\n            for l in ans:\\n                for i in xrange(len(l)+1):\\n                    new_ans.append(l[:i]+[n]+l[i:])\\n                    if i<len(l) and l[i]==n: break              #handles duplication\\n            ans = new_ans\\n        return ans\\n\\t\\t\\n\\nBelow is a backtracking solution:\\n```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    from collections import Counter\\n    def permuteUnique(self, nums):\\n        def btrack(path, counter):\\n            if len(path)==len(nums):\\n                ans.append(path[:])\\n            for x in counter:  # dont pick duplicates\\n                if counter[x] > 0:\\n                    path.append(x)\\n                    counter[x] -= 1\\n                    btrack(path, counter)\\n                    path.pop()\\n                    counter[x] += 1\\n        ans = []\\n        btrack([], Counter(nums))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18648,
                "title": "share-my-java-code-with-detailed-explanantion",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }\\n            permute(ans, nums, 0);\\n            return ans;\\n        }\\n        \\n        private void permute(List<List<Integer>> ans, int[] nums, int index) {\\n            if (index == nums.length) { \\n                List<Integer> temp = new ArrayList<>();\\n                for (int num: nums) { temp.add(num); }\\n                ans.add(temp);\\n                return;\\n            }\\n            Set<Integer> appeared = new HashSet<>();\\n            for (int i=index; i<nums.length; ++i) {\\n                if (appeared.add(nums[i])) {\\n                    swap(nums, index, i);\\n                    permute(ans, nums, index+1);\\n                    swap(nums, index, i);\\n                }\\n            }\\n        }\\n        \\n        private void swap(int[] nums, int i, int j) {\\n            int save = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = save;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums==null || nums.length==0) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 18632,
                "title": "short-40ms-c-solution-similar-to-permutation-i-solution",
                "content": "This is like the Permutation I solution, but we use an unordered_set to avoid swapping elements that are the same (which would generate identical permutations).\\n\\n    class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }\\n            unordered_set<int> st;\\n            for (int j = i; j < nums.size(); ++j) {\\n                if (st.count(nums[j]) == 1) { continue; }\\n                st.insert(nums[j]);\\n                std::swap(nums[i], nums[j]);\\n                permuteUniqueHelper(i + 1, nums, result);\\n                std::swap(nums[i], nums[j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int> > result;\\n            permuteUniqueHelper(0, nums, result);\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void permuteUniqueHelper(int i, vector<int>& nums, vector<vector<int> >& result) {\\n            if (i == nums.size()) { result.emplace_back(nums); return; }",
                "codeTag": "Java"
            },
            {
                "id": 18649,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef permuteUnique(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, [], res)\\n    return res\\n    \\ndef dfs(self, nums, path, res):\\n    if not nums:\\n        res.append(path)\\n    for i in xrange(len(nums)):\\n        if i > 0 and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933190,
                "title": "c-4-different-solutions-with-explanations-and-tips",
                "content": "**First solution**\\nStarting with the simplest solution using `std::next_permutation`. This may not be acceptable in a 1:1 interview, but it\\'s a good start. If you are doing a technical evaluation, this may be acceptable. Note that I\\'m sorting the elements as `std::next_permutation` returns `false` once it reaches the last lexicographically sorted permutation.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Second Solution**\\nIn the previous solution, I used `std::sort` which increases the time complexity, but it\\'s not entirely necessary. We could simply record the initial state of the array and keep generating the next permutation until we completed a cycle. To provide an acceptable solution for this approach, I implemented `next_permutation` myself. The great thing about this solution is that it solves 4 different problems that I know of: [Permutations I](https://leetcode.com/problems/permutations/), [Permutation II](https://leetcode.com/problems/permutations-ii/), [Next Permutation problem](https://leetcode.com/problems/next-permutation/), and [Next Greater Element iii](https://leetcode.com/problems/next-greater-element-iii/) so it\\'s worth practicing it.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\\n\\n**Third Solution**\\nMy intuition to solving this problem was using a similar solution to the [Permutations problem](https://leetcode.com/problems/permutations/) but skipping iterations for duplicate numbers. In order to do that I had to sort the array first. That approach on its own wasn\\'t enough. Swapping numbers twice proved to be challenging. To prevent duplicates, I ended up removing the second swap and passing the array by value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\\n\\n**Fourth solution**\\nBacktracking using a hash table. This is the same solution you\\'d find in the `Solution` tab. The key insight here is that by iterating through unique numbers, we can avoid duplication. If you practice the [Permutations problem](https://leetcode.com/problems/permutations/) first, identifying this solution might be challenging, but it\\'s easy enough to understand when you consider it on its own.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n\\t\\t\\n        vector<vector<int>> output;\\n        output.emplace_back(nums);\\n        while (next_permutation(begin(nums), end(nums))) {\\n            output.emplace_back(nums);\\n        }\\n        return output;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int> initial_state(nums);\\n        vector<vector<int>> output;\\n        do {\\n            output.emplace_back(nums);\\n            nextPermutation(nums);\\n        } while (nums != initial_state);\\n        return output;\\n    }\\nprivate:\\n    void nextPermutation(vector<int>& nums) {\\n        if (size(nums) <= 1) return;\\n        auto pos = 0;\\n        for (int i = size(nums) - 2; i >= 0; --i) {\\n            if (nums[i] < nums[i + 1]) {\\n                pos = i;\\n                break;\\n            }\\n        }\\n        for (int i = size(nums) - 1; i >= pos; --i) {\\n            if (nums[pos] < nums[i]) {\\n                swap(nums[i], nums[pos]);\\n                ++pos;\\n                break;\\n            }\\n        }\\n        reverse(begin(nums) + pos, end(nums));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        sort(begin(nums), end(nums));\\n        generatePermutations(nums, output, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(vector<int> nums, vector<vector<int>>& output, int idx) {\\n        if (idx == size(nums)) {\\n            output.emplace_back(nums);\\n        }\\n        for (int i = idx; i < size(nums); ++i) {\\n            if (i != idx && nums[i] == nums[idx]) continue;\\n            swap(nums[i], nums[idx]);\\n            generatePermutations(nums, output, idx + 1);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> curr;\\n        unordered_map<int, int> counter;\\n        for (auto x : nums) ++counter[x];\\n        generatePermutations(counter, curr, output, size(nums));\\n        return output;\\n    }\\nprivate:\\n    void generatePermutations(unordered_map<int, int>& counter, vector<int>& curr, vector<vector<int>>& output, int n) {\\n        if (size(curr) == n) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (auto [key, value] : counter) {\\n            if (value == 0) continue;\\n            curr.emplace_back(key); --counter[key];\\n            generatePermutations(counter, curr, output, n);\\n            curr.pop_back(); ++counter[key];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189116,
                "title": "summarization-of-permutations-i-and-ii-python",
                "content": "Recall Permutation I, where there is no duplicate. \nThe basic idea was to enumerate all possibilities of the first element, and recursively permute the remaining, then concatenate. \n\nFor example: 123\nlet 1 be the first element, recursively permute 23\nlet 2 be the first element, recursively permute 13\nlet 3 be the first element, recursively permute 12\n\nI'll show two versions here; a more intutive recursion and less intutive (I think) backtracking \n\n```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n\nNow consider the case where there are duplicates in `nums`. \nThe idea is still the same. except we only put the duplicated element in the front once. \n\nFor example, 11223\nlet 1 be the first element, recursively permute 1223\nlet 2 be the first element, recursively permute 1123\nlet 3 be the first element, recursively permute 1122\n\nHow to adapt the previous code to take care of duplicates? \nWe can simply pick out the unique element, and recursively permute the remainining.\n\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n\nAll the above solutions don't require the nums to be sorted first. \nIf we sort nums first, we can have a more elegant solution as posted here: \nhttps://leetcode.com/problems/permutations-ii/discuss/18596/A-simple-C%2B%2B-solution-in-only-20-lines\n\nThe original post was in C++, here I reproduce in Python: \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n\nThis code may be less intutive at first glance, since it's different from usual backtracking: it swaps nums[l] and nums[i] before backtracking, but didn't swap them back afterwards! This is exactly the elegance of this solution. This is exactly implementing \"pick the unique and permute the remaining\". To see this, the k-th swap always does the following, swap the first appearance of the k-th largest value with the first value, which is the (k-1)-th largest value. This way the subarray passed on is maintained sorted! \nFor example:\n\n112233\n1st swap, 1 with itself, 1**12233**\n2nd swap, 1 with 2, 2**11233**\n3rd swap, 2 with 3, 3**11223**\nThe bolded part is always sorted. So this invariance is nicely maintained in this implementation. \n\nNote in the above implementation, we have to pass in the value of nums by passing in list(nums). We can avoid that by recover the array afterwards. This is easy since after all the swaps in the for loop, the array looks like, e.g., this:\n\n311223\n\nIt is rotated by one position. We can simply rotate it back! \n(this solution was also posted in that thread by dyp) \n\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "solutionTags": [],
                "code": "```\n# intuitive recursion\nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return [[]]\n        res = []\n        for i in range(n):\n            for p in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + p)\n        return res\n```\n```\n# backtracking \nclass Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                nums[l], nums[i] = nums[i], nums[l]   # swap nums[l] and nums[i]\n                dfs(l+1)\n                nums[l], nums[i] = nums[i], nums[l]  # swap them back\n        dfs(0)\n        return res\n```\n```\n# intuitive recursion (beat 60.77%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) == 0:\n            return [[]]\n        res = []\n        for i in set(nums):\n            remaining = list(nums)\n            remaining.remove(i)\n            for p in self.permuteUnique(remaining):\n                res.append([i] + p)\n        return res\n```\n```\n# backtracking  (beat 94.13%) \nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in set(nums[l:]):\n                remaining = nums[l:]\n                remaining.remove(i)\n                dfs(nums[:l] + [i] + remaining, l+1)\n        dfs(nums, 0)\n        return res\n\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap nums[l] and nums[i]\n                dfs(list(nums), l+1)  # it's important to pass the value of nums, not reference \n        nums.sort()\n        dfs(nums, 0)\n        return res\n```\n```\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        n = len(nums)\n        res = []\n        def rotate(nums, l):\n            tmp = nums[l]\n            i = l + 1\n            while i < n:\n                nums[i-1] = nums[i]\n                i += 1\n            nums[-1] = tmp\n            \n        def dfs(nums, l):\n            if l == n-1:\n                res.append(list(nums))\n                return \n            for i in range(l, n):\n                if i > l and nums[i] == nums[l]: continue\n                nums[l], nums[i] = nums[i], nums[l]  # swap\n                dfs(nums, l+1)  # note now we're passing by reference\n            # recover\n            rotate(nums, l)\n        nums.sort()\n        dfs(nums, 0)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 18628,
                "title": "accepted-backtracking-c-solution-by-using-map-28ms",
                "content": "I see most solutions are using next permutation. That's great and only uses O(1) space.\\n\\nAnyway I am sharing backtracking solution which uses O(n) space. This is actually a typical backtracking problem. We can use hash map to check whether the element was already taken. However, we could get TLE if we check vector<int> num every time. So we iterate the hash map instead.\\n\\n    class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }\\n        permuteUnique(v, r, map, num.size());\\n        return v;\\n    }\\n    \\n    void permuteUnique(vector<vector<int>> &v, vector<int> &r, map<int, int> &map, int n)\\n    {\\n        if (n <= 0)\\n        {\\n            v.push_back(r);\\n            return;\\n        }\\n        for (auto &p : map)\\n        {\\n            if (p.second <= 0) continue;\\n            p.second--;\\n            r.push_back(p.first);\\n            permuteUnique(v, r, map, n - 1);\\n            r.pop_back();\\n            p.second++;\\n        }\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        vector<vector<int>> v;\\n        vector<int> r;\\n        map<int, int> map;\\n        for (int i : num)\\n        {\\n            if (map.find(i) == map.end()) map[i] = 0;\\n            map[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18604,
                "title": "a-non-recursive-c-implementation-with-o-1-space-cost",
                "content": "    class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tif(i == 0){\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\n    \\t\\t\\tfor (j=S.size()-1; j>i-1; j--){\\n    \\t\\t\\t\\tif (S[j]>S[i-1]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\t\\t\\t\\t\\t\\n    \\t\\t\\tswap(S[i-1], S[j]);\\n    \\t\\t\\treverse(S, i, S.size()-1);\\n    \\t\\t\\tres.push_back(S);\\n    \\t\\t}\\n    \\t\\treturn res;\\n        }\\n    \\tvoid reverse(vector<int> &S, int s, int e){\\t\\t\\n    \\t\\twhile (s<e){\\n    \\t\\t\\tswap(S[s++], S[e--]);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tvector<vector<int> > res;\\n    };\\n\\nBasically, assume we have \"1234\", the idea is to increase the number in ascending order, so next is \"1243\", next is \"1324\", and so on.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > permuteUnique(vector<int> &S) {\\n    \\t\\t// res.clear();\\n    \\t\\tsort(S.begin(), S.end());\\t\\t\\n    \\t\\tres.push_back(S);\\n    \\t\\tint j;\\n    \\t\\tint i = S.size()-1;\\n    \\t\\twhile (1){\\n    \\t\\t\\tfor (i=S.size()-1; i>0; i--){\\n    \\t\\t\\t\\tif (S[i-1]< S[i]){\\n    \\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 18669,
                "title": "c-backtracking-and-nextpermutation",
                "content": "**Backtracking**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Next Permutation**\\n\\nBesides backtracking, you may also solve it using [Next Permutation](https://leetcode.com/problems/next-permutation/): computing the next permutation and add it to the result until it becomes the original array. To know when `nextPermutation` should stop, we sort `nums` in ascending order and stop when it becomes in descending order.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        permute(nums, 0, perms);\\n        return perms;\\n    }\\nprivate:\\n    void permute(vector<int> nums, int i, vector<vector<int>>& perms) {\\n        if (i == nums.size()) {\\n            perms.push_back(nums);\\n        } else {\\n            for (int j = i; j < nums.size(); j++) {\\n                if (j == i || nums[j] != nums[i]) {\\n                    swap(nums[i], nums[j]);\\n                    permute(nums, i + 1, perms);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> perms;\\n        do {\\n            perms.push_back(nums);\\n        } while(nextPermutation(nums));\\n        return perms;\\n    }\\nprivate:\\n    bool nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), i, j;\\n        for (i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                break;\\n            }\\n        }\\n        if (i < 0) {\\n            reverse(nums.begin(), nums.end());\\n            return false;\\n        } else {\\n            for (j = n - 1; j > i; j--) {\\n                if (nums[j] > nums[i]) {\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin() + i + 1, nums.end());\\n            return true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214219,
                "title": "best-c-3-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!*KlogK), In worst case when all element of Array(nums) will different then there will\\n    be N! permutations and N! function calls and for every permutation we have to check in Hash Table(set) for\\n    inserting which take O(KlogK) time .Where N is the size of the array(nums) and ! stands for factorial. K is\\n    the worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking + Hash Table(set). \\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, set<vector<int>>& set, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            set.insert(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            permuteUnique(nums, set, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        set<vector<int>> set;\\n        permuteUnique(nums, set, temp, 0);\\n        for(auto it : set){\\n            output.push_back(it);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!*K), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls and for every permutation we have to check in Array(output) for\\n    duplicated which take O(K) time .Where N is the size of the array(nums) and ! stands for factorial. K is the\\n    worst case size of Array(output). \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, int index){\\n        if(index == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<temp.size(); i++){\\n            swap(temp[index], temp[i]);\\n            bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n            if(isPresent){\\n                continue;\\n            }\\n            permuteUnique(nums, output, temp, index+1);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        permuteUnique(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N!), In worst case when all element of Array(nums) will different then there will be N!\\n    permutations and N! function calls. Where N is the size of the array(nums) and ! stands for factorial. \\n\\n    Space Complexity: O(N!*N), In worst case when all element of Array(nums) will different, since we have to\\n    store all the possible solutions which are N! in size where N is the size of the array and ! stands for\\n    factorial.\\n\\n    Solved using Array + BackTracking. \\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void permuteUnique(vector<int>& nums, vector<vector<int>>& output, vector<int> temp, vector<bool>& visited){\\n        if(temp.size() == nums.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(visited[i] || i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;\\n            visited[i] = true;\\n            temp.push_back(nums[i]);\\n            permuteUnique(nums, output, temp, visited);\\n            temp.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        vector<bool> visited(nums.size(), 0); \\n        permuteUnique(nums, output, temp, visited);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030416,
                "title": "python-simple-backtrack-beats-90",
                "content": "The problem is solved using a backtracking approach. For this particular case, as we have duplicates in input, we can  track the count of each number.  Python provides a built-in lib `Counter` which I will be using for this problem. As the order of output results doesn\\'t matter, we can use this `Counter` variable to track visited elements in the exploration path\\n\\nThe solution Tree for this problem for an input `[1,1,2]` would look like this:\\n\\n<img width=\"400\" src=\"https://assets.leetcode.com/users/images/c7ae7036-ae8b-4d79-aca7-8950a2750a27_1652316056.5212104.jpeg\">\\n\\nBelow is the code that will represent the above solution tree\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```\\n**Space** - `O(N)` - Each call stack depth would be `N` where `N` is the length of input list.\\n**Time** - `O(n * \\u03A3(P(N, k)))` - In worst case, all numbers in the input array will be unique. In this case, each path will go upto `N` depth in solution tree. At each level, the branching factor is reduced by `1` so it will go like `N, N-1, N-2...1` starting from root.  (Time complexity shared by [@AntonBelski](https://leetcode.com/AntonBelski/))\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        permutations = []\\n        counter = Counter(nums)\\n        def findAllPermutations(res):\\n            if len(res) == len(nums):\\n                permutations.append(res)\\n                return \\n            \\n            for key in counter:\\n                if counter[key]:\\n                    counter[key]-=1 # decrement visited key\\n                    findAllPermutations(res + [key])    \\n                    counter[key]+=1 # restore the state of visited key to find the next path\\n                \\n        findAllPermutations([])\\n        return permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18616,
                "title": "6-lines-python-ruby",
                "content": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Build the list of permutations one number at a time, insert the number into each already built permutation but only **before** other instances of the same number, never after. Inspired by [cbmbbz's already good solution](https://leetcode.com/discuss/77245/line-python-solution-with-line-handle-duplication-beat-others), though I then saw others had used the idea earlier.\\n\\n---\\n\\nPython solution\\n-\\n\\nTo find the last index for inserting new number `n` into old permutation `p`, I search for previous instances of `n` in `p`. But because `index` throws an exception if unsuccessful, I add a [sentinel](https://en.wikipedia.org/wiki/Sentinel_value) `n` at the end (which is the appropriate last insertion index then).\\n\\n    def permuteUnique(self, nums):\\n        perms = [[]]\\n        for n in nums:\\n            perms = [p[:i] + [n] + p[i:]\\n                     for p in perms\\n                     for i in xrange((p + [n]).index(n) + 1)]\\n        return perms\\n\\nOr as \"one-liner\" using `reduce`:\\n\\n    def permuteUnique(self, nums):\\n        return reduce(lambda perms, n: [p[:i] + [n] + p[i:]\\n                                        for p in perms\\n                                        for i in xrange((p + [n]).index(n) + 1)],\\n                      nums, [[]])\\n\\n---\\n\\nRuby solution\\n-\\n\\n    def permute_unique(nums)\\n      nums.reduce([[]]) { |perms, n|\\n        perms.flat_map { |p|\\n          last = p.index(n) || p.size\\n          (0..last).map { |i| p[0,i] + [n] + p[i..-1] }\\n        }\\n      }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 562948,
                "title": "c-backtracking-24ms-with-explainations-about-remove-duplicates",
                "content": "I have to talk a little more about how I come up with this.\\nThere is difference between \"Combination/Subset\" and \"Permutation\".\\nFor example:[1,2,3], Combination only has [1,2,3]. Permutations includes[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1].\\n[**1.Combination Sum**](https://leetcode.com/problems/combination-sum/)\\nBecause it is combination, so [1,2,3] and [3,2,1] are duplicates.\\nIf we take [1,5,2,3] as an example, when we iterate to index 2 where value is 2, it makes no sense to start before index 2, because [1,5,2] and [2,1,5] are the same.\\nThat\\'s the meaning ```i_start```(or ```begin```) has,\\nand **this ```begin``` may make sense in other questions, we should keep it in mind**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**2.Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nWhat about the duplicates caused from the duplicate numbers in input?\\nWe ```sort``` them first. and then take ```1122333``` as an example.\\nIf we meet ```11```, we will have these choice at this level(or layer or depth).\\n```11```\\n```2 || 2 || 3 || 3 || 3```\\nApparently, the second ```2``` and the 2nd & 3rd ```3``` will induce duplicate solutions, because we use DFS and these solutions have been computed in the path ```112(first \\'2\\')``` or ```113(first\\'3\\')```.\\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\\nThat\\'s why ```num[i]==num[i-1]```.\\nSo why ```i>begin```?\\nIf we go further, we will meet ```112```, we will have these choice at this level.\\n```112```\\n```2 || 3 || 3 || 3```\\nSurely, we are not willing to skip the first```2```at beginning of this level.\\nThat\\'s why ```i>begin```.\\nSo we use ```i>begin && num[i]==num[i-1]```.\\nIn short, to remove the second part duplicates, we have to **sort the array first, and then skip the same value at each level**.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n[**3.Permutations**](https://leetcode.com/problems/permutations/)\\nUnder this question, [1,2,3] and [3,2,1] are different.\\nSo **we have to iterate from 0 in each iteration rather than start from ```begin```.**\\nWhat about numbers we have used? We can mark them like **array ```visited```** in BFS.\\nIf we have used it, we should skip it. And we should keep this in mind.\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\n**4.Permutations II**\\nNow, it is time to talk about this problem.\\nYou can find both some similarities and some difference bettwen Combination Sum with Permutations, Combination Sum II with Permutations II.\\nIt is difficult for me to put it clear in English, but I wish you can find the similarities and difference.\\nAs we make use of the solution to Combination Sum in Combination Sum II, we also can make use of the array ```visited``` in Permutations.\\nAnd we just need to **skip same value at each level(or layer or depth)**, what should we do?\\nBecause it is problem about permutation, so we have to iterate from 0, resulting in using array ```visited```.\\n**The level should include every number in array ```nums``` which has not been visited.**\\nAnd like what we do in Combination Sum II, we skip same value at each level to remove duplicates.\\nWe have to iterate from 0, so i-1>=0, --> i>0.\\nSo we use ```(i && !_visited[i-1] && nums[i]==nums[i-1])```.\\nWhy ```!_visited[i-1]```? If ```nums[i-1]```has been visited, it is not the value at this level.\\nSolution:\\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\\nThere are more problems, wish you can find some similarities.\\n[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```i_start```\n```begin```\n```begin```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& combination, int target, int i_start){\\n\\t\\tif(target == 0){\\n\\t\\t\\t_res.push_back(combination);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = i_start; i < candidates.size();++i){//i_start is important to remove duplicates under the situation\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcombination.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, combination, target - candidates[i], i);\\n\\t\\t\\t\\tcombination.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n    vector<vector<int>> combinationSum(const vector<int>& candidates, int target) {\\n\\t\\tvector<int> combination;\\n\\t\\tDFS(candidates, combination, target,0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```sort```\n```1122333```\n```11```\n```11```\n```2 || 2 || 3 || 3 || 3```\n```2```\n```3```\n```112(first \\'2\\')```\n```113(first\\'3\\')```\n```\\n\\u2193If we choose first 2,                          \\u2193If we choose second 2,\\n      112                                                  112\\n2 || 3 || 3 || 3                                        3 || 3 || 3\\n```\n```num[i]==num[i-1]```\n```i>begin```\n```112```\n```112```\n```2 || 3 || 3 || 3```\n```2```\n```i>begin```\n```i>begin && num[i]==num[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvoid DFS(const vector<int>& candidates, vector<int>& cur, int target, int begin){\\n\\t\\tif(target == 0)\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\tfor (int i = begin; i < candidates.size();++i){//begin is to remove first part of duplicates, which plays the same role in problem Combination Sum.\\n\\t\\t\\tif(i > begin && candidates[i] == candidates[i-1])//this means to remove the second part of duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(target - candidates[i] >= 0){\\n\\t\\t\\t\\tcur.push_back(candidates[i]);\\n\\t\\t\\t\\tDFS(candidates, cur, target - candidates[i], i + 1);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\t\\tsort(candidates.begin(), candidates.end());//this helps to remove the second part of duplicates\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(candidates, cur, target, 0);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```begin```\n```visited```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because of it is permutation, we have to start from 0 in each iteration\\n\\t\\t\\tif(!_visited[i]){//the visited array\\n\\t\\t\\t\\t_visited[i] = true;\\n\\t\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t_visited[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```\n```visited```\n```visited```\n```nums```\n```(i && !_visited[i-1] && nums[i]==nums[i-1])```\n```!_visited[i-1]```\n```nums[i-1]```\n```\\nclass Solution {\\nprivate:\\n\\tvector<vector<int>> _res;\\n\\tvector<bool> _visited;\\n\\tvoid DFS(const vector<int>& nums, vector<int>& cur){\\n\\t\\tif(cur.size()==nums.size()){\\n\\t\\t\\t_res.push_back(cur);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < nums.size();++i){//because it is a problem about permutation, we have to iterate from 0.\\n\\t\\t\\tif(_visited[i])//1st step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif(i && !_visited[i-1] && nums[i]==nums[i-1])//2nd step to remove duplicates\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t_visited[i] = true;\\n\\t\\t\\tcur.push_back(nums[i]);\\n\\t\\t\\tDFS(nums, cur);\\n\\t\\t\\tcur.pop_back();\\n\\t\\t\\t_visited[i] = false;\\n\\t\\t}\\n\\t}\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n\\t\\tsort(nums.begin(), nums.end());//help to remove duplicates\\n\\t\\t_visited.resize(nums.size(), false);\\n\\t\\tvector<int> cur;\\n\\t\\tDFS(nums, cur);\\n\\t\\treturn _res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18724,
                "title": "share-my-recursive-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }\\n        \\n        private void permute(List<List<Integer>> result, List<Integer> current, int[] num, boolean[] visited) {\\n            if (current.size() == num.length) {\\n                result.add(new ArrayList<Integer>(current));\\n                return;\\n            }\\n            for (int i=0; i<visited.length; i++) {\\n                if (!visited[i]) {\\n                    if (i > 0 && num[i] == num[i-1] && visited[i-1]) {\\n                        return;\\n                    }\\n                    visited[i] = true;\\n                    current.add(num[i]);\\n                    permute(result, current, num, visited);\\n                    current.remove(current.size()-1);\\n                    visited[i] = false;\\n                }\\n            }\\n        }\\n    }\\n\\nThe idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return!",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Arrays.sort(num);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            List<Integer> current = new ArrayList<Integer>();\\n            boolean[] visited = new boolean[num.length];\\n            permute(result, current, num, visited);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 18601,
                "title": "short-iterative-java-solution",
                "content": "Hi guys!\\n\\nHere's an iterative solution which doesn't use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn't come up with more effective controling of uniqueness than just using a Set.\\n\\nSee the code below!\\n\\n----------\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            LinkedList<List<Integer>> res = new LinkedList<>();\\n            res.add(new ArrayList<>());\\n            for (int i = 0; i < num.length; i++) {\\n                Set<String> cache = new HashSet<>();\\n                while (res.peekFirst().size() == i) {\\n                    List<Integer> l = res.removeFirst();\\n                    for (int j = 0; j <= l.size(); j++) {\\n                        List<Integer> newL = new ArrayList<>(l.subList(0,j));\\n                        newL.add(num[i]);\\n                        newL.addAll(l.subList(j,l.size()));\\n                        if (cache.add(newL.toString())) res.add(newL);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2031042,
                "title": "java-backtracking-explained-easy-understanding",
                "content": "Hello Leetcoders, Hope you all are good.\\n\\nLet\\'s dig into the problem and think best way to get the solution.\\n\\n**Problem Discription :**\\n```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\\n\\n**formula** :-* (if they ask total no. of unique permutations)*\\ntotal no of permutations = n!\\nif there are some duplicates number in that case = n! / a! * b!\\nwhere a & b are frequency of the duplicate numbers\\n\\nbut question says print all permutations\\nso here we use **backtracking**\\n\\nfirst of all we need to **sort the array** because there are some duplicate numbers and we don\\'t want to process same number twice\\n\\nfor writting backrtracking code we need to create a **helper** method \\n\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\\n\\n**Now backtracking code**\\n\\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```\\n\\n\\n\\n\\n# ***If you like the explanation please UP-VOTE the article***\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nGiven an integer array that may contains duplicate values. You have to find all unique permutations of the integer array.\\nE.g arr = [1,1,2]\\n\\nAll possible permutations are \\n\\n[1,1,2]\\n[1,2,1]\\n[2,1,1]\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\t\\t\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        Arrays.sort(nums); // sort the array\\n\\t\\t\\n\\t\\t// create a boolean array which track the certain indexed integer is present in out temp list or not\\n        helper(ans, new ArrayList<>(), nums, new boolean[nums.length]); // helper method\\n\\t\\t\\n        return ans; // return output\\n    }\\n```\n```\\nprivate void helper(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] vis) {\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\twhen size of the temp list and size of the inout array are same then add this temp list into the final ans list.\\n\\t\\t\\tthis is one of our permutation for given integer array\\n\\t\\t*/\\n        if(nums.length == temp.size()) {\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\t\\t\\n        /*\\n\\t\\t\\tTraverse for whole array one by one.\\n\\t\\t*/\\n        for(int i=0;i<nums.length; i++) {\\n\\t\\t\\n            if(vis[i]) continue; // if current element is already present in the temp, skip the element\\n            if(i > 0 && ! vis[i-1] && nums[i] == nums[i-1]) continue; // if prev element and current element is equal, skip the element\\n            \\n            vis[i] = true;\\n            temp.add(nums[i]);\\n            \\n            helper(ans, temp, nums, vis); // recursive call\\n            \\n\\t\\t\\t// backtracking\\n            temp.remove(temp.size() - 1);\\n            vis[i] = false;\\n        }\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18670,
                "title": "short-and-fast-recursive-java-solution-easy-to-understand-with-explaination",
                "content": "The idea is to try to put every number at the beginning of the array, and then do the same thing for the rest of the array. There is no need to sort because we use a HashSet to track and make sure each number is put at the begining of the array only once.\\n\\n```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        res = new LinkedList<>();\\n        get(nums, 0);\\n        return res;\\n    }\\n    \\n    private void get(int[] nums, int start) {\\n        if (start == nums.length - 1) {\\n            res.add(toList(nums));\\n            return;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = start; i < nums.length; i++) {\\n            if (set.add(nums[i])) {\\n                int tmp = nums[start];\\n                nums[start] = nums[i];\\n                nums[i] = tmp;\\n                get(nums, start + 1);\\n                nums[i] = nums[start];\\n                nums[start] = tmp;\\n            }\\n        }\\n    }\\n    \\n    private List<Integer> toList(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for (int i : nums) list.add(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18657,
                "title": "iterative-python-solution-without-using-set-111ms",
                "content": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element.\\n\\n    \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        num.sort()\\n        ret = [[]]\\n        for n in num:\\n            new_ret = []\\n            l = len(ret[-1])\\n            for seq in ret:\\n                for i in range(l, -1, -1):\\n                    if i < l and seq[i] == n:\\n                        break\\n                    new_ret.append(seq[:i] + [n] + seq[i:])\\n            ret = new_ret\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 1355985,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.025 (0.027) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var res = [[Int]](), path = [Int](), vis = [Bool](repeating: false, count: nums.count)\\n        dfs(&res, &path, &vis, nums.sorted(by: <))\\n        return res\\n    }\\n    private func dfs(_ r: inout [[Int]], _ p: inout [Int], _ v: inout [Bool], _ n: [Int]) {\\n        guard p.count != n.count else { r.append(p); return }\\n        for i in 0..<n.count {\\n            if v[i] || (i > 0 && n[i] == n[i-1] && v[i-1]) { continue }\\n            p.append(n[i])\\n            v[i] = true\\n            dfs(&r, &p, &v, n)\\n            p.removeLast()\\n            v[i] = false\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.permuteUnique([1,1,2])\\n        XCTAssertEqual(value, [[1,1,2],[1,2,1],[2,1,1]])\\n    }\\n    func test1() {\\n        let value = solution.permuteUnique([1,2,3])\\n        XCTAssertEqual(value, [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750388,
                "title": "python3-dfs-solutions-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 121739,
                "title": "c-backtracking-solution-beat-95-with-explanation-no-extra-space-memory-to-record-choice",
                "content": "use backtracking with swap element to find solution\\n ```checkmiddle(nums,i,begin) ``` function is used for checking if there is any value same as i between i and begin.  if there is no such point, we proceed this operation and do the next recursion. If there is, it means the same swap has been done before. E.g. \\\\[1,1,2,2],  we should not swap value position 1 and 3 becuase when when list as \\\\[1,2,1,2] , swap position 2 and 3 (\\\\[1,2,2,1]) has been done before\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```checkmiddle(nums,i,begin) ```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>res;\\n        backtracking(nums, res, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    void backtracking(vector<int>& nums, vector<vector<int>>& res,int begin){\\n        if(begin==nums.size()-1){\\n            res.push_back(nums);\\n            return;\\n        }\\n        for(int i = begin; i<nums.size();i++){\\n            if((nums[i]!=nums[begin] || i == begin) && checkmiddle(nums,i,begin)){\\n                swap(nums[i],nums[begin]);\\n                backtracking(nums, res, begin+1);\\n                swap(nums[i],nums[begin]);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool checkmiddle(vector<int>& nums, int i , int begin){\\n        for(int k = begin; k<i; k++)\\n            if(nums[i] == nums[k])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265223,
                "title": "python-backtracking",
                "content": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```\\n\\nA good way to think about the solution is to draw a recursion tree. The node in the tree here is the evaluation of s in each recursive call.\\n![image](https://assets.leetcode.com/users/vubui/image_1553967971.png)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def _permute(self, nums, s, k):\\n        if len(s) == k:\\n            self.permutations.append(s[:])\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            s.append(nums[i])\\n            self._permute(nums[:i] + nums[i+1:], s, k)\\n            s.pop()\\n            \\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.permutations = []\\n        \\n        self._permute(sorted(nums), [], len(nums))\\n        \\n        return self.permutations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527937,
                "title": "java-tc-o-n-n-sc-o-n-recursive-backtracking-iterative-solutions",
                "content": "**Recursive Backtracking**\\n\\n```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Iterative Solution**\\n\\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Recursive Backtracking using visited array**\\n\\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Permutations questions on LeetCode:\\n- [46. Permutations](https://leetcode.com/problems/permutations/discuss/1527929/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Recursive-Backtracking-and-Iterative-Solutions)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Recursive Backtracking using countMap.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each\\n * permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + countMap + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int n : nums) {\\n            countMap.put(n, countMap.getOrDefault(n, 0) + 1);\\n        }\\n\\n        permuteUniqueHelper(result, nums.length, countMap, new ArrayList<>());\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int inputLength, HashMap<Integer, Integer> countMap, List<Integer> tempList) {\\n        if (tempList.size() == inputLength) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int num : countMap.keySet()) {\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            countMap.put(num, count - 1);\\n            tempList.add(num);\\n            permuteUniqueHelper(result, inputLength, countMap, tempList);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Iterative Solution\\n *\\n * The idea is to add the nth number in every possible position of each permutation of the first n-1 numbers.\\n *\\n * Time Complexity: O(N * N!). Number of permutations = P(N,N) = N!. Each permutation takes O(N) to construct\\n *\\n * T(n) = (x=2->n) \\u2211 (x-1)!*x(x+1)/2\\n *      = (x=1->n-1) \\u2211 (x)!*x(x-1)/2\\n *      = O(N * N!)\\n *\\n * Space Complexity: O((N-1) * (N-1)!) = O(N * N!). All permutations of the  first n-1 numbers.\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(Arrays.asList(nums[0]));\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            List<List<Integer>> newResult = new ArrayList<>();\\n            for (List<Integer> cur : result) {\\n                for (int j = 0; j <= i; j++) {\\n                    List<Integer> newCur = new ArrayList<>(cur);\\n                    newCur.add(j, nums[i]);\\n                    newResult.add(newCur);\\n\\n                    // If number just added is same as the number at jth index of cur list. Then we\\n                    // can break to avoid duplicates.\\n                    if (j < i && cur.get(j) == nums[i]) {\\n                        break;\\n                    }\\n                }\\n            }\\n            result = newResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Backtracking using visited array.\\n *\\n * Time Complexity: O(N * N! + NlogN). Number of permutations = P(N,N) = N!.\\n * Each permutation takes O(N) to construct\\n *\\n * T(n) = n*T(n-1) + O(n)\\n * T(n-1) = (n-1)*T(n-2) + O(n)\\n * ...\\n * T(2) = (2)*T(1) + O(n)\\n * T(1) = O(n)\\n *\\n * Above equations can be added together to get:\\n * T(n) = n (1 + n + n*(n-1) + ... + (n....2) + (n....1))\\n *      = n (P(n,0) + P(n,1) + P(n,1) + ... + P(n,n-1) + P(n,n))\\n *      = n * Floor(e*n!)\\n *      = O(N * N!)\\n *\\n * Space Complexity: O(N). Recursion stack + visited array + Sorting + tempList\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null || nums.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(nums);\\n        permuteUniqueHelper(result, nums, new ArrayList<>(), new boolean[nums.length]);\\n        return result;\\n    }\\n\\n    private void permuteUniqueHelper(List<List<Integer>> result, int[] nums, List<Integer> tempList, boolean[] visited) {\\n        if (tempList.size() == nums.length) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            /**\\n             * !visited[i - 1] is making sure that duplicate results are not added. Since\\n             * nums[i-1] and nums[i] are same, nums[i] can only be used if nums[i-1] is\\n             * currently in use.\\n             */\\n            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {\\n                continue;\\n            }\\n            visited[i] = true;\\n            tempList.add(nums[i]);\\n            permuteUniqueHelper(result, nums, tempList, visited);\\n            tempList.remove(tempList.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932924,
                "title": "python-simple-dfs-backtracking-explained",
                "content": "Another classical backtracking problem. Let us try to built our sequence element by element, inserting new element in different places. Imagine, that we have `[1,3,1,2]`. Then our building process will look like:\\n\\n1. `[1]` on the first step we have not choice, so here we have only one option.\\n2. Now, we need to insert next element somewhere, and we have two options: before and after, so we have `[1,3]` and `[3,1]` options here.\\n3. Now we need to insert new element `1`. The problem here is that when we insert it, we can have repeating answers, so the rule is: insert in only before the already existing occurrences of this element. So, in `[1,3]` we can only insert it before `1` and get `[1,1,3]` and in `[3,1]` we have two places to insert and we have `[1,3,1]` and `[3,1,1]`.\\n4. Finally, we want to insert `2` to the each of existing answers, and we have: `[2,1,1,3]`, `[1,2,1,3]`, `[1,1,2,3]`, `[1,1,3,2]`, `[2,1,3,1]`, `[1,2,3,1]`, `[1,3,2,1]`, `[1,3,1,2]`, `[2,3,1,1]`, `[3,2,1,1]`, `[3,1,2,1]`, `[3,1,1,2]` \\n\\n**Complexity**: Time complexity is `O(Q n)`, where `Q` is number of desired permutations and `n` is length of `nums`, because every time we build our sequence we write it in our final answer, that is there will be no dead-ends. `Q` can be evaluated, using multinomial coefficients https://en.wikipedia.org/wiki/Multinomial_theorem. Space complexity is the same. \\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        def dfs(ind, built):\\n            if ind == len(nums):\\n                ans.append(built)\\n                return\\n\\n            stop = built.index(nums[ind]) if nums[ind] in built else ind\\n            \\n            for i in range(stop+1):\\n                dfs(ind+1, built[:i]+[nums[ind]]+built[i:])\\n\\n        ans = []\\n        dfs(0, [])  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662237,
                "title": "c-backtracking",
                "content": "Same code as for problem 46. Permutations, with an extra if\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429532,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18630,
                "title": "java-iterative-solution-no-set-needed",
                "content": "In each iteration, put the new number to all possible place. \\nTo avoid duplicate we also have to:\\n1) For duplicate numbers in a row, only add same number in in front of them.\\n2) Break when same number exists in the permutation.\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }\\n                }\\n            }\\n            return r;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] nums) {\\n            LinkedList<List<Integer>> r = new LinkedList<>();\\n            r.add(new ArrayList<Integer>());\\n            for(int i=0; i<nums.length; i++){\\n                int n = r.size();\\n                for(int j=0; j<n; j++){\\n                    List<Integer> list = r.poll();\\n                    for(int k=0; k<=list.size(); k++){\\n                        if(k > 0 && list.get(k-1) == nums[i])\\n                            break;\\n                        ArrayList<Integer> t = new ArrayList<>(list);\\n                        t.add(k, nums[i]);\\n                        r.offer(t);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 589917,
                "title": "c-solution",
                "content": "**Intuition**\\n![image](https://assets.leetcode.com/users/newbiecoder1/image_1587445651.png)\\n\\n**Complexity**\\n- Time: O(n! * n)\\n- Space: O(n! * n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**update on 6/17/2021**\\nwhy ```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;``` can avoid duplicates?\\nFor example, nums = [1,1,2]\\nWe add the first 1 to the list, then we need to explore [1] + permutation of [1,2] (index 1 and 2)\\nWhen checking the second 1, if we don\\'t check whether the first 1 has been used, then we will cexplore [1] + permutation of [1,2] (index 0 and 2)\\n\\n![image](https://assets.leetcode.com/users/images/87da018f-1dfb-4b05-a00a-7aa26fcde8da_1637625422.2813182.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(nums);\\n        bool[] used = new bool[nums.Length];\\n        Backtracking(nums, new List<int>(), res, used);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] nums, List<int> list, List<IList<int>> res, bool[] used)\\n    {\\n        if(list.Count == nums.Length)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < nums.Length; i++)\\n            {\\n                if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;\\n                \\n                list.Add(nums[i]);\\n                used[i] = true;\\n                Backtracking(nums, list, res, used);\\n                list.RemoveAt(list.Count - 1);\\n                used[i] = false;\\n            }\\n        }\\n    }\\n}\\n```\n```if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] || used[i]) continue;```",
                "codeTag": "Java"
            },
            {
                "id": 278301,
                "title": "java-1ms-solution-which-beats-100-with-explanation-of-how-to-remove-duplicate",
                "content": "The key of the problem is duplicate removal. The solution contains three steps which is simple:\\n1. Sort the given array;\\n2. Use an boolean array ```used``` to record whether the element with corresponding index has been used;\\n2. Judge whether current element is equal to previous element (```nums[i] == nums[i - 1]```) and previous element is used or not (```used[i - 1]```).\\n\\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```used```\n```nums[i] == nums[i - 1]```\n```used[i - 1]```\n```\\npublic void traverse(List<List<Integer>> resultList, List<Integer> current, int[] nums, boolean[] used) {\\n\\tif( current.size() == nums.length )\\n\\t\\tresultList.add(new ArrayList<Integer>(current));\\n\\telse{\\n\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\tif( used[i] || ( i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) ) // remove duplicate\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tcurrent.add(nums[i]);\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\ttraverse(resultList, current, nums, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t\\tcurrent.remove(current.size() - 1);\\n\\t\\t}\\n\\t}\\n}\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n\\tArrays.sort(nums); // sort is necessary\\n\\tList<List<Integer>> resultList = new ArrayList<List<Integer>>();\\n\\ttraverse(resultList, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n\\treturn resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179947,
                "title": "4ms-backtracking-java-with-explanations",
                "content": "**Thought**\\nWe think about the Search Tree when we apply Backtracking.\\n```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\\nHow do we ensure the permutations to be unique?\\nThe elements with the same value should be used one by one in order. \\nSo we sort elements first, and prune the branch when an element is the same as the previous element but the previous element has not been used in current result.\\n**Code**\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n- 1 - 1 - 2\\n    - 2 - 1\\n\\n- X\\n\\n- 2 - 1 - 1\\n    - X\\n  \\nX means pruning to avoid duplicate permutations.\\n```\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        if (nums == null || nums.length == 0)\\n            return new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> finalResult = new ArrayList<>();\\n        permuteUniqueRecur(nums, finalResult, new ArrayList<>(), new boolean[nums.length]);\\n        return finalResult;\\n    }\\n\\n    private void permuteUniqueRecur(int[] nums, List<List<Integer>> finalResult, List<Integer> currResult, boolean[] used) {\\n\\n        if (currResult.size() == nums.length) {\\n            finalResult.add(new ArrayList<>(currResult));\\n            return;\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (used[i] || (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])) {\\n                continue;\\n            }\\n            currResult.add(nums[i]);\\n            used[i] = true;\\n            permuteUniqueRecur(nums, finalResult, currResult, used);\\n            used[i] = false;\\n            currResult.remove(currResult.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031720,
                "title": "c-simple-backtrack-solution-with-comments-easy-to-understand",
                "content": "**1st approach** Straight forward DFS by using set (to store unique answers).\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2nd Approach** A simple extension of permutation 1. You just need to skip the same element to create unique permutations.\\n\\n***CODE ->***\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Please Upvote if you like the explaination : )**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,set<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){            // Base case-> if temporsry vector size becomes equal to size of given list \\n            ans.insert(t);                // Before returning store the valid permutation inside the ans\\n            return ;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=11){            // check if the element is already included\\n                int j=nums[i];\\n                nums[i]=11;        // make the current ele to 11 (which is out of the range) so that we will not insert this element in next call\\n                t.push_back(j);      // store it in the temporary vector\\n                solve(nums,ans,t);  //recursively call to complete the permutations\\n                nums[i]=j;      // backtrack \\n                t.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>> s;          //to store unique permutations\\n        vector<vector<int>> ans;\\n        \\n        solve(nums,s,{});\\n        \\n        for(auto i:s){\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int>& nums,vector<vector<int>> &ans,vector<int> t){\\n        if(t.size()==nums.size()){\\n            ans.push_back(t);\\n            return ;\\n        }\\n        \\n        for(int j=0;j<nums.size();j++){\\n            if(nums[j]!=11){\\n\\t\\t\\t// The difference between the upper code and this code\\n\\t\\t\\t\\n            if(j>0 && nums[j]==nums[j-1]) continue;       // skip the element which has already been included\\n            int i=nums[j];\\n            nums[j]=11;\\n            t.push_back(i);\\n            solve(nums,ans,t);\\n            t.pop_back();\\n            nums[j]=i;\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());          // sort the givern nums vector to check the consecutive elements\\n        vector<vector<int>> ans;\\n        solve(nums,ans,{});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949631,
                "title": "c-solution-with-time-complexity-analysis-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion & HashMap.***\\n- Here we\\u2019ll first take all the elements count in hashmap, as there could be duplicated elements, this will help us not to take the same elements twice for the same location.\\n- In our help function, we\\u2019ll pass the index value and given array size.\\n- Base condition when current index will be equal to given array size then we\\u2019ll push temp in ans vector, `if(index == n) ans.push_back(temp)`\\n- Else we\\u2019ll iterate the map & push value one by one to temp, at any point if the map value became 0, we\\u2019ll continue from that.\\n- After the function call, we\\u2019ll remove the current element from temp & run the loop again.\\n- **Time complexity:** O(n*k), where k is the size of unique elements & n is the size of given array.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    vector<vector<int>> ans;\\n    unordered_map<int, int> mp;\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        for(auto x:nums) mp[x]++;\\n        \\n        help(0, n);\\n        return ans;\\n    }\\n    \\n    void help(int index, int n){\\n        if(index == n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(auto k:mp){\\n            int key = k.first;\\n            int value = k.second;\\n            \\n            if(value == 0) continue;\\n            \\n            temp.push_back(key);\\n            mp[key]--;\\n            \\n            help(index+1, n);\\n            \\n            temp.pop_back();\\n            mp[key]++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309479,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18799,
                "title": "my-c-recursive-dfs-backtracking-solutions",
                "content": "Using an unordered_map to get all the distinct elements and the number of their occurence so that we don't need to do sorting. Then do dfs and backtracking to generate all the permutations: for each iteration, put each available distinct element (i.e. numMap->second >0) into path, update numMap, and do DFS at the next level. Once path has a length of len, then we get a new permutation and just add path to res.\\n\\n    class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}\\n            for(auto it = numMap.begin(); it != numMap.end(); ++it)\\n            {\\n                if(it->second)\\n                {\\n                    path.push_back(it->first); // update the current path\\n                    --(it->second); // and map\\n                    dfsHelper(res, path, numMap, len); // then do dfs at the next level\\n                    path.pop_back(); // backtracking by recovering path and map\\n                    ++(it->second);\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            int i,len = nums.size();\\n            vector<vector<int>> res;\\n            if(len>0)\\n            {\\n                vector<int> path;\\n\\n                unordered_map<int, int> numMap; //generate a map\\n                for(i=0; i<len; ++i) ++numMap[nums[i]];\\n\\n                dfsHelper(res, path, numMap, len);\\n            }\\n            return res;\\n            \\n            \\n        }\\n    };\\n\\nIf we do soring, then the unordered_map is not needed.\\n\\n    class Solution {\\n    private:\\n        void dfs(vector<vector<int>> &res, vector<int> &cur, vector<int> canVec, int len)\\n        {\\n            if(cur.size()==len)\\n            {\\n                res.push_back(cur);\\n            }\\n            else\\n            {\\n                for(auto i=0; i<canVec.size(); ++i)\\n                {\\n                    if(i>0 && canVec[i] == canVec[i-1] ) continue;\\n                    cur.push_back(canVec[i]);\\n                    vector<int> temp = canVec;\\n                    temp.erase(temp.begin()+i);\\n                    dfs(res, cur, temp, len);\\n                    cur.pop_back();\\n                }\\n            }\\n        }\\n    \\n    public:\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            \\n            vector<vector<int>> res;    \\n            int  len = nums.size();\\n            if(len>0)\\n            {\\n                vector<int> cur;\\n                std::sort(nums.begin(), nums.end());\\n                dfs(res, cur, nums, len);\\n            }\\n            return res;\\n            \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: \\n        void  dfsHelper(vector<vector<int>>  &res, vector<int> &path, unordered_map<int, int> &numMap, int len)\\n        {\\n            if(path.size()==len) {res.push_back(path); return;}",
                "codeTag": "Java"
            },
            {
                "id": 249718,
                "title": "python-dfs-easy-to-understand",
                "content": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Inspired by the answer from Permutations by @caikehe\\nhttps://leetcode.com/problems/permutations/discuss/18296/Simple-Python-solution-(DFS).\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        self.dfs(nums, [], res)\\n        return res\\n    \\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)",
                "codeTag": "Java"
            },
            {
                "id": 18760,
                "title": "small-modification-of-permutation-i-using-a-set",
                "content": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "solutionTags": [],
                "code": "    public static List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        permute(nums,0,nums.length,res);\\n        return res;\\n    }\\n    public static void permute(int[] nums, int i, int j, List<List<Integer>> res){\\n        \\n        if(i == j-1){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int x:nums) list.add(x);\\n            res.add(list);\\n            return;\\n        }\\n        HashSet<Integer> visited= new HashSet<Integer>();\\n        for(int k=i;k<j;k++){\\n            if(!visited.contains(nums[k])){\\n                swap(nums,i,k);\\n                permute(nums,i+1,j,res);\\n                swap(nums,i,k);\\n                visited.add(nums[k]);\\n            }\\n            \\n        }\\n    }\\n    public static void swap(int[] nums, int i,int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18844,
                "title": "share-python-solution-without-using-set",
                "content": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same idea as already in other posts, just the Python version for reference.\\n     \\n    def permuteUnique(self, num):\\n        if not num:\\n            return []\\n        return self.permute(sorted(num))\\n        \\n    def permute(self, num):\\n        if len(num) == 1:\\n            return [num]\\n            \\n        ret = []\\n        for index, elt in enumerate(num):\\n            if index > 0 and num[index - 1] == elt:\\n                continue\\n            ret += [[elt] + p for p in self.permute(num[:index] + num[index + 1:])]\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 2031147,
                "title": "simplest-bruteforce-100-faster-easy-understanding-without-backtracking",
                "content": "**next_permutation** is an inbuilt library.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```\\nHope you like the solution.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> st;\\n        vector<int> temp = nums;\\n        do\\n        {\\n            next_permutation(temp.begin(), temp.end());\\n            st.insert(temp);\\n        } while (temp != nums);\\n        vector<vector<int>> ans;\\n        for (auto it: st)\\n            ans.push_back(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909423,
                "title": "100-fastest-swift-solution-time-o-n-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * n!), where n is the length of the nums.\\n    //   - space: O(n), where n is the length of the nums.\\n\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        var dict = [Int: Int]()\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n\\n        for num in nums { dict[num, default: 0] += 1 }\\n        backtrack(&comb, nums.count, &dict, &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(_ comb: inout [Int], _ n: Int, _ dict: inout [Int: Int], _ ans: inout [[Int]]) {\\n        guard comb.count != n else { ans.append(comb); return }\\n\\n        for (_, el) in dict.enumerated() {\\n            guard el.value != 0 else { continue }\\n            comb.append(el.key)\\n            dict[el.key, default: 0] -= 1\\n            backtrack(&comb, n, &dict, &ans)\\n            comb.removeLast()\\n            dict[el.key] = el.value\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228299,
                "title": "c-nextpermutation-backtracking-using-extraw-space-backtracking-most-optimised-one",
                "content": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "**1st Approach * C++ NextPermutation***\\n\\t\\n\\tvector<int> nextPermutation(vector<int>& nums) {\\n        int i,j;\\n        for( i=nums.size()-2; i>=0; i--)  if(nums[i]<nums[i+1]) break; \\n        if( i<0 ) {reverse(nums.begin(), nums.end());}\\n        else\\n        {\\n            for( j=nums.size()-1; j>i; j--) if(nums[j] > nums[i])break; \\n            swap(nums[j],nums[i]); \\n\\t\\t\\treverse(nums.begin()+i+1, nums.end());\\n        }\\n            return nums;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans; int n = nums.size(),fact =1;\\n        for(int i =1; i<=n ; i++) fact *= i;\\n        ans.push_back(nums);\\n        for(int i =0; i<fact; i++) ans.push_back(nextPermutation(ans[i]));\\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        return ans;\\n    }\\n\\t\\n**2nd Approach Backtracking(Extraw Space )**\\n\\t\\n\\tvoid solve(vector<int>&nums, vector<int>&temp, vector<int>&vst, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(temp.size()==nums.size()) \\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            if(!vst[i])\\n            { \\n                vst[i]=1;\\n                temp.push_back(nums[i]);\\n                solve(nums, temp, vst,ans);\\n                vst[i]=0;\\n                temp.pop_back();\\n            }\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans; \\n        vector<int>vst,temp;\\n        for(int i=0; i<nums.size();i++) vst.push_back(0);\\n        solve(nums,temp, vst, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**3rd Approach Backtracking Optimised**\\n\\t\\n\\t void solve(vector<int>&nums, int idx, vector<vector<int>>&ans)\\n\\t\\t{\\n        if(idx==nums.size()) \\n        {\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=idx; i<nums.size();i++)\\n        {\\n            swap(nums[i],nums[idx]);\\n            solve(nums,idx+1,ans);\\n            swap(nums[i],nums[idx]);\\n        }\\n        return ;\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        solve(nums, 0, ans);\\n        sort(begin(ans),end(ans));\\n        ans.erase(unique(begin(ans), end(ans)),end(ans));\\n        return ans;\\n    }\\n\\t\\n**4rth Approach Using STL**\\n\\t\\n\\t    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n       vector<vector<int>> res;\\n        sort(nums.begin(), nums.end());\\n        do\\n        {\\n            res.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 824487,
                "title": "2-java-solution-using-set",
                "content": "This question is similar to below 2 questions ->\\n\\nhttps://leetcode.com/problems/permutations/solutions/822916/simple-java-solution-recursive-0ms-100-faster\\n\\nhttps://leetcode.com/problems/subsets-ii/solutions/1767720/2-java-solution-with-and-without-set\\n\\n# Approach 1-> \\nit will take little more time as we are processing duplicate data also and at last just adding to set which will ignore duplicate list.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\\n\\n# Approach 2->\\nit is faster as here we are ignoring branch which cannot lead to answer.\\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(nums);\\n        helper(0,nums,ans);\\n        return new ArrayList<>(ans);\\n    }\\n    private void helper(int i,int[] nums,Set<List<Integer>> ans) {\\n        if(i==nums.length) {\\n            List<Integer> list = new ArrayList<>();\\n            for(int item:nums) {\\n                list.add(item);\\n            }\\n            ans.add(list);\\n            return;\\n        }\\n        for(int j=i;j<nums.length;j++) {\\n            swap(nums,i,j);\\n            helper(i+1,nums,ans);\\n            swap(nums,i,j);\\n        }\\n    }\\n\\n    private void swap(int[] nums,int i,int j) {\\n        int t=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=t;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    permute(nums, 0, list);\\n    return list;\\n}\\n\\nprivate void permute(int[] nums, int i, List<List<Integer>> list) {\\n    if (i == nums.length) {\\n        List<Integer> l1 = new ArrayList<>();\\n        for (int n : nums) {\\n            l1.add(n);\\n        }\\n        list.add(l1);\\n        return;\\n    }\\n    Set<Integer> set = new HashSet<>();\\n    for (int s = i; s < nums.length; s++) {\\n        if (set.add(nums[s])) {\\n            swap(nums, s, i);\\n            permute(nums, i + 1, list);\\n            swap(nums, s, i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124324,
                "title": "python-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        nums.sort()\\n        result = []\\n        self.permutation(nums, [],result)\\n        return result\\n\\n    def permutation(self, numbers, curr, result):\\n        if len(numbers) == 0:\\n            result.append(curr)\\n\\n        for i in range(len(numbers)):\\n            if i > 0 and numbers[i] == numbers[i-1]:\\n                continue\\n            self.permutation(numbers[0:i]+numbers[i+1:], curr + [numbers[i]], result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18607,
                "title": "concise-java-solution-based-on-dfs",
                "content": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "solutionTags": [],
                "code": "The basic idea is using DFS to put possible numbers to each i position, use boolean visited[] to flag the visited nodes, so that avoid accessing the same node many times. The tricky part of this problem is the solution for duplicated numbers: in the same position, only put one distinct number once.\\n\\n**For i position, there're (n-i) possibilities, so the total possilities are: n*(n-1)*(n-2)..1 = O(n!):**\\n\\n**Time complexity = O(n!)**\\n\\n    public LinkedList<List<Integer>> permuteUnique(int[] A) {\\n    \\t LinkedList<List<Integer>>res = new LinkedList<List<Integer>>();\\n    \\t Arrays.sort(A);//Sort the array first\\n    \\t DFS(A, new LinkedList<Integer>(), new boolean[A.length], res);\\n    \\t return res;\\n     }\\n     void DFS(int[] A,  LinkedList<Integer>solution, boolean visited[], LinkedList<List<Integer>>res) {\\n    \\t if (solution.size() == A.length) {\\n    \\t\\t res.add(new LinkedList<Integer>(solution));\\n    \\t\\t return;\\n    \\t }\\t\\t  \\n    \\t for (int i = 0; i < A.length; i++) {\\n    \\t     //Deal with duplicated numbers, visited[i-1] should be true. (In the same position, only put one distinct number)\\n    \\t\\t if (visited[i] || (i-1 >= 0 && visited[i-1] && A[i] == A[i-1]))\\n    \\t\\t\\t continue; \\n    \\t\\t visited[i] = true;\\n    \\t\\t solution.add(A[i]);\\n    \\t\\t DFS(A, solution, visited, res);\\n    \\t\\t solution.remove(solution.size()-1);\\n    \\t\\t visited[i] = false;\\t\\n    \\t }\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 18825,
                "title": "c-solution-adapted-from-the-most-voted-permutations-i-solution-of-mine",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }\\n     \\n        void permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)    {\\n            if (begin >= num.size()) {\\n                result.push_back(num);\\n                return;\\n            }\\n            \\n            // detect duplicate        \\n            unordered_set<int> set;\\n            for (int i = begin; i < num.size(); i++) {\\n                if (set.count(num[i]) > 0)\\n                    continue;\\n                set.insert(num[i]);\\n                \\n                swap(num[begin], num[i]);\\n                permuteRecursive(num, begin + 1, result);\\n                swap(num[begin], num[i]);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > permuteUnique(vector<int> &num) {\\n            vector<vector<int> > result;\\n            \\n            permuteRecursive(num, 0, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3385921,
                "title": "97-beats-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDefault backtrack solution. If elements are similar we dont need to swap them because we will get the same permutation, so we use ``` ++pos; ``` in loop to find different from ```nums[i]``` number. After all we should use ```pos = i;``` for use correct pos in next itteration. \\n\\n# Complexity\\n- Time complexity: suggest\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N! (if all numbers are unique there is N! factorial possible permutations)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```\\n![o7i7nDOFhCs.jpg](https://assets.leetcode.com/users/images/2b0d907c-3d3d-462f-b60e-8ecd1e45c4e5_1680844815.8535395.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` ++pos; ```\n```nums[i]```\n```pos = i;```\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currSubset;\\n\\n        std::sort(nums.begin(), nums.end());\\n        permutations(nums, 0, output);\\n\\n        return output;\\n    }\\nprivate:\\n    void permutations(std::vector<int> const& nums, int pos, std::vector<std::vector<int>>& output) {\\n        output.push_back(nums);\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            auto tmp = nums;\\n            while (pos < nums.size()-1) {\\n                ++pos;\\n                if (tmp[i] != tmp[pos]) {\\n                    std::swap(tmp[i], tmp[pos]);\\n                    permutations(tmp, i+1, output);\\n                }\\n            }\\n            pos = i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140136,
                "title": "c-simple-and-efficient-2-different-solutions",
                "content": "**Intuition:** Since we are asked to calculate all the possible permutations, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n*Note :This question is very similar to the [Permutations](https://leetcode.com/problems/permutations/) problem and I already explained that in detail [here](https://leetcode.com/problems/permutations/discuss/1140113/Clear-and-simple-explanation-(2-approach)-with-intuition%3A-100-faster) , so I am going to just tell the change thats going to be made for this particular question .*\\n\\n**Concept:** When the pointers(`i` and `idx`) are not equal but the elements are equal, we have to skip that combination but the problem that arises is that it can\\'t distinguish if the order is different between two combinations. For instance: `1,2,4]!=[4,2,1]` acc to our condition, but this can\\'t be distinguished , unless the ordering is same between the two....\\n\\nAnd to maintain the relative order, we do **sorting**.\\n\\n**Approach 1:** Using next_permutation\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\\n**Approach 2:** Backtracking\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```\\n*Note: You can also use **find** method or use **for** loop and then check before adding in \"ans\" if it exists or not ,instead of sorting and doing what I did above, but I did that and the runtime was 700ms in that case, hence I didn\\'t include that. This code is optimised version of that raw code.*\\n\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you have any doubts regarding anything , please ask in comments!!!\\nIf you like, please **UPVOTE**\\nHappy Coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        ans.push_back(nums);\\n        while(next_permutation(nums.begin(),nums.end()))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void helper(vector<int> nums,int idx)\\n    {\\n        if(idx==nums.size())\\n        {\\n            ans.push_back(nums);\\n        }\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            if(i!=idx && nums[i]==nums[idx])    continue;\\n            swap(nums[i],nums[idx]);\\n            helper(nums,idx+1);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        helper(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360071,
                "title": "explaining-the-used-array-trick",
                "content": "When a number has the same value with its previous, we can use this number only if its previous number (in sorted input array) is used.\\n\\nExplanation: \\n\\nA number which is equal to its previous number can be used only if its previous number has already been used, in this way we can make sure that in the resulting permutations, groups of same numbers will always have the same ordering between them. Thus we no longer have the problems of duplicates resulting permutations.\\n\\nFor example, for the array `aaabb`. The second `b` cannot be used if the first `b` has not been put somewhere in the current permutation. With the same logic, the second `a` cannot be used if the first `a` has not been put somewhere in the current permutation, the third `a` cannot be used if the second `a` has not been put somewhere in the current permutation. \\n\\nHere, `previous` means the ordering in the sorted input array `nums`.\\n\\nAs we have duplicates in input array `nums`, each number can be uniquely identified with their ordering index in the sorted input array `nums`. \\n\\n```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n\\tvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(res, nums, current, used);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<int>>& res, vector<int>& nums, vector<int>& current, vector<bool>& used){\\n        if(current.size() == nums.size()){\\n            res.push_back(current);\\n            return;\\n        }\\n        for(int i = 0; i < nums.size(); i++){\\n            if(!used[i]){\\n                if(i == 0 || nums[i] != nums[i - 1] || used[i - 1]){\\n                    used[i] = true;\\n                    current.push_back(nums[i]);\\n                    backtrack(res, nums, current, used);\\n                    used[i] = false;\\n                    current.pop_back();\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 217564,
                "title": "javascript-o-n-n-time-and-space-backtracking",
                "content": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * n!)\\n * Space: O(n * n!)\\n * n - # of nums\\n */\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nfunction permuteUnique(nums) {\\n  const solutions = [];\\n  nums.sort((a, b) => a - b);\\n  findPermutations(nums, solutions, [], new Set());\\n  return solutions;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number[][]} solutions\\n * @param {number[]} current\\n * @param {Set} used\\n */\\nfunction findPermutations(nums, solutions, current, used) {\\n  if (current.length === nums.length) {\\n    return solutions.push(current.slice());\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (used.has(i)) {\\n      continue;\\n    }\\n\\n    // If current matches previous, only continue if previous is used\\n    if (i > 0 && nums[i] === nums[i - 1] && !used.has(i - 1)) {\\n      continue;\\n    }\\n\\n    current.push(nums[i]);\\n    used.add(i);\\n    findPermutations(nums, solutions, current, used);\\n    current.pop();\\n    used.delete(i);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18613,
                "title": "13-lines-c-backtracking",
                "content": "My [solution](https://discuss.leetcode.com/topic/94915/backtracking-clean-c-recursion-with-detailed-explanation) for [**Permutations I**](https://leetcode.com/problems/permutations/description/).\n\nSolution for **Permutations II** is similar to **Permutations I**, the only difference is that we **CAN'T** swap back after each permutation, cause we want to pick a new different number for position `i` in each loop.\n\nFor example, suppose array nums = [1, 1, 2, 2, 3], first we swap nums[0] = 1 with the first different number nums[2] = 2, after first swap, nums = [2, 1, 1, 2, 3], then if we swap back `1` with `2`,  nums = [1, 1, 2, 2, 3].\n\nNow, we want to pick nums[4] = 3 as a new number for position `0`, but nums[3] = 2 would be considered the new different number because we swaped the number '1' back to position `0`, so we will swap nums[0] with nums[3], nums = [2, 1, 2, 1, 3], so the same number '2' appears twice at position `0`, which caused the repeated outcomes.\n\n```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\nclass Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>>res;\n        DFS(res, nums, 0);\n        return res;        \n    }\n    \n    void DFS(vector<vector<int>>& res, vector<int> nums, int pos){\n        if(pos == nums.size() - 1){\n            res.push_back(nums);\n            return;\n        }\n        for(int i = pos; i < nums.size(); i++){\n            if(i != pos && nums[i] == nums[pos]) continue;\n            swap(nums[pos], nums[i]);\n            DFS(res, nums, pos + 1);\n        }\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 18615,
                "title": "difference-and-explanation-between-subset-i-ii-and-perm-i-ii-simple-sol-listed",
                "content": "There are many good posts explaining the backtrack idea of these two topics. \\n\\nThe subset and permutation problems all have similar code. However, I did not find one that explains the difference between them. And despite the fact that they have similar code, actually they are very different.\\n\\n\\n* subset I, II\\nMy codes are similar to many others: push one element into the vector and then recursively call the function. After that pop that element out.\\n**Explanation:** The subset problem is all about **choice**, whether you want certain element inside the vector or not. For example, [1, 2, 3], starting with pos = 0. At pos = 0, you push 1 into temp, then recursively call the function. Then this reclusive call is a \"crossroad\". Inside the call (with all other calls inside), you have the \"1\" chosen and every vector you produce will begin with 1. When the call returns (ie. you pop 1 out), you are on the other road of the crossroad, which does not contain 1. These are just the first \"choice\" you are faced. And after that you face with other similar choices. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n**subset II :** Eliminate the dup with sort and then the condition: do not put this element inside, if it has same element before && the former dup has not been put into it. Because otherwise, you better off put the former dup into the vector instead of this (latter dup) one. \\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\n* Permutation I, II\\nPermutation I is a very typical problem. \\n\\n**Note:** the pos here is different with the pos in subset. The pos in subset is more like choice in front of crossroad while the pos in permutation is the \"digit\" you are considering. In other words, you you consider the elements one by one: which one should be the first? which one should be the second? ...and so on. The **pos** is just the \"first\", \"second\"...\\n\\nWhen you consider the n**th** element, you swap the n**th** with element from n**th** to the last one, so that every element after that will have a chance to stay in the n**th** position. You recursively call, after each case.\\n\\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\\n\\npermutation II\\nI prefer to use the unordered_map to solve the dup problem. How does it solve the problem? because it treats all the dup as one element with several copies. \\n\\nFor example, [1, 1, 2], when you iterate, in the same \"level\", the 1 will only be put once. We only put the other 1 into the vector in the recursive call in next levels.\\n\\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n\\n        for(int i=pos; i<nums.size(); ++i){\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& temp, vector<int>& nums, int pos){\\n        res.push_back(temp);\\n        \\n        for(int i=pos; i<nums.size(); ++i){\\n            if(i != pos && nums[i] == nums[i - 1]) continue;\\n            temp.push_back(nums[i]);\\n            helper(res, temp, nums, i + 1);\\n            temp.pop_back();\\n            \\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        sort(nums.begin(), nums.end());\\n        helper(res, temp, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(vector<vector<int>>& res, vector<int>& nums, int pos){\\n        if(nums.size() == pos){\\n            res.push_back(nums);\\n            return ;\\n        }\\n        for(int i=pos; i < nums.size(); ++i){\\n            swap(nums[i], nums[pos]);\\n            helper(res, nums, pos + 1);\\n            swap(nums[i], nums[pos]);\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        helper(res, nums, 0);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    void helper(unordered_map<int, int>& bar, vector<int>& temp, vector<vector<int>>& res, int n){\\n        if(temp.size() == n){\\n            res.push_back(temp);\\n            return ;\\n        }\\n        for(auto &i : bar){\\n            if(i.second <= 0) continue;\\n            i.second --;\\n            temp.push_back(i.first);\\n            helper(bar, temp, res, n);\\n            temp.pop_back();\\n            i.second ++;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        unordered_map<int, int> bar;\\n        for(int i : nums){\\n            bar[i] ++;\\n        }\\n        vector<int> temp;\\n        helper(bar, temp, res, nums.size());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477601,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*n!)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/b074654c-3a20-4c40-8faf-f265fc22c19b_1683031288.086733.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        // Create a list to store the final results\\n        List<List<Integer>> res = new ArrayList<>();\\n        // Sort the input array to group duplicates together\\n        Arrays.sort(nums);\\n        // Create a boolean array to keep track of used numbers\\n        boolean[] used = new boolean[nums.length];\\n        // Call the recursive backtrack method to generate all permutations\\n        backtrack(nums, used, new ArrayList<>(), res);\\n        // Return the list of permutations\\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, boolean[] used, List<Integer> curr, List<List<Integer>> res) {\\n        // If the current permutation is complete, add it to the results list\\n        if (curr.size() == nums.length) {\\n            res.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        \\n        // Loop through the indices of the input array\\n        for (int i = 0; i < nums.length; i++) {\\n            // Skip if the number has already been used or if it\\'s a duplicate that has already been used\\n            if (used[i] || (i > 0 && nums[i] == nums[i-1] && !used[i-1])) {\\n                continue;\\n            }\\n            // Mark the current number as used, add it to the current permutation list\\n            used[i] = true;\\n            curr.add(nums[i]);\\n            // Recursively call backtrack to generate all permutations\\n            backtrack(nums, used, curr, res);\\n            // Mark the current number as unused, remove it from the current permutation list\\n            used[i] = false;\\n            curr.remove(curr.size()-1);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666977,
                "title": "python-backtracking-faster-96-detailed-explanation-and-visualization",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```\\n\\nand visual explanation -\\n![image](https://assets.leetcode.com/users/images/f39f3270-e403-46a3-96c5-3ef4287d0217_1667010361.5402923.png)\\n\\n\\nPlease vote if you like my solution :D\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        ans = []\\n        n = len(nums)\\n        visited = [False] * len(nums)\\n        \\n        nums.sort()\\n        \\n        def backtracking(nums, res):\\n            # GOAL / Base case\\n            if len(res) == n:\\n                ans.append(res[:])\\n                return\\n            \\n            for i in range(len(nums)):\\n                # CONSTRAINTs\\n                # if current element is duplicated of previous one\\n                if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]):\\n                    continue\\n                \\n                # Make CHOICE\\n                res.append(nums[i])\\n                \\n                # BACKTRACKING\\n                visited[i] = True\\n                backtracking(nums, res)\\n                \\n                # RESET STATE\\n                visited[i] = False\\n                res.pop()\\n        \\n\\t\\t# Inital state\\n        backtracking(nums, [])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032690,
                "title": "c-easy-understanding-comments-with-picture-daily-leetcoding-challenge-may-day-12",
                "content": "**Please Upvote If It Helps**\\n\\n**![image](https://assets.leetcode.com/users/images/a25c51ac-74ea-4f44-b0a4-aa9b03225be4_1652378764.7523286.jpeg)\\n**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, set<vector<int>>& st, vector<int>& nums, int n)\\n    {\\n        // if our idx reaches to the n then store that vector into set\\n        if(idx==n)\\n        {\\n            st.insert(nums);\\n            return;\\n        }\\n        \\n        // now iterating over the given vector size\\n        // because we need , vector size subsets\\n        for(int i=idx;i<nums.size();i++)\\n        {\\n            // just swap the values and store them after swaping \\n            swap(nums[i],nums[idx]);\\n            \\n            helper(idx+1,st,nums,nums.size());\\n            \\n            // after taking them as a subset again swap them to make them as it is for next iteration\\n            swap(nums[i],nums[idx]);\\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        // making a set that will store only unique values\\n        set<vector<int>> st;\\n        \\n        // it will help in determining the all permutations\\n        helper(0,st,nums,nums.size());\\n        \\n        // copying all the set values into a 2D vector because our main function return type is 2D vector \\n        vector<vector<int>> ans(st.begin(),st.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031755,
                "title": "properly-explained-c-backtrack-solution-explained-with-comments",
                "content": "**Easy Recursive Solution \\nUpvote for Explaination :D**\\n\\n```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n vector<vector<int>> ans ;\\n    \\n    void helper( vector<int> &nums, int cnt, int n ){\\n        \\n        // If cnt == nums.size we have got our one combination \\n        // Push it inside our answer \\n        if( cnt == n ) {\\n            ans.push_back( nums ) ;\\n            return ;\\n        }\\n        \\n        unordered_set<int> s ;      // Set ensures that one element is placed once at every ith position  \\n        for( int i=cnt ; i<n ; i++ ){\\n            \\n            // If we have used the number at this ith position previously then just ignore this and continue to next number \\n            if( s.find(nums[i]) != s.end() )  \\n                continue ;  \\n            else s.insert(nums[i]);      // If we have not used the number then insert it for next verification\\n            \\n            swap( nums[i], nums[cnt] );       // Create a combination \\n            helper( nums, cnt+1, n ) ;        // Find out all possible combinations with the created one \\n            swap( nums[i], nums[cnt] );       // Backtracking \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        helper( nums, 0, n);\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682486,
                "title": "javascript-backtracking-solution-with-written-intuition",
                "content": "Time: `O(n!)` - Each `dfs` call makes (n-1) `dfs` calls\\nSpace: `O(n!)` - If all nums are unique, a unique combo is yielded at end of every branch.\\n\\nStrategy and Intuition\\n\\n* When asked for combos, it\\'s a good bet that we can use a recursive approach.\\n* To place an item once per combo, we\\'ll need to save info about the indicies we\\'ve visited.\\n* To meet the condition for unique combos, we\\'ll need a way to \"skip\" over nums that have already yielded combos.  Sorting helps us check if the curr num is a repeat one.\\n* Every `dfs` call has 3 steps.\\n\\t1) Add `i` to visited\\n\\t2) Call `dfs`\\n\\t3) Remove `i` from visited (this is the backtracking step)\\n* In plain English, \"skip\" the current `i` when:\\n\\t* We\\'ve already been to the index in an earlier call to `dfs`\\n\\t\\t* `if (visited.has(i)) continue;`\\n\\t* The curr num is the same as the prev num AND we haven\\'t seen the prev index\\n\\t\\t* `if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;`\\n* **Preventing Duplicates**\\n\\t* Any subsequent repeat nums will yield duplicate combos if not handled.\\n\\t* Take the input `[a1, a2, b1]` which yields combos `[a1, a2, b1], [a2, a1, b1]`\\n\\t\\t* To prevent this, simply stop `a2` from being added before `a1`\\n\\t\\t* Thus, `!visited.has(i-1)) continue;`\\n\\nHope this helps!\\n```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let res = [];\\n    dfs(nums.sort(), res, new Set());\\n    return res;\\n};\\n\\nconst dfs = (nums, res, visited) => {\\n    if (nums.length === visited.size) {\\n        let arr = [];\\n        for (let idx of visited) {\\n            arr.push(nums[idx]);\\n        }\\n        res.push(arr);\\n        return;\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {         \\n        if (nums[i] === nums[i-1] && !visited.has(i-1)) continue;\\n        if (visited.has(i)) continue;\\n        visited.add(i);\\n        dfs(nums, res, visited);\\n        visited.delete(i);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501603,
                "title": "backtracking-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    set<vector<int>> ans;\\n    void permutation(vector<int>& nums, int i){\\n        if(i==nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int j=i;j<nums.size();j++){\\n            swap(nums[i],nums[j]);\\n            permutation(nums,i+1);\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    \\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permutation(nums,0);\\n        vector<vector<int>> res(ans.begin(),ans.end());\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434637,
                "title": "simple-c-solution-with-explanation",
                "content": "Prerequisite -> How to find all permutations of a string.\\n\\nHere, We just have to make sure, every time we swap two positions, then we are swapping unique numbers. So we can take a hashMap, and store whether we have already swapped this number or not.\\nIf Swapped , then skip this recursvie call.\\nelse call the function and mark the number as swapped or true.\\n\\nHere is Implementation of the above approach.\\n\\nPLEASE UPVOTE, IF YOU LIKE MY CODE & APPROACH.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<vector<int>> &res, vector<int> nums, int idx) {\\n        if(idx == nums.size()) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        \\n        unordered_map<int, bool> mp;\\n        for(int i = idx; i < nums.size(); i++) {\\n            if(mp[nums[i]]) continue;\\n            mp[nums[i]] = true;\\n            swap(nums[i], nums[idx]);\\n            solve(res, nums, idx + 1);\\n            swap(nums[i], nums[idx]);\\n        }\\n        return;\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> res;\\n        solve(res, nums, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893745,
                "title": "very-easy-recursive-js-solution",
                "content": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction permuteUnique(nums: number[]): number[][] {\\n    const numberOfItems: number = nums.length;\\n    const map: Map<number, number> = new Map(); // (item, # of available times)\\n    const numsWithNoDuplicate: number[] = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (map.has(num)) {\\n            map.set(num, map.get(num) + 1);\\n        } else {\\n            map.set(num, 1);\\n            numsWithNoDuplicate.push(num);\\n        }\\n    }\\n    \\n    const result: number[][] = [];\\n    const currPath: number[] = [];\\n    \\n    permute(numberOfItems, numsWithNoDuplicate, currPath, map, result);\\n    \\n    return result;\\n    // N = the number of items in the given array\\n    // T.C: O(N!)\\n    // S.C: O(N)\\n};\\n\\nfunction permute(numberOfItems: number, nums: number[], currPath: number[], map: Map<number,number>, result: number[][]) {\\n    if (currPath.length === numberOfItems) {\\n        const newArray: number[] = currPath.slice();\\n        result.push(newArray);\\n        return;\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        const num: number = nums[i];\\n        if (map.get(num) > 0) {\\n            currPath.push(num);\\n            map.set(num, map.get(num) - 1);\\n            \\n            permute(numberOfItems, nums, currPath, map, result)\\n            \\n            currPath.pop();\\n            map.set(num, map.get(num) + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460214,
                "title": "easy-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private void Helper(IList<IList<int>> res, int idx, int[] nums)\\n    {\\n        if (idx == nums.Length)\\n        {\\n            res.Add(nums.ToList());\\n            return;\\n        }\\n\\n        ISet<int> visited = new HashSet<int>();\\n\\n        for (int i = idx; i < nums.Length; i++)\\n        {\\n            if (!visited.Add(nums[i]))\\n            {\\n                continue;\\n            }\\n\\n            var tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n\\n            Helper(res, idx + 1, nums);\\n\\n            tmp = nums[idx];\\n            nums[idx] = nums[i];\\n            nums[i] = tmp;\\n        }\\n\\n    }\\n\\n    public IList<IList<int>> PermuteUnique(int[] nums)\\n    {\\n        IList<IList<int>> res = new List<IList<int>>();\\n        Helper(res, 0, nums);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072933,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> ans;\\n    void f(vector<int> A,int l)\\n    {\\n        if(l==A.size())\\n        {\\n            ans.push_back(A);\\n            return;\\n        }\\n        unordered_set<int> seen;  \\n        for(int i=l;i<A.size();i++)\\n        {\\n            if(seen.find(A[i])!=seen.end())\\n            continue;\\n            swap(A[i],A[l]);\\n            f(A,l+1);\\n            swap(A[i],A[l]);\\n            seen.insert(A[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        f(nums,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661167,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```Plz upvote if you like the code..",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n     void solution(vector<int> nums,int index,vector<vector<int>>& ans){\\n        if(index==nums.size()){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        unordered_set<int> st;\\n       for(int j=index;j<nums.size();j++){\\n           if(st.find(nums[j])!=st.end()) continue;\\n           st.insert(nums[j]);\\n           swap(nums[index],nums[j]);\\n           solution(nums,index+1,ans);\\n           swap(nums[index],nums[j]);\\n       }\\n     }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int index=0;\\n        solution(nums,index,ans);\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030892,
                "title": "simple-swapping",
                "content": "The question is very similar to permutation 1 to understand this ,one must be familiar with permutation1 ,the only difference i sthat we are not suppose to take repeated element, that problem was solved earlier using set,but it used to take extra time, so i came up with new approach that we don\\'t need to store extras \\n```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>ans= new ArrayList<>();\\n    public void swap(int i,int j,int[]nums){\\n        int k=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=k;\\n    }\\n    \\n    public void fun(int k, int[]nums){\\n        if(k==nums.length){\\n            List<Integer>a= new ArrayList<>();\\n        for(int x:nums)a.add(x);\\n            ans.add(a);\\n            return;\\n        }\\n        HashSet<Integer>s=new HashSet<>();\\n\\t\\t//here i\\'m creating an hash set for one recurrsion\\n        for(int i=k;i<nums.length;i++){\\n\\t\\t//there i\\'m checking and making sure that nums[i] is not getting repeteation \\n          if(s.contains(nums[i]))continue;\\n            s.add(nums[i]);\\n            swap(i,k,nums);\\n            fun(k+1,nums);\\n            swap(i,k,nums);\\n       \\n        }\\n    }\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n    fun(0,nums);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933335,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n   \\n    Set<List<Integer>> set = new HashSet<>();\\n    int visited[] = null;\\n    \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n       \\n        visited = new int[nums.length];\\n        helper(nums, new ArrayList<Integer>());\\n       \\n        return new ArrayList<>(set);\\n        \\n    }\\n    \\n    private void helper(int[] nums, List<Integer> list){\\n         if(list.size()==nums.length){\\n           set.add(new ArrayList<>(list)); \\n             return;\\n         }\\n      \\n        for(int i=0; i<nums.length; i++){    \\n\\n            if(visited[i] == 0){\\n                list.add(nums[i]);\\n                visited[i] = 1;\\n                helper(nums, list);\\n                list.remove(list.size()-1);\\n                visited[i] = 0;\\n            }\\n\\n             \\n        }\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933328,
                "title": "c-simple-backtracking-solution",
                "content": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int> nums, int index)\\n    {\\n        if(index == nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            if(nums[i] != nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                backtrack(nums, index+1);\\n            }\\n            else if(i == index)\\n            {\\n                backtrack(nums, index+1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18733,
                "title": "java-recursive-solution-with-minimal-extra-space",
                "content": "The idea is to directly modify the order of original array using a swap method instead of creating new list saving the results of every recursive call.\\n\\n    public class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }\\n    \\n    public void backTrack(int[] nums, List<List<Integer>> result, int begin, int end){\\n        if(begin>end){\\n            //changing int[] to arraylist and save into final result list\\n            result.add(new ArrayList<Integer>() {{ for (int i : nums) add(i); }});\\n        }\\n        \\n        else{\\n            for(int i=begin; i<=end; i++){\\n               \\n                if(!isDuplicate(nums, begin, i)){\\n                    swap(nums,i,begin);\\n                    backTrack(nums, result, begin+1, end); \\n                    swap(nums,i,begin);\\n                }\\n                \\n            }\\n        \\n        }\\n        \\n    }\\n    \\n    //check whether the current number has appeared in the subarray. if same number appears, we do not need to move this number again\\n\\n    public boolean isDuplicate(int[] nums, int begin, int i){\\n        for(int a=begin; a<i; a++){\\n            if(nums[a]==nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int buf = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = buf;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n\\n        List<List<Integer>> result = new ArrayList();\\n        if(nums.length==0) return result;\\n        backTrack(nums, result, 0, nums.length-1);\\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 18720,
                "title": "for-those-who-get-tle-3-3-0-0-2-3-2",
                "content": "    #include<vector>\\n    #include<iostream>\\n    using namespace std;\\n    \\n    class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }\\n            for(int i = begin; i < nums.size(); i++){\\n                if(begin != i && nums[begin] == nums[i])\\n                    continue;\\n                swap(nums[begin], nums[i]);\\n                recur(nums, begin + 1, res);\\n                swap(nums[begin], nums[i]);\\n            }\\n        }\\n        vector< vector<int> > permuteUnique(vector<int>& nums) {\\n            vector< vector<int> > res;\\n            recur(nums, 0, res);\\n            return res;\\n        }\\n    \\n        /*methods 2: sorted, pass value */\\n        void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n            if (i == j-1) {\\n                res.push_back(num);\\n                return;\\n            }\\n            for (int k = i; k < j; k++) {\\n                if (i != k && num[i] == num[k]) continue;\\n                swap(num[i], num[k]);\\n                recursion(num, i+1, j, res);\\n            }\\n        }\\n        vector<vector<int> > permuteUnique2(vector<int> &num) {\\n            sort(num.begin(), num.end());\\n            vector<vector<int> >res;\\n            recursion(num, 0, num.size(), res);\\n            return res;\\n        }\\n    };\\n    \\n    int main(){\\n        class Solution a;\\n        int n[] = {3,3,0,0,2,3,2};\\n        vector<int> nums;\\n        for(int i = 0; i < sizeof(n) / sizeof(int); i++)\\n            nums.push_back(n[i]);\\n        vector< vector<int> > res = a.permuteUnique(nums);\\n        vector< vector<int> > res2 = a.permuteUnique2(nums);\\n        cout << \"size of methods 1: \" << res.size() << endl << \"size of methods 2: \" << res2.size() << endl;\\n        return 0;\\n    }\\n\\nAt first I use the first method and run into the problem and couldn't figure out why,then I find the answer at \\n[https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines?state=edit-66279&show=61784#a61784][1] (in the first answer).\\n\\nBefore I figured it out, I also inplement this two methods to see the difference of the output, and it's really vivid; )\\nAfter you run it, res.size() is much bigger than res2.size() because it contains duplicate answers!\\nLet's take this array (1,2,2,3) for example, now pos(start) = 0 and i = 0;\\n\\n(1,2,2,3) (pos = 0, i = 0)\\n\\n(2,1,2,3) (pos = 0, i = 1)\\n\\n(2,2,1,3) (pos = 0, i =2)\\n\\n(3,2,2,1) (pos = 0, i =3)\\n\\nIn the second case and third case,the permutations of subsets (1,2,3) and (2,1,3) are exactly the same, so it generates duplicate answers as it continues recursion.\\n\\nREALLY appreciate BarneyZhao and TonyLic for pointing it out for me!\\n\\n\\n  [1]: https://leetcode.com/discuss/25279/a-simple-c-solution-in-only-20-lines",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        /* methods 1: no sort, swap twice, use reference */\\n        void recur(vector<int> &nums, int begin, vector< vector<int> > &res){\\n            if(begin == nums.size()){\\n                res.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 18809,
                "title": "tle-on-1-1-3-1-please-help",
                "content": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "solutionTags": [],
                "code": "public List<List<Integer>> permuteUnique(int[] num) `{`\\n        ArrayList<List<Integer>> rst = new ArrayList<List<Integer>>();\\n        Arrays.sort(num);\\n        getPermute(num, 0, rst);\\n        return rst;\\n    }\\n    \\n    public void getPermute(int[] num, int start, ArrayList<List<Integer>> rst){\\n        \\n        if(start == num.length){\\n            ArrayList<Integer> list = new ArrayList<Integer>();\\n            for(int i : num){\\n                list.add(i);\\n            }\\n            rst.add(list);\\n            return;\\n        }\\n        \\n        for(int i = start; i < num.length; i++){\\n            if(i > start && num[i] == num[start]){\\n                continue;\\n            }\\n            swap(num, i, start);\\n            getPermute(num, start + 1, rst);\\n            swap(num, i, start);\\n        }\\n    }\\n    \\n    private void swap(int[] num, int i, int j){\\n        int temp = num[i];\\n        num[i] = num[j];\\n        num[j] = temp;\\n    }\\n\\n\\nAnyone has a clue why this code will cause TLE? It runs pretty will on my eclipse",
                "codeTag": "Unknown"
            },
            {
                "id": 3704875,
                "title": "easy-beginner-friendly-solution-recursion-and-stl-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive Tree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I\\'ve considered the original array, and have done the operations in it.\\n2. Basically I have swapped all the values at differnt indices from a value at a particular index.\\n3. Here is the example: \\n   \\n![image.png](https://assets.leetcode.com/users/images/20211b7b-2484-4658-ac3f-3cba4e3569bf_1688225850.3467298.png)\\n\\n- Initally we are on index 0:\\nSwap 1 with 1 then 2 with 1 and then 3 with 1.\\nNow we have got three differnt arrays\\n- Now we are on index 1:\\n**For array 1:**\\nSwap 2 with 2 and then swap 3 with 2\\n**For array 2:**\\nSwap 1 with 1 and then swap 3 with 1.\\n**For array 3:**\\nSwap 2 with 2 and then swap 1 with 2.\\n\\nSo in total we have got 6 different arrays.\\n\\n4. Now let\\'s say instead of [1,2,3] we had [1,1,2]\\nIn this case, there would be **duplicate arrays**, so for removing them I have **used MAP**.\\n\\n\\nFeel free to mention your doubts in the comments below :)\\n\\n# Complexity\\n- Time complexity: **O(n!)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n!)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> nums, int index, vector<vector<int>> & ans)\\n    {\\n        if(index >= nums.size())\\n        {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for(int i = index; i < nums.size(); i++)\\n        {\\n            swap(nums[index], nums[i]);\\n            solve(nums, index + 1, ans);\\n\\n            //backtrack\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans, unique;\\n        int index = 0;\\n\\n        map<vector<int>, int> mp;\\n\\n        solve(nums, index, ans);\\n\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            mp[ans[i]]++;\\n        }\\n\\n        for(auto & it: mp)\\n        {\\n            unique.push_back(it.first);\\n        }\\n\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847565,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> pn;\\n        vector<int> t=nums;\\n        do\\n        {\\n            pn.push_back(nums);\\n            nextPermutation(nums);\\n        }\\n        while(nums!=t);\\n        return pn;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        int bp=-1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                bp=i;\\n                break;\\n            }\\n        }\\n        if(bp<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n        for(int i=nums.size()-1;i>bp;i--)\\n        {\\n            if(nums[i]>nums[bp])\\n            {\\n                swap(nums[bp],nums[i]);\\n                reverse(nums.begin()+bp+1,nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773174,
                "title": "permutations-2-java-solution-using-hashset-in-permutations-1",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         Set<List<Integer>> ans = new HashSet();\\n\\t        helper(nums,0,ans);\\n\\t        return new ArrayList(ans);\\n    }\\n     public void helper(int[] nums, int index, Set<List<Integer>> ans)\\n\\t    {\\n\\t    \\tif(index==nums.length)\\n\\t    \\t{\\n\\t    \\t\\t    ArrayList<Integer> list =new ArrayList<>();\\n\\t    \\t        for(int i = 0 ; i<nums.length ; i++){\\n\\t    \\t            list.add(nums[i]);\\n\\t    \\t        }\\n\\t    \\t        ans.add(list);\\n\\t    \\t        return;\\n\\t    \\t}\\n\\t    \\t\\n\\t        for(int i = index; i<nums.length; i++)\\n\\t        {\\n\\t            swap(i,index,nums);\\n\\t            helper(nums, index+1, ans);\\n\\t            swap(i,index,nums);\\n\\t        }\\n\\t    }\\n\\t    public static void swap(int i , int j, int[] nums){\\n\\t    \\t  int t=nums[i];\\n\\t    \\t    nums[i]=nums[j];\\n\\t    \\t    nums[j]=t;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032973,
                "title": "c-recursion-backtracking-permutations",
                "content": "**Approach-1 : Using set, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\\n\\n**Approach-2 : Using sort, recursion, and backtracking**\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, set<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.insert(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=11) //check whether nums[i] already used if it is we skip if not we follow given statements\\n            {\\n                //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n                //then call helper function and when unique permutation is found and\\n                //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutaton\\n                permute.push_back(nums[i]); \\n                int j = nums[i]; \\n                nums[i] = 11;              \\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        set<vector<int>> unique; //use set for all unique permutation\\n        vector<vector<int>> ans;\\n        helper(nums, unique, {});\\n        \\n        //put set elements into ans\\n        for(auto i:unique) \\n            ans.push_back(i);\\n        \\n        return ans;     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int> &nums, vector<vector<int>> &unique, vector<int> permute)\\n    {\\n        //base condition if permute size is equal to the nums size   \\n        if(permute.size()==nums.size())\\n        {\\n            unique.push_back(permute); //put permute into the set unique and return\\n            return;\\n        }\\n        \\n        //iterate over nums \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            //we check whether nums[i-1] equals to nums[i] if it is we continue, for avoiding duplicate permutation\\n            //push nums[i] into permute and marks nums[i] as used by assigning 11 to it\\n            //then call helper function and when unique permutation is found and\\n            //we backtrack, we replace 11 with real value of nums and pop nums[i] from unique for the next permutation\\n            if(nums[i]!=11) \\n            {\\n                if(i>0 && nums[i-1]==nums[i]) continue;\\n            \\n                permute.push_back(nums[i]);\\n                int j = nums[i];\\n                nums[i] = 11;\\n                helper(nums, unique, permute);\\n                nums[i] = j;\\n                permute.pop_back();\\n                \\n            }\\n        }\\n            \\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) \\n    {\\n        //sort nums for getting duplicate nums in a sequence\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> unique;\\n        helper(nums, unique, {});\\n        return unique;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030556,
                "title": "c-next-perumutation",
                "content": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> ans; \\n        ans.push_back(nums);\\n        while(next_permu(nums))\\n            ans.push_back(nums);\\n        return ans;\\n    }\\n    \\n    bool next_permu(vector<int> &nums){\\n        int i;\\n        for(i = n - 2; i >= 0 and nums[i] >= nums[i+1]; i--);\\n        if(i < 0) return false;\\n        int j;\\n        for(j = n - 1; j >= 0 and nums[j] <= nums[i]; j--);\\n        \\n        swap(nums[j],nums[i]);        \\n        reverse(nums.begin() + i + 1, nums.end());\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008905,
                "title": "python-recursion-with-explanation",
                "content": "for the recursion/backtrack function we have a base case and a main case:\\n* Base Case: if where the pointer is pointing at is beyond the length of nums, add the permutation made into the results list\\n* Main Case: for each time the backtrack function is called, generate a new empty seen set, so we can make sure that we don\\'t generate the same permutation again.\\nfor example, as you can see in the image, at the first leve (index =0) , the seen set has 1 and 2 in it. so for the second 2, as the seen set has already one 2 in it, it doesnt go through the actions under the if condition. The same procedure happens for other level as well. \\n\\n![image](https://assets.leetcode.com/users/images/a57b0466-9aaf-4c58-980e-0b186bd40b28_1651702847.700333.jpeg)\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n\\n        results = []\\n    \\n        def backtrack(pointer):\\n            if pointer == len(nums):\\n                results.append(nums[:])\\n                return\\n            \\n            seen = set() #generate an empty set eveytime the backtrack function is called\\n            for i in range(pointer, len(nums)):\\n\\t\\t\\t\\n                if nums[i] not in seen: #do below > if nums[i] is not already in the seen\\n\\t\\t\\t\\t\\n                    seen.add(nums[i]) #add nums[i] to the seen so if there is a duplicate, if condition can catch it\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n                    backtrack(pointer+1)\\n                    \\n                    nums[i], nums[pointer] = nums[pointer], nums[i]\\n                    \\n        backtrack(0)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697139,
                "title": "javascript",
                "content": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let result = []\\n    nums.sort((a,b) => a-b)\\n    let visited = new Array(nums.length).fill(false)\\n    \\n    function backtrack(permutations){\\n        if (permutations.length === nums.length){\\n            result.push([...permutations])\\n        } else {\\n            for (let i = 0; i < nums.length; i++){\\n                // duplicate check\\n                if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])) continue\\n                visited[i] = true\\n                permutations.push(nums[i])\\n                backtrack(permutations)\\n                visited[i] = false\\n                permutations.pop()\\n            }\\n        }\\n    }\\n    \\n    backtrack([])\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640499,
                "title": "two-js-easy-solutions-with-comments-with-wo-sorting",
                "content": "**IMPORTANT: It\\'s only for those who\\'ve solved the Permutations I probelem. This by no means, is an exhaustive explanation.**\\n**No sorting**\\nThe idea here is, the moment you encounter a number while looping over the remaining array, you check if that is already in the set of values. If yes, you continue, (move to the next element).\\nOtherwise, add the current element to the set that holds the unique elements in the array. And do the processing.\\nThis way, we don\\'t need to sort, which improves the timing, but extra space will be used O(n) where n is number of unique elements in the set, Since `set.has(el)` is constant time O(1), this improves the time complexity.\\nIn case of sorting, unless quicksort is used, you\\'ll endup using extra time and space both.\\n\\n**No Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\\n**Sorting**\\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let data = [];\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        let uniques = new Set();\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n            if(uniques.has(remaining[i])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n                uniques.add(remaining[i]);\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n\\tlet data = [];\\n\\tnums = nums.sort();\\n\\tfunction _permute(curr, remaining) {\\n\\t\\tif (!remaining.length) {\\n\\t\\t\\tdata.push(curr);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (let i = 0; i < remaining.length; i++) {\\n\\t\\t\\tif (i > 0 && remaining[i] === remaining[i - 1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurr.push(remaining[i]);\\n\\t\\t\\t\\t_permute([...curr], [...remaining.slice(0, i), ...remaining.slice(i + 1)]);\\n\\t\\t\\t\\tcurr.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t_permute([], nums);\\n\\treturn data;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 18660,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 18803,
                "title": "accepted-iterative-solution-in-java",
                "content": "Here's my iterative solution in java:\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }\\n                    }\\n                    \\n                    permutations = newPermutations;\\n                }\\n            }\\n            return new ArrayList<List<Integer>>(permutations);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> permuteUnique(int[] num) {\\n            Set<List<Integer>> permutations = new HashSet<List<Integer>>();\\n            \\n            if(num.length > 0){\\n                permutations.add(Arrays.asList(num[0]));\\n                \\n                for(int index = 1; index < num.length; index++) {\\n                  \\n                    Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();\\n                    for(List<Integer> list : permutations){\\n    \\n                        for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){\\n                            List<Integer> newList = new ArrayList(list);\\n                            newList.add(innerIndex, num[index]);\\n                            newPermutations.add(newList);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3312385,
                "title": "cheat-one-liner-in-python-using-in-built-permutations-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(permutations(nums)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279614,
                "title": "fast-easy-o-n-nlogn-o-1-no-backtracking-no-recursion-no-inbuilt-fn",
                "content": "# Intuition\\nBased on finding the next permutation every time.\\n\\n# Approach\\nThe approach is derived from the [next permuatation](https://leetcode.com/problems/next-permutation) solution, where we have to [find](https://leetcode.com/problems/next-permutation/submissions/911026310/) the next permuation of an array of integers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n! + nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>> vc;\\n        int i,j,n=nums.size()-1;\\n        do{\\n            i=j=n;\\n            while(i && nums[i-1]>=nums[i]) i--;\\n            if(i){\\n                while(nums[i-1]>=nums[j]) j--;\\n                swap(nums[i-1],nums[j]);\\n            }\\n            reverse(nums.begin()+i,nums.end());\\n            vc.push_back(nums);\\n        }while(i);\\n        return vc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103517,
                "title": "94-javascript-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\n\\nhttps://youtu.be/pamdPigxHoY\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    nums.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (arr,temp) =>{\\n        if(arr.length == 1){\\n            res.push([...temp,arr[0]])\\n            return;\\n        }\\n        for(let i =0;i<arr.length;i++){\\n            if(arr[i] == arr[i-1]) continue;\\n            iterate(arr.filter((num,idx)=>idx !=i),[...temp,arr[i]])\\n        }\\n    }\\n    iterate(nums,[])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018452,
                "title": "easiest-faang-method-ever",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N!*N) + O(N) + O(NlogN) ~  O(N! * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) //For using set DS & vector vec\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    void Permutations(int ind, vector<int> &nums, set<vector<int>> &ans){\\n        if(ind==nums.size())\\n            ans.insert(nums);\\n\\n        for(int i=ind;i<nums.size();i++){      \\n            if(i>ind && nums[i]==nums[ind]) continue;\\n            swap(nums[i],nums[ind]);\\n            Permutations(ind+1, nums, ans);\\n            swap(nums[i],nums[ind]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        set<vector<int>> ans;\\n        vector<vector<int>> vec;\\n        Permutations(0, nums, ans);\\n        for(auto it:ans){\\n            vec.emplace_back(it);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949128,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N!)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823043,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        do {\\n            ans.push_back(nums);\\n        }\\n        while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030931,
                "title": "java-classic-backtracking",
                "content": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> permutations = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtracking(permutations, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return permutations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> permutations, List<Integer> current, int[] nums, boolean[] used) {\\n        if (current.size() == nums.length)\\n            permutations.add(new ArrayList<>(current));\\n        else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\\n                current.add(nums[i]);\\n                used[i] = true;\\n                backtracking(permutations, current, nums, used);\\n                used[i] = false;\\n                current.remove(current.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030484,
                "title": "c-backtracking-and-hashing",
                "content": "Idea:\\n* Generate all permutations using the backtracking algorithm.\\n* Then generate a equivalent hash value for each permutations and store it into the map.\\n* For a permutation, if the hash value is not found into the map then add it to the answer otherwise discard it.\\n\\nComplexity for unordered_map: O(n^n)\\nComplexity for ordered_map: O(n^n) log (n^n)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mymap;\\n    int mod = 1e9 + 7;\\n    int base = 37;\\n    vector<vector<int> > ans;\\n    vector<int> temp;\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++) nums[i] = nums[i] + 10;\\n        solve(nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    void solve(vector<int>& nums, int mask, int hashValue){\\n        int n = nums.size();\\n        if(mask == (1<<n)-1){\\n            if(!mymap[hashValue]){\\n                ans.push_back(temp);\\n                mymap[hashValue]++;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if( !(mask & (1<<i)) ){\\n                long long t = hashValue * 1ll * base + nums[i];\\n                if(t>=mod) t %= mod;\\n                temp.push_back(nums[i] - 10);\\n                solve(nums, mask | (1<<i), t);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860786,
                "title": "c-backtracking-using-hashmap-to-avoid-identical-solution-c-easy-11ms-solution",
                "content": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\\n\\n#####  For those who find difficulty understanding it and need explanation\\nwhat we are doing is,\\ntaking all possible unique element one by one in one place and then doing permutation for remaining places with remaing element (since all permutations should be unique, if for example , we have taken 1 in first place and calculated all possible permutations for the remaing , then we cannot take 1 again at same place and calculate the same permutation again)\\n\\n```\\n for(auto &k: nums) mp[k]++;\\n```\\nwe have stored the frequency of all elements in map.\\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\\nif idx==n , means we have used all the element and a permutation is formed. then push this permutation in ans array.\\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```\\ni) we are iterating to all the element in mp only once since we want unique numbers at unique places.\\nii) if (val==0) means , the element we are iterating at is used totally and none left , then we should continue and move to another element.\\niii) if (val != 0 ) means, we can use this element here. and so we push this element curr , and do permutation for the remaing , and again pop back to ensure it leaves no trail of its past.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n//backtracking using hashmaps.\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;  //to store freqency of all unique elements.\\n    vector<vector<int>> ans;    // to store all permutations once formed.\\n    vector<int> curr;           //curr is empty initially, and is formed step by step \\n                                //one all elements are used in curr, it is pushed in ans.\\n    void permutations(int idx,vector<int>& nums){\\n        int n=nums.size();\\n        \\n        if(idx==n){                //all elements are used then push it in ans array.\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        for(auto &k: mp){\\n            int key=k.first;    //the element.\\n            int val=k.second;   //its frequency.\\n            \\n            if(val==0) continue;    // val==0 means this element is used completely\\n                                    // and cannot be further use.\\n            curr.push_back(key);mp[key]--;  //else use this element and form a permutation.\\n            permutations(idx+1,nums);       \\n            curr.pop_back();mp[key]++;      // pop back so as to leave no trail of previous\\n        }                                   // permutations formed.\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        for(auto &k: nums) mp[k]++; //storing frequency of elements.\\n        permutations(0,nums);\\n        \\n        return ans; \\n    }\\n};\\n```\n```\\n for(auto &k: nums) mp[k]++;\\n```\n```\\nif(idx==n){\\n            ans.push_back(curr);\\n            return;\\n        }\\n```\n```\\nfor(auto &k: mp){\\n            int key=k.first;\\n            int val=k.second;\\n            \\n            if(val==0) continue;\\n            \\n            curr.push_back(key);mp[key]--;\\n            permutations(idx+1,nums);\\n            curr.pop_back();mp[key]++;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437256,
                "title": "simple-java-solution-faster-than-99-39",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        Arrays.sort(nums);\\n        permute(nums, new ArrayList<Integer>(), new boolean[nums.length]);\\n        return result;\\n    }\\n    \\n    public void permute(int[] nums, List<Integer> list , boolean[] used) {\\n        \\n        if(list.size() == nums.length){\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(!used[i]){\\n                if(i == 0 || nums[i-1] != nums[i] || used[i-1]){\\n                used[i] = true;\\n                list.add(nums[i]);\\n                permute(nums, list, used);\\n                used[i] = false;\\n                list.remove(list.size()-1);  \\n                }\\n                               \\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348102,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        let sorted = nums.sorted()\\n        var candidates = [Int]()\\n        var result = [[Int]]()\\n        var isVisited = Array(repeating: false, count: nums.count)\\n        \\n        backTracking(sorted, &candidates, &result, &isVisited)\\n        return result\\n    }\\n    \\n    // assume its like a tree\\n    func backTracking(_ nums: [Int], _ candidates: inout [Int], _ result: inout [[Int]], _ isVisited: inout [Bool]) {\\n        // when reach the leaves\\n        guard candidates.count < nums.count else {\\n            result.append(candidates)\\n            return \\n        }\\n        \\n        for i in 0..<nums.count where !isVisited[i] {\\n\\n            // filter out cases when a number has same value with its previous, and its previous is not used, we mark as \"@\" in below graph; like sibling same value cases\\n            if i > 0 && nums[i-1] == nums[i] && !isVisited[i-1] { continue }\\n            \\n            candidates.append(nums[i])\\n            isVisited[i] = true\\n            \\n            backTracking(nums, &candidates, &result, &isVisited)\\n            \\n            candidates.removeLast()\\n            isVisited[i] = false\\n        }\\n        \\n    }\\n}\\n\\n\\n// eg: [1, 1, 2]; assume it\\'s like a tree; \"*\" means duplicated cases, \"@\" means who have same value of its previous\\' sibling\\n//                           [ ]\\n//              /             |                \\\\\\n//            [1]            [@1]               [2]\\n//           /   \\\\          /   \\\\             /   \\\\\\n//       [1,1]  [1,2]    *[1,1] *[1,2]      [2,1]  [2,@1]\\n//         /       \\\\       /        \\\\        /       \\\\\\n//     [1,1,2]  [1,2,1] *[1,1,2]  *[1,2,1] [2,1,1]  *[2,1,1]\\n\\n//    output: [[1,1,2],[1,2,1],[2,1,1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280164,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PermuteUnique(int[] nums) {\\n        var n = nums.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (n == 0) return result;\\n        \\n        Array.Sort(nums);\\n\\n        DFS(nums, new bool[n], 0, new List<int>(), result);\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[] nums, bool[] isVisited, int start, IList<int> oneResult, IList<IList<int>> result) {\\n        var n = nums.Length;\\n\\n        if (oneResult.Count == n) {\\n            result.Add(new List<int>(oneResult));\\n        } else {\\n            for (int i = 0; i < n; i++) {\\n                if (isVisited[i]) continue;\\n                if (i > 0 && nums[i - 1] == nums[i] && isVisited[i-1]) continue;\\n\\n                oneResult.Add(nums[i]);\\n                isVisited[i] = true;\\n                DFS(nums, isVisited, i, oneResult, result);\\n                isVisited[i] = false;\\n                oneResult.RemoveAt(oneResult.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 18731,
                "title": "1-line-python-solution-set-list-slicing-beats-46-11",
                "content": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "Inspired by this [one-liners][1].\\n\\n    def permuteUnique(self, nums):\\n        return [[n] + p for n in set(nums) for p in self.permuteUnique(nums[:nums.index(n)] + nums[nums.index(n) + 1:])] or [[]]\\n\\n  [1]: https://leetcode.com/discuss/42550/one-liners-in-python",
                "codeTag": "Python3"
            },
            {
                "id": 3713810,
                "title": "java-solution-using-backtrackingba-understandable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo understand more check  my previous solution !!!\\nhttps://leetcode.com/problems/permutations/solutions/3713561/java-solution-using-backtracking-method/\\n\\n\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Hash Function"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\n\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        HashSet<List<Integer>> set = new HashSet<>();\\n\\n        backtrack(res, nums, 0, set);\\n        return res;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, int[] nums, int index, HashSet<List<Integer>> set) {\\n        if (index == nums.length) {\\n            List<Integer> current = toList(nums);\\n            if (!set.contains(current)) {\\n                res.add(current);\\n                set.add(current);\\n            }\\n        } else {\\n            for (int i = index; i < nums.length; i++) {\\n                swap(index, i, nums);\\n                backtrack(res, nums, index + 1, set);\\n                swap(index, i, nums);\\n            }\\n        }\\n    }\\n\\n    public void swap(int m, int n, int[] nums) {\\n        int temp = nums[m];\\n        nums[m] = nums[n];\\n        nums[n] = temp;\\n    }\\n\\n    public List<Integer> toList(int[] nums) {\\n        ArrayList<Integer> l = new ArrayList<>();\\n        for (int n : nums) {\\n            l.add(n);\\n        }\\n        return l;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712389,
                "title": "c-backtracking-using-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void backTrack(vector<vector<int>>& res, vector<int>& curr, unordered_map<int,int>& m, vector<int>& nums) {\\n        if(curr.size() == nums.size()) {\\n            res.push_back(curr);\\n        }\\n\\n        for(auto itr = m.begin(); itr != m.end(); itr++) {\\n            if(itr->second == 0) continue;\\n            curr.push_back(itr->first);\\n            itr->second -= 1;\\n            backTrack(res, curr, m, nums);\\n            curr.pop_back();\\n            itr->second += 1;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> curr;\\n        unordered_map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i]]++;\\n        }\\n        backTrack(res, curr, m, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209528,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>>ans;\\n        do{\\n            ans.push_back(nums);\\n        }while(next_permutation(nums.begin(), nums.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097461,
                "title": "c-easy-solution-recursion-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(set<vector<int>>&res,vector<int>&temp,vector<int>& nums,vector<int>& vis){\\n        if(nums.size()==temp.size()){\\n            res.insert(temp);\\n            return;\\n        }\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                temp.push_back(nums[i]);\\n                f(res,temp,nums,vis);\\n                temp.pop_back();\\n                vis[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        set<vector<int>>res;\\n        vector<int>temp;\\n        vector<int>vis(nums.size(),0);\\n        f(res,temp,nums,vis);\\n        vector<vector<int>>ans;\\n        for(auto it:res){\\n            ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845014,
                "title": "easy-c-solution-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int pos,vector<vector<int>>&ans,vector<int>& nums){\\n        if(pos>nums.size()){\\n            return;\\n        }\\n        \\n        if(pos==nums.size()-1){\\n\\t\\t\\n\\t\\t//Check for duplicate vectors in 2D vector\\n            for(int i=0;i<ans.size();i++){\\n                if(ans[i]==nums){\\n                    return;\\n                }\\n            }\\n            ans.push_back(nums);\\n            return;\\n        }\\n        \\n        for(int i=pos;i<nums.size();i++){\\n            swap(nums[i],nums[pos]);\\n            help(pos+1,ans,nums);\\n\\t\\t\\t\\n\\t\\t\\t//Backtraking\\n            swap(nums[i],nums[pos]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        // set<set<int>>s;\\n        vector<vector<int>>ans;\\n        // vector<int>v;\\n        help(0,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630122,
                "title": "easy-java-solution",
                "content": "**Solution**\\nThis is solution is same as LEETCODE permutations with few changes to remove duplication\\n```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\\nRest Same Logic as Permutations(leetcode 46):-\\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> permuteUnique(int[] nums) \\n {\\n        List<List<Integer>> al = new ArrayList<>();\\n        generate(nums, 0, nums.length-1, al);\\n\\t\\t//taking hashset of generic List so to remove duplicate lists\\n        HashSet<List> hs = new HashSet<>();\\n        for(List a: al)\\n        {\\n            hs.add(a); //adding all the lists from list of list to the HashSet\\n        }\\n        al.clear(); //clearing the original list of list to add new unique lists\\n        for(List a: hs)\\n        {\\n            al.add(a); //adding lists from HashSet\\n        }\\n        return al; //returning ans\\n    }\\n```\n```\\nstatic void generate(int a[], int i, int l, List<List<Integer>> al)\\n    {\\n        if(i==l) //if index comes at last element of array\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n\\t\\t\\t//creating the list every time when the base conditions get hit\\n            for(int x: a)\\n            {\\n                cl.add(x);\\n            }\\n            al.add(cl); //adding this list to list of list\\n        }\\n        else\\n        {\\n            for(int j = i; j<=l; j++) // loop from i to last element //after each recursion i will get incremented and loop will also change \\n            {\\n                a = swap(a, i, j); //swapping ith element with jth element\\n                generate(a, i+1, l, al); // further calling the recursion call again for further swaping\\n                a = swap(a, j, i); //after the recursion ends returning back and swaping again the ith and jth element so that we get original array back for another recursion call\\n            }\\n            \\n        }\\n    }\\n\\t//Swap Function:---\\n\\tstatic int[] swap(int a[], int i, int j)\\n    {\\n        int temp = a[i];\\n        a[i] = a[j];\\n        a[j]= temp;\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030500,
                "title": "easy-cpp-solution-permutations-2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```\\n\\nFeel free to comment if you have any doubt. Upvote if my solution helped you.",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<vector<int>>v;\\n    set<vector<int> > s;\\n    void number(vector<int>&x, int index, vector<int>&nums){\\n    if(index==nums.size()){\\n        auto pos = s.find(nums);\\n        if(pos==s.end()){\\n        v.push_back(nums);\\n        s.insert(nums);\\n        }\\n        \\n        return;\\n    }\\n    for(int i=index;i<nums.size();i++){\\n        swap(nums[i],nums[index]);\\n        number(x,index+1,nums);\\n        swap(nums[i],nums[index]);\\n    }\\n    \\n}\\n    \\n   \\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<int>x;\\n    number(x, 0, nums);\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030468,
                "title": "c-backtracking-with-bootleg-key-to-make-sure-it-is-unique",
                "content": "**Solved live on stream.  Link in profile.**\\n\\n```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    string makeKey(vector<int>& path) {\\n        string key = \"\";\\n        for(int x : path) {\\n            key += to_string(x) + \\':\\';\\n        }\\n        return key;\\n    }\\n    \\n    void bt(vector<int>& nums, unordered_set<int>& seen, vector<int>& path, vector<vector<int>>& ans, unordered_set<string>& uniques) {\\n        if(path.size() == nums.size()) {\\n            string key = makeKey(path);\\n            if(uniques.find(key) != uniques.end()) return;\\n            uniques.insert(key);\\n            ans.push_back(path);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if(seen.find(i) != seen.end()) continue;\\n            seen.insert(i);\\n            path.push_back(nums[i]);\\n            bt(nums, seen, path, ans, uniques);\\n            seen.erase(i);\\n            path.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        unordered_set<string> uniques;\\n        unordered_set<int> seen;\\n        vector<int> path;\\n        vector<vector<int>> ans;\\n        bt(nums, seen, path, ans, uniques);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976262,
                "title": "c-optimised-solution-without-duplicates-100-time-0ms-100-space-8mb",
                "content": "This problem is nice because it offers a few subtle challenges:\\n* we need to figure out how to get all the permutations; \\n* we want to do so as efficiently as possible, without generating duplicates;\\n* partially connected with the previous one, we want to avoid unnecessary memory usage, so we should have our result variable already properly sized in advance.\\n\\nLet\\'s start with the last point, *shall we?* [imagine this bit pronounced with the tone of [the Critical Drinker](https://www.youtube.com/channel/UCSJPFQdZwrOutnmSFYtbstA)]\\n\\nWe know (or can google/derive) that the number of permutations we will get is equal to the factorial of the numbers of elements, divided by the factorial of the frequency of each of them.\\n\\nSo, for example, if our input is `{1,2,3,4,5}`, we will get `5!` permutations, that is to say `120`; if we were still given `5` elements, but they were, say, `{1,1,4,4,4}`, we will have  `5! / 2! / 3!` (since we have `2` `1`s and `3` `4`s), which is `10`.\\n\\nAnd what about not generating duplicates? We can do it with the built-in `next_permutation` that will `return` us only the next different permutation, no matter whether we have duplicated elements or not. Even better if we try to replicate that behaviour ourselves, since it is good practice.\\n\\nWith that in mind, time to start, declaring externally a precomputed array `facts` with all the factorials up to `8` (our largest possible input); inside our function we will also declare:\\n* `len` as the size of our input;\\n* `resSize` as the size of our result, initially set to be the factorial of `len` (that we will also decrease, so that it will become the value of the last index of the input);\\n* `freqs` and `nFreqs` will store the frequencies of the positive and negative numbers we will be passed.\\n\\nWe will then loop through each element `n` in `nums` and:\\n* increased either `freqs[n]` or `nFreqs[-n]` by `1` (depending on whether or not `n` was positive);\\n* divide `resSize` by the updated frequence (which in turn will equate to dividing from the factorial of the overall frequence of each element).\\n\\nNow that we have a proper value for `resSize`, we can create our last support variables `res` with the proper capacity, without consuming resources with several painful/expensive reallocations!\\n\\nAnd now time to prepare `nums` - for convenience setting it to be our first permutation (ie:  the one with all its elements sorted in increasing order); I am fully aware this would not be strictly necessary, but since at some point we might reach a point in which we reach the last permutation (all the elements in decreasing order), and thus do the same, I just preferred to keep my logic a bit lighter and start with it.\\n\\nWe will write this value in `res[0]`.\\n\\nAssuming `resSize > 1`, we will then loop `resSize` times, using also `j`, `k` and `n` as loop variables and for each iteration we will basically replicate the behaviour of `next_permutation` by:\\n* setting `j` to be the value of the rightmost element (`len`);\\n* looping `while` `j > 0` and:\\n\\t* checking when we have to create a new permutation, which is when we find that the the element right before `j` is actually smaller, in which case we will:\\n\\t\\t* set `n` to be the preceding element (`nums[j - 1`);\\n\\t\\t* set `k` to equal the initial value of `j`, that is to say the index of the rightmost element - `len`;\\n\\t\\t* decrease `k` by `1` `while` nums[k] <= n`, to make it so that `k` is now pointing to the first element from the right greater than `n`;\\n\\t\\t* swap `nums[j- 1]` and `nums[k]`;\\n\\t\\t* if `j` is not still the last element `len`, we will then also sort `nums` from `j` onwards;\\n\\t\\t* finally, we will `break` out of the loop, since we have now a valid permutation :)\\n\\t* increasing `j` by `1`\\n* writing the updated `nums` in `res[i]`.\\n\\nFor a more indepth analysis of the generation of the next permutation, I put some more words [in the solution of that specific problem](https://leetcode.com/problems/next-permutation/discuss/1044321/C%2B%2B-2-Pointer-Solution-Explained-100-Time-~90-Space) ok\\n\\nOnce done,  we can just `return` our efficiently computed `res` :)\\n\\nThe code:\\n\\n```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nconstexpr int facts[9] = {0, 1, 2, 6, 24, 120, 720, 5040, 40320};\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int> &nums) {\\n        // support variables\\n        int len = nums.size(), resSize = facts[len--], freqs[11] = {}, nFreqs[11] = {};\\n        // adjusting resSize\\n        for (int n: nums) {\\n            resSize /= ++(n > 0 ? freqs[n] : nFreqs[-n]);\\n        }\\n        vector<vector<int>> res(resSize);\\n        // preparing nums\\n        sort(begin(nums), end(nums));\\n        res[0] = nums;\\n        // adding all the other permutations to res\\n        for (int i = 1, j, k, n; i < resSize; i++) {\\n            // replicating next_permutation(begin(nums), end(nums));\\n            j = len;\\n            while (j) {\\n                // creating a new permutation, only when the next number is lower\\n                if (nums[j - 1] < nums[j]) {\\n                    // preparing the inner loop variables\\n                    n = nums[j - 1], k = len;\\n                    // looking for the first number > n, from right\\n                    while (nums[k] <= n) k--;\\n                    // swapping the number right before j and the one pointed by k\\n                    swap(nums[j - 1], nums[k]);\\n                    // sorting the rest\\n                    if (j != len) sort(begin(nums) + j, end(nums));\\n                    break;\\n                }\\n                j--;\\n            }\\n            res[i] = nums;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852855,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\\n.\\nFor the [***Permutation***](https://leetcode.com/problems/permutations/) Problem :\\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n       int n=nums.size();\\n   \\t   vector<vector<int>> res;\\n       res.push_back(nums);\\n       map<vector<int>,int> mp;\\n       \\n       for(int i=0;i<n;++i){\\n           int sz=res.size();\\n           for(int t=0;t<sz;++t){\\n               vector<int> temp=res[t];\\n               for(int j=i+1;j<n;++j){\\n                   if(temp[i]==temp[j]) continue;\\n                   vector<int> temp2=temp;\\n                   swap(temp2[i],temp2[j]);\\n                   if(!mp[temp2]) res.push_back(temp2),mp[temp2]++;\\n               }\\n           }\\n       }\\n       return res;\\n   }\\n```\n```\\nvector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        res.push_back(nums);\\n        \\n        for(int i=0;i<n;++i){\\n            int sz=res.size();\\n            for(int t=0;t<sz;++t){\\n                vector<int> temp=res[t];\\n                for(int j=i+1;j<n;++j){\\n                    vector<int> temp2=temp;\\n                    swap(temp2[i],temp2[j]);\\n                    res.push_back(temp2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733304,
                "title": "faster-than-99-57-javascript",
                "content": "The difference of this problem with it\\'s prequel is `the inputs of the last one are all \\'unique\\'`.\\nHaving duplicate numbers in the inputs also means that there will be duplicate outputs.\\n\\nTo prevent this, I could just create a `seen` variable that holds all the seen permutations but this will be inefficient since we still need to go through every permutation, even duplicates.\\n\\nOne optimization is to stop the recursion once we know that we are going through the same numbers again. This is where backtracking becomes handy. First thing to do is to sort the nums array. Next thing is to use a `prev` variable that holds the previous element for each iteration. This prev variable will help us know if we\\'ve already gone through the number and mitigate further waste of time and space.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/ac9db05d-8ec1-4843-a1d5-047d9fc493a3_1643608089.8550267.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const sorted = nums.sort((x,y) => x-y), permutations = [];\\n\\n    const rcr = (arr, permutation) => {\\n        if (!arr.length) return permutations.push(permutation);\\n\\n        let prev = -Infinity;\\n        for (let i = 0; i < arr.length; i++) {\\n            if (prev === arr[i]) continue;\\n\\n            newArr = arr.slice(0, i).concat(arr.slice(i+1));\\n            rcr(newArr, [...permutation, arr[i]]);\\n\\n            prev = arr[i];\\n        }\\n    }\\n    rcr(nums, []);\\n\\n    return permutations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714036,
                "title": "permutations-ii-c-0ms-solution-stl-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>vec;\\n        sort(nums.begin(),nums.end());\\n        do{\\n            vec=nums;\\n            v.push_back(vec);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233163,
                "title": "c-backtracking-only-using-swap-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if this help you**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void help(vector<int>&a,int x)\\n    {\\n        if(x==a.size())\\n        ans.push_back(a);\\n        bool us[21]={0};\\n        for(int i=x;i<a.size();i++)\\n        {\\n            if(us[a[i]+10]==0)\\n            {\\n            swap(a[i],a[x]);\\n            help(a,x+1);\\n            swap(a[i],a[x]);\\n            us[a[i]+10]=1;\\n            }\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>&a) {\\n        help(a,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995011,
                "title": "python-optimal-iterative-recursive-solutions-visuals",
                "content": "-----------------\\nSub-optimal Iterative DFS \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time: `O(N*N!) * (N!)` => `O(N*N!^2)` => that\\'s just awful!\\n\\t- the `N!` multiplier is for having to check if a path already has a duplicate in results.\\n\\t- Can also be expressed as `O(E+V)*(V!)` where V = verticies/nodes\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n-----------------\\nOptimal Iterative DFS \\n----------------\\n-----------------\\n\\n\\n**Idea:**\\n* Eliminate the possibility of a duplicate from the get go rather than deal with it later and introduce higher time complexity.\\n* nums must be sorted. See below for a visual illustation.\\n\\n![image](https://assets.leetcode.com/users/images/21ffa2fe-c9ad-4121-ac26-79ba2aaa42bb_1609396957.1626086.png)\\n\\n\\n\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\\n\\n\\n\\n-----------------\\nSub-optimal Recursive with backtracking \\n----------------\\n-----------------\\n\\n**Big-O**\\n* Time:  `O(N*N!^2)`\\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\n\\n\\n-----------------\\nOptimal Recursive with backtracking \\n----------------\\n-----------------\\n**Big-O**\\n* Time:  `O(N*N!)` or `O(E+V)` \\n* Space: `O(N!)`\\n\\n**Code:**\\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\\n\\nFor a detailed and visual-rich explanation of the permutation problem, please refer to my post on **46.Permutations** => https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nstack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                if path not in res: # -- O(N!)\\n                    res.append(path)\\n            # children\\n            for i in range(len(nums)): # -- O(E)\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n        sort first\\n        nums.sort() # O(nlogn)\\n        \\n        stack = [(nums, [])] # (nums, path)\\n        res = []\\n        while stack: # -- O(E+V)\\n            nums, path = stack.pop()\\n            if not nums:\\n                res.append(path)\\n            # children\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:  # --- Skip the sibling node if its the same as current node\\n                    continue\\n                newNums = nums[:i] + nums[i+1:]\\n                newPath = path + [nums[i]]\\n                stack.append((newNums, newPath))\\n        return res\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```\n```\\ndef permuteUnique(self, nums):\\n\\t\\t# - helper\\n        def recursive(nums, path=[], res=[]):\\n            if not nums:\\n                p = path[::]\\n                if p not in res:\\n                    res.append(p)\\n            else:\\n                for i in range(len(nums)):\\n                    if i > 0 and nums[i-1] == nums[i]:  # --- Skip the sibling node if its the same as current node\\n                        continue\\n                    newNums = nums[:i] + nums[i+1:]\\n                    newPath = path + [nums[i]]\\n                    recursive(newNums, newPath, res)\\n            \\n            return res\\n        \\n        # - main\\n        return recursive(nums, [], [])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 933086,
                "title": "golang-backtrack-0ms-solution",
                "content": "BackTrack with 3 key considerations :\\n1. Goal - find a combination with length equals to nums\\n2. Options - each element in nums\\n3. Constrains\\n3.1 Each element can be visited once\\n3.2 If there is a duplication, the first element has to be visited before second element\\n\\n\\n```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc permuteUnique(nums []int) [][]int {\\n    if len(nums) == 0 {\\n        return nil\\n    }\\n    sort.Ints(nums)\\n    res := make([][]int, 0)\\n    visited := make(map[int]bool)\\n    list := make([]int, 0)\\n    backTrack(nums, visited, list, &res) \\n    return res\\n}\\n\\nfunc backTrack(nums []int, visited map[int]bool, list []int, res *[][]int) {\\n    //back track goal, length of list equals to length of nums\\n    if len(list) == len(nums) {\\n        temp := make([]int, len(list))\\n        copy(temp, list) //copy list into temp, so it won\\'t impact subsequent process on list\\n        *res = append(*res, temp)\\n        return\\n    }\\n    \\n    //options are each elements in nums slice\\n    for i := 0; i < len(nums); i++ {\\n        if visited[i] {\\n            continue //constrain, ignore visited element\\n        }\\n        if i > 0 && nums[i] == nums[i - 1] && !visited[i - 1] {\\n            continue //constrain, if there is a duplication, the first element need to be visited first\\n        }\\n        list = append(list, nums[i])\\n        visited[i] = true\\n        backTrack(nums, visited, list, res)\\n        list = list[:len(list) - 1]\\n        visited[i] = false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836504,
                "title": "c-backtracking-dfs",
                "content": "![image](https://assets.leetcode.com/users/images/eb4e8d5a-3b93-4c0a-a0cf-bd91114f0923_1600261272.6389656.png)\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& subset, vector<int>& nums, vector<int>& curr, vector<bool>& used)\\n    {\\n        if(curr.size() == nums.size()){\\n            subset.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(used[i] == true)\\n                continue;\\n            curr.push_back(nums[i]);\\n            used[i] = true;\\n            dfs(subset, nums, curr, used);\\n            curr.pop_back();\\n            used[i] = false;\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> subset;\\n        vector<int> curr;\\n        vector<bool> used(nums.size());\\n        dfs(subset, nums, curr, used);\\n        sort(subset.begin(), subset.end());\\n        subset.erase(unique(subset.begin(), subset.end()), subset.end());\\n        return subset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528326,
                "title": "issac3-general-approach-to-backtracking-questions-in-cpp",
                "content": "Thanks ```Issac3``` for sharing. Here is same approach in C++. \\n\\nPermutation:\\nGiven a collection of distinct integers, return all possible permutations.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\\n\\nPermutation-II \\n\\n47. Permutations II\\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\\n\\n78. Subsets\\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\\n\\n90. Subsets II\\nGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\\n39. Combination Sum\\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\\n\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        backtrack(s, temp, result, 0);\\n        return result;        \\n    }\\n    \\n    void backtrack(string& s, vector<string>& temp, vector<vector<string>>& result, int start){\\n        \\n        if(start == s.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<s.size(); i++){\\n                if(isPalindrome(s, start, i)){\\n                    temp.emplace_back(s.substr(start, i-start+1));\\n                    backtrack(s, temp, result, i+1);\\n                    temp.pop_back();\\n                }\\n            }            \\n        }        \\n    }\\n    \\n    bool isPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n};\\n",
                "solutionTags": [],
                "code": "```Issac3```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result);\\n        return result;\\n    }\\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(find(temp.begin(), temp.end(), nums[i]) != temp.end()) continue; \\n                \\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result);\\n                temp.pop_back();\\n            }\\n        }   \\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {   \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        vector<bool> used(nums.size(), false);\\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, used);\\n        return result;        \\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, vector<bool>& used){\\n        \\n        if(temp.size() == nums.size()){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=0; i<nums.size(); i++){\\n                if(used[i] || i>0 && nums[i] == nums[i-1] && !used[i-1]) continue; \\n                used[i] = true;\\n                temp.push_back(nums[i]);\\n                backtrack(nums, temp, result, used);\\n                used[i] = false;\\n                temp.pop_back();\\n            }            \\n        }        \\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp;\\n        \\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }                \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        backtrack(nums, temp, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start){\\n        \\n        result.emplace_back(temp);\\n        \\n        for(int i=start; i<nums.size(); i++){\\n            if(i>start && nums[i]== nums[i-1]) continue;\\n            temp.emplace_back(nums[i]);\\n            backtrack(nums, temp, result, i+1);\\n            temp.pop_back();\\n        }\\n        \\n    }\\n    \\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n        \\n        vector<vector<int>> result; \\n        vector<int> temp;\\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int>& temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain<0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i, remain - nums[i]); // not i+1 because we CAN reuse same elements\\n                temp.pop_back();\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\\n        vector<vector<int>> result;\\n        vector<int> temp; \\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        backtrack(nums, temp, result, 0, target);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<int>& nums, vector<int> temp, vector<vector<int>>& result, int start, int remain){\\n        \\n        if(remain <0){ \\n            return;\\n        }else if(remain == 0){\\n            result.emplace_back(temp);\\n        }else{\\n            \\n            for(int i=start; i<nums.size(); i++){\\n                if(i>start && nums[i] == nums[i-1]) continue; \\n                \\n                temp.emplace_back(nums[i]);\\n                backtrack(nums, temp, result, i+1, remain - nums[i]); // here i+1 because each numer can be choosen only \\'once\\'\\n                \\n                temp.pop_back();                \\n            }           \\n        }        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430222,
                "title": "rust-0ms-9-lines",
                "content": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\\n\\nAnd shorter version (however *successors* is not supported by the rust of leetcode):\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut res = vec![nums];\\n        loop {\\n            let cur = Self::next(res.last().unwrap().clone());\\n            if cur == res[0] {\\n                break;\\n            }\\n            res.push(cur);\\n        }\\n        res\\n    }\\n\\n    fn next(mut nums: Vec<i32>) -> Vec<i32> {\\n        if let Some(prev) = (0..nums.len()-1).rposition(|x| nums[x] < nums[x+1]) {\\n            let j = nums.iter().rposition(|&x| x > nums[prev]).unwrap();\\n            nums.swap(prev, j);\\n            nums[prev+1..].reverse();\\n        } else {\\n            nums.reverse();\\n        }\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        std::iter::successors(Some(nums.clone()), |n| {\\n            let mut cur = n.clone();\\n            if let Some(prev) = (0..cur.len()-1).rposition(|x| cur[x] < cur[x+1]) {\\n                let j = cur.iter().rposition(|&x| x > cur[prev]).unwrap();\\n                cur.swap(prev, j);\\n                cur[prev+1..].reverse();\\n            } else { cur.reverse(); }\\n            if cur == nums { None } else { Some(cur) }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354605,
                "title": "functional-style-scala-solution",
                "content": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n    def permuteUnique(nums: Array[Int]): List[List[Int]] = {\\n        permute(nums.toList)\\n    }\\n    \\n    def permute(nums: List[Int]): List[List[Int]] = {\\n        nums match {\\n            case List() => List(List())\\n            case _ => for {\\n                x <- nums.distinct\\n                perm <- permute(removeElem(nums, x))\\n            } yield x :: perm\\n        } \\n    }\\n    \\n    def removeElem(nums: List[Int], n: Int): List[Int] = {\\n        nums match {\\n            case List() => List()\\n            case (x :: xs) => if (x == n) { xs } else { x :: removeElem(xs, n) }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 145257,
                "title": "simple-recursive-python-solution-beats-100",
                "content": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "solutionTags": [],
                "code": "    def permuteUnique(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not nums:\\n            return []\\n        res = []\\n        self.helper(res,nums,[])\\n        return res\\n    \\n    def helper(self, res, nums, path):\\n        if not nums:\\n            res.append(path)\\n            return\\n        dic = {x:1 for x in nums}\\n        \\n        for i in range(len(nums)):\\n            if dic[nums[i]] == 1:\\n                self.helper(res, nums[:i] + nums[i+1:], path + [nums[i]])\\n                dic[nums[i]] -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 18718,
                "title": "easy-iterative-solution-similar-with-permutations-i",
                "content": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "     \\n       The solution is similar with permutations I problem, but added a condition\\n        Method: repetition numbers only have one permutation, e.g. [1,1,1,1].\\n           so each time only adding a number to the left of its repetition\\n           e.g. [1,2] --> [1,1,2] -->then stop. \\n \\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\\n        ret.add(new ArrayList<Integer>());\\n        \\n        for(int i=0; i<nums.length; i++){\\n            List<List<Integer>> save = new ArrayList<List<Integer>>();\\n            for(List<Integer> lst: ret){\\n                for(int j=0; j<=lst.size(); j++){\\n                    if(j != 0 && lst.get(j-1) == nums[i]) // stop here\\n                        break;\\n                    List<Integer> l = new ArrayList<Integer>(lst);\\n                    l.add(j, nums[i]);\\n                    save.add(l);\\n                }\\n            }\\n            ret = save;\\n        }\\n        \\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 18742,
                "title": "simple-20-line-c-solution-using-backtracking-with-explanation",
                "content": "    // This question is mostly the same as Permutation I, but with an unordered_set to avoid duplicates. \\n    // The key point to avoid duplicates is to avoid selecting repeated numbers at the same position.\\n    class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }\\n            unordered_set<int> M;\\n            for (int i = index; i < nums.size(); i ++) {\\n                if (M.find(nums[i]) != M.end()) continue; \\n                else M.insert(nums[i]);\\n                swap(nums[i], nums[index]);\\n                myPermuteUnique(results, nums, index+1);\\n                swap(nums[i], nums[index]);\\n            }\\n        }\\n        vector<vector<int>> permuteUnique(vector<int>& nums) {\\n            vector<vector<int>> results;\\n            myPermuteUnique(results, nums, 0);\\n            return results;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void myPermuteUnique(vector<vector<int>>& results, vector<int>& nums, int index){\\n            if (index == nums.size()) {\\n                results.push_back(nums);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3985033,
                "title": "ermutations-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int n, vector<vector<int> > &result) {\\n        if(i == n-1){\\n            result.push_back(num);\\n            return;\\n        }\\n\\n        for(int k = i; k < n; k++){\\n            if(k != i && num[k] == num[i]) continue;\\n\\n            swap(num[k], num[i]);\\n            recursion(num, i+1, n, result);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n\\n        int n = num.size();\\n\\n        vector<vector<int>> result;\\n        recursion(num, 0, n, result);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860836,
                "title": "c-2-backtrackings-frequency-set-swap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere 2 different kinds of backtracking solutions are provided. One uses frequency table. Other uses swaps. Since it is hard to avoid of duplicates using swaps, the C++ set comes to aid.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using frequency table\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\\n# Code for swap & set\\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n    int n0, sz;\\n    vector<int2> nWm;\\n    vector<vector<int>> result;\\n\\n    void backtrack(vector<int>& subset, vector<int2>& freq) {\\n        if (subset.size() == n0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        for (int i = 0; i < sz; i++) {\\n            if (freq[i].second > 0) {\\n                subset.push_back(nWm[i].first);\\n                freq[i].second--;\\n                backtrack(subset, freq);\\n                subset.pop_back();\\n                freq[i].second++;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        nWm.push_back({ nums[0], 1 });\\n        int idx = 0;\\n        n0 = nums.size();\\n        for (int i = 1; i < n0; i++) {\\n            if (nums[i] == nums[i-1])\\n                nWm[idx].second++;\\n            else {\\n                nWm.push_back({ nums[i], 1 });\\n                idx++;\\n            }\\n        }\\n        sz=++idx;\\n\\n        vector<int> subset;\\n        backtrack(subset, nWm);\\n        return result;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    set<vector<int>> ans;\\n    void f(int i, vector<int>& nums){\\n        if (i==n){// reach the end of nums\\n            ans.insert(nums);\\n            return ;\\n        } \\n        f(i+1, nums);\\n        for (int j=i+1; j<n; j++){\\n            if (nums[i]!=nums[j]){\\n                swap(nums[i], nums[j]);\\n                f(i+1, nums);\\n                swap(nums[i], nums[j]);\\n            } \\n        }\\n    }    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        f(0, nums);\\n        return vector<vector<int>>(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851561,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) \\n    {\\n        if (i == j-1) \\n        {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) \\n        {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) \\n    {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696518,
                "title": "backtracking-concept",
                "content": "# Backtracking concept\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362041,
                "title": "if-it-equals-the-previous-element-just-skip-it-simple-backtracking-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(remainder, path):\\n            remainder = remainder[:]\\n            path = path[:]\\n            if len(remainder) == 0:\\n                result.append(path)\\n            for i in range(len(remainder)):\\n                if i > 0 and remainder[i] == remainder[i-1]:\\n                    continue\\n                path.append(remainder[i])\\n                backtrack(remainder[0:i] + remainder[i+1:], path)\\n                path.pop()\\n            return\\n\\n        nums.sort()\\n        result = []\\n        backtrack(nums, [])\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217602,
                "title": "8ms-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursion(vector<int> num, int i, int j, vector<vector<int> > &res) {\\n        if (i == j-1) {\\n            res.push_back(num);\\n            return;\\n        }\\n        for (int k = i; k < j; k++) {\\n            if (i != k && num[i] == num[k]) continue;\\n            swap(num[i], num[k]);\\n            recursion(num, i+1, j, res);\\n            // swap(num[i], num[k]);\\n        }\\n    }\\n    vector<vector<int> > permuteUnique(vector<int> &num) {\\n        sort(num.begin(), num.end());\\n        vector<vector<int> >res;\\n        recursion(num, 0, num.size(), res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940506,
                "title": "easy-and-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res=set()\\n        def per(nm: List[int],x: List[int]) -> None:\\n            if nm ==[]:\\n                aa=\"\"\\n                for i in x:\\n                    aa+=str(i)+\"*\"\\n                res.add(aa)\\n            else:\\n                for i in range(len(nm)):    \\n                    nmc=nm[:i]+nm[i+1:]\\n                    xx=x.copy()\\n                    xx.append(nm[i])\\n                    per(nmc,xx)\\n        per(nums,[])\\n        r=[]\\n        for i in res:\\n            a=i.split(\\'*\\')\\n            a.pop()\\n            b=[]\\n            for j in a:\\n                b.append(int(j))\\n            r.append(b)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422874,
                "title": "recursion-striver-approach-with-explanation-map-technique",
                "content": "**Algo:**\\n**Step 1**: Create a boolean map and while iterating the array, whenever you encounter an element then pick that element and mark the particular index as false \\n**Step 2:** Repeat until you reach the last element\\n**Step 3:** Once the list size matches the array size then we got our first combination\\n**Step 4:** After that remove that element from our list and mark the index as true for other combination(back tracking)\\n**Step 5:** To avoid duplicate entries, sort the array and check if the arr[i] == arr[i+1], if matches then we can skip the iteration by i++ ( We can use HashSet, but it will consume additional space - Not recommended)\\n\\nCredits to Striver for this type of approach\\nNote: We can use swap technique as well to generate all permutations.\\n```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\\n        boolean[] map=new boolean[nums.length];\\n        List<Integer> list=new ArrayList<Integer>();\\n        //sort the array so that duplicate entries will be next to each other\\n        Arrays.sort(nums);\\n        mapCombo(nums,map,res,list);\\n        return res;\\n    }\\n    \\n    private void mapCombo(int[] nums,boolean[] map,List<List<Integer>> res,List<Integer> list){\\n        \\n        //base condition : Whenever our list size becomes same as arr size, we got our combination\\n        if(list.size()==nums.length){\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(!map[i]){\\n                list.add(nums[i]);\\n                //Pick \\n                map[i]=true;\\n                mapCombo(nums,map,res,list);\\n                //Not pick\\n                map[i]=false;\\n                list.remove(list.size()-1);\\n                //to avoid duplicates combination\\n                while(i+1<nums.length && nums[i]==nums[i+1])i++;\\n                \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269821,
                "title": "simple-and-easy-to-understand-java-solution-100-accepted",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result= new ArrayList<>();\\n        Permutation(result,nums,0);\\n        return result;\\n    }\\n    public void Permutation(List<List<Integer>> result,int[] nums,int start){\\n        if(start==nums.length)\\n            result.add(toList(nums));\\n        for(int i=start;i<nums.length;i++){\\n            if(i!=start && !Permutate(start,i,nums))continue;\\n            \\n            swap(i,start,nums);\\n            Permutation(result,nums,start+1);\\n            swap(i,start,nums);\\n        }\\n    }\\n    public List<Integer> toList(int[] nums){\\n        List<Integer> res=new ArrayList<>();\\n        for(int i:nums)\\n            res.add(i);\\n        return res;\\n    }\\n    public void swap(int i,int j,int[] nums){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public boolean Permutate(int start,int j,int[] nums){\\n        for(int i=start;i<j;i++)\\n            if(nums[i]==nums[j])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118718,
                "title": "backtrack-solution-using-treemap-in-java",
                "content": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n      List<List<Integer>> res = new ArrayList();\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        for(int i=0; i<nums.length; i++){\\n            int temp = nums[i];\\n            if(map.get(temp) == null) map.put(temp, 1);\\n            else{\\n                int a = map.get(temp);\\n                map.put(temp, a+1);\\n            }\\n        }\\n        backtrack(nums, res, new ArrayList(), map);\\n        return res;\\n    }\\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> temp, TreeMap<Integer, Integer> map){\\n        if(temp.size() == nums.length){\\n            res.add(new ArrayList(temp));\\n            return;\\n        }\\n        for(int num : map.keySet()){\\n            int count = map.get(num);\\n            if(count == 0) continue;\\n            map.put(num, count-1);\\n            temp.add(num);\\n            backtrack(nums, res, temp, map);\\n            temp.remove(temp.size()-1);\\n            map.put(num, count);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2033012,
                "title": "c-backtracking-easy-to-understand-dlc-may13",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        vector<int> ds;\\n        vector<int> check(nums.size(), 0);\\n        \\n        helper(ds, res, check, nums);\\n        return res;\\n    }\\n    \\n    void helper(vector<int> &ds, vector<vector<int>> &res, vector<int> &check, vector<int> &nums){\\n        if(ds.size() == nums.size() && !(find(res.begin(), res.end(), ds) != res.end())){\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            if(check[i]==0){        //if unchecked, can be pushed\\n                ds.push_back(nums[i]);\\n                check[i] = 1;   //check\\n                helper(ds, res, check, nums);\\n                ds.pop_back();\\n                check[i] = 0;   //uncheck\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031631,
                "title": "multiple-solutions-js-with-explanation",
                "content": "**Time complxities** for both the approaches is no worse then O(b^d)\\n\\nExample: [1,1,2] O(3^3)\\n\\n**Solution 1 Create Map**\\n\\n```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\\n\\n**Solution 2 Without creating Map beforehand, but use Indexes instead**\\n\\n**Idea**:\\n\\nSince we have duplicate numbers, that\\'s why we have to create Map in Solution 1. Another approach we can think of is that, why not keep track of \"indexes\" rather then values on that indexes. \\n\\nExample:\\n\\nnums:      [1, 1, 2] \\nindexes:   0, 1, 2\\n \\nIn Set, we will have [0,1,2] and hence while backtracking for next iteration, we can ignore permutation created from this set using \"uniqueSet\" set variable\\n\\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar permuteUnique = function(nums) {\\n    let map = new Map();\\n    \\n\\t//Create map and count occurence of each num\\n    for(let i = 0; i < nums.length; i++) {\\n        let n = nums[i];\\n        \\n        if(map.has(n)) {\\n            map.set(n, map.get(n) + 1);\\n        } else {\\n            map.set(n, 1);\\n        }\\n    }\\n    \\n    let res = [];\\n    \\n    const recursePermute = (start, map, ds) => {\\n        if(ds.length === nums.length) {\\n            res.push([...ds]);\\n            return res;\\n        }\\n        \\n        for(const [key, value] of map.entries()) {\\n            let n = key;\\n            \\n\\t\\t\\t//If we have count then add it in our \"ds\"\\n            if(map.get(n) > 0) {\\n                map.set(n, map.get(n) - 1);\\n                ds.push(n);\\n                recursePermute(start, map, ds);\\n                ds.pop();\\n                map.set(n, map.get(n) + 1);\\n            }\\n        }\\n    }\\n    \\n    recursePermute(0, map, []);\\n    \\n    return res;\\n};\\n```\n```\\nvar permuteUnique = function(nums) {\\n    const len = nums.length;\\n\\t\\n    const ans = [];\\n    const set = new Set();\\n\\t\\n    const uniqueSet = new Set();\\n    \\n    const recursePermuteUnique = (set) => {\\n        if(set.size === len) {\\n            let temp = [];\\n\\t\\t\\t//Create permuation using indexes saved in set\\n            let str = \\'\\';\\n            set.forEach(d => { temp.push(nums[d]); str = str + nums[d]; });\\n            if(!uniqueSet.has(str)) {\\n                ans.push(temp);\\n                uniqueSet.add(str);\\n            }\\n            return null;\\n        }\\n        \\n\\t\\t//Track each permutation with indexes saved in the set. Hence, keeping track of unique values.\\n        for(let i = 0; i < len; i++) {\\n            if(!set.has(i)) {\\n                set.add(i);\\n                recursePermuteUnique(set);\\n                set.delete(i);\\n            }\\n        }\\n    }\\n    \\n    recursePermuteUnique(set);\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031514,
                "title": "easy-c-using-set-of-vector-and-next-permutation-function",
                "content": "We sort nums[] and keep inserting every possible permutation into an unordered set of vectors which will automatically remove any redundancy.\\n\\n```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct hashsetofvector\\n      {\\n         size_t operator()(const vector<int> &myVector) const \\n         {\\n             std::hash<int> hasher;\\n             size_t answer = 0;\\n             for (int i : myVector) \\n            {\\n                answer ^= hasher(i) + 0x9e3779b9 + \\n                                  (answer << 6) + (answer >> 2);\\n           }\\n           return answer;\\n       }\\n   };\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n          unordered_set <vector<int>,hashsetofvector> s;\\n        sort(nums.begin(),nums.end());\\n        do\\n        {\\n            s.insert(nums);\\n        }\\n        while(next_permutation(nums.begin(),nums.end()));\\n        vector<vector<int>> ans;\\n        for(auto i:s)\\n        {\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031402,
                "title": "python-diagram-tree-structure-recursion-explained",
                "content": "We need to generate all possible unique permutations and the numbers inside the input list can be duplicates.\\nTo remove redundant permutations, I have used **set** as it stores unique values by hashing. And hence, elements inside the set should be hashable. List is not hashable but tuple is. So, we stored **tuples** inside the set.\\n\\nNow, Iterate through each element of the list, add the element to answer and send the remaining list ahead to the recursive call for further operations.\\n\\n![image](https://assets.leetcode.com/users/images/aea6eade-637e-47be-bec3-ef215661fb12_1652344786.5857453.png)\\n\\n\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```\\n\\n***EDIT:***\\n**Time Complexity** can be given by the recursive formula: \\n* **T(n) = n * T(n-1) + c** (solving by substitution) **= O(n!) = O(n^n).**\\n\\n**Space Complexity** owing to the \"lst\" list *(see code)* at each level: Max depth = Number of elements = n,\\n*at level 1, lst size = 1\\nat level 2, lst size = 2\\n...\\nat level n, lst size = n*\\nAnd all the levels are called on top of one another in a stack as function calls, so all the list are stored simultaneously.\\nSpace complexity = 1 * 2 * 3 * ... * n **= n! = O(n^n)**.\\nAlso, we store and return a list of size O(n^n).",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        self.ans = set()\\n        def get_perms(nums, lst):\\n            if not nums:\\n                self.ans.add(tuple(lst.copy()))\\n                return\\n            for i in range(len(nums)):\\n                get_perms(nums[:i] + nums[i+1:], lst + [nums[i]])\\n        get_perms(nums, [])\\n        return list(self.ans)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031150,
                "title": "short-and-simple-backtracking-set",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans;\\n\\n    void permute(vector<int> &nums, int index) {\\n        if (index == nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        unordered_set<int> s;\\n        for (int i = index; i < nums.size(); i++) {\\n            if (s.find(nums[i]) != s.end())    continue;\\n            s.insert(nums[i]);\\n            swap(nums[index], nums[i]);\\n            permute(nums, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        permute(nums, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031039,
                "title": "python-solution-continuing-permutation-i-faster-than-96-33",
                "content": "# Permutation I \\n**Solution**\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\\n\\n**#1 :** The only change we need to do in our permutation I code for permutation II code is to take care of dupelicates and this can be done by just using set( ) in nums while using for loop to iterate over nums. Rest code is same and simple .\\n# Permutation II\\n**Solution**\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```\\n**Pls do upvote .. if it helps in anyway :-)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for x in nums :\\n                rem = list(nums)\\n                rem.remove(x)\\n                dfs(rem, curr + [x])\\n        res = []\\n        dfs(nums, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:   \\n        def dfs(nums, curr) :\\n            if not nums :\\n                res.append(curr)\\n            for i in set(nums) : #1\\n                rem = list(nums)\\n                rem.remove(i)\\n                dfs(rem, curr + [i])\\n        res = []\\n        dfs(nums, [])    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807660,
                "title": "easy-solution-with-image-explanation-c-set",
                "content": "Before Read, This solution try to solve **[Permutations](https://leetcode.com/problems/permutations/)** Problem. Then try the Permutations II problem by yourself. if you are not able to do then read my solution.\\n\\nWe used **Set** because we don\\'t need to store duplicates value.\\n\\nSame as the permutation but we store answer data in Set Data structure for unique value.\\n\\n![image](https://assets.leetcode.com/users/images/5489ffc0-0eac-4ef6-a5c6-43796adfeb23_1646078649.0260248.jpeg)\\n\\n\\n```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void solve(int ind ,vector<int>&nums ,set<vector<int>>&ans){\\n        if(ind == nums.size()){\\n            ans.insert(nums);\\n            return;\\n        }\\n        \\n        for(int i=ind;i<nums.size();i++){\\n             swap(nums[ind],nums[i]);\\n             solve(ind+1,nums,ans);\\n             swap(nums[ind],nums[i]);\\n        }\\n    }\\npublic:\\n      vector<vector<int>>permuteUnique(vector<int> &nums)\\n        {\\n            set<vector < int>> ans;\\n            vector<vector < int>> store;\\n            solve(0, nums, ans);\\n\\n            return  vector<vector < int>>(ans.begin(),ans.end());\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768113,
                "title": "java-backtracking-hashmap",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> result = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int num:nums)\\n            map.put(num, map.getOrDefault(num,0)+1);\\n        backtracking(nums, result, map, new ArrayList<Integer>());\\n        return result;\\n    }\\n    private void backtracking(int[] nums, List<List<Integer>> result, Map<Integer, Integer> map, List<Integer> list){\\n        if (list.size() == nums.length){\\n            result.add(new ArrayList<Integer>(list));\\n                return;\\n        }\\n        for (Integer key: map.keySet()){\\n            if (map.get(key)>0){\\n                list.add(key);\\n                map.put(key, map.get(key) -1);\\n                backtracking(nums, result, map, list);\\n                map.put(key, map.get(key) +1);\\n                list.remove(list.size() -1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560188,
                "title": "python-3-2-approaches",
                "content": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\t# Implement with a counter\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res, path = [], []\\n        count = Counter(nums)\\n        \\n        def dfs():\\n            if len(path) == len(nums):\\n                res.append(path.copy())\\n                return\\n            \\n            for num in count:\\n                if count[num] > 0:\\n                    count[num] -= 1\\n                    path.append(num)\\n                    dfs()\\n                    path.pop()\\n                    count[num] += 1\\n        dfs()\\n        return res\\n\\t\\n\\t# Implement with sort and (i, i-1) comparision\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        res = []\\n        def dfs(nums, path = []):\\n            if not nums:\\n                res.append(path)\\n            for i in range(len(nums)):\\n                if i > 0 and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(nums[:i] + nums[i+1:], path + [nums[i]])\\n        dfs(nums)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493203,
                "title": "python-swapping-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}\\n            for i in range(start,len(nums)):\\n                num = nums[i]\\n                if num not in lookup:\\n                    nums[i],nums[start] = nums[start],nums[i]\\n                    dfs(start+1)\\n                    nums[i],nums[start] = nums[start],nums[i]                    \\n                    lookup[num] = True\\n                    \\n        dfs(0)\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        nums.sort()\\n        result = []\\n        def dfs(start: int):\\n            if start == len(nums):\\n                result.append([]+nums)\\n                return\\n            lookup = {}",
                "codeTag": "Java"
            },
            {
                "id": 1463505,
                "title": "c-12ms-recursion",
                "content": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        sort(nums.begin(), nums.end());\\n        util(nums, ans, 0, nums.size()-1);\\n        return ans;\\n        \\n    }\\n    \\n    void util(vector<int> nums, vector<vector<int>> &ans,\\n                            int l, int r){\\n        \\n        if(l==r){\\n            ans.push_back(nums);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = l;i<=r;i++){\\n                if(l != i && nums[l] == nums[i]) {\\n                    continue;\\n                }\\n                swap(nums[l], nums[i]);\\n                util(nums, ans, l+1, r);\\n            }\\n        }\\n        return;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453394,
                "title": "python-dfs-easy-to-understand-with-sorting",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return self.dfs(sorted(nums), [], [])\\n\\n    def dfs(self, nums: List[int], path: List[int], res: List[List[int]]) -> List[List[int]]:\\n        if not nums: res.append(path)\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]: continue\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404856,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "\\n\\n    var permuteUnique = function(nums) {\\n        nums.sort((a,b) => {\\n            return a-b\\n        })\\n    \\n        let temp = []\\n        let result = []\\n    \\n        function backtracking(nums, temp) {\\n            if(nums.length === 0) {\\n                result.push([...temp])\\n                return\\n            }\\n            \\n            for(let i=0; i<nums.length; i++) {\\n                if(i !== 0 && nums[i] == nums[i-1]) continue\\n                \\n                temp.push(nums[i])\\n                nums.splice(i, 1)\\n                backtracking(nums, temp)\\n                nums.splice(i, 0, temp.pop())\\n            }\\n        }\\n        backtracking(nums, temp)\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1087101,
                "title": "python-easy-recursion-beats-99",
                "content": "We solve the recursion by dividing into 2 disjoint subproblems:\\n* rec1: dont put num at index i\\n* rec2: put num at index i\\n\\nThis way we get all permutations without duplicates.\\n```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums):\\n        res = [[]]\\n        for num, freq in Counter(nums).items():\\n            res = self.permuteRec(res, num, freq, 0)\\n        return res\\n    \\n    def permuteRec(self, perms, num, freq, i):\\n        if freq == 0: return perms\\n        if i == len(perms[0]): return [p + [num] * freq for p in perms]\\n        rec1 = self.permuteRec(perms, num, freq, i + 1)\\n        rec2 = self.permuteRec([p[:i] + [num] + p[i:] for p in perms], num, freq - 1, i + 1)\\n        return rec1 + rec2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038659,
                "title": "python-one-liner-set-o-n-space-sol",
                "content": "After doing `permutations i`, which I abstracted away with an `itertools` func, you should be able to wrap everything from there in a `set` and return in O(N) space\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\\nwhich can be simplified to:\\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def permute(nums: List[int]) -> List[List[int]]:\\n            return itertools.permutations(nums)\\n        p = permute(nums)\\n        s = set()\\n        for x in p:\\n            if x not in s:\\n                s.add(x)\\n        return s\\n```\n```py\\nreturn set(itertools.permutations(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933438,
                "title": "rust-heap-s-algorithm",
                "content": "https://en.wikipedia.org/wiki/Heap%27s_algorithm\\n\\n```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn permute_unique(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut permutes = vec![];\\n        let n = nums.len();\\n        fn permute(arr: &mut Vec<i32>, size: usize, soln: &mut Vec<Vec<i32>>) {\\n            if size == 0 {\\n                soln.push(arr.clone());\\n            } else {\\n                permute(arr, size-1, soln);\\n                /* if size is odd swap first and last element\\n                   if size is even swap the ith and last element */\\n                for i in 0..size-1 {\\n                    if (size & 1) != 0 {\\n                        arr.swap(0, size-1);\\n                    } else {\\n                        arr.swap(i, size-1);\\n                    }\\n                    permute(arr, size-1, soln);\\n                }\\n            }\\n        }\\n        permute(&mut nums, n, &mut permutes);\\n        permutes.sort_unstable();\\n        permutes.dedup();\\n        permutes\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 933066,
                "title": "rust-backtracking-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        let mut hm: HashMap<i32, usize> = HashMap::new();\\n        nums.iter()\\n            .for_each(|&num| *hm.entry(num).or_insert(0) += 1);\\n        let mut answer = Vec::new();\\n        let mut v = Vec::new();\\n        Solution::helper(&mut hm, &mut answer, &mut v);\\n        answer\\n    }\\n    fn helper(hm: &mut HashMap<i32, usize>, answer: &mut Vec<Vec<i32>>, v: &mut Vec<i32>) {\\n        let candidates: Vec<i32> = hm.iter().filter(|(_, &v)| v > 0).map(|(&k, _)| k).collect();\\n        if candidates.is_empty() {\\n            answer.push(v.clone());\\n        } else {\\n            for candidate in candidates.iter() {\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val -= 1;\\n                }\\n                v.push(*candidate);\\n                Solution::helper(hm, answer, v);\\n                v.pop();\\n                if let Some(val) = hm.get_mut(candidate) {\\n                    *val += 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932931,
                "title": "java-backtracking-solution-1ms",
                "content": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n         if(nums.length == 0){\\n          return new ArrayList<>();\\n        }\\n      Arrays.sort(nums);\\n      boolean visited[] = new boolean[nums.length];\\n      List<Integer> sans = new ArrayList<>();\\n      permute_(nums , visited , sans , 0);\\n      return ans;\\n    }\\n  public void permute_(int nums[] , boolean visited[] , List<Integer> sans , int count){\\n     \\n       if(count == nums.length){\\n         List<Integer> list = new ArrayList<>(sans);\\n         ans.add(list);\\n         return;\\n       }\\n       int prev = -(int)1e8;\\n       for(int i=0 ; i<nums.length ; i++){\\n          \\n            if(!visited[i] && prev!=nums[i]){\\n              visited[i] = true;\\n              prev = nums[i];\\n              sans.add(nums[i]);\\n              permute_(nums , visited , sans , count + 1);\\n              sans.remove(sans.size()-1);\\n              visited[i] = false;\\n            }\\n         \\n       }\\n      \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825485,
                "title": "java-swap-solution-with-photo",
                "content": "![image](https://assets.leetcode.com/users/images/3841a6d4-5dab-403a-8230-fd12710db6fe_1599076859.8893676.png)\\n\\n```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        final List<List<Integer>> results = new LinkedList<>();\\n        Arrays.sort(nums);\\n        permutate(nums, 0, results);\\n        return results;\\n    }\\n\\n    private void permutate(int[] nums, int start, List<List<Integer>> results) {\\n        if (start == nums.length) {\\n            results.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));\\n        } else {\\n            for (int i = start; i < nums.length; i++) {\\n                int j = i - 1;\\n                while (j >= start && nums[j] != nums[i]) {\\n                    --j;\\n                }\\n                if (j != start - 1) {\\n                    continue;\\n                }\\n                swap(nums, i, start);\\n                permutate(nums, start + 1, results);\\n                swap(nums, i, start);\\n            }\\n        }\\n    }\\n\\n    private void swap(int[] array, int i, int j) {\\n        if (i != j) {\\n            int temp = array[i];\\n            array[i] = array[j];\\n            array[j] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 814879,
                "title": "javascript-simple-recursive-with-foreach-filter",
                "content": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar permuteUnique = function(nums, prefix = [], mem = {}, ret = []) {\\n    if (!nums.length && !mem[prefix]) {\\n        ret.push(prefix);\\n        mem[prefix] = 1;\\n    }\\n\\n    nums.forEach((n, i) => permuteUnique(nums.filter((v, j) => i !== j), prefix.concat(n), mem, ret));\\n    \\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769214,
                "title": "short-c-code-using-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        do{\\n            res.push_back(nums);\\n        }while(next_permutation(nums.begin(),nums.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732823,
                "title": "javascript-backtracking-with-memory-store-to-skip-repeated-calls",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function(nums) {\\n    const res = [];\\n    const length = nums.length;\\n    const visited = new Array(length).fill(0);\\n    const memo = new Set();\\n    traverse(nums, res, [], length, visited, memo);\\n    return res;\\n};\\n\\nconst traverse = (nums, res, temp, length, visited, memo) => {\\n    if (temp.length === length) {\\n        res.push([...temp]);\\n        return;\\n        \\n    }\\n    \\n    for (let i = 0; i < length; i++) {\\n        if (visited[i]) continue;\\n        visited[i] = 1;\\n        temp.push(nums[i]);\\n        if (memo.has(temp.join(\\'\\'))) {\\n            temp.pop();\\n            visited[i] = 0;\\n            continue;\\n        }\\n        memo.add(temp.join(\\'\\'));\\n        traverse(nums, res, temp, length, visited, memo);\\n        temp.pop();\\n        visited[i] = 0;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 632531,
                "title": "java-backtracking-simple-solution-runtime-1-ms-faster-than-99-07",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        permuteRecursive(nums, resultList, 0, nums.length);\\n        return resultList;\\n    }\\n    \\n    public void permuteRecursive(int[] nums, List<List<Integer>> resultList, int index, int length) {\\n        if(index == length) {\\n            List<Integer> results = new ArrayList<Integer>();\\n            for (int n : nums)\\n                results.add(n);\\n            resultList.add(results);\\n            return;\\n        }\\n        \\n\\t\\t// Set - To avoid duplicates\\n        Set<Integer> set = new HashSet();\\n        \\n        for(int i=index; i<length; i++) {\\n            if(set.add(nums[i])) {\\n                swap(nums, index, i);\\n                permuteRecursive(nums, resultList, index+1, length);\\n                swap(nums, index, i);\\n            }\\n        }\\n    }\\n    \\n    public void swap(int[] nums, int firstIndex, int secondIndex) {\\n        int temp = nums[firstIndex];\\n        nums[firstIndex] = nums[secondIndex];\\n        nums[secondIndex] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475950,
                "title": "python-solution-faster-than-98-14-and-100-in-memory",
                "content": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        solution = []\\n        combination = []\\n        \\n        self.findPermutations(nums, combination, solution)\\n        return solution\\n    \\n    def findPermutations(self, nums, combination, solution):\\n        if nums == []:\\n            solution.append(list(combination))\\n            return\\n        \\n        for i in range(len(nums)):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            combination.append(nums[i])\\n            new_nums = nums[:i] + nums[i+1:]\\n            self.findPermutations(new_nums, combination, solution)\\n            combination.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357834,
                "title": "backtracking-solution-clean-and-simple-beat-100",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> resultSet = new ArrayList<>();\\n        List<Integer> permutation = new ArrayList<>();\\n        boolean[] visited = new boolean[nums.length];\\n        \\n        Arrays.sort(nums); // sort the array first\\n        dfs(nums, visited, permutation, resultSet);\\n        return resultSet;\\n    }\\n    \\n    public void dfs(int[] nums, boolean[] visited, List<Integer> permutation, List<List<Integer>> resultSet) {\\n        // find one permutation, add into the resultSet, exit of recursion\\n        if (permutation.size() == nums.length) {\\n            resultSet.add(new ArrayList<>(permutation));\\n            return;\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            // number is the same as the previous one, avoid reusing it\\n            if (i > 0 && visited[i - 1] == false && nums[i] == nums[i - 1]) {\\n                continue;\\n            }\\n            \\n            permutation.add(nums[i]);\\n            visited[i] = true;\\n            dfs(nums, visited, permutation, resultSet);\\n            // Backtracking, modify the visited status\\n            permutation.remove(permutation.size() - 1);\\n            visited[i] = false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304952,
                "title": "swift-o-n-n-no-recursion-no-extra-memory",
                "content": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```\\n\\nThis is my preferred way to solve this problem diue to no",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func permuteUnique(_ nums: [Int]) -> [[Int]] {\\n        \\n        var nums = nums\\n        nums.sort()\\n        \\n        var result = [[Int]]()\\n        result.append(nums)\\n        \\n        while true {\\n            \\n            var flipIndex = -1\\n            \\n            var i: Int = nums.count - 2\\n            while i >= 0 {\\n                if nums[i + 1] > nums[i] {\\n                    flipIndex = i\\n                    break\\n                }\\n                i -= 1\\n            }\\n            \\n            if flipIndex == -1 { break }\\n            \\n            var successorIndex: Int = -1\\n            var successorValue: Int = 0\\n            \\n            i = flipIndex + 1\\n            while i < nums.count {\\n                if nums[i] > nums[flipIndex] {\\n                    if successorIndex == -1 || nums[i] <= successorValue {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                }\\n                i += 1\\n            }\\n            \\n            nums.swapAt(successorIndex, flipIndex)\\n            \\n            var first: Int = flipIndex + 1\\n            var last: Int = nums.count - 1\\n            while first < last {\\n                nums.swapAt(first, last)\\n                last -= 1\\n                first += 1\\n            }\\n            result.append(nums)\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567629,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1747883,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1634028,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1567758,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1729127,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1816527,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1732784,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2058722,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2052381,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 2027146,
                "content": [
                    {
                        "username": "slazz11",
                        "content": "For those who are having trouble understanding time complexity....check this out\\n\\n![image](https://assets.leetcode.com/users/images/ef3d10aa-b95b-4d86-9c09-dd2f1ecff599_1625104463.423103.png)\\n\\nIt takes N steps to generate a single permutation. Since there are in total N! possible permutations, at most it would take O(N * N!) steps to generate all permutations. Multiply Horizontal vs Vertical\\n\\n"
                    },
                    {
                        "username": "primkruskal",
                        "content": "But also each node takes O(N) time right?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/permutations-ii/solutions/3018452/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "Abhinay_c",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sonnylaskar",
                        "content": "This is same as `permutations-i` problem except that there can be `duplicates`. So we need to avoid processing the same node, so checking `nums[i] != nums[i-1]` is important. So we need `sorting` - Tip"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/permutations-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking with Groups of Numbers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "Just like the question  47. Permutations, use a dictionary .\nIn that question every element appeared only once so we were checking whether we have seen a particular element previously or not (using dictionary).\nBut here repetitions are there so just maintain a dictionary and see if the element have appeared less than k times(i.e the count of any element>0) where k is the number of occurance of that number in nums.\nRest of the things will be same like reducing the count(in dictionary) of elements before recursive call and popping the array storing the curr elements and increasing the count (for backtracking).\n\np.s --Dictionary in python=map in c++"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Recursion on $$(n-1)$$ while only adding the $$n^{th}$$ element after the last occurrence in a previous permutation.\n\nI copied my code from previous problem (Permutations 1), and only needed to add a few short lines of code.\n\nEx: {2,1,3} can become {2,1,3,(**1**)}, or {2,1,(**1**), 3}, but not {(**1**),2,1,3} or {2,(**1**),1,3}"
                    },
                    {
                        "username": "Bhaskar47",
                        "content": "Some Pls help me to identify whats the problem with my code\n `class Solution {\n\n    public void swap(int[] nums,int l,int h){\n          int t=nums[l];\n          nums[l]=nums[h];\n          nums[h]=t;\n    }\n    public void solve(List<List<Integer>> res,int[] nums,int n,int index){\n          if(index==n){\n\n              List<Integer> temp=new ArrayList<>();\n              for(int t:nums)\n              {\n                  temp.add(t);\n              }\n\n              res.add(temp);\n              return;\n          }\n\n          for(int i=index;i<n;i++){\n              if( i>index && (nums[i]==nums[i-1] || nums[i]==nums[index]) ) continue;\n             \n              swap(nums,i,index);\n              solve(res,nums,n,index+1);\n              swap(nums,i,index);\n          }\n          \n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        for(int t:nums){\n            System.out.println(t);\n        }\n        List<List<Integer>> res=new ArrayList<>();\n        solve(res,nums,nums.length,0);\n        \n        return res; \n    }\n}`\n\nIts faiiling test case  [-1,2,0,-1,1,0,1] @"
                    },
                    {
                        "username": "note_08",
                        "content": "[@wangshuoyuan2](/wangshuoyuan2)  I get that part but so how  this code is working  plzz help\\n class Solution {\\npublic:\\n    void helper(int start,int n,vector<int> nums,vector<vector<int>>&ans){\\n        if(start==n){\\n            ans.push_back(nums);\\n            return ;\\n        }\\n        for(int i=start;i<n;i++){\\n            if(i!=start && nums[start]==nums[i]) continue;\\n            swap(nums[start],nums[i]);\\n            helper(start+1,n,nums,ans);\\n            swap(nums[start],nums[i]);\\n        }\\n    }\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        helper(0,n,nums,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "swap will change the order of nums, so in the later dfs, the nums is not a sorted array. Same thing happens to me and it takes me many time to figure it out :("
                    },
                    {
                        "username": "rg02",
                        "content": "same here, did you find a workaround?"
                    },
                    {
                        "username": "Ayushi_01",
                        "content": "why does it work fine without backtracking ( swapping the elements again to retain the original structure) even if the nums array is passed by reference?"
                    },
                    {
                        "username": "devinat11",
                        "content": "How to cheese this problem:\\nDo the same thing as permutations 1, but return the unique result:\\n`return [list(x) for x in set(tuple(l) for l in res)]`"
                    },
                    {
                        "username": "realitant",
                        "content": "I mean you\\'re not wrong, but if you\\'re going to cheese it, go all the way: return set(permutations(nums))"
                    },
                    {
                        "username": "codemode365",
                        "content": "This problem was pretty challenging than that of the permutation 1, I was trying to solve the problem in my local environment and When I was developing the algorithm I\\'ve already solved the problem but I didn\\'t knew so I was trying to fix the code which I later  realized\\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            }
        ]
    },
    {
        "title": "Insertion Sort List",
        "question_content": "<p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list&#39;s head</em>.</p>\n\n<p>The steps of the <strong>insertion sort</strong> algorithm:</p>\n\n<ol>\n\t<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>\n\t<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>\n\t<li>It repeats until no input elements remain.</li>\n</ol>\n\n<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" style=\"height:180px; width:300px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 46420,
                "title": "an-easy-and-clear-way-to-sort-o-1-space",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n    \\t\\tif( head == null ){\\n    \\t\\t\\treturn head;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode helper = new ListNode(0); //new starter of the sorted list\\n    \\t\\tListNode cur = head; //the node will be inserted\\n    \\t\\tListNode pre = helper; //insert node between pre and pre.next\\n    \\t\\tListNode next = null; //the next node will be inserted\\n    \\t\\t//not the end of input list\\n    \\t\\twhile( cur != null ){\\n    \\t\\t\\tnext = cur.next;\\n    \\t\\t\\t//find the right place to insert\\n    \\t\\t\\twhile( pre.next != null && pre.next.val < cur.val ){\\n    \\t\\t\\t\\tpre = pre.next;\\n    \\t\\t\\t}\\n    \\t\\t\\t//insert between pre and pre.next\\n    \\t\\t\\tcur.next = pre.next;\\n    \\t\\t\\tpre.next = cur;\\n    \\t\\t\\tpre = helper;\\n    \\t\\t\\tcur = next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn helper.next;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n    \\t\\tif( head == null ){\\n    \\t\\t\\treturn head;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tListNode helper = new ListNode(0); //new starter of the sorted list\\n    \\t\\tListNode cur = head; //the node will be inserted\\n    \\t\\tListNode pre = helper; //insert node between pre and pre.next\\n    \\t\\tListNode next = null; //the next node will be inserted\\n    \\t\\t//not the end of input list\\n    \\t\\twhile( cur != null ){\\n    \\t\\t\\tnext = cur.next;\\n    \\t\\t\\t//find the right place to insert\\n    \\t\\t\\twhile( pre.next != null && pre.next.val < cur.val ){\\n    \\t\\t\\t\\tpre = pre.next;\\n    \\t\\t\\t}\\n    \\t\\t\\t//insert between pre and pre.next\\n    \\t\\t\\tcur.next = pre.next;\\n    \\t\\t\\tpre.next = cur;\\n    \\t\\t\\tpre = helper;\\n    \\t\\t\\tcur = next;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn helper.next;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 190913,
                "title": "java-python-with-explanations",
                "content": "For example,\\n```\\nGiven 1 -> 3 -> 2 -> 4 - > null\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n               |    |\\n              ptr toInsert\\n-- locate ptr = 3 by (ptr.val > ptr.next.val)\\n-- locate toInsert = ptr.next\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n          |         |\\n   toInsertPre     toInsert\\n-- locate preInsert = 1 by preInsert.next.val > toInsert.val\\n-- insert toInsert between preInsert and preInsert.next\\n```\\n****\\n**Java**\\n```\\n    public ListNode insertionSortList(ListNode ptr) {    \\n        if (ptr == null || ptr.next == null)\\n            return ptr;\\n        \\n        ListNode preInsert, toInsert, dummyHead = new ListNode(0);\\n        dummyHead.next = ptr;\\n\\n        while (ptr != null && ptr.next != null) {\\n            if (ptr.val <= ptr.next.val) {\\n                ptr = ptr.next;\\n            } else {      \\n                toInsert = ptr.next;\\n                // Locate preInsert.\\n                preInsert = dummyHead;\\n                while (preInsert.next.val < toInsert.val) {\\n                    preInsert = preInsert.next;\\n                }\\n                ptr.next = toInsert.next;\\n                // Insert toInsert after preInsert.\\n                toInsert.next = preInsert.next;\\n                preInsert.next = toInsert;\\n            }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n```\\n**Python**\\n```\\n     def insertionSortList(self, head):\\n\\n        dummyHead = ListNode(0)\\n        dummyHead.next = nodeToInsert = head\\n        \\n        while head and head.next:\\n            if head.val > head.next.val:\\n                # Locate nodeToInsert.\\n                nodeToInsert = head.next\\n                # Locate nodeToInsertPre.\\n                nodeToInsertPre = dummyHead\\n                while nodeToInsertPre.next.val < nodeToInsert.val:\\n                    nodeToInsertPre = nodeToInsertPre.next\\n                    \\n                head.next = nodeToInsert.next\\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\\n                nodeToInsert.next = nodeToInsertPre.next\\n                nodeToInsertPre.next = nodeToInsert\\n            else:\\n                head = head.next\\n            \\n        return dummyHead.next\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nGiven 1 -> 3 -> 2 -> 4 - > null\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n               |    |\\n              ptr toInsert\\n-- locate ptr = 3 by (ptr.val > ptr.next.val)\\n-- locate toInsert = ptr.next\\n\\ndummy0 -> 1 -> 3 -> 2 -> 4 - > null\\n          |         |\\n   toInsertPre     toInsert\\n-- locate preInsert = 1 by preInsert.next.val > toInsert.val\\n-- insert toInsert between preInsert and preInsert.next\\n```\n```\\n    public ListNode insertionSortList(ListNode ptr) {    \\n        if (ptr == null || ptr.next == null)\\n            return ptr;\\n        \\n        ListNode preInsert, toInsert, dummyHead = new ListNode(0);\\n        dummyHead.next = ptr;\\n\\n        while (ptr != null && ptr.next != null) {\\n            if (ptr.val <= ptr.next.val) {\\n                ptr = ptr.next;\\n            } else {      \\n                toInsert = ptr.next;\\n                // Locate preInsert.\\n                preInsert = dummyHead;\\n                while (preInsert.next.val < toInsert.val) {\\n                    preInsert = preInsert.next;\\n                }\\n                ptr.next = toInsert.next;\\n                // Insert toInsert after preInsert.\\n                toInsert.next = preInsert.next;\\n                preInsert.next = toInsert;\\n            }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n```\n```\\n     def insertionSortList(self, head):\\n\\n        dummyHead = ListNode(0)\\n        dummyHead.next = nodeToInsert = head\\n        \\n        while head and head.next:\\n            if head.val > head.next.val:\\n                # Locate nodeToInsert.\\n                nodeToInsert = head.next\\n                # Locate nodeToInsertPre.\\n                nodeToInsertPre = dummyHead\\n                while nodeToInsertPre.next.val < nodeToInsert.val:\\n                    nodeToInsertPre = nodeToInsertPre.next\\n                    \\n                head.next = nodeToInsert.next\\n                # Insert nodeToInsert between nodeToInsertPre and nodeToInsertPre.next.\\n                nodeToInsert.next = nodeToInsertPre.next\\n                nodeToInsertPre.next = nodeToInsert\\n            else:\\n                head = head.next\\n            \\n        return dummyHead.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 46423,
                "title": "explained-c-solution-24ms",
                "content": "Keep a sorted partial list (`head`) and start from the second node (`head -> next`), each time when we see a node with `val` smaller than its previous node, we scan from the `head` and find the position that the node should be inserted. Since a node may be inserted before `head`, we create a `dummy` head that points to `head`.\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629811,
                "title": "c-python-java-2-simple-solution-w-explanation-swap-values-pointer-manipulation-approaches",
                "content": "We need to sort the given linked list using insertion sort\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort by Swapping Values)***\\n\\nA **pseudocode for standard insertion sort** might look like this -\\n\\n```c\\nfor i = 0 to n\\n\\tcur = A[i] and j = i - 1\\n\\twhile j >= 0 and arr[j] > cur:\\n\\t\\tarr[j+1] = arr[j]                     // shift right till we find greater than cur\\n\\t\\tj = j-1\\n\\tarr[j+1] = cur                            // insert cur at correct pos\\n```\\n\\nThis works for array and can even work for doubly linked-list where we can traverse backwards as well. However, for a singly linked list, we cant traverse backward and thus we cant directly implement in the above approach. \\n\\nSo, instead of beginning to left of current element and right-shifting each element till we find correct position for `cur`, we can modify the approach and begin inner iteration from 0 till we reach `i` (current element position) and swap the values whenever `A[j] > A[i]`. At the end, this will effectively achieve the same result as standard insertion sort does after each step.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        for(auto cur = head; cur; cur = cur -> next) \\n            for(auto j = head; j != cur; j = j -> next) \\n                if(j -> val > cur -> val) \\n                    swap(j -> val, cur -> val);\\n        return head;    \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        cur = head\\n        while cur:\\n            j = head\\n            while j != cur:\\n                if j.val > cur.val: \\n                    j.val, cur.val = cur.val, j.val\\n                j = j.next\\n            cur = cur.next\\n        return head\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        for(ListNode cur = head; cur != null; cur = cur.next) \\n            for(ListNode j = head; j != cur; j = j.next) \\n                if(j.val > cur.val)\\n                    j.val = j.val ^ cur.val ^ (cur.val = j.val);         // swap       \\n        return head;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Sort by Swapping Nodes)***\\n\\nIn the above solution, we required to iterate all the way from `head` till `cur` node everytime. Moreover, although each step outputs same result as insertion sort, it doesnt exactly functions like standard insertion sort algorithm in the sense that we are supposed to find & insert each element at correct position\\n\\nBasically,  Insertion sort works by finding the correct position of `cur` in the sorted portion of list and inserting it at that position. This is particularly beneficial in case of linked list since we can remove `cur` from its position and insert `cur` at its correct position of sorted list in `O(1)` by simply manipulating pointers/links  and thus we dont even need right-shift assignments as in case of arrays.\\n\\nWe can find correct position of `cur` by iterating in sorted portion of list till we find a node which has value less than cur. Then we remove `cur` from its original position and insert it at its correct position. The steps can be stated as -\\n1. Update next pointer of `cur` to `j` which is the position before which `cur` needs to be inserted. **`cur -> next = j`**\\n2. Update next pointer of previous node of `j` (`jPrev`) to `cur`. This is because `cur` is now inserted before `j` and thus `jPrev`\\'s next node should point at cur. **`jPrev -> next = cur`**\\n3. Update next pointer of previous node of `cur` (`curPrev`) to next of `cur`. This is because `cur` was removed from its original position and thus `curPrev` should point to next of `cur`. **`curPrev -> next = curNext`**\\n4. The current node is now placed at its proper position and all pointers have been updated. Now, move on to next node and continue this process till we reach the end of list.\\n\\nThe below illustration will help better understand the process -\\n\\n```python\\nConsider that we are at cur=2 and we found its correct position is before the node j=3\\n\\n    jPrev     j            curPrev    cur\\n      1   \\u2192  \\'3\\'  \\u2192   4   \\u2192   5   \\u2192   \\'2\\'   \\u2192   6              =>   1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n\\n\\n                   2\\uFE0F\\u20E3\\n      \\u21B1    \\u2192      \\u2192      \\u2192      \\u2192     \\u21B4                                                         curPrev    cur\\n=>    1   \\u2508  \\'3\\'  \\u2192   4   \\u2192   5   \\u2508  \\'2\\'  \\u2508   6               =>    1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n              \\u2B11   \\u2190     \\u2190    \\u2193       \\u21B2       \\u2191\\n\\t            1\\uFE0F\\u20E3           \\u21B3    \\u2192    \\u2192    \\u2B0F  \\n\\t   \\t  \\t  \\t                3\\uFE0F\\u20E3\\n```\\n\\nAnother thing to note is that `curPrev`  only gets updated when `cur` is already at its correct position. In all other cases, curPrev will remain same becase `cur` is removed from its original position and inserted somewhere back. So when we move to the next node, `curPrev` will remain its previous node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head);\\n        for(auto curPrev = head, cur = head -> next; cur;) {\\n            auto jPrev = dummy, j = jPrev -> next, curNext = cur -> next;\\n            if(cur -> val > curPrev -> val)           // cur already at correct position...so no need to update cur\\n                curPrev = cur;                        // only case where curPrev will need to be updated\\n            else {\\n                while(j -> val < cur -> val)\\n                    jPrev = j, j = j -> next;\\n                cur -> next = j;                      //  1\\uFE0F\\u20E3\\n                jPrev -> next = cur;                  //  2\\uFE0F\\u20E3\\n                curPrev -> next = curNext;            //  3\\uFE0F\\u20E3    \\n            }\\n            cur = curNext;                            // move to next node now     \\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b><i>Maintain Less Variables</i></b></summary>\\n\\nWe can do away with using lesser variable names. Since we have access to next nodes, we can only maintain `jPrev` and `curPrev` and still have access to `j` and `cur`. The below solution has updated `j` and `cur` to denote `jPrev` and `curPrev` but kept the same name for simplicity.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head), cur = head;\\n        while(cur -> next) \\n            if(cur -> next -> val > cur -> val) \\n                cur = cur -> next;\\n            else {\\n                auto j = dummy, curNextNext = cur -> next -> next;\\n                while(j -> next -> val < cur -> next -> val)\\n                    j = j -> next;\\n                cur -> next -> next = j -> next;\\n                j -> next = cur -> next;\\n                cur -> next = curNextNext;\\n            }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n**Python**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy, cur_prev, cur = ListNode(-1, head), head, head.next\\n        while cur:\\n            j_prev, j, cur_next = dummy, dummy.next, cur.next\\n            if cur.val > cur_prev.val:\\n                cur_prev = cur\\n            else:                \\n                while j.val < cur.val:\\n                    j_prev, j = j, j.next\\n                cur.next = j\\n                j_prev.next = cur\\n                cur_prev.next = cur_next\\n            cur = cur_next\\n        return dummy.next\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1, head), curPrev = head, cur = head.next;\\n        while(cur != null) {\\n            ListNode jPrev = dummy, j = jPrev.next, curNext = cur.next;\\n            if(cur.val > curPrev.val) curPrev = cur;\\n            else {\\n                while(j.val < cur.val) {\\n                    jPrev = j; \\n                    j = j.next;\\n                }\\n                cur.next = j;\\n                jPrev.next = cur;\\n                curPrev.next = curNext;\\n            }\\n            cur = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant space is being used\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```c\\nfor i = 0 to n\\n\\tcur = A[i] and j = i - 1\\n\\twhile j >= 0 and arr[j] > cur:\\n\\t\\tarr[j+1] = arr[j]                     // shift right till we find greater than cur\\n\\t\\tj = j-1\\n\\tarr[j+1] = cur                            // insert cur at correct pos\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        for(auto cur = head; cur; cur = cur -> next) \\n            for(auto j = head; j != cur; j = j -> next) \\n                if(j -> val > cur -> val) \\n                    swap(j -> val, cur -> val);\\n        return head;    \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        cur = head\\n        while cur:\\n            j = head\\n            while j != cur:\\n                if j.val > cur.val: \\n                    j.val, cur.val = cur.val, j.val\\n                j = j.next\\n            cur = cur.next\\n        return head\\n```\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        for(ListNode cur = head; cur != null; cur = cur.next) \\n            for(ListNode j = head; j != cur; j = j.next) \\n                if(j.val > cur.val)\\n                    j.val = j.val ^ cur.val ^ (cur.val = j.val);         // swap       \\n        return head;\\n    }\\n}\\n```\n```python\\nConsider that we are at cur=2 and we found its correct position is before the node j=3\\n\\n    jPrev     j            curPrev    cur\\n      1   \\u2192  \\'3\\'  \\u2192   4   \\u2192   5   \\u2192   \\'2\\'   \\u2192   6              =>   1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n\\n\\n                   2\\uFE0F\\u20E3\\n      \\u21B1    \\u2192      \\u2192      \\u2192      \\u2192     \\u21B4                                                         curPrev    cur\\n=>    1   \\u2508  \\'3\\'  \\u2192   4   \\u2192   5   \\u2508  \\'2\\'  \\u2508   6               =>    1   \\u2192   2   \\u2192   3   \\u2192   4   \\u2192   5   \\u2192   6\\n              \\u2B11   \\u2190     \\u2190    \\u2193       \\u21B2       \\u2191\\n\\t            1\\uFE0F\\u20E3           \\u21B3    \\u2192    \\u2192    \\u2B0F  \\n\\t   \\t  \\t  \\t                3\\uFE0F\\u20E3\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head);\\n        for(auto curPrev = head, cur = head -> next; cur;) {\\n            auto jPrev = dummy, j = jPrev -> next, curNext = cur -> next;\\n            if(cur -> val > curPrev -> val)           // cur already at correct position...so no need to update cur\\n                curPrev = cur;                        // only case where curPrev will need to be updated\\n            else {\\n                while(j -> val < cur -> val)\\n                    jPrev = j, j = j -> next;\\n                cur -> next = j;                      //  1\\uFE0F\\u20E3\\n                jPrev -> next = cur;                  //  2\\uFE0F\\u20E3\\n                curPrev -> next = curNext;            //  3\\uFE0F\\u20E3    \\n            }\\n            cur = curNext;                            // move to next node now     \\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        auto dummy = new ListNode(INT_MIN, head), cur = head;\\n        while(cur -> next) \\n            if(cur -> next -> val > cur -> val) \\n                cur = cur -> next;\\n            else {\\n                auto j = dummy, curNextNext = cur -> next -> next;\\n                while(j -> next -> val < cur -> next -> val)\\n                    j = j -> next;\\n                cur -> next -> next = j -> next;\\n                j -> next = cur -> next;\\n                cur -> next = curNextNext;\\n            }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy, cur_prev, cur = ListNode(-1, head), head, head.next\\n        while cur:\\n            j_prev, j, cur_next = dummy, dummy.next, cur.next\\n            if cur.val > cur_prev.val:\\n                cur_prev = cur\\n            else:                \\n                while j.val < cur.val:\\n                    j_prev, j = j, j.next\\n                cur.next = j\\n                j_prev.next = cur\\n                cur_prev.next = cur_next\\n            cur = cur_next\\n        return dummy.next\\n```\n```java\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1, head), curPrev = head, cur = head.next;\\n        while(cur != null) {\\n            ListNode jPrev = dummy, j = jPrev.next, curNext = cur.next;\\n            if(cur.val > curPrev.val) curPrev = cur;\\n            else {\\n                while(j.val < cur.val) {\\n                    jPrev = j; \\n                    j = j.next;\\n                }\\n                cur.next = j;\\n                jPrev.next = cur;\\n                curPrev.next = curNext;\\n            }\\n            cur = curNext;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46573,
                "title": "clean-java-solution-using-a-fake-head",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n      ListNode curr = head, next = null;\\n      // l is a fake head\\n      ListNode l = new ListNode(0);\\n      \\n      while (curr != null) {\\n        next = curr.next;\\n        \\n        ListNode p = l;\\n        while (p.next != null && p.next.val < curr.val)\\n          p = p.next;\\n        \\n        // insert curr between p and p.next\\n        curr.next = p.next;\\n        p.next = curr;\\n        curr = next;\\n      }\\n      \\n      return l.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n      ListNode curr = head, next = null;\\n      // l is a fake head\\n      ListNode l = new ListNode(0);\\n      \\n      while (curr != null) {\\n        next = curr.next;\\n        \\n        ListNode p = l;\\n        while (p.next != null && p.next.val < curr.val)\\n          p = p.next;\\n        \\n        // insert curr between p and p.next\\n        curr.next = p.next;\\n        p.next = curr;\\n        curr = next;\\n      }\\n      \\n      return l.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46459,
                "title": "accepted-solution-using-java",
                "content": "    public class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode helper=new ListNode(0);\\n        ListNode pre=helper;\\n        ListNode current=head;\\n        while(current!=null) {\\n            pre=helper;\\n            while(pre.next!=null&&pre.next.val<current.val) {\\n                pre=pre.next;\\n            }\\n            ListNode next=current.next;\\n            current.next=pre.next;\\n            pre.next=current;\\n            current=next;\\n        }\\n        return helper.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode helper=new ListNode(0);\\n        ListNode pre=helper;\\n        ListNode current=head;\\n        while(current!=null) {\\n            pre=helper;\\n            while(pre.next!=null&&pre.next.val<current.val) {\\n                pre=pre.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1176552,
                "title": "python3-188ms-solution-explanation-with-visualization",
                "content": "**Idea**\\n- Add `dummy_head` before `head` will help us to handle the insertion easily\\n- Use two pointers\\n\\t- `last_sorted`: last node of the sorted part, whose value is the largest of the sorted part\\n\\t- `cur`: next node of `last_sorted`, which is the current node to be considered\\n\\n\\tAt the beginning, `last_sorted` is `head` and `cur` is `head.next`\\n- When consider the `cur` node, there\\'re 2 different cases\\n\\t- `last_sorted.val <= cur.val`: `cur` is in the correct order and can be directly move into the sorted part. In this case, we just move `last_sorted` one step forward\\n\\t![image](https://assets.leetcode.com/users/images/996a6192-d1c4-4f0b-8fd5-a0c9f6b147cb_1619384454.3517435.png)\\n\\n\\t- `last_sorted.val > cur.val`: `cur` needs to be inserted somewhere in the sorted part. In this case, we let `prev` start from `dummy_head` and iteratively compare `prev.next.val` and `cur.val`. If `prev.next.val > cur.val`, we insert `cur` between `prev` and `prev.next`\\n\\t- ![image](https://assets.leetcode.com/users/images/47c2462c-08d7-4eb2-8789-7aba83a84b91_1619384469.52542.png)\\n\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        # No need to sort for empty list or list of size 1\\n        if not head or not head.next:\\n            return head\\n        \\n        # Use dummy_head will help us to handle insertion before head easily\\n        dummy_head = ListNode(val=-5000, next=head)\\n        last_sorted = head # last node of the sorted part\\n        cur = head.next # cur is always the next node of last_sorted\\n        while cur:\\n            if cur.val >= last_sorted.val:\\n                last_sorted = last_sorted.next\\n            else:\\n                # Search for the position to insert\\n                prev = dummy_head\\n                while prev.next.val <= cur.val:\\n                    prev = prev.next\\n                    \\n                # Insert\\n                last_sorted.next = cur.next\\n                cur.next = prev.next\\n                prev.next = cur\\n                \\n            cur = last_sorted.next\\n            \\n        return dummy_head.next\\n```\\n\\n**Complexity**\\n- Time: O(n^2)\\n- Space: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        \\n        # No need to sort for empty list or list of size 1\\n        if not head or not head.next:\\n            return head\\n        \\n        # Use dummy_head will help us to handle insertion before head easily\\n        dummy_head = ListNode(val=-5000, next=head)\\n        last_sorted = head # last node of the sorted part\\n        cur = head.next # cur is always the next node of last_sorted\\n        while cur:\\n            if cur.val >= last_sorted.val:\\n                last_sorted = last_sorted.next\\n            else:\\n                # Search for the position to insert\\n                prev = dummy_head\\n                while prev.next.val <= cur.val:\\n                    prev = prev.next\\n                    \\n                # Insert\\n                last_sorted.next = cur.next\\n                cur.next = prev.next\\n                prev.next = cur\\n                \\n            cur = last_sorted.next\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46432,
                "title": "ac-python-192ms-solution",
                "content": "    def insertionSortList(self, head):\\n        p = dummy = ListNode(0)\\n        cur = dummy.next = head\\n        while cur and cur.next:\\n            val = cur.next.val\\n            if cur.val < val:\\n                cur = cur.next\\n                continue\\n            if p.next.val > val:\\n                p = dummy\\n            while p.next.val < val:\\n                p = p.next\\n            new = cur.next\\n            cur.next = new.next\\n            new.next = p.next\\n            p.next = new\\n        return dummy.next\\n\\n\\n    # 21 / 21 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 192 ms\\n    # 97.05%\\n\\nOf course, the solution is still O(n^2) in the worst case, but it can be faster than most implements under given test cases.\\n\\nTwo key points are: (1) a quick check see if the new value is already the largest (2) only refresh the search pointer p when the target is before it, in other words smaller.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def insertionSortList(self, head):\\n        p = dummy = ListNode(0)\\n        cur = dummy.next = head\\n        while cur and cur.next:\\n            val = cur.next.val\\n            if cur.val < val:\\n                cur = cur.next\\n                continue\\n            if p.next.val > val:\\n                p = dummy\\n            while p.next.val < val:\\n                p = p.next\\n            new = cur.next\\n            cur.next = new.next\\n            new.next = p.next\\n            p.next = new\\n        return dummy.next\\n\\n\\n    # 21 / 21 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 192 ms\\n    # 97.05%\\n\\nOf course, the solution is still O(n^2) in the worst case, but it can be faster than most implements under given test cases.\\n\\nTwo key points are: (1) a quick check see if the new value is already the largest (2) only refresh the search pointer p when the target is before it, in other words smaller.",
                "codeTag": "Python3"
            },
            {
                "id": 920371,
                "title": "python-insertion-sort-explained",
                "content": "In this problem we are asked to implement insertion sort on singly-linked list data structure. And we do not really have a choice how to do it: we just need to apply definition of Insertion Sort. Imagine, that we already sorted some part of data, and we have something like:\\n`1 2 3 7` **4** `6`,\\nwhere by bold **4** I denoted element we need to insert on current step. How we can do it? We need to iterate over our list and find the place, where it should be inserted. Classical way to do it is to use **two pointers**: `prv` and `nxt`, stands for previous and next and stop, when value of `nxt` is greater than value of node we want ot insert. Then we insert this element into correct place, doing `curr.next = next, prv.next = curr`. Also, now we need to update our `curr` element: for that reason in the beginning of the loop we defined `curr_next = curr.next`, so we can update it now.\\n\\n**Complexity**: time complexity is `O(n^2)`, as Insertion sort should be: we take `O(n)` loops with `O(n)` loop inside. Space complexity is `O(1)`, because what we do is only change connections between our nodes, and do not create new data.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy = ListNode(-1)\\n        curr = head\\n        while curr:\\n            curr_next = curr.next\\n            prv, nxt = dummy, dummy.next\\n            while nxt:\\n                if nxt.val > curr.val: break\\n                prv = nxt\\n                nxt = nxt.next\\n                \\n            curr.next = nxt\\n            prv.next = curr\\n            curr = curr_next\\n        \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        dummy = ListNode(-1)\\n        curr = head\\n        while curr:\\n            curr_next = curr.next\\n            prv, nxt = dummy, dummy.next\\n            while nxt:\\n                if nxt.val > curr.val: break\\n                prv = nxt\\n                nxt = nxt.next\\n                \\n            curr.next = nxt\\n            prv.next = curr\\n            curr = curr_next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629448,
                "title": "c-easy-to-solve-detailed-explanation-with-dry-run",
                "content": "**Intuition:-**\\nNothing for intuition this time. Since the question is loud and clear that we need to use insertion sort[Also explained in the description of the question] for sorting the linked list .\\n*A tip -Do not get intimidated by the length of code have faith in yourself that you can understand.*\\n\\n**Algorithm:-**\\n1. Let\\'s create a `newHead ` as the name suggests it will be representating our final linked list. Initialize it to NULL.\\n2. Now we will traverse our original linkedlist and seperate our head nodes one at a time in each iteration to insert them in the `newHead` initiated linkedlist\\n3. During insertion in `newHead` we need to take care of three conditions \\n* Condition 1: If this is the first node that is being inserted in the `newHead` the node will get insertd at `newHead `\\n* Condition 2:  After the the first insertion we need to check whether the next insertion will be in between or in the end of` newHead linkedlist`\\n* Condition 3: To check the condition 2 we need this condition i.e we will traverse the newHead linkedlist using a temporary pointer \"`root`\" and find the appropriate position of the `temp` node\\n4. Repeat process 2 and 3 until all the nodes are inserted to newHead\\n\\n[The three conditon we talked are in the form of **if** ,**elseif**, and **else** in the code given]\\n\\n\\n**Before getting inside the code let\\'s have a dry run :**\\n![image](https://assets.leetcode.com/users/images/0aabafee-7553-4cb4-a1b4-a748789e3178_1639536272.2921226.jpeg)\\n\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;//initializing the newHead for our sorted linkedlist\\n        while(head){\\n            // Exluding node from the original linked list we will do this one at a time\\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n             // if the position of element is at index 0 i.e. at the start (the temp node is the smallest of all the nodes that are currently present in the sorted linked list)\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //Our sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n......*Continuation from previous posts..\\nThis a filler episode..The great 5 archeologist that were selected were those who understand the Doge\\'s significance in real life .They have researched about everything in the field of Dogegenesis.People will see masters at work.Thus the National Government Chose them and gave them the code name of Doggo, Dogelina, Dogenderous, yomru and JThree. The captain of this team is JThree. The Doggo has a keen ears ,Dogelina has mastered the breathing sense ,Yomru has physique of super strength,Dogenderous has mastered the sneaking ability i.e to remove his presence, and JThree has foreseeing eyes which is based on high probability calculations.\\nTo be continued in the next post*......",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;//initializing the newHead for our sorted linkedlist\\n        while(head){\\n            // Exluding node from the original linked list we will do this one at a time\\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n             // if the position of element is at index 0 i.e. at the start (the temp node is the smallest of all the nodes that are currently present in the sorted linked list)\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //Our sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46422,
                "title": "my-c-solution",
                "content": "    ListNode *insertionSortList(ListNode *head)\\n    {\\n    \\tif (head == NULL || head->next == NULL)\\n    \\t\\treturn head;\\n    \\n    \\tListNode *p = head->next;\\n    \\thead->next = NULL;\\n    \\n    \\twhile (p != NULL)\\n    \\t{\\n    \\t\\tListNode *pNext = p->next;    /*store the next node to be insert*/\\n    \\t\\tListNode *q = head;\\n    \\n    \\t\\tif (p->val < q->val)    /*node p should be the new head*/\\n    \\t\\t{\\n    \\t\\t\\tp->next = q;\\n    \\t\\t\\thead = p;\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\twhile (q != NULL && q->next != NULL && q->next->val <= p->val)\\n    \\t\\t\\t\\tq = q->next;\\n    \\t\\t\\tp->next = q->next;\\n    \\t\\t\\tq->next = p;\\n    \\t\\t}\\n    \\n    \\t\\tp = pNext;\\n    \\t}\\n    \\treturn head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode *insertionSortList(ListNode *head)\\n    {\\n    \\tif (head == NULL || head->next == NULL)\\n    \\t\\treturn head;\\n    \\n    \\tListNode *p = head->next;\\n    \\thead->next = NULL;\\n    \\n    \\twhile (p != NULL)\\n    \\t{\\n    \\t\\tListNode *pNext = p->next;    /*store the next node to be insert*/\\n    \\t\\tListNode *q = head;\\n    \\n    \\t\\tif (p->val < q->val)    /*node p should be the new head*/\\n    \\t\\t{\\n    \\t\\t\\tp->next = q;\\n    \\t\\t\\thead = p;\\n    \\t\\t}\\n    \\t\\telse \\n    \\t\\t{\\n    \\t\\t\\twhile (q != NULL && q->next != NULL && q->next->val <= p->val)\\n    \\t\\t\\t\\tq = q->next;\\n    \\t\\t\\tp->next = q->next;\\n    \\t\\t\\tq->next = p;\\n    \\t\\t}\\n    \\n    \\t\\tp = pNext;\\n    \\t}\\n    \\treturn head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46470,
                "title": "concise-python-solution-with-comments",
                "content": "    def insertionSortList(self, head):\\n        cur = dummy = ListNode(0)\\n        while head:\\n            if cur and cur.val > head.val: # reset pointer only when new number is smaller than pointer value\\n                cur = dummy\\n            while cur.next and cur.next.val < head.val: # classic insertion sort to find position\\n                cur = cur.next\\n            cur.next, cur.next.next, head = head, cur.next, head.next # insert\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def insertionSortList(self, head):\\n        cur = dummy = ListNode(0)\\n        while head:\\n            if cur and cur.val > head.val: # reset pointer only when new number is smaller than pointer value\\n                cur = dummy\\n            while cur.next and cur.next.val < head.val: # classic insertion sort to find position\\n                cur = cur.next\\n            cur.next, cur.next.next, head = head, cur.next, head.next # insert\\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 46497,
                "title": "7ms-java-solution-with-explanation",
                "content": "The only real modification here is to take advantage of the ability to add to both the front and end of a linked list in constant time.  A typical insertion sort would have to go through the entire array to find the new location to insert the element. If the element should be placed first in the array then we have to shift everything over.  Thankfully, with a linked list we don't need to do this.  The slight modification of keeping a pointer to the last node as well as the first dramatically increased the runtime of the algorithm.  That being said, the speedup still has a lot to do with the ordering if the items in the array.  \\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null)\\n        {\\n            return head;\\n        }\\n\\n        ListNode sortedHead = head, sortedTail = head;\\n        head = head.next;\\n        sortedHead.next = null;\\n        \\n        while (head != null)\\n        {\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null;\\n            \\n            // new val is less than the head, just insert in the front\\n            if (temp.val <= sortedHead.val)\\n            {\\n                temp.next = sortedHead;\\n                sortedTail = sortedHead.next == null ? sortedHead : sortedTail;\\n                sortedHead = temp;\\n            }\\n            // new val is greater than the tail, just insert at the back\\n            else if (temp.val >= sortedTail.val)\\n            {\\n                sortedTail.next = temp;\\n                sortedTail = sortedTail.next;\\n            }\\n            // new val is somewhere in the middle, we will have to find its proper\\n            // location.\\n            else\\n            {\\n                ListNode current = sortedHead;\\n                while (current.next != null && current.next.val < temp.val)\\n                {\\n                    current = current.next;\\n                }\\n                \\n                temp.next = current.next;\\n                current.next = temp;\\n            }\\n        }\\n        \\n        return sortedHead;\\n    }",
                "solutionTags": [],
                "code": "The only real modification here is to take advantage of the ability to add to both the front and end of a linked list in constant time.  A typical insertion sort would have to go through the entire array to find the new location to insert the element. If the element should be placed first in the array then we have to shift everything over.  Thankfully, with a linked list we don't need to do this.  The slight modification of keeping a pointer to the last node as well as the first dramatically increased the runtime of the algorithm.  That being said, the speedup still has a lot to do with the ordering if the items in the array.  \\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null)\\n        {\\n            return head;\\n        }\\n\\n        ListNode sortedHead = head, sortedTail = head;\\n        head = head.next;\\n        sortedHead.next = null;\\n        \\n        while (head != null)\\n        {\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null;\\n            \\n            // new val is less than the head, just insert in the front\\n            if (temp.val <= sortedHead.val)\\n            {\\n                temp.next = sortedHead;\\n                sortedTail = sortedHead.next == null ? sortedHead : sortedTail;\\n                sortedHead = temp;\\n            }\\n            // new val is greater than the tail, just insert at the back\\n            else if (temp.val >= sortedTail.val)\\n            {\\n                sortedTail.next = temp;\\n                sortedTail = sortedTail.next;\\n            }\\n            // new val is somewhere in the middle, we will have to find its proper\\n            // location.\\n            else\\n            {\\n                ListNode current = sortedHead;\\n                while (current.next != null && current.next.val < temp.val)\\n                {\\n                    current = current.next;\\n                }\\n                \\n                temp.next = current.next;\\n                current.next = temp;\\n            }\\n        }\\n        \\n        return sortedHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46419,
                "title": "python-time-limit-is-too-tight",
                "content": "I have basically the same code in python and java (see below). python got TLE, but java was accepted. I propose to relax the python time limit a little bit.\\n\\n**Python**\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        srt = None\\n        while head:\\n            node = head\\n            head = head.next\\n            node.next = None\\n            srt = self.insertTo(srt, node)\\n        return srt\\n        \\n    def insertTo(self, head, node):\\n        node.next = head\\n        head = node\\n        while node.next and node.val > node.next.val:\\n            node.val, node.next.val = node.next.val, node.val\\n            node = node.next\\n        return head\\n\\n**java**\\n\\n    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            ListNode srt = null;\\n            while (head != null) {\\n                ListNode node = head;\\n                head = head.next;\\n                node.next = null;\\n                srt = insertTo(srt, node);\\n            }\\n            return srt;\\n        }\\n        \\n        public ListNode insertTo(ListNode head, ListNode node) {\\n            node.next = head;\\n            head = node;\\n            while (node.next != null && node.val > node.next.val) {\\n                node.val = node.val ^ node.next.val;\\n                node.next.val = node.val ^ node.next.val;\\n                node.val = node.val ^ node.next.val;\\n                node = node.next;\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        srt = None\\n        while head:\\n            node = head\\n            head = head.next\\n            node.next = None\\n            srt = self.insertTo(srt, node)\\n        return srt\\n        \\n    def insertTo(self, head, node):\\n        node.next = head\\n        head = node\\n        while node.next and node.val > node.next.val:\\n            node.val, node.next.val = node.next.val, node.val\\n            node = node.next\\n        return head\\n\\n**java**\\n\\n    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            ListNode srt = null;\\n            while (head != null) {\\n                ListNode node = head;\\n                head = head.next;\\n                node.next = null;\\n                srt = insertTo(srt, node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1941840,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log n), where n is the number of nodes in the linked list.\\n    //   - space: O(n)\\n    \\n    func insertionSortList(_ head: ListNode?) -> ListNode? {\\n        var nodes: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nodes.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        nodes.sort(by: { $0.val < $1.val })\\n        \\n        var newHead: ListNode?\\n        var prev: ListNode?\\n        \\n        for node in nodes {\\n            if newHead == nil {\\n                newHead = node\\n            }\\n            \\n            prev?.next = node\\n            prev = node\\n        }\\n        \\n        prev?.next = nil\\n        return newHead\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log n), where n is the number of nodes in the linked list.\\n    //   - space: O(n)\\n    \\n    func insertionSortList(_ head: ListNode?) -> ListNode? {\\n        var nodes: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nodes.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        nodes.sort(by: { $0.val < $1.val })\\n        \\n        var newHead: ListNode?\\n        var prev: ListNode?\\n        \\n        for node in nodes {\\n            if newHead == nil {\\n                newHead = node\\n            }\\n            \\n            prev?.next = node\\n            prev = node\\n        }\\n        \\n        prev?.next = nil\\n        return newHead\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46571,
                "title": "c-recursive-insertion-sort",
                "content": "        \\n    ListNode* insertionSortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *h = insertionSortList(head->next);\\n        if (head->val <= h->val) {  // first case\\n            head->next = h;\\n            return head;\\n        }\\n        ListNode *node = h;   // second case\\n        while (node->next && head->val > node->next->val)\\n            node = node->next;\\n        head->next = node->next;\\n        node->next = head;\\n        return h;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "        \\n    ListNode* insertionSortList(ListNode* head) {\\n        if (head == nullptr || head->next == NULL)\\n            return head;\\n        ListNode *h = insertionSortList(head->next);\\n        if (head->val <= h->val) {  // first case\\n            head->next = h;\\n            return head;\\n        }\\n        ListNode *node = h;   // second case\\n        while (node->next && head->val > node->next->val)\\n            node = node->next;\\n        head->next = node->next;\\n        node->next = head;\\n        return h;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46520,
                "title": "concise-javascript-solution",
                "content": "    function insertionSortList(head) {\\n        var before = { val: -Number.MAX_VALUE, next: null };\\n        \\n        while (head) {\\n            var prev = before;\\n            \\n            // find prev\\n            while (prev.next && prev.next.val < head.val) {\\n                prev = prev.next;\\n            }\\n            \\n            var next = head.next;\\n            head.next = prev.next;\\n            prev.next = head;\\n            head = next;\\n        }\\n        \\n        return before.next;\\n    }",
                "solutionTags": [],
                "code": "    function insertionSortList(head) {\\n        var before = { val: -Number.MAX_VALUE, next: null };\\n        \\n        while (head) {\\n            var prev = before;\\n            \\n            // find prev\\n            while (prev.next && prev.next.val < head.val) {\\n                prev = prev.next;\\n            }\\n            \\n            var next = head.next;\\n            head.next = prev.next;\\n            prev.next = head;\\n            head = next;\\n        }\\n        \\n        return before.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1629715,
                "title": "c-simple-and-short-explained-solution-no-extra-space",
                "content": "**Idea:**\\nWe start the new sorted list with a zero node, so that it will be easier to insert in every position.\\nWe iterate through the list with the `head` pointer.\\nFor each node, we use the function `insert` to iterate through the new sorted list and find the right insertion position.\\nWe return `new_head->next` because our zero node will always be first and we don\\'t want it.\\n\\n**Time Complexity:** O(n^2)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    void insert(ListNode* head, ListNode* node) {\\n        while (head->next && head->next->val < node->val) head = head->next;\\n        node->next = head->next;\\n        head->next = node;\\n    }\\n    \\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* new_head = new ListNode(0);\\n\\n        while (head) {\\n            ListNode* node = head;\\n            head = head->next;\\n            insert(new_head, node);\\n        }\\n        \\n        return new_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void insert(ListNode* head, ListNode* node) {\\n        while (head->next && head->next->val < node->val) head = head->next;\\n        node->next = head->next;\\n        head->next = node;\\n    }\\n    \\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* new_head = new ListNode(0);\\n\\n        while (head) {\\n            ListNode* node = head;\\n            head = head->next;\\n            insert(new_head, node);\\n        }\\n        \\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920433,
                "title": "c-pointer-based-solution-explained-100-time-90-space",
                "content": "Ah, gotta love starting the day with classic algorithms you otherwise would just see again on textbooks and manuals :)\\n\\nIn order to proceed with this one, we need to first of all check if we are dealing with an empty list: if so, we just return `NULL`.\\n\\nOtherwise, we create 3 support variables, all `ListNode` pointers:\\n* `tail`, initialised to be `head` will delimit up to where our sorted domain extends;\\n* `curr` is the node we are currently considering and putting in sorted order;\\n* `iter`, finally, it is a support variable for when we need to go and splice `curr` if it is not the newest minimum or the newest maximum; I know I might have not used it, just splicing `curr` so that it would bubble up to his position, but that seemed needlessly expensive and not worth saving the tiny amount of memory an extra pointer would cost us - so, unless your interviewer really wants you to consider other approaches (like dealing with devices of very little memory, but then not sure how they would handle linked lists), just discuss it quickly and make your own call of what is best.\\n\\nThen we have our main loop and we will proceed until we have something else to parse, that is to say as long as `tail->next`. Notice we do not need to check if `tail` exist, since we initialised it to `head` and we checked before that `head` has to be non `NULL`.\\n\\nInside our loops we will:\\n* check if `curr` is the newest maximum and thus replace `tail` with it;\\n* get the next value after `tail` out and assign it to `curr`;\\n* check if `curr` is the newest minimum and thus replace `head` with it;\\n* check for all the other cases, assigning `head` to `iter` initially and gradually increasing it, checking if `curr` fits between `iter` and `iter->next`.\\n\\nOnce we are done parsing the whole list, we return `head` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return NULL;\\n        ListNode *tail = head, *curr, *iter;\\n        while (tail->next) {\\n            // checking if the next one is already the next bigger\\n            if (tail->val <= tail->next->val) {\\n                tail = tail->next;\\n                continue;\\n            }\\n            // taking a new node to parse, curr, out of the list\\n            curr = tail->next;\\n            tail->next = curr->next;\\n            // checking if curr will become the new head\\n            if (curr->val < head->val) {\\n                curr->next = head;\\n                head = curr;\\n                continue;\\n            }\\n            // all the other cases\\n            iter = head;\\n            while (iter != tail) {\\n                // checking when we can splice curr between iter and the following value\\n                if (curr->val < iter->next->val) {\\n                    curr->next = iter->next;\\n                    iter->next = curr;\\n                    break;\\n                }\\n                // moving to the next!\\n                iter = iter->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return NULL;\\n        ListNode *tail = head, *curr, *iter;\\n        while (tail->next) {\\n            // checking if the next one is already the next bigger\\n            if (tail->val <= tail->next->val) {\\n                tail = tail->next;\\n                continue;\\n            }\\n            // taking a new node to parse, curr, out of the list\\n            curr = tail->next;\\n            tail->next = curr->next;\\n            // checking if curr will become the new head\\n            if (curr->val < head->val) {\\n                curr->next = head;\\n                head = curr;\\n                continue;\\n            }\\n            // all the other cases\\n            iter = head;\\n            while (iter != tail) {\\n                // checking when we can splice curr between iter and the following value\\n                if (curr->val < iter->next->val) {\\n                    curr->next = iter->next;\\n                    iter->next = curr;\\n                    break;\\n                }\\n                // moving to the next!\\n                iter = iter->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46572,
                "title": "simple-and-clean-java-code",
                "content": "    public ListNode insertionSortList(ListNode head) {\\n\\t\\tListNode cur = head;\\n\\t\\tListNode dummy = new ListNode(0), p;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t//locate the insertion position.\\n\\t\\t\\tp = dummy;\\n\\t\\t\\twhile (p.next != null &&  cur.val > p.next.val) {\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert between p and p.next.\\n\\t\\t\\tListNode pNext = p.next;\\n\\t\\t\\tp.next = cur;\\n\\t\\t\\tListNode next = cur.next;\\n\\t\\t\\tcur.next = pNext;\\n\\t\\t\\tcur = next;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode insertionSortList(ListNode head) {\\n\\t\\tListNode cur = head;\\n\\t\\tListNode dummy = new ListNode(0), p;\\n\\t\\twhile (cur != null) {\\n\\t\\t\\t//locate the insertion position.\\n\\t\\t\\tp = dummy;\\n\\t\\t\\twhile (p.next != null &&  cur.val > p.next.val) {\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert between p and p.next.\\n\\t\\t\\tListNode pNext = p.next;\\n\\t\\t\\tp.next = cur;\\n\\t\\t\\tListNode next = cur.next;\\n\\t\\t\\tcur.next = pNext;\\n\\t\\t\\tcur = next;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 920574,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode current = head.next;\\n        ListNode pre = head;\\n        while(current !=null){\\n            if(current.val>=pre.val){\\n                current = current.next;\\n                pre = pre.next;\\n            }\\n            else{\\n                pre.next = current.next;\\n                if(current.val<=head.val){ \\n                    current.next = head;\\n                    head = current;\\n                }\\n                else{\\n                    ListNode search = head;\\n                    while(search.next != null && search.next.val<current.val){\\n                        search = search.next;\\n                    }\\n                    ListNode tmp = search.next;\\n                    search.next = current;\\n                    current.next = tmp;\\n                }\\n                current = pre.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null) return head;\\n        ListNode current = head.next;\\n        ListNode pre = head;\\n        while(current !=null){\\n            if(current.val>=pre.val){\\n                current = current.next;\\n                pre = pre.next;\\n            }\\n            else{\\n                pre.next = current.next;\\n                if(current.val<=head.val){ \\n                    current.next = head;\\n                    head = current;\\n                }\\n                else{\\n                    ListNode search = head;\\n                    while(search.next != null && search.next.val<current.val){\\n                        search = search.next;\\n                    }\\n                    ListNode tmp = search.next;\\n                    search.next = current;\\n                    current.next = tmp;\\n                }\\n                current = pre.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206758,
                "title": "147-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution involves iterating through the linked list, removing each node from the list, and then inserting it into the sorted portion of the list. The sorted portion of the list is initially just the first node, and grows with each iteration.\\n\\nThis solution has a time complexity of O(n^2) since in the worst case, we may need to iterate through the entire sorted portion of the list for each node in the unsorted portion of the list. The space complexity is O(1) since we are only manipulating the existing linked list and not creating any new data structures.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # Initialize the sorted portion of the list to be the first node\\n        sorted_head = ListNode(0)\\n        sorted_head.next = head\\n        sorted_tail = head\\n        \\n        # Start with the second node in the list, since the first node is already sorted\\n        curr = head.next\\n        \\n        while curr:\\n            # If the current node is greater than the tail of the sorted list, \\n            # it is already in the correct place, so just move on to the next node\\n            if curr.val >= sorted_tail.val:\\n                sorted_tail = curr\\n                curr = curr.next\\n            else:\\n                # Remove the current node from the list\\n                sorted_tail.next = curr.next\\n                \\n                # Find the correct position to insert the current node in the sorted list\\n                insert_pos = sorted_head\\n                while insert_pos.next.val < curr.val:\\n                    insert_pos = insert_pos.next\\n                \\n                # Insert the current node into the sorted list\\n                curr.next = insert_pos.next\\n                insert_pos.next = curr\\n                \\n                # Move on to the next node in the unsorted portion of the list\\n                curr = sorted_tail.next\\n        \\n        return sorted_head.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # Initialize the sorted portion of the list to be the first node\\n        sorted_head = ListNode(0)\\n        sorted_head.next = head\\n        sorted_tail = head\\n        \\n        # Start with the second node in the list, since the first node is already sorted\\n        curr = head.next\\n        \\n        while curr:\\n            # If the current node is greater than the tail of the sorted list, \\n            # it is already in the correct place, so just move on to the next node\\n            if curr.val >= sorted_tail.val:\\n                sorted_tail = curr\\n                curr = curr.next\\n            else:\\n                # Remove the current node from the list\\n                sorted_tail.next = curr.next\\n                \\n                # Find the correct position to insert the current node in the sorted list\\n                insert_pos = sorted_head\\n                while insert_pos.next.val < curr.val:\\n                    insert_pos = insert_pos.next\\n                \\n                # Insert the current node into the sorted list\\n                curr.next = insert_pos.next\\n                insert_pos.next = curr\\n                \\n                # Move on to the next node in the unsorted portion of the list\\n                curr = sorted_tail.next\\n        \\n        return sorted_head.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629981,
                "title": "for-god-s-sake-don-t-try-sorting-a-linked-list-during-the-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> nums;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        temp = head;\\n        int i = 0;\\n        while(temp != NULL){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629485,
                "title": "python-dummy-head-clean-and-easy-to-understand-with-detailed-explanation",
                "content": "**Time Complexity : O(N<sup>2</sup>) \\nSpace Complexity : O(1)**\\n**Dummy head can make the code more concise**\\n```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        p, sl = head, ListNode()  # sl is the sortedList with dummy head node.\\n        while p:  # traverse the input linked list until None\\n            q = sl  # q is the pre of current node of sortedList\\n            while q.next and q.next.val < p.val:  # find the insertion position sequentially\\n                q = q.next\\n            p.next, q.next, p, q = q.next, p, p.next, q.next  # insert p to q.next\\n        return sl.next  # Note sl is the dummy head node\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        p, sl = head, ListNode()  # sl is the sortedList with dummy head node.\\n        while p:  # traverse the input linked list until None\\n            q = sl  # q is the pre of current node of sortedList\\n            while q.next and q.next.val < p.val:  # find the insertion position sequentially\\n                q = q.next\\n            p.next, q.next, p, q = q.next, p, p.next, q.next  # insert p to q.next\\n        return sl.next  # Note sl is the dummy head node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629387,
                "title": "python-actual-insertion-sort-solution-article-has-inaccurate-implementation",
                "content": "Strictly speaking, in insertion sort, the intermeidate sorted list is iterated backwards (we first compare the new item with the last item and swap if they are out of order: this is repeated until new item is in order with previous item)\\nHowever, in the solution article and some other posts, the intermediate sorted list is iterated forwards.  This still produces correct output and the time complexity either way is still O(n^2).  However, I believe we should implement the strict form for two reasons:\\n* Insertion sort is particularly efficient for partially sorted array, and the benefit only exists if intermediate array is iterated backwards\\n* Iterating singly linked list forwards is straightforward, but it\\'s challenging to iterate it backwards.  I figured this is what makes this problem challenging (and thus interesting)\\n\\nThe way I approach this is to keep intermediate sorted list in *descending* order to work around single linkage.  After we have a descending array, we simply need to revert the linkage of the list by iterating the array one more time.  For partially sorted array (list), this ensures a O(n) time complexity.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # the intermidiate sorted list is in descending order so that strict insertion sort is possible\\n        # lastly, reverse the sorted list\\n        sentinel = ListNode(0, head)\\n        node = head.next\\n        head.next = None\\n        while node:\\n            next_node = node.next\\n            \\n            prior = sentinel\\n            while prior.next and prior.next.val > node.val:\\n                prior = prior.next\\n            node.next = prior.next\\n            prior.next = node\\n            \\n            node = next_node\\n        \\n        node = sentinel.next  # node to be modified\\n        head = None  # track the head of reversed list\\n        while node:\\n            next_node = node.next\\n            \\n            node.next = head\\n            head = node\\n            \\n            node = next_node\\n            \\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # the intermidiate sorted list is in descending order so that strict insertion sort is possible\\n        # lastly, reverse the sorted list\\n        sentinel = ListNode(0, head)\\n        node = head.next\\n        head.next = None\\n        while node:\\n            next_node = node.next\\n            \\n            prior = sentinel\\n            while prior.next and prior.next.val > node.val:\\n                prior = prior.next\\n            node.next = prior.next\\n            prior.next = node\\n            \\n            node = next_node\\n        \\n        node = sentinel.next  # node to be modified\\n        head = None  # track the head of reversed list\\n        while node:\\n            next_node = node.next\\n            \\n            node.next = head\\n            head = node\\n            \\n            node = next_node\\n            \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46421,
                "title": "my-c-solution-by-using-pointer-s-pointer-to-do-insertion",
                "content": "Short and easy way to manipulate the list.\\n \\n\\n    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            ListNode **node = &head;\\n            while ((*node)) {\\n                bool flag = false;\\n                for (ListNode **cmp=&head; *cmp!=*node; cmp=&(*cmp)->next) {\\n                    if ((*node)->val <= (*cmp)->val) {\\n                        //Do insertion\\n                        ListNode *tmp = *node;\\n                        *node = (*node)->next;\\n                        tmp->next = *cmp;\\n                        *cmp = tmp;\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                //Node has been moved to the next already.\\n                if (flag) continue;\\n                node = &(*node)->next;\\n            }\\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            ListNode **node = &head;\\n            while ((*node)) {\\n                bool flag = false;\\n                for (ListNode **cmp=&head; *cmp!=*node; cmp=&(*cmp)->next) {\\n                    if ((*node)->val <= (*cmp)->val) {\\n                        //Do insertion\\n                        ListNode *tmp = *node;\\n                        *node = (*node)->next;\\n                        tmp->next = *cmp;\\n                        *cmp = tmp;\\n                        flag = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1629375,
                "title": "python3-insertion-sort-explained",
                "content": "The idea is to create a dummy node that would be the head of the sorted part of the list. Iterate over the given list and one by one add nodes to the sorted list at the appropriate place following the insertion sort algorithm.\\n\\nTime: **O(n^2)**\\nSpace: **O(1)**\\n\\nRuntime: 1677 ms, faster than **51.65%** of Python3 online submissions for Insertion Sort List.\\nMemory Usage: 16.4 MB, less than **29.01%** of Python3 online submissions for Insertion Sort List.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sort = ListNode() #dummy node\\n\\n        cur = head\\n        while cur:\\n            sortCur = sort\\n            while sortCur.next and cur.val >= sortCur.next.val:\\n                sortCur = sortCur.next\\n                \\n            tmp, sortCur.next = sortCur.next, cur\\n            cur = cur.next\\n            sortCur.next.next = tmp\\n            \\n        return sort.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sort = ListNode() #dummy node\\n\\n        cur = head\\n        while cur:\\n            sortCur = sort\\n            while sortCur.next and cur.val >= sortCur.next.val:\\n                sortCur = sortCur.next\\n                \\n            tmp, sortCur.next = sortCur.next, cur\\n            cur = cur.next\\n            sortCur.next.next = tmp\\n            \\n        return sort.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067224,
                "title": "simple-solution-with-step-by-step-explaination",
                "content": "In this question, we have to perform insertion sorting on a linked list.\\nTherefore, to first understand this, we first need to know about Insertion sort.\\nIn Insertion Sort, the array (linked list in this case) is divided into two parts, the unsorted and sorted parts.\\n\\nElements from unsorted part are picked and placed at their correct sorted position.\\n\\nIn this, we will be using three pointers *prev*, *curr* and *tmp* for storing previous values, current values and for storing head of the linked list.\\n\\nAt first, we have to check for edge cases, that is, whether the list is empty or has only one element. In both of these cases, we have to just simply return the head as no computation is required.\\n\\nAfter checking for the above mentioned cases, we have to perform sorting.\\nFor every element, we have to check whether the element is at its correct position or not.\\n\\nIf the current value is less than the previous value, then we have to swap them, and furthermore, we have to now check the previously sorted part of the list as well including the currently sorted element.\\n\\nFor example consider the list:\\n**[1,2,4,5,3]**\\nIn this, [1,2,4,5] is sorted part but [3] is not.\\nhere, **prev points to 5 and curr points to 3**\\nsince, 3 is less than 5, we will swap these.\\nAfter swapping:\\n**[1,2,4,3,5]**\\nNow, we can see that 3 is not at its correct position, so we have to check in the Sorted part as well i.e. **[1,2,4]**\\nHere, we will use **tmp** pointer to iterate linked list from the head till that element, and compare that element (here, 3) with all the elements, and position it accordingly.\\n\\nOnce, we complete the comparing and swapping for all the remaining elements, our resultant list is sorted, which we return.\\n\\nHere\\'s the complete **code** for your reference:\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* prev = nullptr, *curr=head, *tmp=head;\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        else{\\n            prev = head;\\n            curr = head->next;\\n            while(curr!=nullptr){\\n                if(prev->val > curr->val){\\n                    swap(prev->val, curr->val);\\n                    tmp = head;\\n                    while(tmp!=prev){\\n                        if(tmp->val > prev->val){\\n                            swap(tmp->val, prev->val);\\n                        }\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                prev=prev->next;\\n                curr=curr->next;\\n            }\\n            return head;\\n        }\\n    }\\n};\\n```\\n\\n***PS: Do give it an upvote if this helped.\\nIn case of any queries or suggestions feel free to comment below.\\nThanks!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* prev = nullptr, *curr=head, *tmp=head;\\n        if(head==nullptr || head->next==nullptr)\\n            return head;\\n        else{\\n            prev = head;\\n            curr = head->next;\\n            while(curr!=nullptr){\\n                if(prev->val > curr->val){\\n                    swap(prev->val, curr->val);\\n                    tmp = head;\\n                    while(tmp!=prev){\\n                        if(tmp->val > prev->val){\\n                            swap(tmp->val, prev->val);\\n                        }\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                prev=prev->next;\\n                curr=curr->next;\\n            }\\n            return head;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921525,
                "title": "python-clean-concise-time-o-n-2-space-o-1",
                "content": "```python\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummyHead= ListNode(0)\\n        \\n        def insert(head):\\n            prev = dummyHead\\n            curr = dummyHead.next\\n            while curr and curr.val <= head.val:\\n                prev = curr\\n                curr = curr.next\\n                \\n            prev.next = head\\n            head.next = curr\\n        \\n        while head != None:\\n            next = head.next\\n            insert(head)\\n            head = next\\n            \\n        return dummyHead.next\\n```\\n**Complexity:**\\n- Time: `O(N^2)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummyHead= ListNode(0)\\n        \\n        def insert(head):\\n            prev = dummyHead\\n            curr = dummyHead.next\\n            while curr and curr.val <= head.val:\\n                prev = curr\\n                curr = curr.next\\n                \\n            prev.next = head\\n            head.next = curr\\n        \\n        while head != None:\\n            next = head.next\\n            insert(head)\\n            head = next\\n            \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920374,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(head == nullptr ){\\n            return nullptr ;\\n        }\\n       vector<ListNode*>nodes;\\n        nodes.push_back(head);\\n        ListNode*temp = head->next ;\\n        while(temp != nullptr ){\\n            nodes.push_back(temp);\\n            for(int i = nodes.size()-1 ; i > 0 ; i -- ){\\n                if( nodes[i]->val < nodes[i-1]->val ){\\n                     swap(nodes[i-1]->val , nodes[i]->val);    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            temp = temp->next;\\n        }\\n       return head ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(head == nullptr ){\\n            return nullptr ;\\n        }\\n       vector<ListNode*>nodes;\\n        nodes.push_back(head);\\n        ListNode*temp = head->next ;\\n        while(temp != nullptr ){\\n            nodes.push_back(temp);\\n            for(int i = nodes.size()-1 ; i > 0 ; i -- ){\\n                if( nodes[i]->val < nodes[i-1]->val ){\\n                     swap(nodes[i-1]->val , nodes[i]->val);    \\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            temp = temp->next;\\n        }\\n       return head ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 46550,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explaination",
                "content": "This problem is all about details, you just need to check what to do when insert the cur-pointer to the linked-list.\\n\\nYou need to consider 2 cases carefully. I believe it is all about details.\\n\\n    class  Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(-1);\\n            dummy->next=head;\\n            ListNode *cur=head->next, *prev=head;\\n            while(cur){\\n                //record the next pointer \\n                ListNode* nextPtr=cur->next;\\n                //find the inserted position from the dummy start position\\n                ListNode *prePtr=dummy;\\n                ListNode *curPtr=dummy->next;\\n                while(curPtr!=cur && curPtr->val <= cur->val){\\n                    prePtr=prePtr->next;\\n                    curPtr=curPtr->next;\\n                }\\n                /* check the current position  */\\n                /* case 1 : we need to insert it  */\\n                if( curPtr!= cur ){\\n                     prePtr->next = cur;\\n                     cur->next = curPtr;\\n                     prev->next = nextPtr;\\n                     cur=nextPtr;\\n                }\\n                /* case 2 : we do not need to insert it */\\n                else{\\n                    prev=cur;\\n                    cur=cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "This problem is all about details, you just need to check what to do when insert the cur-pointer to the linked-list.\\n\\nYou need to consider 2 cases carefully. I believe it is all about details.\\n\\n    class  Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(-1);\\n            dummy->next=head;\\n            ListNode *cur=head->next, *prev=head;\\n            while(cur){\\n                //record the next pointer \\n                ListNode* nextPtr=cur->next;\\n                //find the inserted position from the dummy start position\\n                ListNode *prePtr=dummy;\\n                ListNode *curPtr=dummy->next;\\n                while(curPtr!=cur && curPtr->val <= cur->val){\\n                    prePtr=prePtr->next;\\n                    curPtr=curPtr->next;\\n                }\\n                /* check the current position  */\\n                /* case 1 : we need to insert it  */\\n                if( curPtr!= cur ){\\n                     prePtr->next = cur;\\n                     cur->next = curPtr;\\n                     prev->next = nextPtr;\\n                     cur=nextPtr;\\n                }\\n                /* case 2 : we do not need to insert it */\\n                else{\\n                    prev=cur;\\n                    cur=cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 46667,
                "title": "one-way-to-accept-in-python-against-tle",
                "content": "My original code is very intuitive. I checked each unsorted element one by one and added it into sorted part. The way I added it is that I check from the head to tailer of the sorted part. Here is my original code in python and off-line test for 2000 data costs 2.3s while the result is TLE for on-line test.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n     \\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThen I change the way to find the insertion spot like this:\\nThe off-line test costs 1.7s and it accepted for on-line test\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n\\n        innerPointer = linkHead.next  #declare innerPointer here\\n\\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            # reset innerPointer only when pointer is needed to be inserted before innerPointer\\n            if innerPointer.val > pointer.val:\\n                innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThere are some other method to improve performance, e.g. section the linkList and store the value of each segment's front elem, then the process of finding the insertion spot will be more efficient",
                "solutionTags": [
                    "Python"
                ],
                "code": "My original code is very intuitive. I checked each unsorted element one by one and added it into sorted part. The way I added it is that I check from the head to tailer of the sorted part. Here is my original code in python and off-line test for 2000 data costs 2.3s while the result is TLE for on-line test.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n     \\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThen I change the way to find the insertion spot like this:\\nThe off-line test costs 1.7s and it accepted for on-line test\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertionSortList(self, head):\\n        linkHead = ListNode(0)\\n        linkHead.next = head\\n        sortedEnd = linkHead.next\\n\\n        if sortedEnd == None:\\n            return head\\n\\n        innerPointer = linkHead.next  #declare innerPointer here\\n\\n        while sortedEnd.next != None:\\n            pointer = sortedEnd.next\\n            sortedEnd.next = pointer.next\\n\\n            # reset innerPointer only when pointer is needed to be inserted before innerPointer\\n            if innerPointer.val > pointer.val:\\n                innerPointer = linkHead\\n\\n            while innerPointer != sortedEnd and innerPointer.next.val < pointer.val:\\n                innerPointer = innerPointer.next\\n                \\n            pointer.next = innerPointer.next\\n            innerPointer.next = pointer\\n\\n            if innerPointer == sortedEnd:\\n                sortedEnd = pointer\\n                \\n        return linkHead.next\\n\\nThere are some other method to improve performance, e.g. section the linkList and store the value of each segment's front elem, then the process of finding the insertion spot will be more efficient",
                "codeTag": "Java"
            },
            {
                "id": 3755361,
                "title": "using-bubble-sort-in-c",
                "content": "# Intuition\\njust use the bubble sort.the only difference is u need to reset the pointer to point head after the completation of second loop and in second loop u need to swap two values if one val is greater than another.then update temp pointer to its next\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n void swap(struct ListNode *p1,struct ListNode *p2)\\n {\\n     int t=p1->val;\\n     p1->val=p2->val;\\n     p2->val=t;\\n }\\n int len(struct ListNode *head)\\n {\\n     struct ListNode *p=head;\\n     int l=0;\\n     while(p!=NULL)\\n     {\\n         l++;\\n         p=p->next;\\n     }\\n     return l;\\n }\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode *p=head;\\n    int i,j;\\n    int l=len(head);\\n    for(i=0;i<l;i++)\\n    {\\n        for(j=0;j<l-i-1;j++)\\n        {\\n            if(p->val>p->next->val)\\n            {\\n                swap(p,p->next);\\n            }\\n            p=p->next;\\n        }\\n        p=head;\\n    }\\n    return head;\\n\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n void swap(struct ListNode *p1,struct ListNode *p2)\\n {\\n     int t=p1->val;\\n     p1->val=p2->val;\\n     p2->val=t;\\n }\\n int len(struct ListNode *head)\\n {\\n     struct ListNode *p=head;\\n     int l=0;\\n     while(p!=NULL)\\n     {\\n         l++;\\n         p=p->next;\\n     }\\n     return l;\\n }\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode *p=head;\\n    int i,j;\\n    int l=len(head);\\n    for(i=0;i<l;i++)\\n    {\\n        for(j=0;j<l-i-1;j++)\\n        {\\n            if(p->val>p->next->val)\\n            {\\n                swap(p,p->next);\\n            }\\n            p=p->next;\\n        }\\n        p=head;\\n    }\\n    return head;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893357,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let output = head\\n  let curr = head.next\\n\\n  head.next = null\\n\\n  while (curr) {\\n    const next = curr.next\\n    const insertion = curr\\n\\n    output = insert(output, insertion)\\n    curr = next as ListNode\\n  }\\n\\n  return output\\n}\\n\\nfunction insert(head: ListNode, other: ListNode) {\\n  let curr = head\\n  const val = other.val\\n\\n  if (val <= head.val) {\\n    other.next = head\\n    return other\\n  }\\n\\n  while (curr) {\\n    if ((val > curr.val && curr.next && val <= curr.next.val) || !curr.next) {\\n      other.next = curr.next\\n      curr.next = other\\n\\n      return head\\n    }\\n\\n    curr = curr.next as ListNode\\n  }\\n\\n  return head\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n  if (!head) return null\\n  if (!head.next) return head\\n\\n  let output = head\\n  let curr = head.next\\n\\n  head.next = null\\n\\n  while (curr) {\\n    const next = curr.next\\n    const insertion = curr\\n\\n    output = insert(output, insertion)\\n    curr = next as ListNode\\n  }\\n\\n  return output\\n}\\n\\nfunction insert(head: ListNode, other: ListNode) {\\n  let curr = head\\n  const val = other.val\\n\\n  if (val <= head.val) {\\n    other.next = head\\n    return other\\n  }\\n\\n  while (curr) {\\n    if ((val > curr.val && curr.next && val <= curr.next.val) || !curr.next) {\\n      other.next = curr.next\\n      curr.next = other\\n\\n      return head\\n    }\\n\\n    curr = curr.next as ListNode\\n  }\\n\\n  return head\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630563,
                "title": "c-in-place-insertion-sort",
                "content": "I sorted the given list in-place since the problem didn\\'t specify producing a new list.\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        /* Base case */\\n        if (head == nullptr) return nullptr; \\n        \\n        /* Perform in-place insertion sort. */\\n        /* Time - O(n^2); Space - O(1) */\\n        int temp = 0;\\n        for (ListNode* node = head; node != nullptr; node = node->next) {            \\n            for (ListNode* comp = head; comp != node; comp = comp->next) {\\n                /* If the current value is less than a previous value, */\\n                /* then swap the values. */\\n                if (node->val < comp->val) {\\n                    temp = node->val;\\n                    node->val = comp->val;\\n                    comp->val = temp;\\n                }\\n            }\\n        }\\n\\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "I sorted the given list in-place since the problem didn\\'t specify producing a new list.\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        /* Base case */\\n        if (head == nullptr) return nullptr; \\n        \\n        /* Perform in-place insertion sort. */\\n        /* Time - O(n^2); Space - O(1) */\\n        int temp = 0;\\n        for (ListNode* node = head; node != nullptr; node = node->next) {            \\n            for (ListNode* comp = head; comp != node; comp = comp->next) {\\n                /* If the current value is less than a previous value, */\\n                /* then swap the values. */\\n                if (node->val < comp->val) {\\n                    temp = node->val;\\n                    node->val = comp->val;\\n                    comp->val = temp;\\n                }\\n            }\\n        }\\n\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1629805,
                "title": "insertion-sort-list-100",
                "content": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :**\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 920840,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=-0w2uswTST8)\\nhttps://www.youtube.com/watch?v=-0w2uswTST8\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode()\\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = dummy_head.next\\n            \\n            while next_pointer:\\n                if curr.val < next_pointer.val:\\n                    break\\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n            \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n        \\n        return dummy_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode()\\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = dummy_head.next\\n            \\n            while next_pointer:\\n                if curr.val < next_pointer.val:\\n                    break\\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n            \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n        \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328375,
                "title": "a-short-and-clear-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode *res = new ListNode(0);\\n        while(head) {\\n            ListNode* p = res->next;\\n            ListNode* pre = res;\\n            while(p && head->val > p->val) {\\n                pre = p;\\n                p = p->next;\\n            }\\n            pre->next = new ListNode(head->val);\\n            pre = pre->next;\\n            pre->next = p;\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode *res = new ListNode(0);\\n        while(head) {\\n            ListNode* p = res->next;\\n            ListNode* pre = res;\\n            while(p && head->val > p->val) {\\n                pre = p;\\n                p = p->next;\\n            }\\n            pre->next = new ListNode(head->val);\\n            pre = pre->next;\\n            pre->next = p;\\n            head = head->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150468,
                "title": "short-simple-and-fast-c-solution-no-need-for-a-dummy-or-similar-to-handle-the-new-head-creation",
                "content": "A lot of solutions allocate a dummy node with the intensions of using the dummy.next to point to the head of the new list. It\\'s much simpler to instead use a pointer to a pointer that stores the address of either the pointer to the new head or the next pointer of the previous node. That way an update to whichever pointer is being pointed to (head or next), will either update the head directly or update the next of the previous node.\\n\\nIt\\'s one of those things that\\'s hard to explain with words. Saying a pointer pointing to a pointer, pointing to the head is just plane confusing. Walking through the code is the best way to understand.\\n\\n```\\n    ListNode* insertionSortList(ListNode* head) {\\n      ListNode* ret_head = nullptr;\\n      while (head) {\\n        ListNode* curr = head;\\n        head = head->next;\\n        \\n        // Use a pointer to pointer so that updating either ret_head or next of the previous node is\\n        // seemless and automatic.\\n        ListNode** prev_next = &ret_head;\\n        while (*prev_next && (*prev_next)->val < curr->val) {\\n          // Update prev_next to hold the address of the next pointer for the next node.\\n          prev_next = &(*prev_next)->next;\\n        }\\n        curr->next = *prev_next;\\n        *prev_next = curr;\\n      }\\n      return ret_head;\\n    }\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\n    ListNode* insertionSortList(ListNode* head) {\\n      ListNode* ret_head = nullptr;\\n      while (head) {\\n        ListNode* curr = head;\\n        head = head->next;\\n        \\n        // Use a pointer to pointer so that updating either ret_head or next of the previous node is\\n        // seemless and automatic.\\n        ListNode** prev_next = &ret_head;\\n        while (*prev_next && (*prev_next)->val < curr->val) {\\n          // Update prev_next to hold the address of the next pointer for the next node.\\n          prev_next = &(*prev_next)->next;\\n        }\\n        curr->next = *prev_next;\\n        *prev_next = curr;\\n      }\\n      return ret_head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46626,
                "title": "10-line-clean-and-easy-to-understand-c-solution",
                "content": "Please see [my blog post][1] for more.\\n\\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode dummy(INT_MIN);\\n        ListNode *prev, *cur, *next;\\n        \\n        for (auto p = head; p; p = next) {\\n            next = p->next;\\n            // invariant: list headed by dummy.next is sorted\\n            for (prev = &dummy, cur = prev->next; cur && p->val > cur->val; prev = cur, cur = cur->next)\\n                ;\\n            prev->next = p;\\n            p->next = cur;\\n        }\\n        \\n        return dummy.next;\\n    }\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2015/02/insertion-sort-list.html",
                "solutionTags": [
                    "Linked List",
                    "Sorting"
                ],
                "code": "Please see [my blog post][1] for more.\\n\\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode dummy(INT_MIN);\\n        ListNode *prev, *cur, *next;\\n        \\n        for (auto p = head; p; p = next) {\\n            next = p->next;\\n            // invariant: list headed by dummy.next is sorted\\n            for (prev = &dummy, cur = prev->next; cur && p->val > cur->val; prev = cur, cur = cur->next)\\n                ;\\n            prev->next = p;\\n            p->next = cur;\\n        }\\n        \\n        return dummy.next;\\n    }\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2015/02/insertion-sort-list.html",
                "codeTag": "Unknown"
            },
            {
                "id": 46449,
                "title": "maybe-the-best-java-solution-with-code-comments",
                "content": "    public class Solution {\\n    \\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null || head.next == null){\\n                return head;\\n            }\\n            //record node before insertNode\\n            ListNode preNode = head;\\n            //rocord node need to be inserted\\n            ListNode insertNode = head.next;\\n            \\n            while(insertNode != null){\\n                //store next insert node\\n                ListNode nextInsert = insertNode.next;\\n                //insert before head\\n                if(insertNode.val <= head.val){\\n                    preNode.next = insertNode.next;\\n                    insertNode.next = head;\\n                    head = insertNode;\\n                }\\n                else if(insertNode.val >= preNode.val){    //insert after tail\\n                    preNode = preNode.next;\\n                }\\n                else{                                      //insert between head and tail\\n                    ListNode compareNode = head;\\n                    //start from the node after head, find insert position\\n                    while(compareNode.next.val < insertNode.val)   compareNode = compareNode.next;\\n                    //insert\\n                    preNode.next = insertNode.next;\\n                    insertNode.next = compareNode.next;\\n                    compareNode.next = insertNode;\\n                }\\n                //get next insert node\\n                insertNode = nextInsert;\\n            }\\n            return head;\\n        }\\n    }\\n\\nHope it will helpful. The thinking is  very straightforward:\\n\\n 1. Insert before head.\\n 2. Insert after tail.(no need change the list).\\n 3. Insert between head and tail.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null || head.next == null){\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3260243,
                "title": "easy-to-understand-code-of-insertion-sort-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n              ListNode d = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = d;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n              ListNode d = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = d;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109086,
                "title": "simple-solution-o-n-2-time-o-1-space",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // idea is we maintain a prev list & for each node we check in prev list until all elements are smaller then insert the node between the smaller & greater elements.\\n        if(!head || !head->next)return head;\\n        ListNode* dummy=new ListNode(INT_MIN);\\n        ListNode* tail=dummy;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode * next=curr->next;\\n            while(tail->next && tail->next->val<curr->val){\\n                tail=tail->next;\\n            }\\n            curr->next=tail->next;\\n            tail->next=curr;\\n            tail=dummy;\\n            curr=next;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // idea is we maintain a prev list & for each node we check in prev list until all elements are smaller then insert the node between the smaller & greater elements.\\n        if(!head || !head->next)return head;\\n        ListNode* dummy=new ListNode(INT_MIN);\\n        ListNode* tail=dummy;\\n        ListNode* curr=head;\\n        while(curr){\\n            ListNode * next=curr->next;\\n            while(tail->next && tail->next->val<curr->val){\\n                tail=tail->next;\\n            }\\n            curr->next=tail->next;\\n            tail->next=curr;\\n            tail=dummy;\\n            curr=next;\\n        }\\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503079,
                "title": "simple-c-clean-solution",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *nxt = head -> next;\\n        while(nxt != NULL)\\n        {\\n            ListNode *curr = head;\\n            while(curr != nxt)\\n            {\\n                if(nxt -> val < curr -> val)\\n                    swap(curr -> val, nxt -> val);\\n                \\n                curr = curr -> next;\\n            }\\n            nxt = nxt -> next;   \\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *nxt = head -> next;\\n        while(nxt != NULL)\\n        {\\n            ListNode *curr = head;\\n            while(curr != nxt)\\n            {\\n                if(nxt -> val < curr -> val)\\n                    swap(curr -> val, nxt -> val);\\n                \\n                curr = curr -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1630522,
                "title": "clearest-go-solution",
                "content": "[Github link](https://github.com/evleria/leetcode-in-go/blob/main/problems/0147-insertion-sort-list/insertion_sort_list.go)\\n\\n```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n\\tdummy := new(ListNode)\\n\\tfor head != nil {\\n\\t\\tcur := dummy\\n\\t\\tfor ; cur.Next != nil && cur.Next.Val < head.Val; cur = cur.Next {\\n\\t\\t}\\n\\t\\tcur.Next, head.Next, head = head, cur.Next, head.Next\\n\\t}\\n\\treturn dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n\\tdummy := new(ListNode)\\n\\tfor head != nil {\\n\\t\\tcur := dummy\\n\\t\\tfor ; cur.Next != nil && cur.Next.Val < head.Val; cur = cur.Next {\\n\\t\\t}\\n\\t\\tcur.Next, head.Next, head = head, cur.Next, head.Next\\n\\t}\\n\\treturn dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629625,
                "title": "2-implementation-explained",
                "content": "**Idea?**\\n* We need to sort the list using Insertion Sort.\\n* Insertion Sort works in **O(n^2) time**, each time picking up the new element and **inserting back this element** at the correct position in the sorted list found till now.\\n\\n**Implementation 1:-(Not Efficient)**\\n* Each time when we pick up the new element, we need to **traverse in a backward manner** in the sorted list to insert this element at the correct position right?\\n* How do we traverse in a backward manner?\\n* We will be **reversing the sorted list up to the current node**.\\n* Then, we\\'ll insert this new value at the correct position.\\n* Again **restore the original list by reversing again**.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    // reverse the List upto the given node\\n    void reverseList(ListNode* head,ListNode* upto){\\n        ListNode *prev = NULL;\\n        while(head!=upto){\\n            ListNode* temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n    }\\n    // insert the value at correct position\\n    void InsertValue(ListNode* curr){\\n        ListNode *nxt = curr->next;\\n        while(nxt!=nullptr and nxt->val>curr->val){\\n            swap(nxt->val,curr->val);\\n            nxt = nxt->next;\\n            curr = curr->next;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* temp = curr->next;\\n            reverseList(head,curr->next); // reverse the list prior to this node\\n            InsertValue(curr); // insert the value\\n            reverseList(curr,nullptr); // reverse the previous list again\\n            curr->next = temp;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n**Implementation 2:-(Efficient)**\\n* The above implementation is quite a hectic task, Can we improve it? **Can we insert a dummy node**?\\n* Okay, Let\\'s make a dummy node.\\n* Each time when we encounter a new element, we\\'ll find the correct position from the start of the sorted list(*starting from dummy node*) and find the position where this new value should be inserted.\\n* **Note:- Here we aren\\'t reversing any list here.**\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(-5005);\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* nxt = curr->next; // store next node for iteration\\n            ListNode* iter = dummy;\\n            // iterate from the beginning and find the suitable position of curr->val\\n            while(iter->next!=nullptr and iter->next->val<curr->val)\\n                iter = iter->next;\\n            curr->next = iter->next;\\n            iter->next = curr; // insert node at this position\\n            curr = nxt;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    // reverse the List upto the given node\\n    void reverseList(ListNode* head,ListNode* upto){\\n        ListNode *prev = NULL;\\n        while(head!=upto){\\n            ListNode* temp = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n    }\\n    // insert the value at correct position\\n    void InsertValue(ListNode* curr){\\n        ListNode *nxt = curr->next;\\n        while(nxt!=nullptr and nxt->val>curr->val){\\n            swap(nxt->val,curr->val);\\n            nxt = nxt->next;\\n            curr = curr->next;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* temp = curr->next;\\n            reverseList(head,curr->next); // reverse the list prior to this node\\n            InsertValue(curr); // insert the value\\n            reverseList(curr,nullptr); // reverse the previous list again\\n            curr->next = temp;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(n^2)\\n    // Space Complexity:- O(1)\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(-5005);\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            ListNode* nxt = curr->next; // store next node for iteration\\n            ListNode* iter = dummy;\\n            // iterate from the beginning and find the suitable position of curr->val\\n            while(iter->next!=nullptr and iter->next->val<curr->val)\\n                iter = iter->next;\\n            curr->next = iter->next;\\n            iter->next = curr; // insert node at this position\\n            curr = nxt;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995877,
                "title": "java-two-solutions-pointer-change-and-value-change",
                "content": "**Pointer change**\\n```\\nclass Solution {\\n     public ListNode insertionSortList(ListNode head) {\\n         ListNode dummy = new ListNode(0);\\n         ListNode curr = head;\\n       \\n         while (curr != null){\\n             ListNode prev = dummy;\\n            \\n             while (prev.next != null && prev.next.val < curr.val)\\n                 prev = prev.next;\\n            \\n             ListNode next = curr.next;\\n             curr.next = prev.next;\\n             prev.next = curr;\\n             curr = next;\\n         }\\n        \\n         return dummy.next;\\n     }\\n}\\n```\\n**Value change**\\n```\\n    class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        while(cur != null) {            \\n            ListNode start = head;\\n\\t\\t\\t\\n\\t\\t\\t// move to the position in the sorted part\\n            while(start.val <  cur.val && start != cur)\\n                start = start.next;\\n            \\n            while(start != cur.next) {\\n                //swap value with current element\\n                int tmp = start.val;\\n                start.val = cur.val;\\n                cur.val = tmp;\\n                \\n                start = start.next;\\n            }            \\n            cur = cur.next;            \\n        }        \\n        return head;        \\n   }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public ListNode insertionSortList(ListNode head) {\\n         ListNode dummy = new ListNode(0);\\n         ListNode curr = head;\\n       \\n         while (curr != null){\\n             ListNode prev = dummy;\\n            \\n             while (prev.next != null && prev.next.val < curr.val)\\n                 prev = prev.next;\\n            \\n             ListNode next = curr.next;\\n             curr.next = prev.next;\\n             prev.next = curr;\\n             curr = next;\\n         }\\n        \\n         return dummy.next;\\n     }\\n}\\n```\n```\\n    class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        while(cur != null) {            \\n            ListNode start = head;\\n\\t\\t\\t\\n\\t\\t\\t// move to the position in the sorted part\\n            while(start.val <  cur.val && start != cur)\\n                start = start.next;\\n            \\n            while(start != cur.next) {\\n                //swap value with current element\\n                int tmp = start.val;\\n                start.val = cur.val;\\n                cur.val = tmp;\\n                \\n                start = start.next;\\n            }            \\n            cur = cur.next;            \\n        }        \\n        return head;        \\n   }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801347,
                "title": "python3-java-4-pointers-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # if head is empty or only have 1 element, return head\\n        if not head: return None\\n        if not head.next: return head\\n        \\n        # Need four pointers and we are going to sort right at the same place\\n        # define dummy to hold the begining of the sorted list,\\n        # define temp to hold a value if order need to be changed\\n        # define current to loop over the list to be sorted\\n        # define runner to loop over the sorted linklist from dummy ->-> current\\n        \\n        dummy = ListNode(None,head)\\n        current = head\\n        \\n        while current.next is not None:\\n            # if in-order, move to the next number\\n            if current.next.val >= current.val:\\n                current = current.next\\n                \\n            # if current.next.val < current.val, list is not in-order, \\n            # we need to remove the current number from the origional linklist, \\n            # then do insertion from dummy.next     \\n            else: \\n                temp = current.next\\n                runner = dummy\\n                current.next = current.next.next\\n                \\n                # insert the value in the sorted linklist\\n                while runner.next.val <= temp.val:\\n                    runner = runner.next\\n                runner.next, temp.next = temp, runner.next\\n                \\n        return dummy.next   \\n                \\n        \\n        \\n        \\n        \\n```\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        // if head.size is samller than 2, we can just return head\\n        if(head==null || head.next ==null) return head;\\n        \\n         // use current to go thourgh the linklist\\n\\t\\t // use temp to store the not-in-order element\\n\\t\\t // use runner to loop over the sorted linklist\\n\\t\\t \\n        ListNode dummy = new ListNode(-1,head);\\n        ListNode current = head;\\n        ListNode temp = null;\\n        ListNode runner = null;\\n        \\n        while (current.next!=null){\\n            // if current.next bigger than current, we do not need to change the order\\n            if (current.next.val >= current.val){\\n                current = current.next;\\n            }else{\\n                runner = dummy;\\n                temp =   current.next; // save the not in-order element to temp\\n                current.next = current.next.next;//remove the not in-order element from the list\\n                \\n                // use runner, looping from dummy, to find where to insert temp\\n                while (runner.next.val <= temp.val){\\n                    runner = runner.next;\\n                }\\n                // find the place to insert, re-build the sorted link-list    \\n                    temp.next = runner.next;\\n                    runner.next = temp;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        # if head is empty or only have 1 element, return head\\n        if not head: return None\\n        if not head.next: return head\\n        \\n        # Need four pointers and we are going to sort right at the same place\\n        # define dummy to hold the begining of the sorted list,\\n        # define temp to hold a value if order need to be changed\\n        # define current to loop over the list to be sorted\\n        # define runner to loop over the sorted linklist from dummy ->-> current\\n        \\n        dummy = ListNode(None,head)\\n        current = head\\n        \\n        while current.next is not None:\\n            # if in-order, move to the next number\\n            if current.next.val >= current.val:\\n                current = current.next\\n                \\n            # if current.next.val < current.val, list is not in-order, \\n            # we need to remove the current number from the origional linklist, \\n            # then do insertion from dummy.next     \\n            else: \\n                temp = current.next\\n                runner = dummy\\n                current.next = current.next.next\\n                \\n                # insert the value in the sorted linklist\\n                while runner.next.val <= temp.val:\\n                    runner = runner.next\\n                runner.next, temp.next = temp, runner.next\\n                \\n        return dummy.next   \\n                \\n        \\n        \\n        \\n        \\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        // if head.size is samller than 2, we can just return head\\n        if(head==null || head.next ==null) return head;\\n        \\n         // use current to go thourgh the linklist\\n\\t\\t // use temp to store the not-in-order element\\n\\t\\t // use runner to loop over the sorted linklist\\n\\t\\t \\n        ListNode dummy = new ListNode(-1,head);\\n        ListNode current = head;\\n        ListNode temp = null;\\n        ListNode runner = null;\\n        \\n        while (current.next!=null){\\n            // if current.next bigger than current, we do not need to change the order\\n            if (current.next.val >= current.val){\\n                current = current.next;\\n            }else{\\n                runner = dummy;\\n                temp =   current.next; // save the not in-order element to temp\\n                current.next = current.next.next;//remove the not in-order element from the list\\n                \\n                // use runner, looping from dummy, to find where to insert temp\\n                while (runner.next.val <= temp.val){\\n                    runner = runner.next;\\n                }\\n                // find the place to insert, re-build the sorted link-list    \\n                    temp.next = runner.next;\\n                    runner.next = temp;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452139,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn insertion_sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut new_head = ListNode::new(0);\\n        while let Some(mut boxed) = head.take() {\\n            head = boxed.next.take();\\n            let mut ptr = &mut new_head;\\n            // ptr.next should be the first element bigger than or equal to boxed.val or None.\\n            while ptr.next.as_ref().is_some() && ptr.next.as_ref().unwrap().val < boxed.val {\\n                ptr = ptr.next.as_mut().unwrap();\\n            }\\n            boxed.next = ptr.next.take();\\n            ptr.next = Some(boxed);\\n        }\\n        new_head.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn insertion_sort_list(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut new_head = ListNode::new(0);\\n        while let Some(mut boxed) = head.take() {\\n            head = boxed.next.take();\\n            let mut ptr = &mut new_head;\\n            // ptr.next should be the first element bigger than or equal to boxed.val or None.\\n            while ptr.next.as_ref().is_some() && ptr.next.as_ref().unwrap().val < boxed.val {\\n                ptr = ptr.next.as_mut().unwrap();\\n            }\\n            boxed.next = ptr.next.take();\\n            ptr.next = Some(boxed);\\n        }\\n        new_head.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328074,
                "title": "c-top-80-o-n-with-o-1-memory-slick-rick-solution-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        //We will store the solution after sentinel..\\n        ListNode *aSentinel = new ListNode(0);\\n        ListNode *aPrev = NULL;\\n        \\n        //We pluck nodes out from the original list, one at a time.\\n        ListNode *aInsert = head;\\n        ListNode *aNextInsert = NULL;\\n        \\n        //We search through the sorted partial result.\\n        ListNode *aSearch = NULL;\\n        \\n        while (aInsert) {\\n            \\n            //a begin\\n            aNextInsert = aInsert->next;\\n            \\n            //Find the spot to insert the node...\\n            \\n            aPrev = aSentinel;\\n            aSearch = aSentinel->next;\\n            while (aSearch != NULL && aSearch->val < aInsert->val) {\\n                aPrev = aSearch;\\n                aSearch = aSearch->next;\\n            }\\n            \\n            aPrev->next = aInsert;\\n            aInsert->next = aSearch;\\n            \\n            //a end\\n            aInsert = aNextInsert;\\n        }\\n        \\n        ListNode *aResult = aSentinel->next;\\n        delete aSentinel;\\n        return aResult;\\n    }\\n};\\n```\\n\\nWe keep the code short by using a sentinel node.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        //We will store the solution after sentinel..\\n        ListNode *aSentinel = new ListNode(0);\\n        ListNode *aPrev = NULL;\\n        \\n        //We pluck nodes out from the original list, one at a time.\\n        ListNode *aInsert = head;\\n        ListNode *aNextInsert = NULL;\\n        \\n        //We search through the sorted partial result.\\n        ListNode *aSearch = NULL;\\n        \\n        while (aInsert) {\\n            \\n            //a begin\\n            aNextInsert = aInsert->next;\\n            \\n            //Find the spot to insert the node...\\n            \\n            aPrev = aSentinel;\\n            aSearch = aSentinel->next;\\n            while (aSearch != NULL && aSearch->val < aInsert->val) {\\n                aPrev = aSearch;\\n                aSearch = aSearch->next;\\n            }\\n            \\n            aPrev->next = aInsert;\\n            aInsert->next = aSearch;\\n            \\n            //a end\\n            aInsert = aNextInsert;\\n        }\\n        \\n        ListNode *aResult = aSentinel->next;\\n        delete aSentinel;\\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 268646,
                "title": "3-ms-java-solution-without-recursive",
                "content": "public ListNode insertionSortList(ListNode head) {\\n        \\n\\t\\tif(head == null || head.next == null) {\\n            return head;\\n         }    \\n         ListNode newHead = new ListNode(0);\\n         newHead.next = head;\\n        \\n         while(head.next != null) {\\n             if (head.val > head.next.val) {\\n                 ListNode curr = head.next;\\n                 ListNode prev = newHead;\\n                 while(prev.next.val < curr.val) {\\n                   prev = prev.next;\\n                 }\\n                 head.next = curr.next;\\n                 curr.next = prev.next;\\n                 prev.next = curr;\\n             } \\n             else {\\n                 head = head.next;\\n             }\\n        } \\n        return newHead.next;\\n    }",
                "solutionTags": [],
                "code": "public ListNode insertionSortList(ListNode head) {\\n        \\n\\t\\tif(head == null || head.next == null) {\\n            return head;\\n         }    \\n         ListNode newHead = new ListNode(0);\\n         newHead.next = head;\\n        \\n         while(head.next != null) {\\n             if (head.val > head.next.val) {\\n                 ListNode curr = head.next;\\n                 ListNode prev = newHead;\\n                 while(prev.next.val < curr.val) {\\n                   prev = prev.next;\\n                 }\\n                 head.next = curr.next;\\n                 curr.next = prev.next;\\n                 prev.next = curr;\\n             } \\n             else {\\n                 head = head.next;\\n             }\\n        } \\n        return newHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46455,
                "title": "clear-javascript-solution",
                "content": "```\\nvar insertionSortList = function(head) {\\n    if (!head) return null;\\n    let sorted = head;\\n    head = head.next;\\n    sorted.next = null;\\n    while (head) {\\n        let prev = null;\\n        let node = sorted;\\n        while (node && head.val > node.val) {\\n            prev = node;\\n            node = node.next;\\n        }\\n        let insert = head;\\n        head = head.next;\\n        insert.next = node;\\n        if (prev) {\\n            prev.next = insert;\\n        } else {\\n            sorted = insert;\\n        }\\n    }\\n    return sorted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insertionSortList = function(head) {\\n    if (!head) return null;\\n    let sorted = head;\\n    head = head.next;\\n    sorted.next = null;\\n    while (head) {\\n        let prev = null;\\n        let node = sorted;\\n        while (node && head.val > node.val) {\\n            prev = node;\\n            node = node.next;\\n        }\\n        let insert = head;\\n        head = head.next;\\n        insert.next = node;\\n        if (prev) {\\n            prev.next = insert;\\n        } else {\\n            sorted = insert;\\n        }\\n    }\\n    return sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46491,
                "title": "simple-python-solution",
                "content": "'''\\nclass Solution(object):\\n    \\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = head\\n        while curr.next:\\n            if curr.next.val < curr.val:\\n                pre = dummy\\n                while pre.next.val < curr.next.val:\\n                    pre = pre.next\\n                tmp = curr.next\\n                curr.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n                \\n            else:\\n                curr = curr.next\\n        return dummy.next\\n'''",
                "solutionTags": [],
                "code": "'''\\nclass Solution(object):\\n    \\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = head\\n        while curr.next:\\n            if curr.next.val < curr.val:\\n                pre = dummy\\n                while pre.next.val < curr.next.val:\\n                    pre = pre.next\\n                tmp = curr.next\\n                curr.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n                \\n            else:\\n                curr = curr.next\\n        return dummy.next\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 46531,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // iteratively\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0), node = head;\\n        dummy.next = head;\\n        while (node.next != null) {\\n            if (node.val > node.next.val) {\\n                p = dummy;\\n                while (p.next != null && p.next.val < node.next.val) {\\n                    p = p.next;\\n                }\\n                ListNode nxt = node.next.next;\\n                node.next.next = p.next;\\n                p.next = node.next;\\n                node.next = nxt;\\n            } else {  // already sorted\\n                node = node.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n    \\n    // recursively\\n    public ListNode insertionSortList1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p = insertionSortList(head.next);\\n        if (head.val <= p.val) {  // already sorted\\n            head.next = p;\\n            return head;\\n        }\\n        ListNode ret = p;\\n        while (p.next != null && p.next.val < head.val) {\\n            p = p.next;\\n        }\\n        head.next = p.next;\\n        p.next = head;\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // iteratively\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0), node = head;\\n        dummy.next = head;\\n        while (node.next != null) {\\n            if (node.val > node.next.val) {\\n                p = dummy;\\n                while (p.next != null && p.next.val < node.next.val) {\\n                    p = p.next;\\n                }\\n                ListNode nxt = node.next.next;\\n                node.next.next = p.next;\\n                p.next = node.next;\\n                node.next = nxt;\\n            } else {  // already sorted\\n                node = node.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n    \\n    // recursively\\n    public ListNode insertionSortList1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p = insertionSortList(head.next);\\n        if (head.val <= p.val) {  // already sorted\\n            head.next = p;\\n            return head;\\n        }\\n        ListNode ret = p;\\n        while (p.next != null && p.next.val < head.val) {\\n            p = p.next;\\n        }\\n        head.next = p.next;\\n        p.next = head;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3301199,
                "title": "c-insertion-sort-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:`O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        // if list contains only one node\\n        if(!head->next) return head;\\n\\n        // dummy node for sorted list & pointer at dummy list\\n        ListNode* sorted = new ListNode();\\n        ListNode* ptr = sorted;   // tail\\n\\n        // create first node of sorted list using first node of head\\n        ptr->next = new ListNode(head->val);\\n        ptr = ptr->next; // update ptr(tail)\\n\\n        // updating head of input list\\n        head = head->next;\\n\\n        while(head){\\n            // if current node\\'s value is greater than last node of sorted list\\n            // need to update tail(ptr) \\n            if(head->val > ptr->val){\\n                ptr->next = new ListNode(head->val);\\n                ptr = ptr->next;\\n            }\\n            else{\\n                // otherwise insert node according to value\\n                ListNode* pre = sorted;\\n                ListNode* curr = sorted->next;\\n\\n                while(curr){\\n                    if(curr->val >= head->val){\\n                        pre->next = new ListNode(head->val);\\n                        pre->next->next = curr;\\n                        break;\\n                    }\\n                    pre = curr;\\n                    curr = curr->next;\\n                }\\n            }\\n            // move forward in input list\\n            head = head->next;\\n        }\\n        // return sorted list\\n        return sorted->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        // if list contains only one node\\n        if(!head->next) return head;\\n\\n        // dummy node for sorted list & pointer at dummy list\\n        ListNode* sorted = new ListNode();\\n        ListNode* ptr = sorted;   // tail\\n\\n        // create first node of sorted list using first node of head\\n        ptr->next = new ListNode(head->val);\\n        ptr = ptr->next; // update ptr(tail)\\n\\n        // updating head of input list\\n        head = head->next;\\n\\n        while(head){\\n            // if current node\\'s value is greater than last node of sorted list\\n            // need to update tail(ptr) \\n            if(head->val > ptr->val){\\n                ptr->next = new ListNode(head->val);\\n                ptr = ptr->next;\\n            }\\n            else{\\n                // otherwise insert node according to value\\n                ListNode* pre = sorted;\\n                ListNode* curr = sorted->next;\\n\\n                while(curr){\\n                    if(curr->val >= head->val){\\n                        pre->next = new ListNode(head->val);\\n                        pre->next->next = curr;\\n                        break;\\n                    }\\n                    pre = curr;\\n                    curr = curr->next;\\n                }\\n            }\\n            // move forward in input list\\n            head = head->next;\\n        }\\n        // return sorted list\\n        return sorted->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547909,
                "title": "c-2-approches-clear-solution",
                "content": "1st approch\\nclass Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n    ListNode *nxt = head -> next;\\n    while(nxt != NULL)\\n    {\\n        ListNode *curr = head;\\n        while(curr != nxt)\\n        {\\n            if(nxt -> val < curr -> val)\\n                swap(curr , nxt );\\n            \\n            curr = curr -> next;\\n        }\\n        nxt = nxt -> next;   \\n    }\\n    return head;\\n}\\n\\n};\\n\\n2nd approch\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy=new ListNode(-1);\\n        \\n        ListNode* curr=head;\\n        \\n        while(curr!=NULL){\\n            ListNode* temp=curr->next;\\n            ListNode* prev=dummy;\\n             ListNode* nxt=dummy->next;\\n            \\n            while(nxt!=NULL){\\n                if(nxt->val>curr->val) break;\\n                \\n                prev=nxt;\\n                nxt=nxt->next;\\n            }\\n            curr->next=nxt;\\n            prev->next=curr;\\n            curr=temp;\\n        }\\n        return dummy->next;\\n        \\n        \\n    }\\n};\\n\\ntime complexity for this will be - o(n).",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* insertionSortList(ListNode* head) {\\n    ListNode *nxt = head -> next;\\n    while(nxt != NULL)\\n    {\\n        ListNode *curr = head;\\n        while(curr != nxt)\\n        {\\n            if(nxt -> val < curr -> val)\\n                swap(curr , nxt );\\n            \\n            curr = curr -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2206116,
                "title": "insertion-sort-list-java-easy-and-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-10000);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            if(curr.val>=prev.val){\\n                prev=curr;\\n                curr=curr.next;\\n            }else{\\n                ListNode temp=dummy;\\n                while(temp.next.val<curr.val){\\n                    temp=temp.next;\\n                }\\n                \\n                prev.next=curr.next;\\n                curr.next=temp.next;\\n                temp.next=curr;\\n                curr=prev.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-10000);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            if(curr.val>=prev.val){\\n                prev=curr;\\n                curr=curr.next;\\n            }else{\\n                ListNode temp=dummy;\\n                while(temp.next.val<curr.val){\\n                    temp=temp.next;\\n                }\\n                \\n                prev.next=curr.next;\\n                curr.next=temp.next;\\n                temp.next=curr;\\n                curr=prev.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170363,
                "title": "easy-c-solution-5-lines",
                "content": "# **I hope this solution helps you*\\n\\n***Mostly in tech interviews interviewer may ask us not to use in-built functions. At that time this code might not be handy***\\n```**\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp = head;  //create a temp list\\n        while(temp->next != NULL){\\n            ListNode* a = temp->next;  //assign next value of the temp list\\n           while(a){\\n            if(temp->val > a->val){  //compare the values\\n                swap(a->val, temp->val);   //swap if condition fails\\n            }\\n            a = a->next;\\n        }\\n        temp = temp->next;\\n       } \\n        return head;\\n    }\\n};\\n```\\n\\n**Upvote if useful. Happy Coding :)**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```**\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp = head;  //create a temp list\\n        while(temp->next != NULL){\\n            ListNode* a = temp->next;  //assign next value of the temp list\\n           while(a){\\n            if(temp->val > a->val){  //compare the values\\n                swap(a->val, temp->val);   //swap if condition fails\\n            }\\n            a = a->next;\\n        }\\n        temp = temp->next;\\n       } \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657797,
                "title": "java-code",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode curr = head, prev = start;\\n        while(curr != null){\\n            if(curr.next != null &&(curr.next.val < curr.val)){\\n                // Insertion\\n                while(prev.next != null && (prev.next.val < curr.next.val))\\n                    prev = prev.next;\\n                ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = start;\\n            } else \\n                curr = curr.next;\\n        }\\n        return start.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode curr = head, prev = start;\\n        while(curr != null){\\n            if(curr.next != null &&(curr.next.val < curr.val)){\\n                // Insertion\\n                while(prev.next != null && (prev.next.val < curr.next.val))\\n                    prev = prev.next;\\n                ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = start;\\n            } else \\n                curr = curr.next;\\n        }\\n        return start.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621233,
                "title": "c-c-compatible-indirect-pointer-solution-with-o-1-space-0ms-100",
                "content": "Using an indirect pointer to the run (where we tried to maintain the sorted partition up to) and perform sorted insert between `head` and `*run`.\\n\\nDetailed Explanation at each step:\\n```\\n// Case 1: we still have a sorted list up to `*run`: if (*run)->val >= max\\n| <= x |  x  |      ...      |\\n|<- sorted ->|<- unsorted  ->|\\n          ^max == *run\\n// so, we can just advance the run to it\\'s pointee\\'s `next`\\n------------------------------------------------------------\\n// Case 2: we have to move`*run` in front to maintain the non-descreasing sequence: if (*run)->val < max\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n ^head ... ^max ^(*run)\\n\\n// Now, just perform a sorted insert of `*run`, between `head` and `max`\\n// we can declare an indirect pointer `indirect` initialized to address of `head`, and\\n// iterate until it points to a node such that node->val >= x (i.e. (*run)->val)\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n       ^(*indirect) (the first node of the >= x partition)\\n\\n// finally we can remove the pointee of `run` (i.e. `*run`) and insert at `*indirect`, such that\\n| < x | x |  >= x  |      ...      |\\n|<-     sorted   ->|<- unsorted  ->|\\n               ^max ^(*run)\\n// NOTE: run is the address of the `next` of the node having `val` == max\\n// NOTE: we don\\'t need to advance the run pointer in this case\\n```\\n\\n\\nCode:\\n```C++\\nclass Solution {\\npublic:\\n    void insert_before(ListNode **at, ListNode *node) {\\n        node->next = *at;\\n        *at = node;\\n    }\\n    \\n    ListNode *remove(ListNode **at) {\\n        ListNode *result = *at;\\n        *at = result->next;\\n        result->next = NULL;\\n        return result;\\n    }\\n    \\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode **run = &head;\\n        \\n        int max = INT_MIN;\\n        \\n        // until the last node\\n        while (*run) {\\n            max = std::max(max, (*run)->val);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if ((*run)->val < max) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // case 2: sorted insert\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ListNode **indirect = &head;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // walk to the next node until we hit the first node of the larger partition\\n                while ((*indirect)->val < (*run)->val)\\n                    indirect = &(*indirect)->next;\\n                \\n                insert_before(indirect, remove(run));\\n            } else {\\n                // case 1\\n                run = &(*run)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Case 1: we still have a sorted list up to `*run`: if (*run)->val >= max\\n| <= x |  x  |      ...      |\\n|<- sorted ->|<- unsorted  ->|\\n          ^max == *run\\n// so, we can just advance the run to it\\'s pointee\\'s `next`\\n------------------------------------------------------------\\n// Case 2: we have to move`*run` in front to maintain the non-descreasing sequence: if (*run)->val < max\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n ^head ... ^max ^(*run)\\n\\n// Now, just perform a sorted insert of `*run`, between `head` and `max`\\n// we can declare an indirect pointer `indirect` initialized to address of `head`, and\\n// iterate until it points to a node such that node->val >= x (i.e. (*run)->val)\\n| < x | >= x |  x  |  ...   |\\n|<- sorted ->|<- unsorted ->|\\n       ^(*indirect) (the first node of the >= x partition)\\n\\n// finally we can remove the pointee of `run` (i.e. `*run`) and insert at `*indirect`, such that\\n| < x | x |  >= x  |      ...      |\\n|<-     sorted   ->|<- unsorted  ->|\\n               ^max ^(*run)\\n// NOTE: run is the address of the `next` of the node having `val` == max\\n// NOTE: we don\\'t need to advance the run pointer in this case\\n```\n```C++\\nclass Solution {\\npublic:\\n    void insert_before(ListNode **at, ListNode *node) {\\n        node->next = *at;\\n        *at = node;\\n    }\\n    \\n    ListNode *remove(ListNode **at) {\\n        ListNode *result = *at;\\n        *at = result->next;\\n        result->next = NULL;\\n        return result;\\n    }\\n    \\n    ListNode *insertionSortList(ListNode *head) {\\n        ListNode **run = &head;\\n        \\n        int max = INT_MIN;\\n        \\n        // until the last node\\n        while (*run) {\\n            max = std::max(max, (*run)->val);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if ((*run)->val < max) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // case 2: sorted insert\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0ListNode **indirect = &head;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  // walk to the next node until we hit the first node of the larger partition\\n                while ((*indirect)->val < (*run)->val)\\n                    indirect = &(*indirect)->next;\\n                \\n                insert_before(indirect, remove(run));\\n            } else {\\n                // case 1\\n                run = &(*run)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545492,
                "title": "c-solution-16ms-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummy = new ListNode(-500000), *node;\\n        dummy->next = head;\\n        node = dummy;\\n        while(head)\\n        {\\n            if(node->val > head->val)\\n            {\\n                node->next = head->next;\\n                ListNode *ptr = dummy;\\n                while(ptr->next->val <= head->val)\\n                    ptr = ptr->next;\\n                head->next = ptr->next;\\n                ptr->next = head;\\n                head = node->next;\\n            }\\n            else\\n            {\\n                node = node->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummy = new ListNode(-500000), *node;\\n        dummy->next = head;\\n        node = dummy;\\n        while(head)\\n        {\\n            if(node->val > head->val)\\n            {\\n                node->next = head->next;\\n                ListNode *ptr = dummy;\\n                while(ptr->next->val <= head->val)\\n                    ptr = ptr->next;\\n                head->next = ptr->next;\\n                ptr->next = head;\\n                head = node->next;\\n            }\\n            else\\n            {\\n                node = node->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315473,
                "title": "faster-than-96-02-c-clean-code",
                "content": "Insertion Sort for Linked list.\\n->Create a dummy node at the start of the linked list\\n->Traverse the list start till end and for each node insert it at the right position by using temporary node prev that tells us the right position for the node.\\n->Return the next node of dummy as that will be the starting of linked list.\\n\\n```\\n/*\\n Definition for singly-linked list.\\n  struct ListNode {\\n      int val;\\n     ListNode next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode next) : val(x), next(next) {}\\n  };\\n */\\nclass Solution {\\npublic:\\n    ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode curr=head,prev=dummy;\\n        while(curr){\\n            if(curr->next && curr->next->val<curr->val){\\n                ListNode nxt=curr->next->next;\\n                ListNode insert=curr->next;              //node to be inserted at right position\\n                while(prev->next->val<insert->val)\\n                     prev=prev->next;                   //takes us to the last node whose value is more than the node to be inserted\\n                curr->next=nxt;\\n                insert->next=prev->next;\\n                prev->next=insert;\\n                prev=dummy;       //again initialized to dummy for next comparisions\\n            }\\n            else\\n              curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n Definition for singly-linked list.\\n  struct ListNode {\\n      int val;\\n     ListNode next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode next) : val(x), next(next) {}\\n  };\\n */\\nclass Solution {\\npublic:\\n    ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy->next=head;\\n        ListNode curr=head,prev=dummy;\\n        while(curr){\\n            if(curr->next && curr->next->val<curr->val){\\n                ListNode nxt=curr->next->next;\\n                ListNode insert=curr->next;              //node to be inserted at right position\\n                while(prev->next->val<insert->val)\\n                     prev=prev->next;                   //takes us to the last node whose value is more than the node to be inserted\\n                curr->next=nxt;\\n                insert->next=prev->next;\\n                prev->next=insert;\\n                prev=dummy;       //again initialized to dummy for next comparisions\\n            }\\n            else\\n              curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132436,
                "title": "python-sol-with-line-by-line-explanation",
                "content": "I have already added the required comments and explanation and if you still have any doubts comment down\\n\\n        \\n        \\n        \"\"\"\\n        We will create a sorted linked list based on the given linkedlist by taking one val at a time and\\n        iterating and checking with prev and next pointer \\n        \\n        \"\"\"\\n        \\n        \\n        #The basic idea is we will create a dummy variable\\n        #the reason we are creating a dummy variable so that we an have a pointer\\n        #to our prev_pointer and curr_pointer \\n        #and the reason we are taking prev pointer and next pointer so that we can compare it with \\n        #the curr.val and place it accordingly\\n        \\n        \\n        \"\"\"\\n        Initially the prev pointer will be pointing to our dummy var and the next pointer will be pointing to the prev.next \\n        \\n        And each iteration we will be moving both our pointers\\n        \\n        \\n        \"\"\"\\n        dummy_head = ListNode()\\n        \\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = prev_pointer.next\\n            \\n            \\n            #Now we will try to find out what would be the correct position be for the curr\\n            #value we are at\\n            \\n            while next_pointer:  #Dont include prev_pointer coz initially it will be null\\n                \\n                if curr.val < next_pointer.val:\\n                    break \\n                    \\n                \\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n                \\n            #Now that we find out the correct poistion all we need to do is update our pointers\\n            \\n            #point to be noted if we simply do curr = curr.next then we will loose the track of original/previous curr.next \\n            \\n            #As we are initializing the curr.next = next_pointer\\n            \\n            #So to avoid that we are storing it in a temp variable \\n             \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n            \\n        return dummy_head.next # Coz the dummy_head has no value that is 0 so we will start from the next node\\n\\t\\t\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "I have already added the required comments and explanation and if you still have any doubts comment down\\n\\n        \\n        \\n        \"\"\"\\n        We will create a sorted linked list based on the given linkedlist by taking one val at a time and\\n        iterating and checking with prev and next pointer \\n        \\n        \"\"\"\\n        \\n        \\n        #The basic idea is we will create a dummy variable\\n        #the reason we are creating a dummy variable so that we an have a pointer\\n        #to our prev_pointer and curr_pointer \\n        #and the reason we are taking prev pointer and next pointer so that we can compare it with \\n        #the curr.val and place it accordingly\\n        \\n        \\n        \"\"\"\\n        Initially the prev pointer will be pointing to our dummy var and the next pointer will be pointing to the prev.next \\n        \\n        And each iteration we will be moving both our pointers\\n        \\n        \\n        \"\"\"\\n        dummy_head = ListNode()\\n        \\n        curr = head\\n        \\n        while curr:\\n            prev_pointer = dummy_head\\n            next_pointer = prev_pointer.next\\n            \\n            \\n            #Now we will try to find out what would be the correct position be for the curr\\n            #value we are at\\n            \\n            while next_pointer:  #Dont include prev_pointer coz initially it will be null\\n                \\n                if curr.val < next_pointer.val:\\n                    break \\n                    \\n                \\n                prev_pointer = prev_pointer.next\\n                next_pointer = next_pointer.next\\n                \\n            #Now that we find out the correct poistion all we need to do is update our pointers\\n            \\n            #point to be noted if we simply do curr = curr.next then we will loose the track of original/previous curr.next \\n            \\n            #As we are initializing the curr.next = next_pointer\\n            \\n            #So to avoid that we are storing it in a temp variable \\n             \\n            temp = curr.next\\n            \\n            curr.next = next_pointer\\n            prev_pointer.next = curr\\n            \\n            curr = temp\\n            \\n        return dummy_head.next # Coz the dummy_head has no value that is 0 so we will start from the next node\\n\\t\\t\\n\\t\\t\\n**UPVOTE IF YOU FIND IT HELPFUL**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 892709,
                "title": "java-solution-with-detailed-explaination",
                "content": "**Explaination**\\n```\\n\\t\\thead : 1 -> 2 -> 4 -> 3 ->null\\n\\t\\t\\n\\t\\tdummyHead : (0)-> 1 -> 2 -> 4 ->3 -> null\\n\\t\\t\\n\\t\\t1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t |    |\\n\\t\\t   head  (head.val <= head.next.val)  => continue\\n\\t\\t  \\n\\t\\t\\t\\t\\t   head\\n\\t\\t\\t\\t\\t \\t |\\n\\t\\t(0) -> 1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t\\t    |         |\\n\\t\\t\\t    preNode    insertNode\\n\\t\\tFind preNode by checking it value with insertNode\\n\\t\\tConnect next of head to next of insertNode \\n\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 4 -> null   (connect head to next of insertion node to break the node from the list and to add it in correct position)\\n\\t\\t\\n\\t\\t\\n\\t\\t(0) -> 1 -> 2  -> 4  -> null  (connect next of insertion node to to pre node )\\n\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t3\\n\\t\\t\\t\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 3 -> 4 -> null  (finally connect the next of pre node to add the insertion node into list)\\n```\\n\\n**Code**\\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        //base case \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head; \\n        ListNode preNode = dummyHead;\\n        ListNode insertNode = dummyHead;\\n        while(head != null && head.next != null){\\n            if(head.val <= head.next.val){\\n                //in ascending order , no need to change\\n                head = head.next;\\n            }\\n            else{\\n                //move the prenode to the start of the dummyhead\\n                preNode = dummyHead;\\n                //the node to insert in its correct position is the node next to the actual head\\n                insertNode = head.next;\\n                //find the pos to insert the current node (insertNode) by checking if pre node values are less than the value of the node to be inserted\\n                while(preNode.next.val < insertNode.val){\\n                    preNode = preNode.next;\\n                }\\n                //now next of the pre node is the place where the cuurent node (insertNode) to be inserted\\n                //connect the original head to next of insertion node to break the node from the list and to add it in correct position\\n                head.next = insertNode.next;\\n                //connect next of insertion node to to pre node \\n                insertNode.next = preNode.next;\\n                //finally connect the next of pre node to add the insertion node into list\\n                preNode.next = insertNode;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\thead : 1 -> 2 -> 4 -> 3 ->null\\n\\t\\t\\n\\t\\tdummyHead : (0)-> 1 -> 2 -> 4 ->3 -> null\\n\\t\\t\\n\\t\\t1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t |    |\\n\\t\\t   head  (head.val <= head.next.val)  => continue\\n\\t\\t  \\n\\t\\t\\t\\t\\t   head\\n\\t\\t\\t\\t\\t \\t |\\n\\t\\t(0) -> 1 -> 2 -> 4 -> 3 -> null\\n\\t\\t\\t\\t    |         |\\n\\t\\t\\t    preNode    insertNode\\n\\t\\tFind preNode by checking it value with insertNode\\n\\t\\tConnect next of head to next of insertNode \\n\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 4 -> null   (connect head to next of insertion node to break the node from the list and to add it in correct position)\\n\\t\\t\\n\\t\\t\\n\\t\\t(0) -> 1 -> 2  -> 4  -> null  (connect next of insertion node to to pre node )\\n\\t\\t\\t\\t\\t|\\n\\t\\t\\t\\t\\t3\\n\\t\\t\\t\\t\\t\\n\\t\\t(0) -> 1 -> 2 -> 3 -> 4 -> null  (finally connect the next of pre node to add the insertion node into list)\\n```\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        //base case \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head; \\n        ListNode preNode = dummyHead;\\n        ListNode insertNode = dummyHead;\\n        while(head != null && head.next != null){\\n            if(head.val <= head.next.val){\\n                //in ascending order , no need to change\\n                head = head.next;\\n            }\\n            else{\\n                //move the prenode to the start of the dummyhead\\n                preNode = dummyHead;\\n                //the node to insert in its correct position is the node next to the actual head\\n                insertNode = head.next;\\n                //find the pos to insert the current node (insertNode) by checking if pre node values are less than the value of the node to be inserted\\n                while(preNode.next.val < insertNode.val){\\n                    preNode = preNode.next;\\n                }\\n                //now next of the pre node is the place where the cuurent node (insertNode) to be inserted\\n                //connect the original head to next of insertion node to break the node from the list and to add it in correct position\\n                head.next = insertNode.next;\\n                //connect next of insertion node to to pre node \\n                insertNode.next = preNode.next;\\n                //finally connect the next of pre node to add the insertion node into list\\n                preNode.next = insertNode;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753647,
                "title": "javascript-clear-and-easy-to-understand-with-es6",
                "content": "```\\nvar insertionSortList = function(head) {\\n    let newHead = new ListNode(0)\\n    while(head){\\n        const t = head\\n        head = head.next\\n        let cur = newHead\\n        while(cur){\\n            if(!cur.next || t.val <= cur.next.val){\\n                [cur.next, t.next] = [t, cur.next]\\n                break\\n            }\\n            cur = cur.next\\n        }\\n    }\\n    return newHead.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar insertionSortList = function(head) {\\n    let newHead = new ListNode(0)\\n    while(head){\\n        const t = head\\n        head = head.next\\n        let cur = newHead\\n        while(cur){\\n            if(!cur.next || t.val <= cur.next.val){\\n                [cur.next, t.next] = [t, cur.next]\\n                break\\n            }\\n            cur = cur.next\\n        }\\n    }\\n    return newHead.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689148,
                "title": "c-easy-solution-in-o-1-space",
                "content": "```\\nListNode* insertionSortList(ListNode* head) {\\n        // if list is empty or has only one node\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\t\\t\\t\\n        // make an empty list, it will store nodes in sorted order\\n        ListNode* newList = NULL;\\n    \\n        ListNode* current = head;\\n        \\n        while(current!=NULL){\\n            \\n            // store current\\'s next in a variable\\n            ListNode* nextt = current->next;\\n            \\n            // insert this node is its correct position in the new list.\\n            if(newList == NULL || newList->val >= current->val){\\n                ListNode* temp = newList;\\n                newList = current;\\n                newList->next = temp;\\n            }\\n            else\\n            {\\n                ListNode* temp = newList;\\n                while(temp && temp->next && temp->next->val <= current->val)\\n                {\\n                    temp = temp->next;\\n                }\\n                ListNode* t = temp->next;\\n                temp->next = current;\\n                temp->next->next=t;\\n            }\\n            // go the the next node\\n            current = nextt;\\n        }\\n        return newList;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* insertionSortList(ListNode* head) {\\n        // if list is empty or has only one node\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\t\\t\\t\\n        // make an empty list, it will store nodes in sorted order\\n        ListNode* newList = NULL;\\n    \\n        ListNode* current = head;\\n        \\n        while(current!=NULL){\\n            \\n            // store current\\'s next in a variable\\n            ListNode* nextt = current->next;\\n            \\n            // insert this node is its correct position in the new list.\\n            if(newList == NULL || newList->val >= current->val){\\n                ListNode* temp = newList;\\n                newList = current;\\n                newList->next = temp;\\n            }\\n            else\\n            {\\n                ListNode* temp = newList;\\n                while(temp && temp->next && temp->next->val <= current->val)\\n                {\\n                    temp = temp->next;\\n                }\\n                ListNode* t = temp->next;\\n                temp->next = current;\\n                temp->next->next=t;\\n            }\\n            // go the the next node\\n            current = nextt;\\n        }\\n        return newList;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 521163,
                "title": "java-2ms-insertion-sort",
                "content": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\\n\\t\\tListNode curr = head;\\n        ListNode prev = dummy;\\n\\t\\twhile (curr != null) {\\n            //to save checking from start below condition is used\\n            if(prev.val > curr.val)\\n                prev = dummy;\\n\\t\\t\\t\\n\\t\\t\\twhile (prev.next != null && prev.next.val<curr.val) {\\n\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert current node between prev and prev.next \\n\\t\\t\\tListNode nextNode=curr.next;\\n\\t\\t\\tcurr.next=(prev.next);\\n\\t\\t\\tprev.next=(curr);\\n\\t\\t\\tcurr=nextNode;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}\\n    \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MIN_VALUE);\\n\\t\\tListNode curr = head;\\n        ListNode prev = dummy;\\n\\t\\twhile (curr != null) {\\n            //to save checking from start below condition is used\\n            if(prev.val > curr.val)\\n                prev = dummy;\\n\\t\\t\\t\\n\\t\\t\\twhile (prev.next != null && prev.next.val<curr.val) {\\n\\t\\t\\t\\tprev = prev.next;\\n\\t\\t\\t}\\n\\t\\t\\t//insert current node between prev and prev.next \\n\\t\\t\\tListNode nextNode=curr.next;\\n\\t\\t\\tcurr.next=(prev.next);\\n\\t\\t\\tprev.next=(curr);\\n\\t\\t\\tcurr=nextNode;\\n\\t\\t}\\n\\t\\treturn dummy.next;\\n\\t}\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 210353,
                "title": "python-solution",
                "content": "Time complexity: `O(n^2)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next = head\\n        pre1 = head\\n        ptr1 = head.next\\n        while ptr1: # keep the loop invariant that nodes between dummy and ptr1 are sorted\\n            pre2 = dummy\\n            ptr2 = dummy.next\\n            while ptr2 != ptr1 and ptr2.val <= ptr1.val: # ptr2 searches for the right place to insert ptr1\\n                pre2 = ptr2\\n                ptr2 = ptr2.next\\n            if ptr2 == ptr1:\\n                pre1 = ptr1\\n                ptr1 = ptr1.next\\n            else:\\n                pre2.next = ptr1\\n                tmp = ptr1.next\\n                ptr1.next = ptr2\\n                ptr2 = ptr1\\n                ptr1 = tmp\\n                pre1.next = ptr1\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next = head\\n        pre1 = head\\n        ptr1 = head.next\\n        while ptr1: # keep the loop invariant that nodes between dummy and ptr1 are sorted\\n            pre2 = dummy\\n            ptr2 = dummy.next\\n            while ptr2 != ptr1 and ptr2.val <= ptr1.val: # ptr2 searches for the right place to insert ptr1\\n                pre2 = ptr2\\n                ptr2 = ptr2.next\\n            if ptr2 == ptr1:\\n                pre1 = ptr1\\n                ptr1 = ptr1.next\\n            else:\\n                pre2.next = ptr1\\n                tmp = ptr1.next\\n                ptr1.next = ptr2\\n                ptr2 = ptr1\\n                ptr1 = tmp\\n                pre1.next = ptr1\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183504,
                "title": "5ms-o-1-space-5-small-steps-that-easy-to-follow",
                "content": "**Preparation:**\n* Order in LinkedList will be changed, extra variable required -> `ListNode n`.\n* LinkedList needs to be divided in sorted and unsorted parts -> `ListNode pivot `.\n* Iteration of sorted part starting from head -> `ListNode current = head`.\n\n**Implementation:**\n1. Iterate LinkedList.\n2. Special case: `pivot` smaller than current element:\n\t* Update pivot : `pivot = n`.\n\t*  Next iteration -> **step1**.\n2. Save link to next element: `n = pivot.next.`\n3. Unattach element from list: `pivot.next = n.next`.\n4. Insert element into sorted part.\n```\npublic ListNode insertionSortList(ListNode head) {\n   if( head == null || head.next == null ) return head;\n\n    ListNode pivot = head;\n    ListNode n = null;\n    while( pivot.next != null){\n      n = pivot.next;\n      if( n.val >= pivot.val) {\n        pivot = n;\n        continue;\n      }\n      pivot.next = n.next;\n      \n      if( n.val <= head.val) {\n        n.next = head;\n        head = n;\n        continue;\n      } \n      \n      ListNode current = head;\n      while( current.next != n && n.val > current.next.val) current = current.next;\n      n.next = current.next;\n      current.next = n;\n    }\n    return head;\n  }\n```",
                "solutionTags": [],
                "code": "```\npublic ListNode insertionSortList(ListNode head) {\n   if( head == null || head.next == null ) return head;\n\n    ListNode pivot = head;\n    ListNode n = null;\n    while( pivot.next != null){\n      n = pivot.next;\n      if( n.val >= pivot.val) {\n        pivot = n;\n        continue;\n      }\n      pivot.next = n.next;\n      \n      if( n.val <= head.val) {\n        n.next = head;\n        head = n;\n        continue;\n      } \n      \n      ListNode current = head;\n      while( current.next != n && n.val > current.next.val) current = current.next;\n      n.next = current.next;\n      current.next = n;\n    }\n    return head;\n  }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151412,
                "title": "15-lines-java-solution-using-dummyhead",
                "content": "```\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0); // use dummyHead\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode iter = dummy; // find the correct insertion point\\n            while (iter.next != null && iter.next.val < cur.val) {\\n                iter = iter.next;\\n            }\\n            ListNode next = cur.next;\\n            cur.next = iter.next;\\n            iter.next = cur;\\n            cur = next;\\n        }\\n        return dummy.next;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0); // use dummyHead\\n        ListNode cur = head;\\n        while (cur != null) {\\n            ListNode iter = dummy; // find the correct insertion point\\n            while (iter.next != null && iter.next.val < cur.val) {\\n                iter = iter.next;\\n            }\\n            ListNode next = cur.next;\\n            cur.next = iter.next;\\n            iter.next = cur;\\n            cur = next;\\n        }\\n        return dummy.next;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46553,
                "title": "insertion-sort-python-solution",
                "content": "    class Solution(object):\\n        def insertionSortList(self, head):\\n            if not head or not head.next:\\n                return head\\n    \\n            dummy = ListNode(None)\\n            dummy.next, tail = head, head.next\\n            dummy.next.next = None\\n    \\n            while tail:\\n                pre, current, next = dummy, dummy.next, tail.next\\n                while current:\\n                    if tail.val <= current.val:\\n                        pre.next, tail.next = tail, current\\n                        break\\n                    pre, current = current, current.next\\n                else:\\n                    pre.next, tail.next = tail, None\\n                tail = next\\n    \\n            return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def insertionSortList(self, head):\\n            if not head or not head.next:\\n                return head\\n    \\n            dummy = ListNode(None)\\n            dummy.next, tail = head, head.next\\n            dummy.next.next = None\\n    \\n            while tail:\\n                pre, current, next = dummy, dummy.next, tail.next\\n                while current:\\n                    if tail.val <= current.val:\\n                        pre.next, tail.next = tail, current\\n                        break\\n                    pre, current = current, current.next\\n                else:\\n                    pre.next, tail.next = tail, None\\n                tail = next\\n    \\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 46570,
                "title": "java-34ms-solution-clear-logic-with-separate-insert-method",
                "content": "using insertion sort logic. Insert each new node into a sorted linked list with dummy head.\\n \\n\\n      public class Solution {\\n            public ListNode insertionSortList(ListNode head) {\\n                ListNode sortedHeadDummy = new ListNode(0);\\n                ListNode curr = head;\\n                while (curr != null) {\\n                    ListNode next = curr.next;\\n                    insert(sortedHeadDummy, curr);\\n                    curr = next;\\n                }\\n                return sortedHeadDummy.next;\\n            }\\n            \\n            private void insert(ListNode dummyHead, ListNode target) {\\n                // left to right scan to insert the target node\\n                ListNode curr = dummyHead;\\n                while (curr.next != null && curr.next.val < target.val) {\\n                    curr = curr.next;\\n                }\\n                target.next = curr.next;\\n                curr.next = target;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode insertionSortList(ListNode head) {\\n                ListNode sortedHeadDummy = new ListNode(0);\\n                ListNode curr = head;\\n                while (curr != null) {\\n                    ListNode next = curr.next;\\n                    insert(sortedHeadDummy, curr);\\n                    curr = next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46636,
                "title": "share-my-c-solution",
                "content": "It is quite easy if you swap value instead of pointer. check my insertionSortListV. Once you understand the \"swap by value\" version. then \"swap by pointer\" is easy too. check insertionSortListP.\\n\\n1. pi means pre-i.   like this:    A1->A2->pj->j->A5->A6-pi->i->... the 3 steps to swap i and j by pointer \\n\\n    SWAP(pi->next, pj->next, t);\\n    SWAP(i->next, j->next, t);\\n    SWAP(i, j, t);\\n\\nif  J is the head, there is no pj. in order to handle this special case normally. I set up an ListNode object in the stack, called  hd. let pj->hd, hd->next = j. \\n\\n    #define SWAP(a, b, t) {t = a; a = b; b = t;}\\n    class Solution {\\n    public:\\n        ListNode *insertionSortListV(ListNode *head) {\\n            ListNode *i, *j;\\n            int v;\\n    \\n            for (i = head->next; i; i = i->next) {\\n                for (j = head; j != i; j = j->next) {\\n                    if (i->val < j->val)\\n                        SWAP(i->val, j->val, v);\\n                }\\n            }\\n            return head;\\n        }\\n    \\n        ListNode *insertionSortListP(ListNode *head) {\\n            ListNode hd(0);\\n            ListNode *i, *j, *t, *pi, *pj;\\n    \\n            i = head->next;\\n            j = head;\\n            hd.next = head;\\n            pi = head;\\n            pj = &hd;\\n            while (i) {\\n                while (j != i) {\\n                    if (i->val < j->val) {\\n                        SWAP(pi->next, pj->next, t);\\n                        SWAP(i->next, j->next, t);\\n                        SWAP(i, j, t);\\n                    }\\n                    pj = j;\\n                    j = j->next;\\n                }\\n                j = hd.next;\\n                pj = &hd;\\n                pi = i;\\n                i = i->next;\\n            }\\n            return hd.next;\\n    \\n        }\\n        ListNode *insertionSortList(ListNode *head) {\\n            // 0 or 1 element, no need to sort.\\n            if (!head || !head->next)\\n                return head;\\n    #if 0\\n            return insertionSortListV(head);\\n    #else\\n            return insertionSortListP(head);\\n    #endif\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortListV(ListNode *head) {\\n            ListNode *i, *j;\\n            int v;\\n    \\n            for (i = head->next; i; i = i->next) {\\n                for (j = head; j != i; j = j->next) {\\n                    if (i->val < j->val)\\n                        SWAP(i->val, j->val, v);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46646,
                "title": "tle-for-python",
                "content": "I have a Time Limit Exceeded when input a list of 5000 numbers.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertSort(self, head):\\n        if head==None or head.next==None:\\n            return head\\n        self.insertSort(head.next)\\n        l=head\\n        r=head.next\\n        while r!=None:\\n            if l.val>r.val:\\n                l.val,r.val=r.val,l.val\\n                l=r\\n                r=r.next\\n            else:\\n                return head\\n        return head\\n    def insertionSortList(self, head):\\n        return self.insertSort(head)\\nis there any solution for the problem?",
                "solutionTags": [
                    "Python"
                ],
                "code": "I have a Time Limit Exceeded when input a list of 5000 numbers.\\n\\n    class Solution:\\n    # @param head, a ListNode\\n    # @return a ListNode\\n    def insertSort(self, head):\\n        if head==None or head.next==None:\\n            return head\\n        self.insertSort(head.next)\\n        l=head\\n        r=head.next\\n        while r!=None:\\n            if l.val>r.val:\\n                l.val,r.val=r.val,l.val\\n                l=r\\n                r=r.next\\n            else:\\n                return head\\n        return head\\n    def insertionSortList(self, head):\\n        return self.insertSort(head)\\nis there any solution for the problem?",
                "codeTag": "Java"
            },
            {
                "id": 3957534,
                "title": "simple-java-solution-true-insertion-sort",
                "content": "# Intuition\\nSplit into two lists. Take from unsorted list and insert into sorted list.\\n\\n# Approach\\nSame as intuition \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head.next;\\n        ListNode h = head; \\n        h.next = null;\\n        while (curr != null) {\\n            ListNode temp = curr;\\n            curr = curr.next;\\n            ListNode px = null;\\n            ListNode x = h;\\n            while (x != null && x.val < temp.val) {\\n                px = x;\\n                x = x.next;\\n            }\\n            if (px != null) \\n                px.next = temp;\\n            else \\n                h = temp;\\n            temp.next = x;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head.next;\\n        ListNode h = head; \\n        h.next = null;\\n        while (curr != null) {\\n            ListNode temp = curr;\\n            curr = curr.next;\\n            ListNode px = null;\\n            ListNode x = h;\\n            while (x != null && x.val < temp.val) {\\n                px = x;\\n                x = x.next;\\n            }\\n            if (px != null) \\n                px.next = temp;\\n            else \\n                h = temp;\\n            temp.next = x;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589060,
                "title": "singly-linked-list-insertion-sort-python-beats-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical inserton sort adapted to singly linked list. Presumably we should have handled the case we don\\'t have a head. But I did not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We should create a second function insert_node. As you might have guessed this is meant to be a function that will insert our current node into our \"subarray\".\\n2. Inside our loop we should create a new reference next_node to the curr.next node because of we break the connections inside our linked list and our garbage collector could potentially remove the rest data. Creating a new reference - avoidance of this.\\n3. `insert_node` is a simple function, firstly if checks whether our current node value is less than sorted_head value. If so we just replace our header with the current node. By the way, sorted_head is just a pointer to the sublist head. Our sublist is expected to be ordered in ascending. Otherwise we continuously check if our node data is greater than each nodes\\' data. This is a way of finding the right place to put our node.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant time, approximate O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sorted_head = None\\n        curr = head\\n\\n        while curr:\\n            next_node = curr.next\\n            sorted_head = self.insert_node(sorted_head, curr)\\n            curr = next_node\\n        \\n        return sorted_head\\n\\n    def insert_node(self, sorted_head, node):\\n        if not sorted_head or node.val < sorted_head.val:\\n            node.next = sorted_head\\n            sorted_head = node\\n        else:\\n            curr = sorted_head\\n            while curr.next and curr.next.val < node.val:\\n                curr = curr.next\\n            node.next = curr.next\\n            curr.next = node\\n        \\n        return sorted_head\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sorted_head = None\\n        curr = head\\n\\n        while curr:\\n            next_node = curr.next\\n            sorted_head = self.insert_node(sorted_head, curr)\\n            curr = next_node\\n        \\n        return sorted_head\\n\\n    def insert_node(self, sorted_head, node):\\n        if not sorted_head or node.val < sorted_head.val:\\n            node.next = sorted_head\\n            sorted_head = node\\n        else:\\n            curr = sorted_head\\n            while curr.next and curr.next.val < node.val:\\n                curr = curr.next\\n            node.next = curr.next\\n            curr.next = node\\n        \\n        return sorted_head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362986,
                "title": "c-o-n-very-easy-solution-beginner-friendly",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>v;\\n        while( temp!=NULL )\\n        {\\n            v.push_back( temp->val );\\n            temp = temp->next;\\n        }\\n        sort( v.begin() ,  v.end() );\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        int n=v.size();\\n        for(int i=0 ; i<n ; i++ )\\n        {\\n            ListNode* newnode = new ListNode( v[i] );\\n            if( ans==NULL )\\n            {\\n                ans = newnode;\\n                temp1 = ans;\\n            }\\n            else\\n            {\\n                temp1->next = newnode;\\n                temp1 = temp1->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>v;\\n        while( temp!=NULL )\\n        {\\n            v.push_back( temp->val );\\n            temp = temp->next;\\n        }\\n        sort( v.begin() ,  v.end() );\\n        ListNode* ans = NULL;\\n        ListNode* temp1 = ans;\\n        int n=v.size();\\n        for(int i=0 ; i<n ; i++ )\\n        {\\n            ListNode* newnode = new ListNode( v[i] );\\n            if( ans==NULL )\\n            {\\n                ans = newnode;\\n                temp1 = ans;\\n            }\\n            else\\n            {\\n                temp1->next = newnode;\\n                temp1 = temp1->next;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093976,
                "title": "java-easiest-approach-explained-3-pointers-o-1-space-soln",
                "content": "```\\nclass Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        //making a dummy node to avoid edge cases\\n        ListNode dummy  = new ListNode(-1);\\n        //  prev moves from starting to value who is just lesser than the next.val\\n        ListNode prev = dummy;\\n        // we use it to compare the adjacent values\\n        ListNode curr =  head;\\n        ListNode next = head.next;\\n        dummy.next = head;\\n        while(next!=null)\\n        {\\n            // first check , if this is true then continue \\n            if(curr.val <=next.val)\\n            {\\n                curr =  curr.next;\\n                next = curr.next;\\n                continue;\\n            }\\n            \\n            // keep moving prev as discussed \\n            while(prev.next !=null && prev.next.val<next.val)\\n            {\\n                prev =  prev.next;\\n            }\\n            // inserting the lesser valued after prev, all the 3 pointers come in use \\n            curr.next= next.next;\\n            next.next = prev.next;\\n            prev.next = next;\\n            // initialising the pointer back to their required positions\\n            prev = dummy;\\n            next = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n// -1 -1 5 3 4 0 \\n//  p    c n\\n//",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\n    public ListNode insertionSortList(ListNode head) {\\n        //making a dummy node to avoid edge cases\\n        ListNode dummy  = new ListNode(-1);\\n        //  prev moves from starting to value who is just lesser than the next.val\\n        ListNode prev = dummy;\\n        // we use it to compare the adjacent values\\n        ListNode curr =  head;\\n        ListNode next = head.next;\\n        dummy.next = head;\\n        while(next!=null)\\n        {\\n            // first check , if this is true then continue \\n            if(curr.val <=next.val)\\n            {\\n                curr =  curr.next;\\n                next = curr.next;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3049703,
                "title": "c-beginner-friendly-solution",
                "content": "\\n\\n### Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // Second Approach -> Selection Sort;\\n        if(!head || !head->next) return head;\\n\\n        ListNode *start = new ListNode(INT_MIN), *curr = head -> next;\\n        start -> next = head;\\n        ListNode *prev = head;\\n\\n        while(curr) {\\n            if(curr -> val < prev -> val) {\\n                ListNode *now = curr, *temp = start;\\n                curr = curr -> next;\\n                while(temp -> next -> val < now -> val) temp = temp -> next;\\n                ListNode *next = temp -> next;\\n                temp -> next = now;\\n                now -> next = next;\\n                prev -> next = curr;\\n            }else {\\n                prev = curr;\\n                curr = curr -> next;\\n            }\\n        }\\n        prev -> next = nullptr;\\n\\n        return start -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        // Second Approach -> Selection Sort;\\n        if(!head || !head->next) return head;\\n\\n        ListNode *start = new ListNode(INT_MIN), *curr = head -> next;\\n        start -> next = head;\\n        ListNode *prev = head;\\n\\n        while(curr) {\\n            if(curr -> val < prev -> val) {\\n                ListNode *now = curr, *temp = start;\\n                curr = curr -> next;\\n                while(temp -> next -> val < now -> val) temp = temp -> next;\\n                ListNode *next = temp -> next;\\n                temp -> next = now;\\n                now -> next = next;\\n                prev -> next = curr;\\n            }else {\\n                prev = curr;\\n                curr = curr -> next;\\n            }\\n        }\\n        prev -> next = nullptr;\\n\\n        return start -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841056,
                "title": "java-solution-well-commented-straightforward-beats-99-time-91-space",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n\\t\\t// base cases\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        // we\\'d return dummy.next as the result\\n        ListNode dummy = new ListNode(0);\\n        // points to the beginning of our result list\\n        ListNode prev = dummy;\\n        \\n        // head refers to the current node which we would try to insert in our result list. we\\n        // would insert this between prev and prev.next \\n        while(head != null) {\\n            \\n            // this would be the node processed in the next iteration. storing this in a temp \\n            // variable as the head (ie. the node we are inserting) would be modified\\n            ListNode next = head.next;\\n            \\n            // bit tricky. resetting prev to the beginning of the result list only if required\\n            if(head.val < prev.val) {\\n                prev = dummy;\\n            }\\n            \\n            while(prev.next != null && head.val > prev.next.val) {\\n                prev = prev.next;\\n            }\\n\\t\\t\\t\\n            // the order of the next two statements is important. run it in your head\\n            head.next = prev.next;\\n            prev.next = head;\\n            // prev = dummy; we would do this only if required\\n            head = next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n\\nFeel free to comment if you have any further doubts. Cheers!\\nAlso please do upvote if you found this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n\\t\\t// base cases\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        // we\\'d return dummy.next as the result\\n        ListNode dummy = new ListNode(0);\\n        // points to the beginning of our result list\\n        ListNode prev = dummy;\\n        \\n        // head refers to the current node which we would try to insert in our result list. we\\n        // would insert this between prev and prev.next \\n        while(head != null) {\\n            \\n            // this would be the node processed in the next iteration. storing this in a temp \\n            // variable as the head (ie. the node we are inserting) would be modified\\n            ListNode next = head.next;\\n            \\n            // bit tricky. resetting prev to the beginning of the result list only if required\\n            if(head.val < prev.val) {\\n                prev = dummy;\\n            }\\n            \\n            while(prev.next != null && head.val > prev.next.val) {\\n                prev = prev.next;\\n            }\\n\\t\\t\\t\\n            // the order of the next two statements is important. run it in your head\\n            head.next = prev.next;\\n            prev.next = head;\\n            // prev = dummy; we would do this only if required\\n            head = next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784435,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = dummy;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        \\n        while (curr != null) {\\n            if (curr.val >= prev.val) {\\n                prev = curr;\\n                curr = curr.next;\\n                continue;\\n            }\\n            \\n            ListNode tmp = dummy;\\n            while (curr.val > tmp.next.val) {\\n                tmp = tmp.next;\\n            }\\n            \\n            prev.next = curr.next;\\n            curr.next = tmp.next;\\n            tmp.next = curr;\\n            curr = prev.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676682,
                "title": "c-insertion-sort-an-easy-and-clear-way-to-sort",
                "content": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        if(head == nullptr) return nullptr;\\n        \\n        int temp = 0;\\n        for(ListNode* curr = head; curr != nullptr; curr = curr->next){\\n            for(ListNode* prev = head; prev != curr; prev = prev->next){\\n                if(curr->val < prev->val){\\n                    temp = curr->val;\\n                    curr->val = prev->val;\\n                    prev->val = temp;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        if(head == nullptr) return nullptr;\\n        \\n        int temp = 0;\\n        for(ListNode* curr = head; curr != nullptr; curr = curr->next){\\n            for(ListNode* prev = head; prev != curr; prev = prev->next){\\n                if(curr->val < prev->val){\\n                    temp = curr->val;\\n                    curr->val = prev->val;\\n                    prev->val = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2629948,
                "title": "python3-solution-with-more-than-93-efficiency",
                "content": "\"memory usage -  49.62% and time - 93.35%\"",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2543123,
                "title": "easy-python-solution-with-69-tc",
                "content": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tdef add(node):\\n\\t\\tcurr = self.ans\\n\\t\\twhile(curr):\\n\\t\\t\\tif(curr.val < node.val):\\n\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\telse: break\\n\\t\\tnode.next, prev.next = prev.next, node\\n\\tself.ans = ListNode(-5001)\\n\\twhile(head):\\n\\t\\ttemp, head = head, head.next\\n\\t\\ttemp.next = None\\n\\t\\tadd(temp)\\n\\treturn self.ans.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tdef add(node):\\n\\t\\tcurr = self.ans\\n\\t\\twhile(curr):\\n\\t\\t\\tif(curr.val < node.val):\\n\\t\\t\\t\\tprev = curr\\n\\t\\t\\t\\tcurr = curr.next\\n\\t\\t\\telse: break\\n\\t\\tnode.next, prev.next = prev.next, node\\n\\tself.ans = ListNode(-5001)\\n\\twhile(head):\\n\\t\\ttemp, head = head, head.next\\n\\t\\ttemp.next = None\\n\\t\\tadd(temp)\\n\\treturn self.ans.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2495574,
                "title": "python3",
                "content": "Time Comp : O(n) to O(n^2)\\n```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummy = ListNode(0 , head) ;\\n        prev , cur = head ,head.next \\n        \\n        while cur :\\n            if cur.val >= prev.val :\\n                prev , cur = cur , cur.next ;\\n                continue \\n            temp = dummy ;\\n            while cur.val > temp.next.val :\\n                temp = temp.next ;\\n            prev.next = cur.next \\n            cur.next = temp.next ;\\n            temp.next = cur ;\\n            cur = prev.next;\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insertionSortList(self, head):\\n        dummy = ListNode(0 , head) ;\\n        prev , cur = head ,head.next \\n        \\n        while cur :\\n            if cur.val >= prev.val :\\n                prev , cur = cur , cur.next ;\\n                continue \\n            temp = dummy ;\\n            while cur.val > temp.next.val :\\n                temp = temp.next ;\\n            prev.next = cur.next \\n            cur.next = temp.next ;\\n            temp.next = cur ;\\n            cur = prev.next;\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389669,
                "title": "c",
                "content": "```\\n\\n    \\n    class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;\\n        while(head){\\n           \\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    \\n    class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* newHead = NULL;\\n        while(head){\\n           \\n            ListNode* temp = head;\\n            head = head->next;\\n            temp->next=NULL;\\n            \\n            //setting the first node of our final linked list \\n            if(newHead == NULL) newHead = temp;\\n\\n            else if(newHead->val >= temp->val){\\n                temp->next = newHead;\\n                newHead = temp;\\n            }\\n            // inserting the node anywhere in the middle or in the end depending upon the value of the temp node;\\n            else{\\n                ListNode* root = newHead;\\n                {\\n                while(root->next){\\n                    if(temp->val > root->val and temp->val <= root->next->val){\\n                        temp->next = root->next;\\n                        root->next = temp;\\n                        break;\\n                    }\\n                    root = root->next;\\n                }  \\n                    //inserting the temp node at the end\\n                    if(root->next==NULL) root->next = temp;\\n                    \\n                }\\n            }\\n        }\\n        //sorted linkedlist\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139934,
                "title": "99-93-faster-solution-in-python-very-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        cur = ans = head\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n            \\n        nums = sorted(nums)\\n            \\n        count = 0\\n        while cur:\\n            cur.val = nums[count]\\n            count+=1\\n            cur = cur.next\\n            \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/0c19db1a-1a20-4f5b-bb9e-161fd677c18b_1654975074.6215382.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nums = []\\n        cur = ans = head\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n            \\n        nums = sorted(nums)\\n            \\n        count = 0\\n        while cur:\\n            cur.val = nums[count]\\n            count+=1\\n            cur = cur.next\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918926,
                "title": "c-recursion-iteration-explained",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n////////////////////////////////////////////////////////////\\n// Solution: Recursion (for fun)\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        ListNode* pre = dummy;\\n        ListNode* p = head;\\n        \\n        while (pre->next && pre->next->val < head->val) pre = pre->next;\\n        \\n        head = p->next;\\n        p->next = pre->next;\\n        pre->next = p;\\n        pre = dummy;\\n        insertionSortList(head);\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n////////////////////////////////////////////////////////////\\n// Solution: Regular insertion sort algo\\n// the approach is very straight forward, thinking there are\\n// 2 slinked list: (1) sorted slinked list, the target one;\\n// (2) the unsorted one which is the original input\\n// we will move each node from the original slinked list to \\n// the sorted one and insert to the right position.\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        // [Tips] Using dummy head node in the cases which original head node might be changed.\\n        ListNode* dummy = new ListNode(-1);    // the dummy head of the sorted slinked list\\n        ListNode* pre = dummy;                 // previous node of the right inserting position in sorted slinked list\\n        ListNode* p = head;                    // for interating the unsorted slinked list\\n\\n        // move the nodes in original slinked list one by one\\n        while (p) { \\n            head = p->next;\\n            // find the right place in the sorted slinked list\\n            while (pre->next && pre->next->val < p->val) pre = pre->next;\\n            \\n            // insert the node to sorted slinked list\\n            p->next = pre->next;\\n            pre->next = p;\\n            // reset pointers: pre and p \\n            pre = dummy;\\n            p = head;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nPlz upvote if you think its helpful.",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n////////////////////////////////////////////////////////////\\n// Solution: Recursion (for fun)\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        ListNode* pre = dummy;\\n        ListNode* p = head;\\n        \\n        while (pre->next && pre->next->val < head->val) pre = pre->next;\\n        \\n        head = p->next;\\n        p->next = pre->next;\\n        pre->next = p;\\n        pre = dummy;\\n        insertionSortList(head);\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n////////////////////////////////////////////////////////////\\n// Solution: Regular insertion sort algo\\n// the approach is very straight forward, thinking there are\\n// 2 slinked list: (1) sorted slinked list, the target one;\\n// (2) the unsorted one which is the original input\\n// we will move each node from the original slinked list to \\n// the sorted one and insert to the right position.\\n////////////////////////////////////////////////////////////\\nclass Solution {\\nprivate:\\n    ListNode* dummy = new ListNode(-1);\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if (!head) return head;\\n        \\n        // [Tips] Using dummy head node in the cases which original head node might be changed.\\n        ListNode* dummy = new ListNode(-1);    // the dummy head of the sorted slinked list\\n        ListNode* pre = dummy;                 // previous node of the right inserting position in sorted slinked list\\n        ListNode* p = head;                    // for interating the unsorted slinked list\\n\\n        // move the nodes in original slinked list one by one\\n        while (p) { \\n            head = p->next;\\n            // find the right place in the sorted slinked list\\n            while (pre->next && pre->next->val < p->val) pre = pre->next;\\n            \\n            // insert the node to sorted slinked list\\n            p->next = pre->next;\\n            pre->next = p;\\n            // reset pointers: pre and p \\n            pre = dummy;\\n            p = head;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916812,
                "title": "sorting-list-with-o-n-time-and-space-complexity-easy-solution",
                "content": "ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>t;\\n        \\n        while(temp!=NULL){\\n            t.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        sort(t.begin(),t.end());\\n        \\n        temp=head;\\n        \\n        int i=0;\\n        \\n        while(temp!=NULL){\\n            temp->val=t[i];\\n            \\n            temp=temp->next;\\n            \\n            i++;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Sorting"
                ],
                "code": "ListNode* insertionSortList(ListNode* head) {\\n        ListNode* temp=head;\\n        vector<int>t;\\n        \\n        while(temp!=NULL){\\n            t.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        sort(t.begin(),t.end());\\n        \\n        temp=head;\\n        \\n        int i=0;\\n        \\n        while(temp!=NULL){\\n            temp->val=t[i];\\n            \\n            temp=temp->next;\\n            \\n            i++;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1903724,
                "title": "java-easy-dummy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(0);\\n        ListNode prev = dummy;\\n        ListNode nex = curr.next;\\n        \\n        while(curr!=null){\\n                while(prev.next != null && prev.next.val < curr.val) prev = prev.next;\\n                curr.next = prev.next;\\n                prev.next = curr;\\n                \\n                curr = nex;\\n                if(curr!=null) nex = curr.next;\\n                prev = dummy;\\n               \\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode curr = head;\\n        ListNode dummy = new ListNode(0);\\n        ListNode prev = dummy;\\n        ListNode nex = curr.next;\\n        \\n        while(curr!=null){\\n                while(prev.next != null && prev.next.val < curr.val) prev = prev.next;\\n                curr.next = prev.next;\\n                prev.next = curr;\\n                \\n                curr = nex;\\n                if(curr!=null) nex = curr.next;\\n                prev = dummy;\\n               \\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894149,
                "title": "100-c-insertion-sort-dummy-node-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head)\\n    {\\n        \\n        ListNode *dummynode=new ListNode(0);\\n        dummynode->next=head;\\n        ListNode *curr=head,*prev=dummynode;\\n        while(curr)\\n        {\\n            if((curr->next)&&curr->next->val<curr->val )\\n            {\\n                while((prev->next)&&(prev->next->val<curr->next->val))\\n                {\\n                    prev=prev->next;\\n                }\\n                ListNode *temp=prev->next;\\n                prev->next=curr->next;\\n                curr->next=curr->next->next;\\n                prev->next->next=temp;\\n                prev=dummynode;\\n                \\n            }\\n            else\\n            {\\n                curr=curr->next;\\n            }\\n            \\n        }\\n        \\n        return dummynode->next;\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head)\\n    {\\n        \\n        ListNode *dummynode=new ListNode(0);\\n        dummynode->next=head;\\n        ListNode *curr=head,*prev=dummynode;\\n        while(curr)\\n        {\\n            if((curr->next)&&curr->next->val<curr->val )\\n            {\\n                while((prev->next)&&(prev->next->val<curr->next->val))\\n                {\\n                    prev=prev->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1764181,
                "title": "python-solution-with-explanations",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #use dummy head to make the code more concise\\n        dummy=ListNode()\\n        dummy.next=head\\n        \\n        #head is the tail node of the sorted list (may sound confused)\\n        while head.next:\\n            \\n            #the node to be compared\\n            current=head.next\\n            \\n            #find the insertion position\\n            temp=dummy\\n            while temp.next is not current and temp.next.val<=current.val:\\n                temp=temp.next   \\n            \\n            #the insertion position is after the tail of the sorted list\\n            #which means the node stays put, it becomes \"head\"\\n            if temp.next is current:\\n                head=head.next\\n                \\n            #do insertion\\n            else:\\n                head.next=current.next\\n                current.next=temp.next\\n                temp.next=current\\n                \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #use dummy head to make the code more concise\\n        dummy=ListNode()\\n        dummy.next=head\\n        \\n        #head is the tail node of the sorted list (may sound confused)\\n        while head.next:\\n            \\n            #the node to be compared\\n            current=head.next\\n            \\n            #find the insertion position\\n            temp=dummy\\n            while temp.next is not current and temp.next.val<=current.val:\\n                temp=temp.next   \\n            \\n            #the insertion position is after the tail of the sorted list\\n            #which means the node stays put, it becomes \"head\"\\n            if temp.next is current:\\n                head=head.next\\n                \\n            #do insertion\\n            else:\\n                head.next=current.next\\n                current.next=temp.next\\n                temp.next=current\\n                \\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 1629962,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        currentNode = head\\n        previousNode = None\\n        while currentNode:\\n            if previousNode and previousNode.val > currentNode.val:\\n                # Detach the current node.\\n                detachedNode = currentNode\\n                previousNode.next = currentNode.next\\n                currentNode = currentNode.next\\n                # Attach the detached node at its correct position.\\n\\t\\t\\t\\t# Check whether the detatched node needs to be attached at first position. If yes then update the head also.\\n                if head.val > detachedNode.val:\\n                    detachedNode.next = head\\n                    head = detachedNode\\n                else:\\n\\t\\t\\t\\t\\t# Traverse the list from start and attach the detached node at its correct position.\\n                    tempPreviousNode = head\\n                    tempCurrentNode = head.next\\n                    while tempCurrentNode and tempCurrentNode.val <= detachedNode.val:\\n                        tempPreviousNode = tempCurrentNode\\n                        tempCurrentNode = tempCurrentNode.next\\n                    tempPreviousNode.next = detachedNode\\n                    detachedNode.next = tempCurrentNode                    \\n            else:\\n                previousNode = currentNode\\n                currentNode = currentNode.next\\n        return head\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        currentNode = head\\n        previousNode = None\\n        while currentNode:\\n            if previousNode and previousNode.val > currentNode.val:\\n                # Detach the current node.\\n                detachedNode = currentNode\\n                previousNode.next = currentNode.next\\n                currentNode = currentNode.next\\n                # Attach the detached node at its correct position.\\n\\t\\t\\t\\t# Check whether the detatched node needs to be attached at first position. If yes then update the head also.\\n                if head.val > detachedNode.val:\\n                    detachedNode.next = head\\n                    head = detachedNode\\n                else:\\n\\t\\t\\t\\t\\t# Traverse the list from start and attach the detached node at its correct position.\\n                    tempPreviousNode = head\\n                    tempCurrentNode = head.next\\n                    while tempCurrentNode and tempCurrentNode.val <= detachedNode.val:\\n                        tempPreviousNode = tempCurrentNode\\n                        tempCurrentNode = tempCurrentNode.next\\n                    tempPreviousNode.next = detachedNode\\n                    detachedNode.next = tempCurrentNode                    \\n            else:\\n                previousNode = currentNode\\n                currentNode = currentNode.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629420,
                "title": "c-solution-o-1-space",
                "content": "##### The idea is to create a dummy node that would be the head of the sorted part of the list. Iterate over the given list and one by one add nodes to the sorted list in the appropriate place following the insertion sort algorithm.\\n\\n\\t/**\\n\\t * Definition for singly-linked list.\\n\\t * struct ListNode {\\n\\t *     int val;\\n\\t *     ListNode *next;\\n\\t *     ListNode() : val(0), next(nullptr) {}\\n\\t *     ListNode(int x) : val(x), next(nullptr) {}\\n\\t *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n\\t\\t\\tif(head == nullptr) return head;\\n\\n\\t\\t\\tListNode *a = new ListNode(0);\\n\\t\\t\\tListNode *cur = head;\\n\\t\\t\\tListNode *pre = a;\\n\\t\\t\\tListNode *next = nullptr;\\n\\n\\t\\t\\twhile(cur != nullptr){\\n\\t\\t\\t\\tnext = cur->next;\\n\\t\\t\\t\\twhile(pre->next != nullptr && pre->next->val < cur -> val){\\n\\t\\t\\t\\t\\tpre = pre -> next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcur->next = pre->next;\\n\\t\\t\\t\\tpre->next = cur;\\n\\t\\t\\t\\tpre = a;\\n\\t\\t\\t\\tcur = next;\\n\\t\\t\\t}\\n\\t\\t\\treturn a->next;\\n\\t\\t}\\n\\t};\\n\\t\\n**Complexity**\\n* Time: O(n ^ 2) \\n* Space: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n\\t\\t\\tif(head == nullptr) return head;\\n\\n\\t\\t\\tListNode *a = new ListNode(0);\\n\\t\\t\\tListNode *cur = head;\\n\\t\\t\\tListNode *pre = a;\\n\\t\\t\\tListNode *next = nullptr;\\n\\n\\t\\t\\twhile(cur != nullptr){\\n\\t\\t\\t\\tnext = cur->next;\\n\\t\\t\\t\\twhile(pre->next != nullptr && pre->next->val < cur -> val){\\n\\t\\t\\t\\t\\tpre = pre -> next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1583730,
                "title": "c-easy-insertion-sort",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sorted;\\n    void sortedInsert(ListNode* cur){\\n        if(!sorted || cur->val<sorted->val){\\n            cur->next=sorted;\\n            sorted=cur;\\n        }\\n        else{\\n            ListNode * pre=sorted;\\n            while(pre->next && pre->next->val<cur->val) pre=pre->next;\\n            cur->next=pre->next;\\n            pre->next=cur;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode * cur=head;\\n        sorted=NULL;\\n        while(cur){\\n            ListNode* nxt=cur->next;\\n            sortedInsert(cur);\\n            cur=nxt;\\n        }\\n        return sorted;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sorted;\\n    void sortedInsert(ListNode* cur){\\n        if(!sorted || cur->val<sorted->val){\\n            cur->next=sorted;\\n            sorted=cur;\\n        }\\n        else{\\n            ListNode * pre=sorted;\\n            while(pre->next && pre->next->val<cur->val) pre=pre->next;\\n            cur->next=pre->next;\\n            pre->next=cur;\\n        }\\n    }\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode * cur=head;\\n        sorted=NULL;\\n        while(cur){\\n            ListNode* nxt=cur->next;\\n            sortedInsert(cur);\\n            cur=nxt;\\n        }\\n        return sorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488706,
                "title": "insertion-sort-list-java-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode prev = head;\\n        ListNode curr = prev.next;\\n        \\n        if(head==null || head.next==null) \\n            return head;\\n        \\n        while(curr != null) {\\n            if(curr.val < prev.val) {\\n                prev.next = curr.next;\\n                if(curr.val <= head.val) {\\n                    curr.next = head;\\n                    head = curr;\\n                } else {\\n                    //search starting from the head\\n                    ListNode ptr = head;\\n                    while(ptr.next!=null && ptr.next.val < curr.val)\\n                        ptr = ptr.next;\\n                    ListNode temp = ptr.next;\\n                    ptr.next = curr;\\n                    curr.next = temp;\\n                }\\n                curr = prev.next;\\n            } else {\\n                curr = curr.next;\\n                prev = prev.next;\\n            }\\n        }\\n       return head; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426236,
                "title": "simple-o-1-space-complexity-solution-using-dummy-node",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        \\n        while(head != null) {\\n            ListNode pre = dummy;\\n            \\n            while(pre.next != null && pre.next.val < head.val)\\n                pre = pre.next;\\n            \\n            ListNode temp = head.next;\\n            head.next = pre.next;\\n            pre.next = head;\\n            head = temp;\\n        }\\n        \\n        head = dummy.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        \\n        while(head != null) {\\n            ListNode pre = dummy;\\n            \\n            while(pre.next != null && pre.next.val < head.val)\\n                pre = pre.next;\\n            \\n            ListNode temp = head.next;\\n            head.next = pre.next;\\n            pre.next = head;\\n            head = temp;\\n        }\\n        \\n        head = dummy.next;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386840,
                "title": "java-solution-detail-explanation-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n    if(head==null) return null;\\n    if(head.next==null) return head;\\n     ListNode ptr=head.next;\\n\\t // result is a new list where old elements to be added to new list in sorted way\\n     ListNode result=new ListNode();\\n     result.val=head.val;\\n     ListNode next=result;\\n     ListNode prev=null;\\n    while(ptr!=null)\\n    {\\n        ListNode temp=new ListNode();\\n        temp.val=ptr.val;\\n\\t\\t/*\\n\\t\\tif first element  is smaller than we have to insert at first position in new list( result list)\\n\\t\\teg: old list ->       5->6->7->3->232->45->null\\n\\t\\t    result list->     5->6->null \\n\\t\\t\\t if ptr.val=3 and next.val=5\\n\\t\\t\\t then in result list 3 has to add at beginning of the list\\n\\t\\t*/\\n        if(ptr.val<=next.val)\\n        {\\n            temp.next=next;\\n            next=temp;\\n            result=temp;\\n        }\\n\\t\\t/*\\n\\t\\telse : we have to traverse the list until we find the right postion to insert the  \\n\\t\\t*/\\n        else\\n        {\\n            while(ptr.val>next.val && next.next!=null)\\n            {\\n                prev=next;\\n                next=next.next;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\tif result list is already sorted then we have to insert in at last position \\n\\t\\t\\teg: old list ->   5->10->7->8->12->2->15->null\\n\\t\\t\\t    result list-> 2->5->7->8->10->12->null\\n\\t\\t\\t\\tptr.val=15\\n\\t\\t\\t\\tnext.val=12\\n\\t\\t\\t\\ttherfore\\n\\t\\t\\t\\t if(next.next==null && next.val<=ptr.val)\\n\\t\\t\\t\\t if(next.next==null && 12<=15)\\n\\t\\t\\teg:\\n\\t\\t\\t*/\\n            if(next.next==null && next.val<=ptr.val)\\n            {\\n                next.next=temp;\\n                next=result;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\telse : we have to insert in between place\\n\\t\\t\\told list-> 2->56->4->5->6->778->43->null\\n\\t\\t\\tnew list-> 2->56->null\\n\\t\\t\\tptr.val=4\\n\\t\\t\\tnext.val=56\\n\\t\\t\\tprev is pointing to the one previous node of next because the next pointer can\\'t move to backwards that\\'s y we are maintaining previous pointer\\n\\t\\t\\tprev is pointing to 2\\n\\t\\t\\t*/\\n            else\\n            {\\n                temp.next=prev.next;\\n                prev.next=temp;\\n                next=result;\\n            }\\n        }\\n        \\n        ptr=ptr.next;\\n    }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n    if(head==null) return null;\\n    if(head.next==null) return head;\\n     ListNode ptr=head.next;\\n\\t // result is a new list where old elements to be added to new list in sorted way\\n     ListNode result=new ListNode();\\n     result.val=head.val;\\n     ListNode next=result;\\n     ListNode prev=null;\\n    while(ptr!=null)\\n    {\\n        ListNode temp=new ListNode();\\n        temp.val=ptr.val;\\n\\t\\t/*\\n\\t\\tif first element  is smaller than we have to insert at first position in new list( result list)\\n\\t\\teg: old list ->       5->6->7->3->232->45->null\\n\\t\\t    result list->     5->6->null \\n\\t\\t\\t if ptr.val=3 and next.val=5\\n\\t\\t\\t then in result list 3 has to add at beginning of the list\\n\\t\\t*/\\n        if(ptr.val<=next.val)\\n        {\\n            temp.next=next;\\n            next=temp;\\n            result=temp;\\n        }\\n\\t\\t/*\\n\\t\\telse : we have to traverse the list until we find the right postion to insert the  \\n\\t\\t*/\\n        else\\n        {\\n            while(ptr.val>next.val && next.next!=null)\\n            {\\n                prev=next;\\n                next=next.next;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\tif result list is already sorted then we have to insert in at last position \\n\\t\\t\\teg: old list ->   5->10->7->8->12->2->15->null\\n\\t\\t\\t    result list-> 2->5->7->8->10->12->null\\n\\t\\t\\t\\tptr.val=15\\n\\t\\t\\t\\tnext.val=12\\n\\t\\t\\t\\ttherfore\\n\\t\\t\\t\\t if(next.next==null && next.val<=ptr.val)\\n\\t\\t\\t\\t if(next.next==null && 12<=15)\\n\\t\\t\\teg:\\n\\t\\t\\t*/\\n            if(next.next==null && next.val<=ptr.val)\\n            {\\n                next.next=temp;\\n                next=result;\\n            }\\n\\t\\t\\t/*\\n\\t\\t\\telse : we have to insert in between place\\n\\t\\t\\told list-> 2->56->4->5->6->778->43->null\\n\\t\\t\\tnew list-> 2->56->null\\n\\t\\t\\tptr.val=4\\n\\t\\t\\tnext.val=56\\n\\t\\t\\tprev is pointing to the one previous node of next because the next pointer can\\'t move to backwards that\\'s y we are maintaining previous pointer\\n\\t\\t\\tprev is pointing to 2\\n\\t\\t\\t*/\\n            else\\n            {\\n                temp.next=prev.next;\\n                prev.next=temp;\\n                next=result;\\n            }\\n        }\\n        \\n        ptr=ptr.next;\\n    }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373965,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return head;\\n        ListNode ptr;\\n        int c=0,i,j=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            c++;\\n        }\\n        int a[]=new int[c];\\n        a[0]=head.val;\\n        for(ptr=head.next,i=1;ptr!=null;ptr=ptr.next,i++)\\n        {\\n            j=i-1;\\n            while(j>=0&&ptr.val<a[j])\\n            {\\n                a[j+1]=a[j];\\n                j--;\\n            }\\n            a[j+1]=ptr.val;\\n        }\\n        i=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            ptr.val=a[i++];\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return head;\\n        ListNode ptr;\\n        int c=0,i,j=0;\\n        for(ptr=head;ptr!=null;ptr=ptr.next)\\n        {\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1305310,
                "title": "easy-golang-solution",
                "content": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    arr := []*ListNode{}\\n    cur := head\\n    \\n    for cur != nil {\\n        if len(arr) != 0 && cur.Val < arr[len(arr) - 1].Val {\\n            cur.Val, arr[len(arr) - 1].Val = arr[len(arr) - 1].Val, cur.Val\\n            cur = arr[len(arr) - 1]\\n            arr = arr[:len(arr) - 1]\\n        } else {\\n            arr = append(arr, cur)\\n            cur = cur.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    arr := []*ListNode{}\\n    cur := head\\n    \\n    for cur != nil {\\n        if len(arr) != 0 && cur.Val < arr[len(arr) - 1].Val {\\n            cur.Val, arr[len(arr) - 1].Val = arr[len(arr) - 1].Val, cur.Val\\n            cur = arr[len(arr) - 1]\\n            arr = arr[:len(arr) - 1]\\n        } else {\\n            arr = append(arr, cur)\\n            cur = cur.Next\\n        }\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305104,
                "title": "c-clean-recursive-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *nextFromHead = head -> next;\\n        head -> next = NULL;\\n        ListNode *sortedListHead = insertionSortList(nextFromHead);\\n\\n        int valueToInsert = head -> val;\\n\\n        if(!sortedListHead or sortedListHead -> val >= valueToInsert) {\\n            head -> next = sortedListHead;\\n            return head;\\n        }\\n\\n        ListNode *curr = sortedListHead, *prev = NULL;\\n        while(curr and curr -> val < valueToInsert) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n\\n        prev -> next = head;\\n        head -> next = curr;\\n        return sortedListHead;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *nextFromHead = head -> next;\\n        head -> next = NULL;\\n        ListNode *sortedListHead = insertionSortList(nextFromHead);\\n\\n        int valueToInsert = head -> val;\\n\\n        if(!sortedListHead or sortedListHead -> val >= valueToInsert) {\\n            head -> next = sortedListHead;\\n            return head;\\n        }\\n\\n        ListNode *curr = sortedListHead, *prev = NULL;\\n        while(curr and curr -> val < valueToInsert) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n\\n        prev -> next = head;\\n        head -> next = curr;\\n        return sortedListHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222935,
                "title": "short-c-double-pointer-no-dummy-head-o-1-space",
                "content": "The idea is straightforward, \\n - we stay back one node behine using the double pointer for the nodes we are interested in. \\n - We move the `ptr` forward only when there been no logical swap, otherwise after swap `*ptr` contains the next node to swap automatically.\\n - `fwd` finds the location to insert `t` node\\n\\n```cpp\\nclass Solution {\\npublic:\\n  ListNode *insertionSortList(ListNode *head) {\\n    ListNode **ptr = &head;\\n    ListNode **fwd;\\n\\n    while (*ptr != nullptr) {\\n      // process\\n      fwd = &head;\\n      while (*fwd != *ptr && (*fwd)->val <= (*ptr)->val) {\\n        fwd = &(*fwd)->next;\\n      }\\n      // link\\n      ListNode *t = *ptr;\\n      *ptr = (*ptr)->next;\\n\\n      t->next = *fwd;\\n      *fwd = t;\\n      // move\\n      if (*ptr == *fwd) {\\n          ptr = &(*ptr)->next;\\n      }\\n    }\\n    return head;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  ListNode *insertionSortList(ListNode *head) {\\n    ListNode **ptr = &head;\\n    ListNode **fwd;\\n\\n    while (*ptr != nullptr) {\\n      // process\\n      fwd = &head;\\n      while (*fwd != *ptr && (*fwd)->val <= (*ptr)->val) {\\n        fwd = &(*fwd)->next;\\n      }\\n      // link\\n      ListNode *t = *ptr;\\n      *ptr = (*ptr)->next;\\n\\n      t->next = *fwd;\\n      *fwd = t;\\n      // move\\n      if (*ptr == *fwd) {\\n          ptr = &(*ptr)->next;\\n      }\\n    }\\n    return head;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156410,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        ListNode* start = new  ListNode();\\n        start->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = start;\\n        \\n        while(curr){\\n            if(curr->next && (curr->next->val < curr->val)){\\n                while(prev->next && (prev->next->val < curr->next->val)){\\n                    prev = prev->next;\\n                }\\n                ListNode* temp = prev->next;\\n                prev->next = curr->next;\\n                curr->next = curr->next->next;\\n                prev->next->next = temp;\\n                prev = start;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return start->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        \\n        ListNode* start = new  ListNode();\\n        start->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = start;\\n        \\n        while(curr){\\n            if(curr->next && (curr->next->val < curr->val)){\\n                while(prev->next && (prev->next->val < curr->next->val)){\\n                    prev = prev->next;\\n                }\\n                ListNode* temp = prev->next;\\n                prev->next = curr->next;\\n                curr->next = curr->next->next;\\n                prev->next->next = temp;\\n                prev = start;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return start->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109670,
                "title": "java-small-and-easy-using-recursion-insertion-sort",
                "content": "I browsed through some of the solutions but most were pretty lengthy and difficult to understand.\\nSome of the people have used merge or selection sort and I fail to understand why, since the question is about insertion sort. So here\\'s my solution,\\n\\nIt can be broken down into four steps,\\n\\n1. Calculate length of the list, to start a loop until the end.\\n2. Start a loop from a[i] to a[n]\\n3. Compare element n with it\\'s predecessor and swap if it element n is smaller. \\n4. Repeat 4 until you can\\'t find a  predecessor for swapping(means that element n is at correct spot)\\n\\nQuick notes: \\nCalculate length is easy, just start a loop until head = null\\nYou can achieve 4 via recursion since it is the easiest way to look up your predecessor\\n\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        int count = 0;\\n        int length = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            length++;\\n            current = current.next;\\n        }\\n        while(length > 0){\\n\\t\\t//count is the name for our variable \\'n\\' : used to compare a[i] ... a[n]\\n            compareWithPre(head,count,0);\\n            count++;\\n            length--;\\n        }\\n        return head;\\n    }\\n    \\n\\t\\n\\t//Recursive function to compare current element with predecessor\\n    private void compareWithPre(ListNode list, int current, int count){\\n        if(count == current) return;\\n        compareWithPre(list.next, current, count+1);\\n        if(list.val > list.next.val){\\n            int temp = list.val;\\n            list.val = list.next.val;\\n            list.next.val = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        int count = 0;\\n        int length = 0;\\n        ListNode current = head;\\n        while(current != null){\\n            length++;\\n            current = current.next;\\n        }\\n        while(length > 0){\\n\\t\\t//count is the name for our variable \\'n\\' : used to compare a[i] ... a[n]\\n            compareWithPre(head,count,0);\\n            count++;\\n            length--;\\n        }\\n        return head;\\n    }\\n    \\n\\t\\n\\t//Recursive function to compare current element with predecessor\\n    private void compareWithPre(ListNode list, int current, int count){\\n        if(count == current) return;\\n        compareWithPre(list.next, current, count+1);\\n        if(list.val > list.next.val){\\n            int temp = list.val;\\n            list.val = list.next.val;\\n            list.next.val = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098142,
                "title": "java-solution-2ms",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyHead = new ListNode();\\n        dummyHead.next = head;\\n        ListNode slow = dummyHead.next;\\n        ListNode fast = dummyHead.next.next;\\n        while (fast != null) {\\n            if (fast.val < slow.val) {\\n                // find out where to place\\n                ListNode insertAfter = dummyHead;\\n                while (insertAfter.next.val < fast.val) {\\n                    insertAfter = insertAfter.next;\\n                }\\n                // save temp values\\n                final ListNode recovery = slow;\\n                final ListNode tempFastNext = fast.next;\\n                final ListNode tempInsertAfterNext = insertAfter.next;\\n                // swap\\n                slow.next = tempFastNext;\\n                insertAfter.next = fast; \\n                fast.next = tempInsertAfterNext; \\n                // update next pointers\\n                slow = recovery;\\n                fast = recovery.next;\\n                continue;\\n            }\\n            slow = fast;\\n            fast = fast.next;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyHead = new ListNode();\\n        dummyHead.next = head;\\n        ListNode slow = dummyHead.next;\\n        ListNode fast = dummyHead.next.next;\\n        while (fast != null) {\\n            if (fast.val < slow.val) {\\n                // find out where to place\\n                ListNode insertAfter = dummyHead;\\n                while (insertAfter.next.val < fast.val) {\\n                    insertAfter = insertAfter.next;\\n                }\\n                // save temp values\\n                final ListNode recovery = slow;\\n                final ListNode tempFastNext = fast.next;\\n                final ListNode tempInsertAfterNext = insertAfter.next;\\n                // swap\\n                slow.next = tempFastNext;\\n                insertAfter.next = fast; \\n                fast.next = tempInsertAfterNext; \\n                // update next pointers\\n                slow = recovery;\\n                fast = recovery.next;\\n                continue;\\n            }\\n            slow = fast;\\n            fast = fast.next;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072712,
                "title": "a-c-function-easy-and-clear-to-sort",
                "content": "\\n```\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));\\n\\tnode->next = NULL;\\n\\tstruct ListNode* cur = head;\\n\\tstruct ListNode* prev = node;\\n\\tstruct ListNode* next;\\n\\twhile (cur) {\\n\\t\\twhile (prev->next && prev->next->val < cur->val) {\\n\\t\\t\\tprev = prev->next;\\n\\t\\t}\\n\\t\\tnext = cur->next;\\n\\t\\tcur->next = prev->next;\\n\\t\\tprev->next = cur;\\n\\t\\tcur = next;\\n\\t\\t\\n\\t\\t//fix to first position\\n\\t\\tprev = node;\\n\\t}\\n\\treturn node->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* insertionSortList(struct ListNode* head){\\n    struct ListNode* node = (struct ListNode*)malloc(sizeof(struct ListNode));\\n\\tnode->next = NULL;\\n\\tstruct ListNode* cur = head;\\n\\tstruct ListNode* prev = node;\\n\\tstruct ListNode* next;\\n\\twhile (cur) {\\n\\t\\twhile (prev->next && prev->next->val < cur->val) {\\n\\t\\t\\tprev = prev->next;\\n\\t\\t}\\n\\t\\tnext = cur->next;\\n\\t\\tcur->next = prev->next;\\n\\t\\tprev->next = cur;\\n\\t\\tcur = next;\\n\\t\\t\\n\\t\\t//fix to first position\\n\\t\\tprev = node;\\n\\t}\\n\\treturn node->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924025,
                "title": "8ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }\\n                ListNode* temp = pre -> next;\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = temp;\\n                pre = dummy;\\n            }\\n            else {\\n                cur = cur -> next;\\n            }\\n        }\\n        return dummy -> next; \\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *pre = dummy, *cur = head;\\n        while (cur) {\\n            if ((cur -> next) && (cur -> next -> val < cur -> val)) {\\n                while ((pre -> next) && (pre -> next -> val < cur -> next -> val)) {\\n                    pre = pre -> next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 920408,
                "title": "insertion-sort-list-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *res = new ListNode(INT_MIN);\\n        while(head){\\n            ListNode *dummy = res;\\n            while(dummy->next && dummy->next->val < head->val){\\n                dummy = dummy->next;\\n            }\\n\\t\\t\\t//Swapping two nodes\\n            ListNode *next_node = head->next;\\n            head->next = dummy->next;\\n            dummy->next = head;\\n            head = next_node;\\n            \\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *res = new ListNode(INT_MIN);\\n        while(head){\\n            ListNode *dummy = res;\\n            while(dummy->next && dummy->next->val < head->val){\\n                dummy = dummy->next;\\n            }\\n\\t\\t\\t//Swapping two nodes\\n            ListNode *next_node = head->next;\\n            head->next = dummy->next;\\n            dummy->next = head;\\n            head = next_node;\\n            \\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920399,
                "title": "insertion-sort-list-python",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        s=ListNode()\\n        cur=head\\n        while cur:\\n            n=s\\n            while n.next:\\n                if cur.val<n.next.val:\\n                    new=ListNode(val=cur.val,next=n.next)\\n                    n.next=new\\n                    break\\n                n=n.next\\n            if n.next==None:\\n                new=ListNode(val=cur.val,next=n.next)\\n                n.next=new\\n            cur=cur.next\\n        return s.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        s=ListNode()\\n        cur=head\\n        while cur:\\n            n=s\\n            while n.next:\\n                if cur.val<n.next.val:\\n                    new=ListNode(val=cur.val,next=n.next)\\n                    n.next=new\\n                    break\\n                n=n.next\\n            if n.next==None:\\n                new=ListNode(val=cur.val,next=n.next)\\n                n.next=new\\n            cur=cur.next\\n        return s.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861354,
                "title": "swift-simple-and-clear-100",
                "content": "Thought process:\\n// iterate over the linked list, at each \"node\":\\n// if it is less than prev node:\\n//      connect prev to next\\n//      move this \"node\" to the correct position\\n// else: keep going\\n```\\nfunc insertionSortList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tlet dummy = ListNode(-1)\\n\\tdummy.next = head\\n\\n\\tvar prev = head\\n\\tvar node = head.next\\n\\twhile node != nil {\\n\\t\\tif node!.val < prev.val {\\n\\t\\t\\tprev.next = node!.next\\n\\t\\t\\tinsert(dummy, node!)\\n\\t\\t\\tnode = prev.next\\n\\t\\t} else {\\n\\t\\t\\tprev = node!\\n\\t\\t\\tnode = node!.next\\n\\t\\t}\\n\\t}\\n\\treturn dummy.next\\n}\\n\\nfunc insert(_ head: ListNode, _ insertingNode: ListNode) {\\n\\tvar node = head\\n\\twhile let next = node.next, insertingNode.val > next.val {\\n\\t\\tnode = next\\n\\t}\\n\\tlet next = node.next\\n\\tnode.next = insertingNode\\n\\tinsertingNode.next = next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insertionSortList(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tlet dummy = ListNode(-1)\\n\\tdummy.next = head\\n\\n\\tvar prev = head\\n\\tvar node = head.next\\n\\twhile node != nil {\\n\\t\\tif node!.val < prev.val {\\n\\t\\t\\tprev.next = node!.next\\n\\t\\t\\tinsert(dummy, node!)\\n\\t\\t\\tnode = prev.next\\n\\t\\t} else {\\n\\t\\t\\tprev = node!\\n\\t\\t\\tnode = node!.next\\n\\t\\t}\\n\\t}\\n\\treturn dummy.next\\n}\\n\\nfunc insert(_ head: ListNode, _ insertingNode: ListNode) {\\n\\tvar node = head\\n\\twhile let next = node.next, insertingNode.val > next.val {\\n\\t\\tnode = next\\n\\t}\\n\\tlet next = node.next\\n\\tnode.next = insertingNode\\n\\tinsertingNode.next = next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812288,
                "title": "clean-java-solution-easy-to-understand",
                "content": "```class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        \\n        while (head != null) {\\n            ListNode node = dummy;\\n            while (node.next != null && node.next.val < head.val) {\\n                node = node.next;\\n            }\\n            \\n            ListNode temp = head.next;\\n            head.next = node.next;\\n            node.next = head;\\n            head = temp;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        \\n        while (head != null) {\\n            ListNode node = dummy;\\n            while (node.next != null && node.next.val < head.val) {\\n                node = node.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 628137,
                "title": "java-easy-solution-with-explanation-and-complexity-analysis",
                "content": "This algorithm is a slight modification of insertion sort for arrays, the need of modification arose because linked list can\\'t be traversed backwards, so we need to traverse in forward direction if we want to preserve the O(n^2) time complexity of insertion sort\\n```\\n/* \\n Algorithm steps:\\n 1) traverse list head until head becomes null\\n 2) pass the curr_node to \"sort_forward\" function\\n 3) sort_forward function ->compare the curr_value from head to curr_node and place it to currect position\\n\\n*** time complexity - > O(n^2)\\n*** space complexity -> O(1)\\n*/\\nclass Solution {\\n  \\n   void sort_forward(ListNode head, ListNode curr){\\n        while(head!=curr){\\n            if(head.val > curr.val){\\n                int temp = head.val;\\n                head.val = curr.val;\\n                curr.val = temp;\\n            }\\n            head = head.next;\\n        }\\n    }\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head.next;\\n        while(curr!=null){\\n            sort_forward(head,curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\nNote-> Still if you want to perform insertion sort exactly as we do for arrays, then the worst  case time complexity will be o(n^3) becuase here we have to find the back_pointer in order to traverse backwards and for that we need to traverse from head to current pointer additionally for each if condition where (list(back_ptr) < list(curr_ptr])\\nin the worst case when list is reverse sorted we need to find back_ptr for every current node,\\nhence leading to time complexity O(n^3)",
                "solutionTags": [],
                "code": "```\\n/* \\n Algorithm steps:\\n 1) traverse list head until head becomes null\\n 2) pass the curr_node to \"sort_forward\" function\\n 3) sort_forward function ->compare the curr_value from head to curr_node and place it to currect position\\n\\n*** time complexity - > O(n^2)\\n*** space complexity -> O(1)\\n*/\\nclass Solution {\\n  \\n   void sort_forward(ListNode head, ListNode curr){\\n        while(head!=curr){\\n            if(head.val > curr.val){\\n                int temp = head.val;\\n                head.val = curr.val;\\n                curr.val = temp;\\n            }\\n            head = head.next;\\n        }\\n    }\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head.next;\\n        while(curr!=null){\\n            sort_forward(head,curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528503,
                "title": "go-4ms",
                "content": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    tail := head\\n    cur := head.Next\\n    head.Next = nil\\n    for cur != nil {\\n        node := cur\\n        cur = cur.Next\\n        node.Next = nil\\n        if node.Val > tail.Val {\\n            tail.Next = node\\n            tail = node\\n            continue\\n        }\\n        if node.Val < head.Val {\\n            node.Next = head\\n            head = node\\n            continue\\n        }\\n        prev := head\\n        for prev.Next != nil && prev.Next.Val < node.Val {\\n            prev = prev.Next\\n        }\\n        node.Next = prev.Next\\n        prev.Next = node\\n    }\\n    return head\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc insertionSortList(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n    tail := head\\n    cur := head.Next\\n    head.Next = nil\\n    for cur != nil {\\n        node := cur\\n        cur = cur.Next\\n        node.Next = nil\\n        if node.Val > tail.Val {\\n            tail.Next = node\\n            tail = node\\n            continue\\n        }\\n        if node.Val < head.Val {\\n            node.Next = head\\n            head = node\\n            continue\\n        }\\n        prev := head\\n        for prev.Next != nil && prev.Next.Val < node.Val {\\n            prev = prev.Next\\n        }\\n        node.Next = prev.Next\\n        prev.Next = node\\n    }\\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 412758,
                "title": "python-solution-using-three-pointers",
                "content": "Pointers used:\\n* `end`: the rightmost node that has been sorted.\\n* `runner`: the pointer that iterates every node after `end` for sorting\\n* `put`: the pointer that iterates every node after `end` to find a suitable location for insertion.\\n\\n\\n```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        dummy = ListNode(float(\\'-inf\\'))\\n        dummy.next = head\\n        end = head\\n        runner = end.next\\n        \\n        while runner:\\n            if runner.val >= end.val:\\n                end, runner = runner, runner.next\\n            else:\\n                put = dummy\\n                while put.next.val < runner.val:\\n                    put = put.next\\n\\t\\t\\t\\t# find the location to insert node\\n                \\n                end.next = runner.next\\n                runner.next = put.next\\n                put.next = runner\\n\\t\\t\\t\\t# insert\\n                \\n                runner = end.next\\n\\t\\t\\t\\t# update runner\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        \\n        dummy = ListNode(float(\\'-inf\\'))\\n        dummy.next = head\\n        end = head\\n        runner = end.next\\n        \\n        while runner:\\n            if runner.val >= end.val:\\n                end, runner = runner, runner.next\\n            else:\\n                put = dummy\\n                while put.next.val < runner.val:\\n                    put = put.next\\n\\t\\t\\t\\t# find the location to insert node\\n                \\n                end.next = runner.next\\n                runner.next = put.next\\n                put.next = runner\\n\\t\\t\\t\\t# insert\\n                \\n                runner = end.next\\n\\t\\t\\t\\t# update runner\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343896,
                "title": "java-3ms-easy-to-understand",
                "content": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode frontier=new ListNode(0);\\n        frontier.next=head;\\n        ListNode pre=frontier;\\n        ListNode cur=head;\\n        ListNode insertNode=null;\\n        while(cur.next!=null){\\n            insertNode=cur.next;\\n            /*\\n            Three Conditions to consider:\\n            1. insert node value < pre.value, so insert it to the head\\n            2. insert node value > cur.value, so simply move cur to the next\\n            3. insert node value lies in between pre and cur, use while loop\\n                to find a proper position to insert.\\n            Done!\\n            * */\\n            if(insertNode.val<pre.next.val){ //insert to the head\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n            }\\n            else if(insertNode.val>=cur.val){//insertNode value >= cur\\n                cur=cur.next;\\n            }\\n            else{//insertNode value < cur\\n                while(pre!=cur && pre.next.val<insertNode.val){\\n                    pre=pre.next;\\n                }\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n                pre=frontier;\\n            }\\n        }\\n        return frontier.next;\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode frontier=new ListNode(0);\\n        frontier.next=head;\\n        ListNode pre=frontier;\\n        ListNode cur=head;\\n        ListNode insertNode=null;\\n        while(cur.next!=null){\\n            insertNode=cur.next;\\n            /*\\n            Three Conditions to consider:\\n            1. insert node value < pre.value, so insert it to the head\\n            2. insert node value > cur.value, so simply move cur to the next\\n            3. insert node value lies in between pre and cur, use while loop\\n                to find a proper position to insert.\\n            Done!\\n            * */\\n            if(insertNode.val<pre.next.val){ //insert to the head\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n            }\\n            else if(insertNode.val>=cur.val){//insertNode value >= cur\\n                cur=cur.next;\\n            }\\n            else{//insertNode value < cur\\n                while(pre!=cur && pre.next.val<insertNode.val){\\n                    pre=pre.next;\\n                }\\n                cur.next=insertNode.next;\\n                insertNode.next=pre.next;\\n                pre.next=insertNode;\\n                pre=frontier;\\n            }\\n        }\\n        return frontier.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340625,
                "title": "insertion-sort-python",
                "content": "```class Solution(object):\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        A = head \\n        point = A\\n\\n        while head:\\n            point = head\\n            while point:\\n                if point.val < head.val:\\n                    point.val,head.val = head.val,point.val\\n                else:\\n                    point = point.next\\n            head = head.next \\n        return A",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def insertionSortList(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        A = head \\n        point = A\\n\\n        while head:\\n            point = head\\n            while point:\\n                if point.val < head.val:\\n                    point.val,head.val = head.val,point.val\\n                else:\\n                    point = point.next\\n            head = head.next \\n        return A",
                "codeTag": "Java"
            },
            {
                "id": 46462,
                "title": "22ms-c-o-1-space-solution-with-description",
                "content": "```\\n/*\\nIterate the list, if next node has a larger value than the current node, we proceed. If not, set the\\nnext node that has larger value than the current one as p1. Then assign p1's next to current\\nnode's next, which means bypass p1 node.\\nNow let's insert p1 from the start position of the list. If p1 has value that is smaller than p2 which\\nwas just set as the first node of the current list, let p1 be the first node instead of p2. If not, advance\\np2, and repeat the last step, until we find a node that has larger value than p1.\\n*/\\nListNode* insertionSortList(ListNode* head) {\\n    if (head == NULL || head->next == NULL) return head;\\n    ListNode* p = head;\\n    while (p->next) {\\n        if (p->val <= p->next->val) {\\n            p = p->next;\\n        }\\n        else {\\n            ListNode *p1 = p->next, *p2 = head;\\n            p->next = p->next->next;\\n            if (p1->val < p2->val) {\\n                p1->next = head;\\n                head = p1;\\n            }\\n            else {\\n                while (p1->val > p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n                p1->next = p2->next;\\n                p2->next = p1;\\n            }\\n        }\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIterate the list, if next node has a larger value than the current node, we proceed. If not, set the\\nnext node that has larger value than the current one as p1. Then assign p1's next to current\\nnode's next, which means bypass p1 node.\\nNow let's insert p1 from the start position of the list. If p1 has value that is smaller than p2 which\\nwas just set as the first node of the current list, let p1 be the first node instead of p2. If not, advance\\np2, and repeat the last step, until we find a node that has larger value than p1.\\n*/\\nListNode* insertionSortList(ListNode* head) {\\n    if (head == NULL || head->next == NULL) return head;\\n    ListNode* p = head;\\n    while (p->next) {\\n        if (p->val <= p->next->val) {\\n            p = p->next;\\n        }\\n        else {\\n            ListNode *p1 = p->next, *p2 = head;\\n            p->next = p->next->next;\\n            if (p1->val < p2->val) {\\n                p1->next = head;\\n                head = p1;\\n            }\\n            else {\\n                while (p1->val > p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n                p1->next = p2->next;\\n                p2->next = p1;\\n            }\\n        }\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46504,
                "title": "my-not-so-short-java-code-beats-96-63-easy-to-understand-as-well-it-can-t-get-better-than-this-i-suppose",
                "content": "There are slight modifications which you can do but that will only make code more complex and hard to understand. In the Interview if you write this kind of easy-to-get-along code, your Interviewer might get happy.\\n```\\npublic ListNode insertionSortList(ListNode head) { //Pretty efficient.\\n\\t\\tif (head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\tListNode curr = head;\\n\\t\\tListNode dummy = new ListNode(0);\\n\\t\\tdummy.next = head;\\n\\t\\tListNode first = dummy;\\n\\n\\t\\twhile (curr.next != null) {\\n\\t\\t\\tif (curr.val > curr.next.val) { // All messy stuff but make complete sense if you can think.\\n\\t\\t\\t\\twhile (first.next.val < curr.next.val) \\n\\t\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t\\tListNode node = curr.next; // Some house keeping stuff here.\\n\\t\\t\\t\\tcurr.next = node.next;\\n\\t\\t\\t\\tnode.next = first.next;\\n\\t\\t\\t\\tfirst.next = node;\\n\\t\\t\\t\\tfirst = dummy;\\n\\n\\t\\t\\t} else\\n\\t\\t\\t\\tcurr = curr.next;\\n\\t\\t}\\n\\n\\t\\treturn dummy.next;\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) { //Pretty efficient.\\n\\t\\tif (head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\tListNode curr = head;\\n\\t\\tListNode dummy = new ListNode(0);\\n\\t\\tdummy.next = head;\\n\\t\\tListNode first = dummy;\\n\\n\\t\\twhile (curr.next != null) {\\n\\t\\t\\tif (curr.val > curr.next.val) { // All messy stuff but make complete sense if you can think.\\n\\t\\t\\t\\twhile (first.next.val < curr.next.val) \\n\\t\\t\\t\\t\\tfirst = first.next;\\n\\t\\t\\t\\tListNode node = curr.next; // Some house keeping stuff here.\\n\\t\\t\\t\\tcurr.next = node.next;\\n\\t\\t\\t\\tnode.next = first.next;\\n\\t\\t\\t\\tfirst.next = node;\\n\\t\\t\\t\\tfirst = dummy;\\n\\n\\t\\t\\t} else\\n\\t\\t\\t\\tcurr = curr.next;\\n\\t\\t}\\n\\n\\t\\treturn dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 46487,
                "title": "mark-of-my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        //faked head node \\n        ListNode* res = new ListNode(-1);\\n        ListNode* cur = res;\\n        //head is the current node we are dealing with\\n        while (head) {\\n            ListNode *next = head->next;\\n            cur = res;\\n            while (cur->next && cur->next->val <= head->val) {\\n                cur = cur->next;\\n            }\\n            //insert the head node into the list\\n            head->next = cur->next;\\n            cur->next = head;\\n            //move forward the head node\\n            head = next;\\n        }\\n        return res->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        //faked head node \\n        ListNode* res = new ListNode(-1);\\n        ListNode* cur = res;\\n        //head is the current node we are dealing with\\n        while (head) {\\n            ListNode *next = head->next;\\n            cur = res;\\n            while (cur->next && cur->next->val <= head->val) {\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46538,
                "title": "java-solution-a-little-trick-beats-90",
                "content": "    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head==null||head.next==null)\\n                return head;\\n            ListNode fakeHead=new ListNode(1);\\n            ListNode pre = fakeHead;\\n            \\n            while(head!=null){\\n                // important trick here to avoid scanning from head.\\n                if(pre!=fakeHead && pre.val>head.val) \\n                    pre=fakeHead;\\n                while(pre.next!=null && pre.next.val<head.val){\\n                    pre=pre.next;\\n                }\\n                ListNode cur=head;\\n                head=head.next;\\n                cur.next=pre.next;\\n                pre.next=cur;\\n            }\\n            return fakeHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head==null||head.next==null)\\n                return head;\\n            ListNode fakeHead=new ListNode(1);\\n            ListNode pre = fakeHead;\\n            \\n            while(head!=null){\\n                // important trick here to avoid scanning from head.\\n                if(pre!=fakeHead && pre.val>head.val) \\n                    pre=fakeHead;\\n                while(pre.next!=null && pre.next.val<head.val){\\n                    pre=pre.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46540,
                "title": "my-solution-in-c",
                "content": "My solution in C. I tried to used the most basic syntax. Any suggestion is welcomed and appreciated.    \\n\\n    struct ListNode* insertionSortList(struct ListNode* head) {\\n\\n    \\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n    \\n        struct ListNode *sorted, *preSorted, *unsorted, *next;\\n    \\n        // First node of unsorted list\\n        unsorted = head->next;\\n    \\n        // Separate sorted and unsorted list\\n        head->next = NULL;\\n    \\n        while (unsorted) {\\n    \\n            // Start from head\\n            sorted = head;\\n            preSorted = head;\\n    \\n            next = unsorted->next;\\n    \\n            int cnt = 0;\\n            while (sorted && sorted->val <= unsorted->val)\\n            {\\n                preSorted = sorted;\\n                sorted = sorted->next;\\n    \\n                cnt++;\\n            }\\n    \\n            if (sorted)\\n            {\\n                // Inserted in the front of the sorted list\\n                if (cnt == 0)\\n                {\\n                    head = unsorted;\\n                }\\n                else\\n                {\\n                    preSorted->next = unsorted;\\n                }\\n    \\n                unsorted->next = sorted;\\n    \\n            }\\n            else\\n            {\\n                // Inserted in the end of the sorted list\\n                unsorted->next = NULL;\\n                preSorted->next = unsorted;\\n            }\\n            unsorted = next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "My solution in C. I tried to used the most basic syntax. Any suggestion is welcomed and appreciated.    \\n\\n    struct ListNode* insertionSortList(struct ListNode* head) {\\n\\n    \\n        if (head == NULL || head->next == NULL)\\n        {\\n            return head;\\n        }\\n    \\n        struct ListNode *sorted, *preSorted, *unsorted, *next;\\n    \\n        // First node of unsorted list\\n        unsorted = head->next;\\n    \\n        // Separate sorted and unsorted list\\n        head->next = NULL;\\n    \\n        while (unsorted) {\\n    \\n            // Start from head\\n            sorted = head;\\n            preSorted = head;\\n    \\n            next = unsorted->next;\\n    \\n            int cnt = 0;\\n            while (sorted && sorted->val <= unsorted->val)\\n            {\\n                preSorted = sorted;\\n                sorted = sorted->next;\\n    \\n                cnt++;\\n            }\\n    \\n            if (sorted)\\n            {\\n                // Inserted in the front of the sorted list\\n                if (cnt == 0)\\n                {\\n                    head = unsorted;\\n                }\\n                else\\n                {\\n                    preSorted->next = unsorted;\\n                }\\n    \\n                unsorted->next = sorted;\\n    \\n            }\\n            else\\n            {\\n                // Inserted in the end of the sorted list\\n                unsorted->next = NULL;\\n                preSorted->next = unsorted;\\n            }\\n            unsorted = next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46552,
                "title": "my-24ms-c-solution-one-trick-explained",
                "content": "The insertion sorting is quite trivial: starting from head, insert each node to the new sorted linked list. \\nStep 1) find the inserting position (i.e. move cur to the position just before head)\\nStep 2) insert head node in between of cur and cur->next;\\nStep 3) move head to the next one\\nHere, we use a dummy node to track the head of the sorted list.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            { //go through each node in the list\\n                for(cur = &dummy; cur->next && cur->next->val<head->val; )  cur = cur->next; //step 1\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head; //step 2\\n                head = temp; //step 3\\n            }\\n            return dummy.next;\\n        }\\n    };\\n\\n\\nThe above one has ~80ms performance. One trick to optimize it is that: in the above version, every time we insert a new node, we always search the inserting position from the beginning of the sorted list (i.e. in step1 for(cur = &dummy;...) and that is not neccessary. If the new to-be-inserted node has a value larger than the value of the last inserted node, then that means the inserting position is after the inserting position found in the previous iteration, so we can use cur from the previous iteration directly. So we include  \\n\\n            if(cur->val>head->val) cur = &dummy; // trick, reset cur only when needed\\n\\nto reset cur to the start of the sorted list only when needed. This speeds up the algorithm to 24ms.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            {\\n                if(cur->val>head->val) cur = &dummy; // trick, reset cur only when needed\\n                for(; cur->next && cur->next->val<head->val; ) \\n                    cur = cur->next;\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head;\\n                head = temp;\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(INT_MIN), *cur=&dummy, *temp;\\n            while(head)\\n            { //go through each node in the list\\n                for(cur = &dummy; cur->next && cur->next->val<head->val; )  cur = cur->next; //step 1\\n                temp = head->next; \\n                head->next = cur->next;\\n                cur->next =head; //step 2\\n                head = temp; //step 3\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46565,
                "title": "9ms-java-solution",
                "content": "    public class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null) return head;\\n            ListNode current = head.next;\\n            ListNode pre = head;\\n            while(current !=null){\\n                if(current.val>=pre.val){\\n                    current = current.next;\\n                    pre = pre.next;\\n                }\\n                else{\\n                    pre.next = current.next;\\n                    if(current.val<=head.val){ //current value smaller than smallest value in the examined list\\n                        //insert current to the beginning\\n                        current.next = head;\\n                        head = current;\\n                    }\\n                    else{\\n                        ListNode search = head;\\n                        while(search.next != null && search.next.val<current.val){\\n                            search = search.next;\\n                        }\\n                        //insert current between search and search.next\\n                        ListNode tmp = search.next;\\n                        search.next = current;\\n                        current.next = tmp;\\n                    }\\n                    current = pre.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode insertionSortList(ListNode head) {\\n            if(head == null) return head;\\n            ListNode current = head.next;\\n            ListNode pre = head;\\n            while(current !=null){\\n                if(current.val>=pre.val){\\n                    current = current.next;\\n                    pre = pre.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46578,
                "title": "detail-java-solution-with-complexity-analysis",
                "content": "    /**\\n     * Time complexity: BEST CASE : COMPLETELY ASCENDING/DESENDING ORDER --> O(n)\\n     *                  WORST CASE : EVERY TIME INSERT JUST BEFORE THE MAX NODE\\n     *                               0+1+2+....+(n-1) --> O((n2-n)/2) --> O(n2)\\n     * Memory complexity: In-place --> O(1)\\n     */\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n        //EDGE CASE\\n        if(head==null || head.next==null) return head;\\n        \\n        //INIT NODES\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode max = head; //CURRENT MAX VALUE NODE (TAIL)\\n        \\n        //INSERTION SORT\\n        while(cur!=null){\\n            while(cur!=null && cur.val>=max.val){ //SKIP ACSENDING SEQUENCE AND UPDATE THE MAX NODE\\n                max = cur;\\n                cur = cur.next;\\n            }\\n            if(cur==null) break;\\n            \\n            ListNode temp = cur.next; //STORE THE NEXT NODE BEFORE INSERTION\\n            if(dummy.next.val>cur.val){ // INSERT BEFORE HEAD NODE, THIS NODE BECOMES NEW HEAD\\n                cur.next = dummy.next;\\n                dummy.next = cur;\\n            }else{\\n                ListNode pre = dummy.next;\\n                while(pre.next!=null){\\n                    if(cur.val>=pre.val && cur.val<=pre.next.val){ //INSERT BETWEEN HEAD AND MAX NODE\\n                        cur.next = pre.next;\\n                        pre.next = cur;\\n                        break;\\n                    }\\n                    pre = pre.next;\\n                }\\n            }\\n            cur = temp;  //UPDATE POINTERS HERE, REALLY IMPORTANT, OTHERWISE YOU'LL END UP WITH A INFINITE LOOP!\\n            max.next = temp;\\n        }\\n        \\n        //RETURN HEAD\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "    /**\\n     * Time complexity: BEST CASE : COMPLETELY ASCENDING/DESENDING ORDER --> O(n)\\n     *                  WORST CASE : EVERY TIME INSERT JUST BEFORE THE MAX NODE\\n     *                               0+1+2+....+(n-1) --> O((n2-n)/2) --> O(n2)\\n     * Memory complexity: In-place --> O(1)\\n     */\\n    public ListNode insertionSortList(ListNode head) {\\n        \\n        //EDGE CASE\\n        if(head==null || head.next==null) return head;\\n        \\n        //INIT NODES\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode max = head; //CURRENT MAX VALUE NODE (TAIL)\\n        \\n        //INSERTION SORT\\n        while(cur!=null){\\n            while(cur!=null && cur.val>=max.val){ //SKIP ACSENDING SEQUENCE AND UPDATE THE MAX NODE\\n                max = cur;\\n                cur = cur.next;\\n            }\\n            if(cur==null) break;\\n            \\n            ListNode temp = cur.next; //STORE THE NEXT NODE BEFORE INSERTION\\n            if(dummy.next.val>cur.val){ // INSERT BEFORE HEAD NODE, THIS NODE BECOMES NEW HEAD\\n                cur.next = dummy.next;\\n                dummy.next = cur;\\n            }else{\\n                ListNode pre = dummy.next;\\n                while(pre.next!=null){\\n                    if(cur.val>=pre.val && cur.val<=pre.next.val){ //INSERT BETWEEN HEAD AND MAX NODE\\n                        cur.next = pre.next;\\n                        pre.next = cur;\\n                        break;\\n                    }\\n                    pre = pre.next;\\n                }\\n            }\\n            cur = temp;  //UPDATE POINTERS HERE, REALLY IMPORTANT, OTHERWISE YOU'LL END UP WITH A INFINITE LOOP!\\n            max.next = temp;\\n        }\\n        \\n        //RETURN HEAD\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 46450,
                "title": "python-again-how-to-improve-so-that-run-time-will-be-below-500ms",
                "content": "After lots of TLE, I modified the post from [jianchao.li.fighter][1] as below, but it still took about 1664ms.\\n\\nI saw lots of people were in the \"<500ms group\", how did you do that!?\\nCould someone give me a hint? Thanks a lot!\\n\\n    class Solution:\\n\\t# @param {ListNode} head\\n\\t# @return {ListNode}\\n\\tdef insertionSortList(self, head):\\n\\t\\tnewhead = ListNode(0)\\n\\t\\tnewhead.next = head\\n\\t\\tpre, cur = newhead, head\\n\\t\\twhile cur:\\n\\t\\t\\tif cur.next and cur.next.val < cur.val:\\n\\t\\t\\t\\twhile pre.next and pre.next.val < cur.next.val:\\n\\t\\t\\t\\t\\tpre = pre.next\\n\\t\\t\\t\\ttmp = pre.next\\n\\t\\t\\t\\tpre.next = cur.next\\n\\t\\t\\t\\tcur.next = cur.next.next\\n\\t\\t\\t\\tpre.next.next = tmp\\n\\t\\t\\t\\tpre = newhead\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur = cur.next\\n\\t\\treturn newhead.next\\n\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/37574/explained-c-solution-24ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t# @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 46581,
                "title": "python-accepted-iterative-solution-another-solution-is-about-330ms",
                "content": "suppose already sorted the part from the second node, then just need to merge the first node with the second part, if head.val is smaller, then the second can be connected behind head node, if head.val is larger than the value of the returned node, then we need to find the position to insert head, and return the returned node. The iterative method is quite easy to follow, when we find the node's value is smaller than that of the previous node, we need to find an insertion position for that node in positions ahead.\\n        \\n    # Recursively, TLE (Why?)\\n    def insertionSortList1(self, head):\\n        if not head or not head.next:\\n            return head\\n        second = self.insertionSortList(head.next)\\n        if head.val <= second.val:\\n            head.next = second\\n            return head\\n        else:\\n            tmp = pre = second\\n            while second and second.val < head.val:\\n                pre = second\\n                second = second.next\\n            head.next = second\\n            pre.next = head\\n            return tmp\\n    \\n    # Iteratively         \\n    def insertionSortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = node = head\\n        while node.next:\\n            if node.val <= node.next.val:\\n                node = node.next\\n            else:\\n                pre = dummy\\n                while pre.next.val < node.next.val:\\n                    pre = pre.next\\n                tmp = node.next\\n                node.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "suppose already sorted the part from the second node, then just need to merge the first node with the second part, if head.val is smaller, then the second can be connected behind head node, if head.val is larger than the value of the returned node, then we need to find the position to insert head, and return the returned node. The iterative method is quite easy to follow, when we find the node's value is smaller than that of the previous node, we need to find an insertion position for that node in positions ahead.\\n        \\n    # Recursively, TLE (Why?)\\n    def insertionSortList1(self, head):\\n        if not head or not head.next:\\n            return head\\n        second = self.insertionSortList(head.next)\\n        if head.val <= second.val:\\n            head.next = second\\n            return head\\n        else:\\n            tmp = pre = second\\n            while second and second.val < head.val:\\n                pre = second\\n                second = second.next\\n            head.next = second\\n            pre.next = head\\n            return tmp\\n    \\n    # Iteratively         \\n    def insertionSortList(self, head):\\n        if not head or not head.next:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = node = head\\n        while node.next:\\n            if node.val <= node.next.val:\\n                node = node.next\\n            else:\\n                pre = dummy\\n                while pre.next.val < node.next.val:\\n                    pre = pre.next\\n                tmp = node.next\\n                node.next = tmp.next\\n                tmp.next = pre.next\\n                pre.next = tmp\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 46593,
                "title": "24-ms-c-clear",
                "content": "Idea: inserting is only necessary if p->val is smaller than val of previous node, otherwise we do nothing but keep moving.\\n\\n    class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n    \\n            if(head && head->next)\\n            {\\n                ListNode* pre = head;\\n                ListNode* p = head->next;\\n                while(p)\\n                {\\n                    if(p->val < pre->val)               //inserting only if necessary\\n                    {\\n                        ListNode* pp = &dummy;          //locate where to insert\\n                        while((pp->next->val < p->val)) //pp won't exceed pre, so no valid check\\n                            pp = pp->next;\\n\\n                    \\t//inserting\\n                    \\tpre->next = p->next;\\n                        p->next = pp->next;\\n                        pp->next = p;\\n                    }\\n                    else\\n                        pre = p;                    \\t//no inserting, keep moving\\n                        \\n                    p = pre->next;\\n                }\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n    \\n            if(head && head->next)\\n            {\\n                ListNode* pre = head;\\n                ListNode* p = head->next;\\n                while(p)\\n                {\\n                    if(p->val < pre->val)               //inserting only if necessary\\n                    {\\n                        ListNode* pp = &dummy;          //locate where to insert\\n                        while((pp->next->val < p->val)) //pp won't exceed pre, so no valid check\\n                            pp = pp->next;\\n\\n                    \\t//inserting\\n                    \\tpre->next = p->next;\\n                        p->next = pp->next;\\n                        pp->next = p;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 46613,
                "title": "my-c-solution",
                "content": "    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if (!head || !head->next) return head;\\n    \\t\\tListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\thead = front;                            // insert head node\\n    \\t\\tListNode* pos = head->next;\\n    \\t\\twhile (pos->next){\\n    \\t\\t\\tListNode* prev = pos->next;\\n    \\t\\t\\tif (prev->val < pos->val){\\n    \\t\\t\\t\\tListNode* loop_pos = head;\\n    \\t\\t\\t\\twhile (prev->val >= loop_pos->next->val) loop_pos = loop_pos->next;\\n    \\t\\t\\t\\tpos->next = prev->next;\\n    \\t\\t\\t\\tprev->next = loop_pos->next;\\n    \\t\\t\\t\\tloop_pos->next = prev;\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tpos = prev;\\n    \\t\\t}\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "    public:\\n        ListNode* insertionSortList(ListNode* head) {\\n            if (!head || !head->next) return head;\\n    \\t\\tListNode* front = new ListNode(0);\\n    \\t\\tfront->next = head;\\n    \\t\\thead = front;                            // insert head node\\n    \\t\\tListNode* pos = head->next;\\n    \\t\\twhile (pos->next){\\n    \\t\\t\\tListNode* prev = pos->next;\\n    \\t\\t\\tif (prev->val < pos->val){\\n    \\t\\t\\t\\tListNode* loop_pos = head;\\n    \\t\\t\\t\\twhile (prev->val >= loop_pos->next->val) loop_pos = loop_pos->next;\\n    \\t\\t\\t\\tpos->next = prev->next;\\n    \\t\\t\\t\\tprev->next = loop_pos->next;\\n    \\t\\t\\t\\tloop_pos->next = prev;\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tpos = prev;\\n    \\t\\t}\\n    \\t\\treturn front->next;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 46614,
                "title": "my-c-in-place-solution-o-1-space-o-n-2-29-ms-time-one-trick-to-speed-up-sorting",
                "content": "There are two tricks here to simplify the programming\\n1) use a dummy node to track the new link head;\\n2) always save the last sorted val (i.e. prev). check if the current unsorted node has a value larger than \"prev\", if so, we just need to search the current insert position from the previous insert position (start); otherwise, let's search from the beginning (Dummy)\\n \\n\\n       class Solution {\\n        public:\\n            ListNode* insertionSortList(ListNode* head) {\\n                ListNode Dummy(INT_MIN); // dummy node to track the new head\\n                ListNode *start = &Dummy, *temp; // the insert position\\n                int prev = INT_MAX; // the value of the last sorted node\\n    \\n                while(head) \\n                {   \\n                    if(prev > head->val) start = &Dummy; // if the last sorted node has a larger value than the current one, then we have to search from the beginning\\n                    prev = head->val;// update prev to the current node value\\n                    while(start->next && start->next->val <= head->val) start = start->next; // search the insert position\\n                    temp = start->next;\\n                    start->next = head;\\n                    head = head->next;\\n                    start->next->next = temp;\\n                }\\n                return Dummy.next;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* insertionSortList(ListNode* head) {\\n                ListNode Dummy(INT_MIN); // dummy node to track the new head\\n                ListNode *start = &Dummy, *temp; // the insert position\\n                int prev = INT_MAX; // the value of the last sorted node\\n    \\n                while(head) \\n                {   \\n                    if(prev > head->val) start = &Dummy; // if the last sorted node has a larger value than the current one, then we have to search from the beginning\\n                    prev = head->val;// update prev to the current node value\\n                    while(start->next && start->next->val <= head->val) start = start->next; // search the insert position\\n                    temp = start->next;\\n                    start->next = head;\\n                    head = head->next;\\n                    start->next->next = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 46625,
                "title": "the-python-time-limit-does-not-make-sense",
                "content": "Here is my code:\\n\\n    def insertionSortList(head):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        last = p = q = dummy\\n        while p and p.next:\\n            q = dummy if p.next.val < last.next.val else last\\n            while q != p and q.next and q.next.val < p.next.val:\\n                q = q.next\\n               \\n            #insert\\n            if p != q:\\n                print('swap',p.val, q.val)\\n                tmp  = p.next\\n                p.next = tmp.next\\n                tmp.next = q.next\\n                q.next = tmp\\n            else:\\n                p = p.next\\n            last = q\\n            \\n    \\n        return dummy.next\\n\\nI have some optimization to reduce the run time and the algorithm becomes linear time in extreme case like below:\\n\\n    0,6,5,4,3,2,1\\n    swap 6 0\\n    0,5,6,4,3,2,1\\n    swap 6 0\\n    0,4,5,6,3,2,1\\n    swap 6 0\\n    0,3,4,5,6,2,1\\n    swap 6 0\\n    0,2,3,4,5,6,1\\n    swap 6 0\\n    0,1,2,3,4,5,6\\n\\n\\nHowever, I still get TLE for the 5000 to 1 test case. Notice that the algo is O(n) time for this special case. Does it make any sense to further optimize this algo? No. In my whole life, I never see any case that sorting with linked list and a O(n^2) algorithm should be absolutely enough.",
                "solutionTags": [],
                "code": "Here is my code:\\n\\n    def insertionSortList(head):\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        last = p = q = dummy\\n        while p and p.next:\\n            q = dummy if p.next.val < last.next.val else last\\n            while q != p and q.next and q.next.val < p.next.val:\\n                q = q.next\\n               \\n            #insert\\n            if p != q:\\n                print('swap',p.val, q.val)\\n                tmp  = p.next\\n                p.next = tmp.next\\n                tmp.next = q.next\\n                q.next = tmp\\n            else:\\n                p = p.next\\n            last = q\\n            \\n    \\n        return dummy.next\\n\\nI have some optimization to reduce the run time and the algorithm becomes linear time in extreme case like below:\\n\\n    0,6,5,4,3,2,1\\n    swap 6 0\\n    0,5,6,4,3,2,1\\n    swap 6 0\\n    0,4,5,6,3,2,1\\n    swap 6 0\\n    0,3,4,5,6,2,1\\n    swap 6 0\\n    0,2,3,4,5,6,1\\n    swap 6 0\\n    0,1,2,3,4,5,6\\n\\n\\nHowever, I still get TLE for the 5000 to 1 test case. Notice that the algo is O(n) time for this special case. Does it make any sense to further optimize this algo? No. In my whole life, I never see any case that sorting with linked list and a O(n^2) algorithm should be absolutely enough.",
                "codeTag": "Python3"
            },
            {
                "id": 46663,
                "title": "concise-solution-in-c",
                "content": "\\n    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n            if(head == NULL || head->next == NULL)\\n                return head;\\n                \\n            ListNode dummy(INT_MIN);\\n            dummy.next = head;\\n            head = &dummy;\\n            \\n            ListNode *p = head->next;\\n            head->next = NULL;\\n            \\n            while(p)\\n            {\\n                ListNode *nextP = p->next;\\n                p->next = NULL;\\n                \\n                ListNode *pre = head;\\n                while(pre->next && pre->next->val <= p->val)\\n                    pre = pre->next;\\n                \\n                p->next = pre->next;\\n                pre->next = p;\\n                \\n                p = nextP;\\n            }\\n            \\n            return head->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n            if(head == NULL || head->next == NULL)\\n                return head;\\n                \\n            ListNode dummy(INT_MIN);\\n            dummy.next = head;\\n            head = &dummy;\\n            \\n            ListNode *p = head->next;\\n            head->next = NULL;\\n            \\n            while(p)\\n            {\\n                ListNode *nextP = p->next;\\n                p->next = NULL;\\n                \\n                ListNode *pre = head;\\n                while(pre->next && pre->next->val <= p->val)\\n                    pre = pre->next;\\n                \\n                p->next = pre->next;\\n                pre->next = p;\\n                \\n                p = nextP;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 46630,
                "title": "accepted-insertion-sort-list",
                "content": "    class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n        if(!head) return NULL;\\n    \\t\\n    \\t// add new node with INT_MIN\\n    \\tListNode* newHead = new ListNode(INT_MIN);\\n    \\tnewHead->next = head;\\n    \\n    \\t// loop every node\\n    \\tfor(ListNode*p = head->next, *prep = head; p; prep = p, p=p->next)\\n    \\t{\\n    \\t    // insert them to the right position of link list\\n    \\t\\tfor(ListNode * cur = newHead; cur->next!=p; cur = cur->next)\\n    \\t\\t{\\n    \\t\\t\\tif (cur->next->val > p->val)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// insert between cur * cur->next\\n    \\t\\t\\t\\tprep->next = p->next;\\n    \\t\\t\\t\\tp->next = cur->next;\\n    \\t\\t\\t\\tcur->next = p;\\n    \\t\\t\\t\\tp = prep;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tListNode* result = newHead->next;\\n    \\tdelete newHead;\\n    \\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *insertionSortList(ListNode *head) {\\n            \\n        if(!head) return NULL;\\n    \\t\\n    \\t// add new node with INT_MIN\\n    \\tListNode* newHead = new ListNode(INT_MIN);\\n    \\tnewHead->next = head;\\n    \\n    \\t// loop every node\\n    \\tfor(ListNode*p = head->next, *prep = head; p; prep = p, p=p->next)\\n    \\t{\\n    \\t    // insert them to the right position of link list\\n    \\t\\tfor(ListNode * cur = newHead; cur->next!=p; cur = cur->next)\\n    \\t\\t{\\n    \\t\\t\\tif (cur->next->val > p->val)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\t// insert between cur * cur->next\\n    \\t\\t\\t\\tprep->next = p->next;\\n    \\t\\t\\t\\tp->next = cur->next;\\n    \\t\\t\\t\\tcur->next = p;\\n    \\t\\t\\t\\tp = prep;\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3926559,
                "title": "straightforward-typescript-solution",
                "content": "# Intuition\\nWhen thinking about sorting a linked list using insertion sort, the approach is similar to sorting an array, with a few modifications to handle the linked list data structure. The goal is to start with an initially empty sorted list and repeatedly insert nodes from the input list into their correct position in the sorted list.\\n\\n# Approach\\n1. **Initialization**: Create a new result node to act as the start of the sorted list.\\n2. **Traversal**: For every node in the original list:\\nFirst, save the next node for future iterations.\\nIdentify where the node fits in the sorted list. If the node to be inserted has a value smaller than the current node in the sorted list or if we\\'re inserting for the first time, reset the pointer to start from the result node.\\nOnce the correct position is found, insert the node.\\n3. After completing the process, the node following the result node will be the head of our sorted list.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - In the worst case, for each node in the original list, we may have to traverse the entire sorted list. Here, n is the number of nodes in the list.\\n- Space complexity:$$O(n)$$ - We are reusing the nodes from the original list and only using a constant amount of extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n    if (!head || !head.next) return head;\\n\\n    const result = new ListNode(0);\\n    let currentElement: ListNode | null = head;\\n    let prevInsertNode: ListNode | null = null;\\n\\n    while (currentElement) {\\n        let nextElement: ListNode | null = currentElement.next;\\n\\n        // Reset the pointer if the current node needs to be inserted before the previous insertion point\\n        if (!prevInsertNode || prevInsertNode.val > currentElement.val) {\\n            prevInsertNode = result;\\n        }\\n\\n        // Find the correct insertion position\\n        while (prevInsertNode.next && prevInsertNode.next.val < currentElement.val) {\\n            prevInsertNode = prevInsertNode.next;\\n        }\\n\\n        // Insert current node\\n        currentElement.next = prevInsertNode.next;\\n        prevInsertNode.next = currentElement;\\n\\n        // Move to the next node in the original list\\n        currentElement = nextElement;\\n    }\\n\\n    return result.next;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction insertionSortList(head: ListNode | null): ListNode | null {\\n    if (!head || !head.next) return head;\\n\\n    const result = new ListNode(0);\\n    let currentElement: ListNode | null = head;\\n    let prevInsertNode: ListNode | null = null;\\n\\n    while (currentElement) {\\n        let nextElement: ListNode | null = currentElement.next;\\n\\n        // Reset the pointer if the current node needs to be inserted before the previous insertion point\\n        if (!prevInsertNode || prevInsertNode.val > currentElement.val) {\\n            prevInsertNode = result;\\n        }\\n\\n        // Find the correct insertion position\\n        while (prevInsertNode.next && prevInsertNode.next.val < currentElement.val) {\\n            prevInsertNode = prevInsertNode.next;\\n        }\\n\\n        // Insert current node\\n        currentElement.next = prevInsertNode.next;\\n        prevInsertNode.next = currentElement;\\n\\n        // Move to the next node in the original list\\n        currentElement = nextElement;\\n    }\\n\\n    return result.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508725,
                "title": "147-insertion-sort-list-java",
                "content": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        while(head!=null)\\n        {\\n            ListNode next=head.next,temp=dummy;\\n            while(temp.next!=null&&temp.next.val<head.val)\\n                temp=temp.next;\\n                head.next=temp.next;\\n                temp.next=head;\\n                head=next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        while(head!=null)\\n        {\\n            ListNode next=head.next,temp=dummy;\\n            while(temp.next!=null&&temp.next.val<head.val)\\n                temp=temp.next;\\n                head.next=temp.next;\\n                temp.next=head;\\n                head=next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415311,
                "title": "easy-recurseive-solution-comments-included-c-insertion-sort-easy-solution",
                "content": "# Approach \\n-> we work on first Node other Node handle by recursion \\n-> // recursive part \\n-> recursion return the new head of updated sorted list\\n-> // calcution part \\n-> we insert  the first node into the new Updated list\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n// base case if 1 node or zero node \\n        if(head == NULL|| head->next ==NULL){\\n            return head;\\n        }\\n        ListNode*temp = head;\\n        ListNode*prev = NULL;\\n// recuresive function -> return updated sorted head of newList\\n       ListNode *newhead = insertionSortList(head->next);\\n        ListNode*it = newhead;\\n\\n// insert first node with updated new list\\n        while(it != NULL){\\n            // find position of first node \\n            if(it->val < temp->val){\\n                prev = it;\\n                it = it->next;\\n            }else{\\n// first node is the smallest Node among all nodes then it would be our head node \\n                if(prev==NULL){\\n                    temp->next = it;\\n                    newhead = temp;\\n                  \\n                }else{\\n// insert first node  between the new list \\n                    prev ->next = temp;\\n                    temp->next = it;\\n                    }\\n                    break;\\n            }\\n        }\\n// first node is greatest among all nodes then it should be inserted in last \\n        if(it == NULL){\\n            prev->next = temp;\\n            temp ->next = it; \\n        }\\n\\n\\n\\n        return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n// base case if 1 node or zero node \\n        if(head == NULL|| head->next ==NULL){\\n            return head;\\n        }\\n        ListNode*temp = head;\\n        ListNode*prev = NULL;\\n// recuresive function -> return updated sorted head of newList\\n       ListNode *newhead = insertionSortList(head->next);\\n        ListNode*it = newhead;\\n\\n// insert first node with updated new list\\n        while(it != NULL){\\n            // find position of first node \\n            if(it->val < temp->val){\\n                prev = it;\\n                it = it->next;\\n            }else{\\n// first node is the smallest Node among all nodes then it would be our head node \\n                if(prev==NULL){\\n                    temp->next = it;\\n                    newhead = temp;\\n                  \\n                }else{\\n// insert first node  between the new list \\n                    prev ->next = temp;\\n                    temp->next = it;\\n                    }\\n                    break;\\n            }\\n        }\\n// first node is greatest among all nodes then it should be inserted in last \\n        if(it == NULL){\\n            prev->next = temp;\\n            temp ->next = it; \\n        }\\n\\n\\n\\n        return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312884,
                "title": "easy-to-understand-and-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null && head.next == null) return head;\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode curr = head;\\n        ListNode numInsert, prev;\\n\\n        while(curr != null && curr.next != null) {\\n            if(curr.val <= curr.next.val) {\\n                curr = curr.next;\\n            } else {\\n                numInsert = curr.next; // numInsert -> the smaller value which needs to be its correct position\\n                prev = dummy; // prev -> this indicate the position where numInsert will be inserted\\n                while(prev.next.val < numInsert.val) {\\n                    prev = prev.next;\\n                }\\n                curr.next = numInsert.next;\\n                numInsert.next = prev.next;\\n                prev.next = numInsert;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null && head.next == null) return head;\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode curr = head;\\n        ListNode numInsert, prev;\\n\\n        while(curr != null && curr.next != null) {\\n            if(curr.val <= curr.next.val) {\\n                curr = curr.next;\\n            } else {\\n                numInsert = curr.next; // numInsert -> the smaller value which needs to be its correct position\\n                prev = dummy; // prev -> this indicate the position where numInsert will be inserted\\n                while(prev.next.val < numInsert.val) {\\n                    prev = prev.next;\\n                }\\n                curr.next = numInsert.next;\\n                numInsert.next = prev.next;\\n                prev.next = numInsert;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267590,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> temp;\\n        ListNode* p = head;\\n        while(p){\\n            temp.push_back(p->val);\\n            p = p->next;\\n        }\\n        sort(temp.begin() , temp.end());\\n        p = head;\\n        int i=0;\\n        while(p){\\n            p->val = temp[i++];\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        res=[]\\n        while(temp):\\n            res.append(temp.val)\\n            temp=temp.next\\n        res.sort()\\n        print(res)\\n        new=head\\n        i=0\\n        while new:             # fill the sorted values\\n            new.val = res[i]  \\n            i += 1\\n            new = new.next\\n        return head\\n```\\n\\n```Java []\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null || head.next == null){\\n       \\treturn head;\\n       }\\n\\n       ListNode mid = getMid(head);\\n       ListNode left = insertionSortList(head);\\n       ListNode right = insertionSortList(mid);\\n\\n       return merge(left,right);\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummyHead = new ListNode();\\n        ListNode tail = dummyHead;\\n        while (list1 != null && list2 != null) {\\n            if (list1.val < list2.val) {\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            } else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyHead.next;\\n    }\\n\\n    ListNode getMid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        vector<int> temp;\\n        ListNode* p = head;\\n        while(p){\\n            temp.push_back(p->val);\\n            p = p->next;\\n        }\\n        sort(temp.begin() , temp.end());\\n        p = head;\\n        int i=0;\\n        while(p){\\n            p->val = temp[i++];\\n            p = p->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp=head\\n        res=[]\\n        while(temp):\\n            res.append(temp.val)\\n            temp=temp.next\\n        res.sort()\\n        print(res)\\n        new=head\\n        i=0\\n        while new:             # fill the sorted values\\n            new.val = res[i]  \\n            i += 1\\n            new = new.next\\n        return head\\n```\n```Java []\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if(head == null || head.next == null){\\n       \\treturn head;\\n       }\\n\\n       ListNode mid = getMid(head);\\n       ListNode left = insertionSortList(head);\\n       ListNode right = insertionSortList(mid);\\n\\n       return merge(left,right);\\n    }\\n    ListNode merge(ListNode list1, ListNode list2) {\\n        ListNode dummyHead = new ListNode();\\n        ListNode tail = dummyHead;\\n        while (list1 != null && list2 != null) {\\n            if (list1.val < list2.val) {\\n                tail.next = list1;\\n                list1 = list1.next;\\n                tail = tail.next;\\n            } else {\\n                tail.next = list2;\\n                list2 = list2.next;\\n                tail = tail.next;\\n            }\\n        }\\n        tail.next = (list1 != null) ? list1 : list2;\\n        return dummyHead.next;\\n    }\\n\\n    ListNode getMid(ListNode head) {\\n        ListNode midPrev = null;\\n        while (head != null && head.next != null) {\\n            midPrev = (midPrev == null) ? head : midPrev.next;\\n            head = head.next.next;\\n        }\\n        ListNode mid = midPrev.next;\\n        midPrev.next = null;\\n        return mid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206878,
                "title": "c-linked-list-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1; i<v.size(); i++){\\n            int j=i;\\n            while(j && v[j]<v[j-1]){\\n                swap(v[j], v[j-1]);\\n                j--;\\n            }\\n        }\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1; i<v.size(); i++){\\n            int j=i;\\n            while(j && v[j]<v[j-1]){\\n                swap(v[j], v[j-1]);\\n                j--;\\n            }\\n        }\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068110,
                "title": "explained-simple-approach-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple insertion sort logic used.\\nWe maintain an \\'ans\\' linked list and append new elements every iteration and we append it by traversing through it and placing where it would belong in a sorted order. \\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* ans=new ListNode(INT_MIN);\\n        ListNode* curans=ans;\\n        ListNode* cur=head;\\n        while(cur){\\n            while(curans->next && cur->val>curans->next->val) curans=curans->next;\\n            ListNode* tmp=curans->next;\\n            curans->next=new ListNode(cur->val); \\n            curans->next->next=tmp;\\n            cur=cur->next;curans=ans;\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        if(!head) return NULL;\\n        ListNode* ans=new ListNode(INT_MIN);\\n        ListNode* curans=ans;\\n        ListNode* cur=head;\\n        while(cur){\\n            while(curans->next && cur->val>curans->next->val) curans=curans->next;\\n            ListNode* tmp=curans->next;\\n            curans->next=new ListNode(cur->val); \\n            curans->next->next=tmp;\\n            cur=cur->next;curans=ans;\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054670,
                "title": "lself-explanatory-code-can-be-solved-in-basic-steps",
                "content": "//We will solve the above question using the following steps\\nStep 1->travers the whole list and get the elements into the vector\\nStep 2->new perform the insertion sort on the above vector\\nStep 3->Now create the Linked list with the above vector\\nStep 4->Now finally return the head of the new linked list formed\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummynode=new ListNode(-1);\\n        ListNode *temp=head;\\n        vector<int>arr;\\n        while(temp!=NULL){\\n         arr.push_back(temp->val);\\n         temp=temp->next;\\n        }\\n\\n        //Here we will perform the insertion sort\\n      for(int j=1;j<arr.length();j++){\\n          int current=arr[j];\\n        int i=j-1;\\nwhile(i>-1 and arr[i]>current){\\n    arr[i+1]=arr[i];\\n       i--;\\n      }\\n\\n   arr[i+1]=current;\\n      }\\n\\n        ListNode *newtemp=dummynode;\\n        for(int i=0;i<arr.size();i++){\\n            newtemp->next=new ListNode(arr[i]);\\n            newtemp=newtemp->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode *dummynode=new ListNode(-1);\\n        ListNode *temp=head;\\n        vector<int>arr;\\n        while(temp!=NULL){\\n         arr.push_back(temp->val);\\n         temp=temp->next;\\n        }\\n\\n        //Here we will perform the insertion sort\\n      for(int j=1;j<arr.length();j++){\\n          int current=arr[j];\\n        int i=j-1;\\nwhile(i>-1 and arr[i]>current){\\n    arr[i+1]=arr[i];\\n       i--;\\n      }\\n\\n   arr[i+1]=current;\\n      }\\n\\n        ListNode *newtemp=dummynode;\\n        for(int i=0;i<arr.size();i++){\\n            newtemp->next=new ListNode(arr[i]);\\n            newtemp=newtemp->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029672,
                "title": "java-o-1-memory-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head.next == null) return head;\\n        ListNode headNew = head, tempOuter = head.next, lastInner = headNew, prevOuter = head;\\n        while (tempOuter != null) {\\n            ListNode tempOuterCopy = tempOuter;\\n            tempOuter = tempOuter.next;\\n            if (lastInner.val > tempOuterCopy.val) {\\n                if (tempOuterCopy.val < headNew.val) {\\n                    if (headNew.next != null && headNew.next.equals(tempOuterCopy)) {\\n                        headNew.next = null;\\n                    }\\n                    tempOuterCopy.next = headNew;\\n                    headNew = tempOuterCopy;\\n                } else {\\n                    ListNode fromHead = headNew, prevInner = headNew;\\n                    while (fromHead != null) {\\n                        if (tempOuterCopy.val < fromHead.val) {\\n                            prevInner.next = tempOuterCopy;\\n                            tempOuterCopy.next = fromHead;\\n                            if (fromHead.next != null && fromHead.next.equals(tempOuterCopy)) fromHead.next = null;\\n                            break;\\n                        }\\n                        prevInner = fromHead;\\n                        fromHead = fromHead.next;\\n                    }\\n                }\\n            } else {\\n                tempOuterCopy.next = null;\\n                lastInner.next = tempOuterCopy;\\n                lastInner = lastInner.next;\\n            }\\n        }\\n        return headNew;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        if (head.next == null) return head;\\n        ListNode headNew = head, tempOuter = head.next, lastInner = headNew, prevOuter = head;\\n        while (tempOuter != null) {\\n            ListNode tempOuterCopy = tempOuter;\\n            tempOuter = tempOuter.next;\\n            if (lastInner.val > tempOuterCopy.val) {\\n                if (tempOuterCopy.val < headNew.val) {\\n                    if (headNew.next != null && headNew.next.equals(tempOuterCopy)) {\\n                        headNew.next = null;\\n                    }\\n                    tempOuterCopy.next = headNew;\\n                    headNew = tempOuterCopy;\\n                } else {\\n                    ListNode fromHead = headNew, prevInner = headNew;\\n                    while (fromHead != null) {\\n                        if (tempOuterCopy.val < fromHead.val) {\\n                            prevInner.next = tempOuterCopy;\\n                            tempOuterCopy.next = fromHead;\\n                            if (fromHead.next != null && fromHead.next.equals(tempOuterCopy)) fromHead.next = null;\\n                            break;\\n                        }\\n                        prevInner = fromHead;\\n                        fromHead = fromHead.next;\\n                    }\\n                }\\n            } else {\\n                tempOuterCopy.next = null;\\n                lastInner.next = tempOuterCopy;\\n                lastInner = lastInner.next;\\n            }\\n        }\\n        return headNew;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955643,
                "title": "o-n-2-real-insertion-sort-logic",
                "content": "# Intuition\\n- Take one dummy parent\\n- Do range sort from dummy parent till the current head position\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyParent = new ListNode(0, head);\\n        ListNode headParent = dummyParent;\\n        while(head != null) {\\n            headParent = sort(dummyParent.next, head, dummyParent, headParent);\\n            head = headParent.next;\\n        }\\n        return dummyParent.next;\\n    }\\n    \\n    ListNode sort(ListNode start, ListNode end, ListNode startParent, ListNode endParent) {\\n        while(start != null && start != end) {\\n            if(end.val < start.val) {\\n                startParent.next = end;\\n                ListNode tempNode = end.next;\\n                end.next = start;\\n                endParent.next = tempNode;\\n                return endParent;\\n            }\\n            startParent = start;\\n            start = start.next;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode dummyParent = new ListNode(0, head);\\n        ListNode headParent = dummyParent;\\n        while(head != null) {\\n            headParent = sort(dummyParent.next, head, dummyParent, headParent);\\n            head = headParent.next;\\n        }\\n        return dummyParent.next;\\n    }\\n    \\n    ListNode sort(ListNode start, ListNode end, ListNode startParent, ListNode endParent) {\\n        while(start != null && start != end) {\\n            if(end.val < start.val) {\\n                startParent.next = end;\\n                ListNode tempNode = end.next;\\n                end.next = start;\\n                endParent.next = tempNode;\\n                return endParent;\\n            }\\n            startParent = start;\\n            start = start.next;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533618,
                "title": "easy-to-understand-java-solution",
                "content": "Lets take an example to understand what the code below does.\\n\\n\\t\\t4 -> 2 -> 1 -> 3\\n\\t\\nAlso, as we know, in Insertion sort, we have a sorted sub-list to which we compare each element and then put it in its correct place. Initially, we assume that the first element is at correct place. We will do the same here.\\n\\nSo we first have a dummy node that will sit before the sorted sub-list because there may be cases when we want to put the node at first place in sorted list. \\n\\n\\t\\t\\tThis is our sorted list in the beginning\\n\\t\\t\\t0 -> null\\n\\nWe start traversing our linked list. And because we want to compare each node value to every node in the sorted list, that means for each iteration, we need a pointer that start from the beginning of sorted list. That\\'s why we do pointer = sorted inside the loop.\\n\\t\\t\\nSo our pointer always points to dummy node of sorted list in each iteration.\\n\\nFor first node i..e, node 4, since pointer.next is null, the node is simply attached to the sorted list. \\n\\t      \\n\\t\\t  0 -> 4 -> null\\n\\nFor the second node i.e., node 2\\n\\nWe have another while loop which will compare each node value of sorted list with the current head node\\'s value (until we reach the end of sorted list). If the value of a node in sorted list is less than value of head node, that means move ahead. Otherwise, if the value of a node in sorted list is greater than value of head node, that means we want to put our head node between pointer and pointer.next;\\n\\nSo, head node\\'s value = 2.\\n\\npointer points to dummy node. So we start comparing pointer.next.val and head node\\'s val\\n\\n\\t  0 -> 4 -> null      head node\\'s val = 2\\n         pointer          Since 4 > 2 the 2nd condition in while loop becomes false and we come out of loop.\\n\\t     .next\\n\\nSo, we put our node 1 between node 0 and node 4 i.e., between pointer and pointer.next.\\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 2 -> 4 -> null\\n\\t\\t\\t\\t\\nNext we have node 1. Again, we start with pointer pointing to dummy node 0. Then our loop runs and we find that node 2\\'s value > node 1\\'st value\\n\\nSo that means we have to place node 1 between node 0 and node 2. \\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 1 -> 2 -> 4 -> null\\n\\nFinally, we have node 3. The inner loop runs.\\n pointer points to node 0\\n is 1 < 3 ? YES. Move to next node. pointer points to node 1\\n is 2 < 3 ? YES. Move to next node. pointer points to node 2\\n is 4 < 3? NO! come out of the loop.\\n \\n So, we have to put node 3 between pointer and pointer.next. i..e, between node 2 and node 4\\n\\nSorted list becomes - \\n\\t\\t\\t\\n\\t\\t\\t\\t0 -> 1 -> 2 -> 3 -> 4 -> null\\n\\t\\t\\t\\t\\nAnd our first loop ends as well since we reached the end of linked list. Hence, we return the sorted.next list (because we don\\'t want to return dummy node).\\n\\n```\\npublic ListNode insertionSortList(ListNode head) {\\n        \\n        //If linked list has only one node\\n        if(head.next == null) return head;\\n        \\n        //The sorted linked list\\n        ListNode sorted = new ListNode(0);        \\n        while(head != null){\\n\\n            ListNode pointer = sorted;\\n            /* \\n            For the first node, pointer.next is null so this loop does not run and we simply attach\\n            first node to the sorted list, just how we do in insertion sort where we assume that first number \\n            is already at correct place\\n            */\\n            while(pointer.next != null && pointer.next.val < head.val){\\n                pointer = pointer.next;\\n            }\\n            \\n            ListNode next = head.next;\\n            \\n            //Put the head node between pointer & pointer.next\\n            head.next = pointer.next;\\n            pointer.next = head;\\n            \\n            head = next;\\n        }\\n        \\n\\n        return sorted.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode insertionSortList(ListNode head) {\\n        \\n        //If linked list has only one node\\n        if(head.next == null) return head;\\n        \\n        //The sorted linked list\\n        ListNode sorted = new ListNode(0);        \\n        while(head != null){\\n\\n            ListNode pointer = sorted;\\n            /* \\n            For the first node, pointer.next is null so this loop does not run and we simply attach\\n            first node to the sorted list, just how we do in insertion sort where we assume that first number \\n            is already at correct place\\n            */\\n            while(pointer.next != null && pointer.next.val < head.val){\\n                pointer = pointer.next;\\n            }\\n            \\n            ListNode next = head.next;\\n            \\n            //Put the head node between pointer & pointer.next\\n            head.next = pointer.next;\\n            pointer.next = head;\\n            \\n            head = next;\\n        }\\n        \\n\\n        return sorted.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502138,
                "title": "simple-insertion-sort-java-and-c",
                "content": "```\\nListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = head,prev= dummy;\\n        \\n        while(curr!=null)\\n        {\\n            if(curr.next!=null && curr.next.val<curr.val)\\n            {\\n             while(prev!=null && prev.next.val<curr.next.val)\\n             prev = prev.next;\\n                \\n             ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = dummy;\\n            }\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = head,prev= dummy;\\n        \\n        while(curr!=null)\\n        {\\n            if(curr.next!=null && curr.next.val<curr.val)\\n            {\\n             while(prev!=null && prev.next.val<curr.next.val)\\n             prev = prev.next;\\n                \\n             ListNode temp = prev.next;\\n                prev.next = curr.next;\\n                curr.next = curr.next.next;\\n                prev.next.next = temp;\\n                prev = dummy;\\n            }\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474623,
                "title": "python-easiest-insertion-sort",
                "content": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        prev, curr = head,head.next\\n        # we can\\'t go back so keep a previous pointer \\n        \\n        while curr:\\n            if curr.val >= prev.val:\\n                prev = curr\\n                curr = curr.next\\n                continue\\n            temp =  dummy\\n            while curr.val > temp.next.val:\\n                temp = temp.next\\n                \\n            prev.next = curr.next\\n            curr.next = temp.next\\n            temp.next = curr\\n            curr = prev.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        prev, curr = head,head.next\\n        # we can\\'t go back so keep a previous pointer \\n        \\n        while curr:\\n            if curr.val >= prev.val:\\n                prev = curr\\n                curr = curr.next\\n                continue\\n            temp =  dummy\\n            while curr.val > temp.next.val:\\n                temp = temp.next\\n                \\n            prev.next = curr.next\\n            curr.next = temp.next\\n            temp.next = curr\\n            curr = prev.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473229,
                "title": "c-easy-with-explanation-on-page",
                "content": "![image](https://assets.leetcode.com/users/images/50e9da0c-cdda-4252-939d-267e7e66e8c2_1661344219.442962.jpeg)\\n![image](https://assets.leetcode.com/users/images/9c9301dc-92e9-42d6-b41e-3eef8ab7625b_1661344231.2653544.jpeg)\\n![image](https://assets.leetcode.com/users/images/0ee51937-704b-41e0-9032-9add372dd74c_1661344246.0958636.jpeg)\\n\\n\\t private:\\n    void insert(ListNode* &head,  ListNode* node )\\n    {\\n        ListNode* temp = head;\\n        while(temp->next!=NULL && temp->next->val < node->val)\\n        {\\n            temp  = temp->next;\\n        }\\n        node->next = temp->next;\\n        temp->next = node;\\n    }\\n    \\n    \\n    \\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n         ListNode* temp = NULL;\\n        \\n        ListNode* newhead = new ListNode(-1);\\n        \\n        while(head!=NULL)\\n        {\\n            temp = head;\\n            head = head->next;\\n            temp->next = NULL;\\n            insert(newhead, temp);\\n        }\\n        return newhead->next;\\n    }\\n\\t\\n**hope u find it helpful.  considering upvote : )**\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/50e9da0c-cdda-4252-939d-267e7e66e8c2_1661344219.442962.jpeg)\\n![image](https://assets.leetcode.com/users/images/9c9301dc-92e9-42d6-b41e-3eef8ab7625b_1661344231.2653544.jpeg)\\n![image](https://assets.leetcode.com/users/images/0ee51937-704b-41e0-9032-9add372dd74c_1661344246.0958636.jpeg)\\n\\n\\t private:\\n    void insert(ListNode* &head,  ListNode* node )\\n    {\\n        ListNode* temp = head;\\n        while(temp->next!=NULL && temp->next->val < node->val)\\n        {\\n            temp  = temp->next;\\n        }\\n        node->next = temp->next;\\n        temp->next = node;\\n    }\\n    \\n    \\n    \\n\\tpublic:\\n\\t\\tListNode* insertionSortList(ListNode* head) {\\n         ListNode* temp = NULL;\\n        \\n        ListNode* newhead = new ListNode(-1);\\n        \\n        while(head!=NULL)\\n        {\\n            temp = head;\\n            head = head->next;\\n            temp->next = NULL;\\n            insert(newhead, temp);\\n        }\\n        return newhead->next;\\n    }\\n\\t\\n**hope u find it helpful.  considering upvote : )**\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2449684,
                "title": "c-o-1-space",
                "content": "```\\nListNode* insertionSort(ListNode* head)\\n    {\\n        ListNode* ptr=head->next;\\n        while(ptr)\\n        {\\n            ListNode* ptr2=head;\\n            while(ptr2!=ptr)\\n            {\\n                if(ptr->val<ptr2->val)\\n                    swap(ptr->val,ptr2->val);\\n                ptr2=ptr2->next;\\n            }\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* insertionSort(ListNode* head)\\n    {\\n        ListNode* ptr=head->next;\\n        while(ptr)\\n        {\\n            ListNode* ptr2=head;\\n            while(ptr2!=ptr)\\n            {\\n                if(ptr->val<ptr2->val)\\n                    swap(ptr->val,ptr2->val);\\n                ptr2=ptr2->next;\\n            }\\n            ptr=ptr->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406756,
                "title": "easy-cpp",
                "content": "ListNode *p=head,*q;\\n        while(p!=NULL)\\n        {\\n            q=p->next;\\n            while(q!=NULL)\\n            {\\n                if(p->val>q->val)\\n            {\\n                    int temp=q->val;\\n                   q->val=p->val;\\n                  p->val=temp;\\n                \\n            }\\n            else\\n                q=q->next;\\n            } \\n            p=p->next;\\n        }\\n        return head;\\n",
                "solutionTags": [],
                "code": "ListNode *p=head,*q;\\n        while(p!=NULL)\\n        {\\n            q=p->next;\\n            while(q!=NULL)\\n            {\\n                if(p->val>q->val)\\n            {\\n                    int temp=q->val;\\n                   q->val=p->val;\\n                  p->val=temp;\\n                \\n            }\\n            else\\n                q=q->next;\\n            } \\n            p=p->next;\\n        }\\n        return head;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2360422,
                "title": "o-1-space-java-c",
                "content": "**Code in Java**\\n```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        ListNode temp = new ListNode(-5001);\\n        ListNode prev = temp;\\n        while(cur != null){\\n            ListNode nxt = cur.next;\\n            if(prev.val >= cur.val)\\n                prev = temp;\\n            while(prev.next != null && prev.next.val < cur.val)\\n                prev = prev.next;\\n            cur.next = prev.next;\\n            prev.next = cur;\\n            cur = nxt;\\n        }\\n        return temp.next;\\n    }\\n}\\n```\\n\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* temp = new ListNode(-5001);\\n        ListNode* prev = temp;\\n        while(cur){\\n            ListNode* nxt = cur->next;\\n            if(prev->val >= cur->val)\\n                prev = temp;\\n            while(prev->next && prev->next->val < cur->val)\\n                prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            cur = nxt;\\n        }\\n        return temp->next;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution helpful**\\n*Feel free to ask any questions*\\n*Happy Coding :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n        ListNode cur = head;\\n        ListNode temp = new ListNode(-5001);\\n        ListNode prev = temp;\\n        while(cur != null){\\n            ListNode nxt = cur.next;\\n            if(prev.val >= cur.val)\\n                prev = temp;\\n            while(prev.next != null && prev.next.val < cur.val)\\n                prev = prev.next;\\n            cur.next = prev.next;\\n            prev.next = cur;\\n            cur = nxt;\\n        }\\n        return temp.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode* cur = head;\\n        ListNode* temp = new ListNode(-5001);\\n        ListNode* prev = temp;\\n        while(cur){\\n            ListNode* nxt = cur->next;\\n            if(prev->val >= cur->val)\\n                prev = temp;\\n            while(prev->next && prev->next->val < cur->val)\\n                prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            cur = nxt;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333312,
                "title": "python-insertion-sort-simple-insertion-sort",
                "content": "* extract all the values from the linked list in a list\\n* sort it using insertion sort or can use any sort i personally think it is not the actual way of solving it but a fruitful way to solve it\\n* now replace all the sorted node values in linked list \\n```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        nums = []\\n        while temp:\\n            nums.append(temp.val)\\n            temp = temp.next\\n        \\n        for i in range(len(nums)):\\n            key = nums[i]\\n            j = i- 1\\n            while j >= 0 and nums[j] > key:\\n                nums[j+1] = nums[j]\\n                j -=1\\n            nums[j+1] = key\\n            \\n        i = 0\\n        temp = head\\n        while temp:\\n            temp.val = nums[i]\\n            i += 1\\n            temp = temp.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\ndef insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        temp = head\\n        nums = []\\n        while temp:\\n            nums.append(temp.val)\\n            temp = temp.next\\n        \\n        for i in range(len(nums)):\\n            key = nums[i]\\n            j = i- 1\\n            while j >= 0 and nums[j] > key:\\n                nums[j+1] = nums[j]\\n                j -=1\\n            nums[j+1] = key\\n            \\n        i = 0\\n        temp = head\\n        while temp:\\n            temp.val = nums[i]\\n            i += 1\\n            temp = temp.next\\n        return head\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1564621,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1565721,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1567473,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571320,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571319,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568975,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1991471,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1576090,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568974,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 2076512,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1564621,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1565721,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1567473,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571320,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1571319,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568975,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1991471,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1576090,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 1568974,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            },
            {
                "id": 2076512,
                "content": [
                    {
                        "username": "Han_V",
                        "content": "One of the quotes is \\n\\n> For God's sake, don't try sorting a linked list during the interview\\n\\nhttp://steve-yegge.blogspot.nl/2008/03/get-that-job-at-google.html\\n\\nSo it might be better to actually copy the values into an array and sort them there."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insertion-sort-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Insertion Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Petersburg",
                        "content": "^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                    },
                    {
                        "username": "zhenx76",
                        "content": "On the insertion sort algorithm, I wrote a typical algorithm that takes O(n^2) worst case. Initially I used Python, and it gave me a TLE when the input list is big (5000 sorted elements). Later I rewrote the exact algorithm in C++ and it was accepted.\\n\\nI understand Python will be slower being interpreted language and all. But hasn't OJ taken that into consideration and scale the criteria accordingly?"
                    },
                    {
                        "username": "soapcn",
                        "content": "I have been searching for a while but it looks like most solutions require scanning the list from beginning to figure out where to insert. However doing this will not take advantage of a almost sorted/already sorted list. Because the list is singly-linked, there is no way to traverse/do comparison backwards into the partially sorted list. Maybe building another doubly-linked list to use space to trade off time is worth it on large lists? Just some thoughts after seeing problems with TLE using Python."
                    },
                    {
                        "username": "justyu",
                        "content": "if it has a head pointer node, the head node need not to be sorted,\\nOr the first node is the given parameter and need to be sorted.\\n\\nI think it should be told in the question."
                    },
                    {
                        "username": "nitintrivedi",
                        "content": "I am wondering, should I sort by value or sort by node\\nSorting by Node will be too much work that will require exchanging nodes and updating their respective neighbors !!"
                    },
                    {
                        "username": "dragoniz3",
                        "content": "Insertion operation is better in linked list than in arrays.\\nThis is the main point this question wants to test.\\n\\nComparison of various operations on linked lists and arrays.\\ninsertion\\n\\nsearch : if sorted then arrays can utilize binary search. Else both will use linear search.\\ndeletion: arrays - linear, ll - constant\\ncreation: arrays - contiguous, ll - non-contiguous\\nread - arrays - constant, ll - linear\\nupdate - arrays - constant, ll - linear because first need to access it."
                    },
                    {
                        "username": "wyd855",
                        "content": "if we use len() it will return the following error:\\nTypeError: object of type 'NoneType' has no len()\\nSo my question is for singly-linked list like this:\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nHow can we calculate the length?"
                    },
                    {
                        "username": "cwillett77",
                        "content": "\"...and growing a sorted output list.\" umm...did you trying watering it? *rimshot* \\n\\nThis may sound pedantic, but since I am a paying customer, I am more apt to continue my subscription if a little more effort went into writing clear descriptions. This is a really tiny example and by no means a blocker. I have seen vast improvements over the last year or so. The grammar and even spelling used to be really bad, but there\\'s still room for improvement as the problem may not be entirely clear if it\\'s poorly written. And with access to ChatGPT, there\\'s really no excuse for writing that is not clear or easy to read. For example, the first sentence didn\\'t really make sense, even though I knew what the author was trying to say. A less experienced developer looking at their first LC problem, might be like \"WTF?\" and leave and never come back. When I asked ChatGPT to improve it (which took almost no effort), it spit this out in response: \\n\"Insertion sort iterates, consuming one input element per iteration to build a sorted output list.\"\\n\\nA subtle change and yet so much better. I think if you\\'re not going to hire a good editor, at least leverage AI to check your writing. [end of grumpy old man rant, \"get off my lawn,\" etc]\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Strobogrammatic Number II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566770,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1567455,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1567236,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1573329,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1571490,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1571489,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            },
            {
                "id": 1779240,
                "content": [
                    {
                        "username": "stevenye",
                        "content": "For example,\\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].\\n\\nI'm just wondering why \"00\" is not a Strobogrammatic Number.\\n\\nThanks!"
                    },
                    {
                        "username": "jribbink",
                        "content": "leading zeroes not valid, it\\'s an edge case"
                    },
                    {
                        "username": "myaliasname3333",
                        "content": "\\'1001\\' is a Strobogrammatic number but not \\'00\\', why?"
                    },
                    {
                        "username": "rs1122",
                        "content": "no leading zeroes. they say it in the description."
                    },
                    {
                        "username": "zhyd",
                        "content": "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\\n\\nSo \"0\" must be that kind of number. However, it does not appear in the correct answers."
                    },
                    {
                        "username": "rache",
                        "content": "Why is 101101 not correct for n = 6?"
                    },
                    {
                        "username": "hydrofuel",
                        "content": "Input:\\n2\\nOutput:\\n[\"11\",\"69\",\"88\",\"96\"]\\nExpected:\\n[\"11\",\"69\",\"88\",\"96\"]"
                    },
                    {
                        "username": "magma917",
                        "content": "My result is:\\n[\"100001\",\"101101\",\"106901\",\"108801\",\"109601\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"601109\",\"606909\",\"608809\",\"609609\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"801108\",\"806908\",\"808808\",\"809608\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"901106\",\"906906\",\"908806\",\"909606\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nBut the given result is:\\n[\"100001\",\"110011\",\"111111\",\"116911\",\"118811\",\"119611\",\"160091\",\"161191\",\"166991\",\"168891\",\"169691\",\"180081\",\"181181\",\"186981\",\"188881\",\"189681\",\"190061\",\"191161\",\"196961\",\"198861\",\"199661\",\"600009\",\"610019\",\"611119\",\"616919\",\"618819\",\"619619\",\"660099\",\"661199\",\"666999\",\"668899\",\"669699\",\"680089\",\"681189\",\"686989\",\"688889\",\"689689\",\"690069\",\"691169\",\"696969\",\"698869\",\"699669\",\"800008\",\"810018\",\"811118\",\"816918\",\"818818\",\"819618\",\"860098\",\"861198\",\"866998\",\"868898\",\"869698\",\"880088\",\"881188\",\"886988\",\"888888\",\"889688\",\"890068\",\"891168\",\"896968\",\"898868\",\"899668\",\"900006\",\"910016\",\"911116\",\"916916\",\"918816\",\"919616\",\"960096\",\"961196\",\"966996\",\"968896\",\"969696\",\"980086\",\"981186\",\"986986\",\"988886\",\"989686\",\"990066\",\"991166\",\"996966\",\"998866\",\"999666\"]\\n\\nI wonder why numbers such as 101101 is not valid?"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Beautiful problem!"
                    }
                ]
            }
        ]
    }
]