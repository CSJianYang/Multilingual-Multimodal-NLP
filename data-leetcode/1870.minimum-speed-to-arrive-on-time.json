[
    {
        "title": "Coloring A Border",
        "question_content": "You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.\nTwo squares are called adjacent if they are next to each other in any of the 4 directions.\nTwo squares belong to the same connected component if they have the same color and they are adjacent.\nThe border of a connected component is all the squares in the connected component that are either adjacent to (at least) a square not in the component, or on the boundary of the grid (the first or last row or column).\nYou should color the border of the connected component that contains the square grid[row][col] with color.\nReturn the final grid.\n&nbsp;\nExample 1:\nInput: grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\nOutput: [[3,3],[3,2]]\nExample 2:\nInput: grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\nOutput: [[1,3,3],[2,3,3]]\nExample 3:\nInput: grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\nOutput: [[2,2,2],[2,1,2],[2,2,2]]\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j], color <= 1000\n\t0 <= row < m\n\t0 <= col < n",
        "solutions": [
            {
                "id": 282847,
                "title": "c-with-picture-dfs",
                "content": "From an initial point, perform DFS and flip the cell color to negative to track visited cells.\\n\\nAfter DFS is complete for the cell, check if this cell is inside. If so, flip its color back to the positive.\\n\\nIn the end, cells with the negative color are on the border. Change their color to the target color.\\n![image](https://assets.leetcode.com/users/votrubac/image_1556425139.png)\\n```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282839,
                "title": "python-bfs-and-dfs",
                "content": "**Python, DFS:**\\n\\nSuggested by @IvanaGyro, we can color the border inside the DFS.\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n**Python, BFS:**\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]):\\n                return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4:\\n                grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else:\\n                    border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 284935,
                "title": "java-dfs-easy-to-understand",
                "content": "The primary intuition is to do a DFS from the starting cell and find all the cells of the oldColor that needs to be changed. We mark these cells with a negative value of the oldColor. Once this is done, we need to find out which among those cells lies interior and which lies exterior. Interior cells have all 4 neighboring cells(top, bottom, left and right) to have either the oldColor value or -oldColor value. Make these interior cells positive again. Once we have processed this for all necessary nodes from the starting cell, we will get a grid containing negative cells that denote the boundary. We need to sweep through the entire grid and change these negative values to the new color.\\n\\n* Check for existence of null or empty grid and return null if so.\\n* Store the color of starting cell grid[r0][c0] in oldColor.\\n* Initiate a DFS from starting cell.\\n* Check if the current cell lies out of bounds off the grid or if current cell does not have the same color as starting cell and return if so.\\n* Otherwise, change the current cell\\'s color to a negative value for us to remember that we have processed this cell.\\n* Do a DFS for all neighboring points that are up, down, left and right from current cell.\\n* Once DFS returns back for the current cell after processing all directions from it, change the current cell\\'s color back to positive value if you find that the current cell lies within adjacent cells top, bottom, left and right with the same value.\\n* Once the entire DFS has been processed, we now have a grid containing negative values representing the border which needs to be recolored to the new color.\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid == null || grid.length == 0)\\n            return null;\\n        int oldColor = grid[r0][c0];\\n        dfs(grid, r0, c0, oldColor);\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int oldColor) {\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != oldColor) \\n            return;\\n        grid[i][j] = -oldColor;\\n        dfs(grid, i+1, j, oldColor);\\n        dfs(grid, i-1, j, oldColor);\\n        dfs(grid, i, j+1, oldColor);\\n        dfs(grid, i, j-1, oldColor);\\n        if(i > 0 && j > 0 && i < grid.length-1 && j < grid[0].length-1\\n           && oldColor == Math.abs(grid[i+1][j])\\n           && oldColor == Math.abs(grid[i-1][j])\\n           && oldColor == Math.abs(grid[i][j+1])\\n           && oldColor == Math.abs(grid[i][j-1]))\\n            grid[i][j] = oldColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693958,
                "title": "java-recursive-dfs-beats-100-time-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[r0][c0]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid, r0, c0, grid[r0][c0], visited, color, n, m);\\n        \\n        return grid;\\n        \\n    }\\n    \\n    public void dfs(int[][] grid, int i, int j, int col, boolean[][] visited, int target, int n, int m){\\n        \\n        if (i>n-1 || i<0 || j>m-1 || j<0 || grid[i][j]!=col || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n        \\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=col || grid[i-1][j]!=col || grid[i][j-1]!=col || grid[i][j+1]!=col)\\n            border = true;\\n        \\n        dfs(grid, i+1, j, col, visited, target, n, m);\\n        dfs(grid, i-1, j, col, visited, target, n, m);\\n        dfs(grid, i, j+1, col, visited, target, n, m);\\n        dfs(grid, i, j-1, col, visited, target, n, m);\\n        \\n        if (border)\\n            grid[i][j] = target;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283262,
                "title": "java-python-3-bfs-and-dfs-codes-w-brief-explanation-and-analysis",
                "content": "**Method 1**:\\n\\n**BFS**\\n\\n1. Let m = grid.length, n = grid[0].length, use the number \\nfrom 0 to m * n - 1 to identify the cells to avoid duplicates;\\ne.g., grid[x][y]\\'s cell number is x * n + y; \\n2. put the initial cell [r0, c0] into the Queue then poll it out,\\nthen check if it is on the grid bounday; If yes, color the cell;\\n3. Traverse the cell\\'s 4 neighbors: \\na) if its neighbor is of different color, the cell is on the \\ncomponent border; \\nb) if same color, put the neighbor into Queue;\\n4. repeat the above 2 and 3 till Queue is empty.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\\n\\n----\\n\\n**Method 2**: \\n\\n**DFS**\\n\\nUse DFS to explore the cell (r0, c0)\\'s component, and negate the visited cell, traverse its 4 neighbors. After the traversal, change back from the negative if the component cell belongs to inner part.\\n\\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```\\n\\n**Analysis for both BFS and DFS:**\\nEach cell at most visited `4` times, therefore\\n\\nTime & space: `O(m * n)`, where `m = grid.length, n = grid[0].length.`",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int clr = grid[r0][c0], m = grid.length, n = grid[0].length;\\n        Set<Integer> component = new HashSet<>(); // put the cell number into Set to avoid visiting again.\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{ r0, c0 }); // add initial cell.\\n        component.add(r0 * n + c0); // add initial cell number.\\n        while (!q.isEmpty()) { // BFS starts.\\n            int r = q.peek()[0], c = q.poll()[1];\\n            if (r == 0 || r == m - 1 || c == 0 || c == n - 1) { grid[r][c] = color; } // on grid boundary.\\n            for (int k = 0; k < 4; ++k) { // travers its 4 neighbors.\\n                int i = r + d[k], j = c + d[k + 1]; // neighbor coordinates.\\n                if (i >= 0 && i < m && j >= 0 && j < n && !component.contains(i * n + j)) { // not visited before.\\n                    if (grid[i][j] == clr) { // its neighbor is of same color, put it into Queue. \\n                        component.add(i * n + j); // avoid visiting again.\\n                        q.offer(new int[]{ i, j }); // put it into Queue. \\n                    }else { // its neighbor is of different color, hence it is on component boundary.\\n                        grid[r][c] = color; \\n                    }\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n         m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n        bfs, component = collections.deque([(r0, c0)]), {(r0, c0)}\\n        while bfs:\\n            r, c = bfs.popleft()\\n            if r * c * (r - m + 1) * (c - n + 1) == 0:\\n                grid[r][c] = color\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n and (i, j) not in component:\\n                    if grid[i][j] == clr:\\n                        component.add((i, j))\\n                        bfs.append((i, j))\\n                    else:    \\n                        grid[r][c] = color\\n        return grid\\n```\n```java\\n    private static final int[] d = { 0, 1, 0, -1, 0 }; // neighbors\\' relative displacements.\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        negateBorder(grid, r0, c0, grid[r0][c0]);\\n        for (int[] g : grid) {\\n            for (int i = 0; i < g.length; ++i) {\\n                if (g[i] < 0) { g[i] = color; }\\n            }\\n        }\\n        return grid;\\n    }\\n    private void negateBorder(int[][] grid, int r, int c, int clr) {\\n        grid[r][c] = -clr; // mark as visited.\\n        int cnt = 0; // use to count grid[r][c]\\'s component neighbors (same color as it).\\n        for (int k = 0; k < 4; ++k) { // traverse 4 neighbors.\\n            int i = r + d[k], j = c + d[k + 1]; // neighbor\\'s coordinates.\\n            if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || Math.abs(grid[i][j]) != clr) { continue; } // out of grid or not same component.\\n            ++cnt; // only if the 4 neighbors of grid[r][c] are all have same color as it, it belongs to inner part.\\n            if (grid[i][j] == clr) { negateBorder(grid, i, j, clr); } // recurse with respect to unvisited component neighbor.\\n        }\\n        if (cnt == 4) { grid[r][c] = clr; } // inner part, change back.\\n    }\\n```\n```python\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        m, n, clr = len(grid), len(grid[0]), grid[r0][c0]\\n\\n        def negateBorder(r, c):\\n            grid[r][c], cnt = -clr, 0\\n            for i, j in (r, c + 1), (r, c - 1), (r + 1, c), (r - 1, c):\\n                if m > i >= 0 <= j < n:\\n                    cnt +=  abs(grid[i][j]) == clr\\n                    if grid[i][j] == clr:\\n                        negateBorder(i, j)\\n            if cnt == 4:\\n                grid[r][c] = clr\\n                \\n        negateBorder(r0, c0)\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if cell < 0:\\n                    grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 283084,
                "title": "confusing-problem-statement-resolved",
                "content": "What does this mean? \\n\\n> The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\n\\nAlso, I did not get how the `2` on the bottom left in the below example did not change? \\n\\n> [1,2,2]\\n[2,3,2]\\n\\nExpected Output:\\n\\n> [1, 3, 3]\\n[2, 3, 3]\\n\\nIn the above picture, `2` is on the bottom left which was untouched but it does satisfy `or on the boundary of the grid (the first or last row or column).` requirement. Why was it not changed to `3`?\\n\\n**CONFUSION RESOLVED:**\\n\\n* Basically, connected component means all the cells which have the same color as `(r0,c0)` whom you can reach with a `single` DFS or BFS starting from `(r0,c0)`. \\n\\n* You color a cell(**when reached from DFS or BFS**) which have the same color who is either at the border, meaning, first row or last row or first column or last column **OR** if that cell has `at least ` 1 different neighbour(meaning having different color).\\n\\n* **Note that**  I could have used `-1` as one of the ways of marking cells in my below code, but I rather find it silly because what if negative number coloring was allowed(LeetCode should add this as a follow up,lol) ? Best way I found was to use a boolean array for marking cells and safely coloring them. \\n\\nMy Solution:\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid,r0,c0,grid[r0][c0],color,grid.length,grid[0].length,visited);        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid,int row,int col,int color,int new_color,int rows,int cols,boolean[][] visited){\\n       if(!isValid(row,col,rows,cols) || visited[row][col] || grid[row][col] != color){\\n            return;\\n       }\\n     \\n        visited[row][col] = true;\\n        \\n        if(row == 0 || col == 0 || row == rows-1 || col == cols-1 || differentComponentNeighbours(grid,row,col,rows,cols,visited,color)){\\n            grid[row][col] = new_color;\\n        }\\n        \\n        dfs(grid,row-1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row+1,col,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col-1,color,new_color,rows,cols,visited);\\n        dfs(grid,row,col+1,color,new_color,rows,cols,visited);\\n    }\\n    \\n    private boolean differentComponentNeighbours(int[][] grid,int row,int col,int rows,int cols,boolean[][] visited,int color){\\n        if(isValid(row-1,col,rows,cols) && !visited[row-1][col] && grid[row-1][col] != color) return true;\\n        if(isValid(row+1,col,rows,cols) && !visited[row+1][col] && grid[row+1][col] != color) return true;\\n        if(isValid(row,col-1,rows,cols) && !visited[row][col-1] && grid[row][col-1] != color) return true;\\n        if(isValid(row,col+1,rows,cols) && !visited[row][col+1] && grid[row][col+1] != color) return true;\\n        return false;\\n    }\\n    \\n    private boolean isValid(int row,int col,int rows,int cols){\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783380,
                "title": "expalanation-of-the-problem-statement",
                "content": "consider the 2nd example: ```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\\nthe grid would look like this:\\n![image](https://assets.leetcode.com/users/images/b81e1f42-f919-4a54-9507-9ff6077c2e25_1597042429.4147203.png)\\nNow, the given location is ``` r0 = 0, c0 = 1``` which is the 2nd cell in first row. So, the component would be:\\n![image](https://assets.leetcode.com/users/images/4a571c93-2af4-4f7f-8768-363158557ab9_1597042643.770675.png)\\nNow, coming to the color changing part\\n**change the color of the cell at ```(0, 1)```** because  by the definition of the border\\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\\n1.  it is part of the component\\n2.  it is 4-directionally adjacent to a square not in the component (below it there a cell with color 3, and on the left there is cell with color 1, so, it meets the criteria)\\n![image](https://assets.leetcode.com/users/images/796bde1c-f034-40f1-a463-8b3421543db5_1597045011.3280766.png)\\n\\n\\nNow, **change the color of the cell at ```(0, 2)```**.\\nIt is not 4-directionally adjacent to a square not in the component (it does not have neighbour whose color is different from itself) **but it is on the border of the grid** (i.e., the first or last row or column of the grid). So, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/f3449341-bf34-4ef5-b30d-d54e0d838a39_1597045067.3039854.png)\\n\\nNow, coming to last cell of our component ```(1,2)```, it follows both the criteria\\n1. it is on the border\\n2. it has a neighbour which does not belong to the component and different from itself.\\nSo, we have to change its color.\\n![image](https://assets.leetcode.com/users/images/6ec7d7f8-3fd3-49bf-819e-9ee13a64c31d_1597045304.0051892.png)\\n\\nTherefore, the output is: ```[[1, 3, 3], [2, 3, 3]]```\\n**Why didnt we change the color of cell at ```(1,0)```?**\\nit follows both the criteria, but **it doesnt belong to the component**\\nThis is my understanding of the problem. I stuggled quite a bit to understand the problem statement and I just want to make it simple to understand for others too.\\ncorrect me if I did mistake.",
                "solutionTags": [],
                "code": "```grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3```\n``` r0 = 0, c0 = 1```\n```(0, 1)```\n```The border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component```\n```(0, 2)```\n```(1,2)```\n```[[1, 3, 3], [2, 3, 3]]```\n```(1,0)```",
                "codeTag": "Unknown"
            },
            {
                "id": 282876,
                "title": "concise-dfs-c",
                "content": "\\tclass Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n\\t\\t\\tint rows, cols;\\n\\n\\t\\t\\tif((rows = grid.size()) == 0 || (cols = grid[0].size()) == 0)\\n\\t\\t\\t\\treturn {};\\n\\n\\t\\t\\tvector<vector<int>> temp = grid;\\n\\t\\t\\tdfs(temp, r0, c0, grid[r0][c0]);\\n\\n\\t\\t\\tfor(int i = 0; i < rows; i++) {\\n\\t\\t\\t\\tfor(int j = 0; j < cols; j++) {\\n\\t\\t\\t\\t\\tif(i == 0 || j == 0 || i == rows - 1 || j == cols - 1) {\\n\\t\\t\\t\\t\\t\\tif(temp[i][j] == INT_MAX)\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif((temp[i][j]) == INT_MAX and \\n\\t\\t\\t\\t\\t\\t   ((temp[i - 1][j] != INT_MAX) || (temp[i + 1][j] != INT_MAX) ||\\n\\t\\t\\t\\t\\t\\t\\t(temp[i][j - 1] != INT_MAX) || (temp[i][j + 1] != INT_MAX)))\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn grid;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tvoid dfs(vector<vector<int>>& grid, int r, int c, int color) {\\n\\t\\t\\tif(r < 0 || r >= grid.size() || c < 0 || c >= grid[0].size() || grid[r][c] != color)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tgrid[r][c] = INT_MAX;\\n\\n\\t\\t\\tdfs(grid, r + 1, c, color);\\n\\t\\t\\tdfs(grid, r - 1, c, color);\\n\\t\\t\\tdfs(grid, r, c + 1, color);\\n\\t\\t\\tdfs(grid, r, c - 1, color);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1372161,
                "title": "beginner-friendly-c-dfs-16ms-78-22",
                "content": "* Easy to understand? must upvote! \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVisited[51][51];\\n    vector<vector<int>> result;\\n    int ROW, COL, COLOR;\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j){\\n        if((i>=0 and i<ROW) and (j>=0 and j<COL) and (grid[i][j] == COLOR) and (!isVisited[i][j]))\\n            return true;\\n        return false;\\n    }\\n    \\n    bool isBorder(vector<vector<int>>& grid, int i, int j){\\n        if(i == 0 || i == ROW-1 || j == 0 || j == COL-1)\\n            return true;\\n        if(grid[i][j+1] != COLOR || grid[i][j-1] != COLOR || grid[i+1][j] != COLOR || grid[i-1][j] != COLOR)\\n            return true;\\n        return false;\\n    }\\n    \\n    void DFS(vector<vector<int>>& grid, int i, int j, int color){\\n        isVisited[i][j] = true;\\n        if(isBorder(grid, i, j))\\n            result[i][j] = color;\\n        if(isValid(grid, i, j+1)){\\n            DFS(grid, i, j+1, color);\\n        }\\n        if(isValid(grid, i, j-1)){\\n            DFS(grid, i, j-1, color);\\n        }\\n        if(isValid(grid, i+1, j)){\\n            DFS(grid, i+1, j, color);\\n        }\\n        if(isValid(grid, i-1, j)){\\n            DFS(grid, i-1, j, color);\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        memset(isVisited, false, sizeof isVisited);\\n        ROW = grid.size(); COL = grid[0].size(); COLOR = grid[r0][c0];\\n        result.resize(ROW, vector<int>(COL));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++)\\n                result[i][j] = grid[i][j];\\n        }\\n        DFS(grid, r0, c0, color);\\n        return result;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282884,
                "title": "java-dfs-simple-easy-to-understand-solution-used-more-space-to-make-it-simple",
                "content": "First copying the input grid (`grid`) to output grid(`result`). After this do DFS on `grid` from start point, after visiting all neighbours, mark current point with given color(on `result` grid, input `grid` is not modified at all) if and only if it is in border of the grid OR border of the component (`isBorder`)\\n\\n```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nprivate int[][] grid;\\n\\n    private int[][] result;\\n\\n    private int R;\\n\\n    private int C;\\n\\n    private boolean[][] visited;\\n\\n    private int finalColor;\\n\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        this.grid = grid;\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n\\n        visited = new boolean[R][C];\\n        finalColor = color;\\n\\n        result = new int[R][C];\\n        for (int r=0; r<R;r++) {\\n            for (int c=0;c<C;c++) {\\n                result[r][c] = grid[r][c];\\n            }\\n        }\\n        dfs(r0,c0, grid[r0][c0]);\\n        return result;\\n    }\\n\\n    private void dfs(int r, int c, int targetColor) {\\n        if (r >= R || r < 0 || c >= C || c < 0)\\n            return;\\n        if (grid[r][c] != targetColor)\\n            return;\\n        if (visited[r][c])\\n            return;\\n\\n        visited[r][c] = true;\\n        dfs(r, c-1, targetColor);\\n        dfs(r, c+1, targetColor);\\n        dfs(r-1, c, targetColor);\\n        dfs(r+1, c, targetColor);\\n\\n        if (isBorder(r,c, targetColor))\\n            result[r][c] = finalColor;\\n    }\\n\\n    private boolean isBorder(int r, int c, int targetColor) {\\n        if (r == R - 1 || c == C - 1 || r == 0 || c == 0)\\n            return true;\\n        int left = grid[r][c-1];\\n        int right = grid[r][c+1];\\n        int top = grid[r-1][c];\\n        int bottom = grid[r+1][c];\\n\\n        if (left != targetColor || right != targetColor || top != targetColor || bottom != targetColor)\\n            return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406166,
                "title": "java-neat-easy-dfs-solution",
                "content": "Just save the border in an additional list and then update the grid. Very simple idea.\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        List<int[]> border = new ArrayList<int[]>();\\n        dfs(grid, r0, c0, grid[r0][c0], border, new boolean[grid.length][grid[0].length]);\\n        \\n        for (int[] coord : border) {\\n            int i = coord[0], j = coord[1];\\n            grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int targetColor, List<int[]> border, boolean[][] visited) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] != targetColor) return;\\n        \\n        visited[i][j] = true;\\n        if (isBorder(grid, i, j, targetColor)) { border.add(new int[]{i, j}); }\\n        \\n        dfs(grid, i+1, j, targetColor, border, visited);\\n        dfs(grid, i-1, j, targetColor, border, visited);\\n        dfs(grid, i, j+1, targetColor, border, visited);\\n        dfs(grid, i, j-1, targetColor, border, visited);\\n    }\\n    \\n    private boolean isBorder(int[][] grid, int i, int j, int targetColor) {\\n        if (i == 0 || j == 0 || i == grid.length - 1 || j == grid[0].length - 1) return true;\\n        return grid[i-1][j] != targetColor || grid[i+1][j] != targetColor || grid[i][j-1] != targetColor || grid[i][j+1] != targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274806,
                "title": "java-0ms-dfs-faster-than-100",
                "content": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }\\n    \\n    \\n    public void dfs(int i,int j,int[][]grid){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length){\\n            return;\\n        }\\n        int count=0;\\n        visited[i][j]=true;\\n        grid[i][j]=colorr;\\n        \\n        if(i+1<grid.length && (grid[i+1][j]==col || visited[i+1][j])){\\n            count++;\\n            if(!visited[i+1][j])\\n            dfs(i+1,j,grid);\\n        }\\n        if(i-1>=0 && (grid[i-1][j]==col || visited[i-1][j])){\\n            count++;\\n            if(!visited[i-1][j])\\n            dfs(i-1,j,grid);\\n        }\\n        if(j+1<grid[0].length && (grid[i][j+1]==col || visited[i][j+1])){\\n            count++;\\n            if(!visited[i][j+1])\\n            dfs(i,j+1,grid);\\n        }\\n        if(j-1>=0 && (grid[i][j-1]==col || visited[i][j-1])){\\n            count++;\\n            if(!visited[i][j-1])\\n            dfs(i,j-1,grid);\\n        }\\n        if(count==4){\\n            grid[i][j]=col;\\n        }\\n\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    \\n    \\n    boolean visited[][];\\n    int col;\\n    int colorr;\\n    \\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        //basically we will to the given node and appy dfs\\n        //while applying dfs we will count the number of calls \\n        //jis bhi node se 4 calls lagi hongi usse change nhi krna hai\\n        //baki sab ko color se paint krdo\\n        col=grid[r0][c0];\\n        colorr=color;\\n        visited=new boolean[grid.length][grid[0].length];\\n        dfs(r0,c0,grid);\\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 700750,
                "title": "easy-understandable-using-flip-coloring-beats-100-in-both-space-and-time",
                "content": "Approach : Flip the colors by making it negative check if the given square satisfy the condition of boundary element or not, All the flipped squares will give connected components\\n```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int color_;\\n    public boolean isValid(int i,int j,int row,int col){\\n        return i>=0 && i<row && j>=0 && j<col;\\n    }\\n    public boolean nonBoundary(int [][]grid,int i,int j,int color){\\n        return color == Math.abs(grid[i-1][j]) && color == Math.abs(grid[i][j-1]) && color == Math.abs(grid[i+1][j]) && color == Math.abs(grid[i][j+1]);\\n    }\\n    public void dfs(int [][]grid,int startcolor,int i,int j){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(!isValid(i,j,m,n) || grid[i][j]!=startcolor) return;\\n        grid[i][j] = -startcolor;\\n        dfs(grid,startcolor,i+1,j);\\n        dfs(grid,startcolor,i,j+1);\\n        dfs(grid,startcolor,i,j-1);\\n        dfs(grid,startcolor,i-1,j);\\n        if(i>0 && i<m-1 && j>0 && j<n-1){\\n            if(nonBoundary(grid,i,j,startcolor)){\\n                grid[i][j] = startcolor;\\n            }\\n        }\\n        \\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int startcolor = grid[r0][c0];\\n        color_ = color;\\n        dfs(grid,startcolor,r0,c0);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]<0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478469,
                "title": "is-this-test-case-correct",
                "content": "When I submitted my code, it said that the following case did not work. How is the expected solution correct according to the problem description?\\n\\n```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\\n```\\n                  ^\\n```\\n\\nThat \"2\" is my problem.",
                "solutionTags": [],
                "code": "```\\nInput:\\n[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]\\n1\\n3\\n1\\nOutput:\\n[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]\\nExpected:\\n[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]\\n```\n```\\n                  ^\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282844,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<vector<int>> &grid, vector<vector<bool>> &colored, int r0, int c0, int color, int connected_col, vector<vector<bool>> &visit) {\\n        if(r0 < 0 or r0 >= grid.size() or c0 < 0 or c0 >= grid[0].size() or grid[r0][c0] != connected_col)\\n            return true;\\n        \\n        if(visit[r0][c0])\\n            return false;\\n        \\n        visit[r0][c0] = true;\\n        if(dfs(grid, colored, r0-1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0+1, c0, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0-1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        \\n        if(dfs(grid, colored, r0, c0+1, color, connected_col, visit))\\n            colored[r0][c0] = true;\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        if(grid.size() == 0)\\n            return {};\\n        \\n        vector<vector<bool>> colored(grid.size(), vector<bool>(grid[0].size(), false));\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\\n        \\n        dfs(grid, colored, r0, c0, color, grid[r0][c0], visited);\\n        \\n        for(int i = 0; i < colored.size(); i++) {\\n            for(int j = 0; j < colored[0].size(); j++)\\n                if(colored[i][j])\\n                    grid[i][j] = color;\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686098,
                "title": "detailed-explanation-with-pictures",
                "content": "` Suppose given `\\n![paint1.png](https://assets.leetcode.com/users/images/81a9c04e-3300-4a5b-aec8-23d2d6fd965d_1687797247.1981645.png)\\n\\n``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\\n![paint1.png](https://assets.leetcode.com/users/images/d6939f0f-dce2-4b2b-b292-e4f49b5e8ef0_1687797844.4885716.png)\\n\\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\\n```\\nLet\\'s look at the cell grid[1][2].\\n```\\n![mainnnnnn.png](https://assets.leetcode.com/users/images/06cc3008-5f1c-4c29-bfc1-e346b3f523fc_1687799040.5686803.png)\\n\\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\\n```\\nFor grid[1][1] : \\n```\\n![main2.png](https://assets.leetcode.com/users/images/d6da1151-583a-4811-968a-a1bd0bbf4aa5_1687799443.3790708.png)\\n\\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\\n![soll.png](https://assets.leetcode.com/users/images/f6b3551f-c996-4945-bbb8-348d2fe8ed1d_1687800180.4796717.png)\\n\\n\\n### My Solution Explanation :\\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\\n![leo.png](https://assets.leetcode.com/users/images/880985b8-14b1-4027-bb6a-04631a3d1743_1687804434.6937025.png)\\n\\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\\n![OPP.png](https://assets.leetcode.com/users/images/c52babc0-2983-4496-860b-21f4ac018440_1687806180.8875253.png)\\n\\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\\n\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```\\n### It took me plenty time to explain everything. If the post was useful to you, an upvote will really make me happy. Thank you for reading it till the end.",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` \\nAll the neighbour(4 directions) of grid[1][3] including neighbours of the neighbours of \\ngrid[1][3]\\n```\n```\\nNow you have to go through the all of those grid[1][3]\\'s neighbours and change the color of \\nthose cells which are on the border(cell whose 4 direction cells values are not equal to\\n that cell value)\\n```\n```\\nLet\\'s look at the cell grid[1][2].\\n```\n```\\nHere only the upper neighbour(green marked) is not same as grid[1][2] (purple marked).\\nSo grid[1][2] is on the border and thus we color it to 1.\\n```\n```\\nFor grid[1][1] : \\n```\n```\\nFor grid[1][1](purple marked) all it\\'s neighbour has the same value as grid[1][1] has, means\\nthis cell is not on the border and that\\'s why we won\\'t color it to 1.\\n```\n```\\nFinal Output : (red = previous color, blue = new color)\\n```\n```\\nIf you want to run the dfs and change the border cell to new color in the dfs it would\\nbe huge messy : \\n```\n```\\nIf I change the color of grid[1][3] and grid[1][2] at the same time in dfs function, then \\nfor grid[1][1] (purple marked) it\\'s right neighbour(grid[1][2]) is 1 and grid[1][1] will be \\ncolored to 1 as it\\'s all neighbours value are not same as grid[1][1] BUT grid[1][1] can\\'t be\\ncolored to 1 as in the Q it\\'s all neighbour has the same value as its.\\n```\n```\\nInstead I made a boolean array of the same size as grid and marked all the neighbours of \\ngrid[row][col] as 1 in dfs(). Now I can easily traverse the \\'visited\\' array and change the \\nborder cells of \\'grid\\' to \\'color\\'.\\n```\n```\\nTo check if the current cell (grid[r][c]) is on the border or not :\\n\\n1. If the cell is on the first or the last row as \\'CELLS ON THE FIRST ROW MISSING UPPER \\n   NEIGHBOUR\\' AND \\'LAST ROW BOTTOM NEIGHBOUR\\'.\\n2. If the cell is on the first colomn(missing left neighbour) or the last colomn(missing right \\n   neighbour)\\n3. If the cell in the middle, then check if all the neighbour has 1 in the \\'visited\\' array, \\n   because if one of them is 0 means it\\'s a border cell. \\n\\n   NO NEED TO CHECK IF THE CELL (WHOSE NEIGHBOURS HAS 1 OR NOT) HAS ALSO 1 BECAUSE UNLESS THAT \\n   CELL HAD NOT 1 WE WOULDN\\'T BE CHECKING IF ALL ITS NEIGHBOURS AS 1 OR NOT.    \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> diff = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}}; // left up right down\\n    \\n    bool on_border_or_neighbours_not_equal(vector<vector<bool>>& visited, int r, int c){\\n        if(r == 0 || r == visited.size()-1 || c == 0 || c == visited[0].size()-1) // on border conditions\\n            return true;\\n        int left = visited[r][c-1], up = visited[r-1][c], right = visited[r][c+1], down = visited[r+1][c];\\n        return left != 1 || up != 1 || right != 1 || down != 1; // at least one neighbour is different conditions\\n    }\\n    \\n    void create_border(vector<vector<int>>& grid, vector<vector<bool>> &visited, int newcolor)\\n    {\\n        for(int r=0; r<visited.size(); r++)\\n        {\\n            for(int c=0; c<visited[0].size(); c++)\\n                if(visited[r][c] == 1 && on_border_or_neighbours_not_equal(visited, r, c))\\n                    grid[r][c] = newcolor;\\n        }\\n    }\\n\\n    void dfs(vector<vector<int>>& grid, int r, int c, int oldcolor, vector<vector<bool>> &visited)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size() || visited[r][c] == 1 || grid[r][c] != oldcolor)\\n            return;\\n        visited[r][c] = 1;\\n        for(const auto &d : diff)\\n            dfs(grid, r+d[0], c+d[1], oldcolor, visited);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n        dfs(grid, row, col, grid[row][col], visited);\\n        create_border(grid, visited, color);\\n        return grid;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        ROW, COL, oldcolor = len(grid), len(grid[0]), grid[row][col]\\n        visited = [ [0 for _ in range(COL)] for _ in range(ROW) ]\\n\\n        def dfs(r:int, c:int):\\n            if r<0 or r>=ROW or c<0 or c>=COL or visited[r][c] == 1 or grid[r][c] != oldcolor :\\n                return\\n            visited[r][c] = 1\\n            [ dfs(r+x, c+y) for (x,y) in ((0, -1), (-1, 0), (0, 1), (1, 0)) ]\\n        \\n        def on_border_or_neighbours_not_equal(r:int, c:int) -> bool:\\n            if r == 0 or r == ROW-1 or c == 0 or c == COL-1 : # on border\\n                return True\\n            left, up, right, down = visited[r][c-1], visited[r-1][c], visited[r][c+1], visited[r+1][c]\\n            return left != 1 or up != 1 or right != 1 or down != 1 # min 1 neighbour is different or not\\n        \\n        def create_border():\\n            for r in range(ROW):\\n                for c in range(COL):\\n                    if visited[r][c] == 1 and on_border_or_neighbours_not_equal(r, c):\\n                        grid[r][c] = color\\n\\n        dfs(row, col)\\n        create_border()\\n        return grid\\n```\n```\\nTime  complexity : O(m*n)\\nSpace complexity : O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595163,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283803,
                "title": "java-dfs-based-solution-with-explanation-simple-to-understand",
                "content": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "solutionTags": [],
                "code": "\\n# Thought process:\\n\\nRun Depth First Search algorithm to find the connected component where (r0, c0) is part of that connected component.\\nOutput of DFS run is visited[][] array where elements that are part of connected component are marked as 1. Rest of the elements are 0.\\n\\n# Only boundary logic is left:\\n\\nTraverse through visited[][] array:\\n\\nIf visited element (visited[][] == 1) is surrounded by all visited nodes (if all neighbors are visited), then keep its color as old. This is case of an internal element.\\n\\nElse give new color since it\\'s a boundary element.\\n    \\n    private boolean isSafe(int[][] grid, int x, int y, int initialColor, int[][] visited)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n    \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return ((visited[x][y] == 0) && (grid[x][y] == initialColor));\\n    }\\n\\t\\n    private void DFS(int[][] grid, int r, int c, int initialColor, int color, int[][] visited)\\n    {\\n        visited[r][c] = 1;\\n        \\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = r + row[k];\\n            y = c + column[k];\\n            \\n            if(isSafe(grid, x, y, initialColor, visited))\\n            {\\n                DFS(grid, x, y, initialColor, color, visited);\\n            }\\n        }\\n        \\n    }\\n    \\n    private boolean isVisitedAndSafe(int x, int y, int[][] visited)\\n    {\\n        int n = visited.length;\\n        int m = visited[0].length;\\n        \\n        if(x<0 || x>n-1 || y<0 || y>m-1)\\n            return false;\\n        \\n        return visited[x][y] == 1;\\n    }\\n    \\n    private boolean isBorder(int i, int j, int[][] visited)\\n    {\\n        int[] row = {0, -1, 0, 1};\\n        int[] column = {-1, 0, 1, 0};\\n        \\n        int count = 0;\\n        \\n        int x;\\n        int y;\\n        \\n        for(int k = 0; k<4; k++)\\n        {\\n            x = i + row[k];\\n            y = j + column[k];\\n            \\n            if(isVisitedAndSafe(x, y, visited))\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        if(count == 4)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private int[][] DFSUtil(int[][] grid, int r, int c, int color)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] visited = new int[n][m]; //initialized as 0\\n        int initialColor = grid[r][c];\\n        \\n        DFS(grid, r, c, initialColor, color, visited);\\n        \\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(visited[i][j] == 1)\\n                {\\n                    if(isBorder(i, j, visited))\\n                        grid[i][j] = color;\\n                }\\n            }\\n        \\n        return grid;\\n        \\n    }\\n\\t\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        return DFSUtil(grid, r0,c0,color);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 282960,
                "title": "easy-java-iterative-solution-using-stack",
                "content": "```class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0});\\n        int origin = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        while (!stack.isEmpty()) {\\n            int[] t = stack.pop();\\n            int r = t[0];\\n            int c = t[1];\\n            if (!visited[r][c]) {\\n                if (r == 0 || r == m-1 || c == 0 || c == n-1 || (grid[r-1][c] != origin && grid[r-1][c] != -1) || \\n                   (grid[r+1][c] != origin && grid[r+1][c] != -1) || (grid[r][c-1] != origin && grid[r][c-1] != -1) || \\n                    (grid[r][c+1] != origin && grid[r][c+1] != -1)) \\n                    grid[r][c] = -1; \\n                \\n                visited[r][c] = true;\\n                if (r - 1 >= 0 && origin == grid[r-1][c]) {\\n                    stack.push(new int[]{r-1, c});\\n                }\\n                \\n                if (r + 1 < m && origin == grid[r+1][c]) {\\n                    stack.push(new int[]{r+1, c});\\n                }\\n                \\n                if (c - 1 >= 0 && origin == grid[r][c-1]) {\\n                    stack.push(new int[]{r, c-1});\\n                }\\n                \\n                if (c + 1 < n && origin == grid[r][c+1]) {\\n                    stack.push(new int[]{r, c+1});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == -1) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Stack<int[]> stack = new Stack<>();\\n        stack.push(new int[]{r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 282871,
                "title": "java-dfs-for-2-times-kinda-long-but-easy-to-understand",
                "content": "First DFS to paint the connect component to -1, then the second DFS to paint the inside square to -2, and the border square to -3. Return the grid by changing -3 squre to color and -2 squre to original color\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int originalColor = grid[r0][c0];\\n        dfs(r0, c0, grid, originalColor);\\n        dfs2(r0, c0, grid);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == -3) {\\n                    grid[i][j] = color;\\n                }\\n                if (grid[i][j] == -2) {\\n                    grid[i][j] = originalColor;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    void dfs(int r, int c, int[][] grid, int color) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != color) {\\n            return;\\n        }\\n        grid[r][c] = -1;\\n        dfs(r-1, c, grid, color);\\n        dfs(r+1, c, grid, color);\\n        dfs(r, c-1, grid, color);\\n        dfs(r, c+1, grid, color);\\n    }\\n    \\n    void dfs2(int r, int c, int[][] grid) {\\n        if (r >= grid.length || c >= grid[0].length || r<0 || c<0 || grid[r][c] != -1) {\\n            return;\\n        }\\n        grid[r][c] = -3;\\n        if (r-1<0 || r+1==grid.length || c-1<0 || c+1==grid[0].length) {\\n            // do nothing\\n        } else if ((grid[r-1][c] == -1 || grid[r-1][c] == -3 || grid[r-1][c] == -2) \\n                   && (grid[r+1][c] == -1 || grid[r+1][c] == -3 || grid[r+1][c] == -2)\\n                   && (grid[r][c-1] == -1 || grid[r][c-1] == -3 || grid[r][c-1] == -2)\\n                   && (grid[r][c+1] == -1 || grid[r][c+1] == -3 || grid[r][c+1] == -2)) {\\n            grid[r][c] = -2;\\n        }\\n        dfs2(r-1, c, grid);\\n        dfs2(r+1, c, grid);\\n        dfs2(r, c-1, grid);\\n        dfs2(r, c+1, grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373784,
                "title": "c-bfs-beats-86-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to get the connected component and then identify the border cells of the connected component.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Run BFS two times\\n- First BFS : Get all the cells which have the same color as the [row, col] given. This will be the connected component of interest\\n- Second BFS : Identify which cells from the first BFS are on the border of the connected component. If the color of the child is different than parent, it means parent is a border cell. Similarly, if the parent itself is on the border of the grid, it is a border cell. Change the color of these border cells\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(r*c)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        queue<pair<int, int>> v;\\n        vector<vector<bool>> vis(r, vector<bool>(c, false));\\n        vector<vector<int>> move{{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        q.push(make_pair(row, col));\\n        int og = grid[row][col];\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            v.push(node);\\n            vis[node.first][node.second] = true;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                vis[rn][rc] = true;\\n\\n                if(grid[rn][rc]== og)\\n                    q.push(make_pair(rn, rc));\\n\\n            }\\n        }\\n\\n        vis.clear();\\n        vis.resize(r, vector<bool>(c, false));\\n        while(!v.empty()){\\n            auto node = v.front();\\n            v.pop();\\n\\n            vis[node.first][node.second] = true;\\n            if(node.first == 0 || node.second == 0 || node.first == r -1 || node.second == c-1){\\n                grid[node.first][node.second] = color;\\n                continue;\\n            }\\n\\n            bool border = false;\\n            for(auto mv : move){\\n                int rn = mv[0] + node.first;\\n                int rc = mv[1] + node.second;\\n\\n                if(rn < 0 || rc < 0 || rn>= r || rc>= c)\\n                    continue;\\n                \\n                if(vis[rn][rc])\\n                    continue;\\n                \\n                if(grid[rn][rc] != og){\\n                    border = true;\\n                    break;\\n                }\\n            }\\n            if(border){\\n                grid[node.first][node.second] = color;\\n            }\\n                \\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039802,
                "title": "bfs-beats-99-easy-to-understand",
                "content": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "Question is poorly articulated so I\\'ll try to explain a bit.\\nAdjacency - Two squares are adjacent id they are in one of the four (up, down, left, right) directions of each other.\\nConnected Component - A connected component is a set of squares which are adjacent to at least one of the squares in the connected component and carry the same color\\nBoundary - A square is said to be a boundary square of a connected component if it\\'s either adjacent to a square of different color or is a boundary square of our grid i.e a square of first or last row or column.\\n\\nNow the question asks us to paint the boundary of the said connected component with a particular given color.\\n\\n**Solution-**\\nNow the solution to it is pretty easy, you traverse the whole conncted component and change the color of each square whose all 4 adjacent sides does not contain the original color.\\n\\n**Simple readable code with the said logic-**\\n\\n\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        change = []\\n        \\n        queue = [[row, col]]\\n        q = 1 \\n        \\n        ori = grid[row][col]\\n        \\n        vis = [[0]*n for i in range(m)]\\n        vis[row][col] = 1 \\n        \\n        while q > 0:\\n            r, c = queue.pop(0)\\n            q -= 1\\n            \\n            sides = 0\\n            \\n            if r-1 >= 0:\\n                if grid[r-1][c] == ori:\\n                    sides += 1\\n                if not vis[r-1][c]:\\n                    vis[r-1][c] = 1 \\n                    if grid[r-1][c] == ori:\\n                        queue.append([r-1, c])\\n                        q += 1        \\n                    \\n            if c-1 >= 0:\\n                if grid[r][c-1] == ori:\\n                    sides += 1\\n                if not vis[r][c-1]:\\n                    vis[r][c-1] = 1 \\n                    if grid[r][c-1] == ori:\\n                        queue.append([r, c-1])\\n                        q += 1       \\n            \\n            if r+1 < m:\\n                if grid[r+1][c] == ori:\\n                    sides += 1\\n                if not vis[r+1][c]:\\n                    vis[r+1][c] = 1 \\n                    if grid[r+1][c] == ori:\\n                        queue.append([r+1, c])\\n                        q += 1 \\n          \\n            if c+1 < n:\\n                if grid[r][c+1] == ori:\\n                    sides += 1\\n                if not vis[r][c+1]:\\n                    vis[r][c+1] = 1 \\n                    if grid[r][c+1] == ori:\\n                        queue.append([r, c+1])\\n                        q += 1 \\n                             \\n            if sides != 4:\\n                change.append([r, c])\\n                \\n        for r, c in change:\\n            grid[r][c] = color \\n            \\n        return grid",
                "codeTag": "Java"
            },
            {
                "id": 2769023,
                "title": "c-easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(vector<vector<int>>& g, int r, int c, int cl) {\\n  if (r < 0 || c < 0 || r >= g.size() || c >= g[r].size() || g[r][c] != cl) return;\\n  g[r][c] = -cl;\\n  dfs(g, r - 1, c, cl), dfs(g, r + 1, c, cl), dfs(g, r, c - 1, cl), dfs(g, r, c + 1, cl);\\n  if (r > 0 && r < g.size() - 1 && c > 0 && c < g[r].size() - 1 && cl == abs(g[r - 1][c]) &&\\n    cl == abs(g[r + 1][c]) && cl == abs(g[r][c - 1]) && cl == abs(g[r][c + 1]))\\n    g[r][c] = cl;\\n}\\nvector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n  dfs(grid, r0, c0, grid[r0][c0]);\\n  for (auto i = 0; i < grid.size(); ++i)\\n    for (auto j = 0; j < grid[i].size(); ++j) grid[i][j] = grid[i][j] < 0 ? color : grid[i][j];\\n  return grid;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972116,
                "title": "java-dfs-faster-than-100-do-checkout-for-explanation",
                "content": "**Do vote up if you like it :)**\\n \\nMake a DFS call on all connected rcColor (given rowColColor), check all your nbrs, if \"all of them\" is rcColor then you are not a boundary cell and you are not supposed to be colored with color, so keep a mark of that cell(say 1e9), and if \"all of the nbrs is not\" rcColor then you are a boundary Cell.\\n\\nNow, after you come out of DFS call, your boundary cells are all marked with -rcColor and withinBoundary cells are marked with 1e9, so change them accordingly.\\n```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```\\n-------------------------------------------------------------",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int n, m;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int rcColor = grid[row][col];\\n        dfs(row, col, rcColor, grid, dir);\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == -rcColor) grid[i][j] = color; // Boundary cell, so mark with color\\n                else if(grid[i][j] == (int)1e9) grid[i][j] = rcColor; // Within boundary cell, so mark with rcColor(original)\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public void dfs(int x, int y, int rcColor, int[][] grid, int[][] dir) {\\n        \\n        grid[x][y] = -rcColor; // visited\\n        int count = 0;\\n        for(int d = 0; d < dir.length; d++) {\\n            int r = x + dir[d][0];\\n            int c = y + dir[d][1];\\n            \\n            if(r >= 0 && r < n && c >= 0 && c < m) {\\n                if(Math.abs(grid[r][c]) == rcColor || grid[r][c] == (int)1e9) count++; // -rcColor, rcColor, 1e9 are same nbrs \\n                if(grid[r][c] == rcColor) { // call on unvisited nbr which is of rcColor\\n                    dfs(r, c, rcColor, grid, dir);\\n                }\\n            }\\n        }\\n        \\n        // Acc. to question if all 4 direction is rcColor, then it is not a boundary cell\\n        // So, mark yourself as 1e9 because if you mark it with rcColor then,\\n        // when you return from this cell, then another cell can call on this cell, considering it unvisited,\\n        // since we are making calls on all connected rcColor cell\\n        if(count == 4) grid[x][y] = (int)1e9; // to keep it visited && a mark for within boundary cell\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418437,
                "title": "javascript-solution-w-comments",
                "content": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Color the cells which belong to same connected component of the starting cell\\n * that doesn\\'t have 4 valid adjacent cells with the same value as that of grid[row][col].\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 96 ms, faster than 66.67% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 41.9 MB, less than 100.00% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder1 = function (grid, row, col, color) {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst visited = new Set();\\n\\tconst pixel = grid[row][col];\\n\\n\\tconst traverse = (x, y) => {\\n\\t\\tconst key = `${x}, ${y}`;\\n\\n\\t\\tif (visited.has(key)) return 1;\\n\\n\\t\\tif (x < 0 || x === grid.length) return 0;\\n\\t\\tif (y < 0 || y === grid[0].length) return 0;\\n\\t\\tif (grid[x][y] !== pixel) return 0;\\n\\n\\t\\tvisited.add(key);\\n\\n\\t\\tlet invalid = 1;\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\tinvalid *= traverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// if all 4 adjacents are the same, don\\'t change\\n\\t\\t// if any of the adjacent are different, change color\\n\\t\\tif (invalid) return 1;\\n\\t\\telse grid[x][y] = color;\\n\\n\\t\\treturn 1;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\treturn grid;\\n};\\n\\n/**\\n * *Time: O(N x M)\\n * *Space: O(N x M)\\n */\\n// Runtime: 73 ms, faster than 100.00% of JavaScript online submissions for Coloring A Border.\\n// Memory Usage: 46.5 MB, less than 45.83% of JavaScript online submissions for Coloring A Border.\\nconst colorBorder = (grid, row, col, color) => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t];\\n\\tconst pixel = grid[row][col];\\n\\n\\t// find borders and mark visited: -pixel\\n\\tconst traverse = (x, y) => {\\n\\t\\tif (x < 0 || x >= grid.length) return;\\n\\t\\tif (y < 0 || y >= grid[0].length) return;\\n\\t\\tif (grid[x][y] !== pixel) return;\\n\\n\\t\\tgrid[x][y] = -pixel; // mark visited\\n\\n\\t\\tdirections.forEach(([dx, dy]) => {\\n\\t\\t\\ttraverse(x + dx, y + dy);\\n\\t\\t});\\n\\n\\t\\t// check if all adjacents have same color\\n\\t\\tconst invalid = directions.every(([dx, dy]) => {\\n\\t\\t\\t// check if valid x AND y boundary\\n\\t\\t\\tconst validX = x > 0 && x < grid.length - 1;\\n\\t\\t\\tconst validY = y > 0 && y < grid[0].length - 1;\\n\\n\\t\\t\\tif (validX && validY) {\\n\\t\\t\\t\\tconst adjacent = grid[x + dx][y + dy];\\n\\n\\t\\t\\t\\treturn pixel === Math.abs(adjacent);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// revert color if all adjacents are same color\\n\\t\\tif (invalid) grid[x][y] = pixel;\\n\\t};\\n\\n\\ttraverse(row, col);\\n\\n\\t// find marked borders and overwrite with new color\\n\\tfor (let r = 0; r < grid.length; ++r)\\n\\t\\tfor (let c = 0; c < grid[r].length; ++c) {\\n\\t\\t\\tconst cv = grid[r][c];\\n\\n\\t\\t\\tif (cv < 0) grid[r][c] = color;\\n\\t\\t}\\n\\n\\treturn grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352828,
                "title": "simple-c-solution-explained-with-comments-and-picture",
                "content": "**This may help to understand the question in more better way**\\n\\n![image](https://assets.leetcode.com/users/images/07c3479b-f0e0-464b-adda-e45f2aaada92_1626872351.374051.png)\\n\\nThanks to @votrubac for the above [image](https://leetcode.com/problems/coloring-a-border/discuss/282847/C%2B%2B-with-picture-DFS)\\n\\n**CODE : **\\n\\n```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(r * c)\\n\\n**Space Complexity :** O(r-2 * c-2) ~ O(r * c) [HASHMAP]",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//all 4 directions\\nint dr[4] = {1,0,0,-1};\\nint dc[4] = {0,1,-1,0};\\n\\nclass Solution {\\n\\t//function to check if the element is inside the grid or not\\n    bool isValid(int i,int j,int r,int c)\\n    {\\n        if(i<0 or j<0 or i>=r or j>=c)\\n            return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid,int r,int c,int i,int j,int col)\\n    {\\n\\t\\t// if (i,j) lies out of the grid or the current square has different color we return\\n        if(!isValid(i,j,r,c) or grid[i][j] != col) \\n            return;\\n        \\n\\t\\t//replace the color of components by -1\\n        grid[i][j] = -1;\\n\\t\\t\\n\\t\\t//calling dfs in all 4 directions\\n        for(int x=0;x<4;x++)\\n            dfs(grid,r,c,i+dr[x],j+dc[x],col);\\n    }\\n    \\n\\t//function to check if a component is surrounded by components from all 4 sides\\n    bool surrounded(vector<vector<int>> &grid,int i,int j,int r,int c)\\n    {   \\n\\t\\t//only non-boundary elements\\n        if(i>0 and j>0 and i<r-1 and j<c-1)\\n        {\\n            if(grid[i-1][j] == -1 and grid[i+1][j] == -1\\n              and grid[i][j-1] == -1 and grid[i][j+1] == -1) \\n                return true; \\n            \\n            else return false;\\n        }\\n        \\n        return false;\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int col = grid[r0][c0];\\n        \\n        int r = grid.size() , c = grid[0].size();\\n        \\n        dfs(grid,r,c,r0,c0,col);\\n        \\n\\t\\t//hashmap to store positions of the surrounded components\\n        map<pair<int,int>,int> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n\\t\\t\\t\\t//storing all the surrouned coordinates\\n                if(grid[i][j] == -1 and surrounded(grid,i,j,r,c))\\n                {\\n                   mp[{i,j}] = 1;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//now coloring all -1 to desired colors \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j] == -1)\\n                {\\n\\t\\t\\t\\t\\t//if surroudned then revert back to original color\\n                    if(mp.find({i,j}) != mp.end()) grid[i][j] = col;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//else color with new color\\n                   else grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227062,
                "title": "c-bfs-95",
                "content": "```\\nclass Solution {\\n    int dirx[4] = {0,1,0,-1};\\n    int diry[4] = {1,0,-1,0};\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> ans = grid;\\n        \\n        int sc = grid[r0][c0];\\n        q.push({r0,c0});\\n        grid[r0][c0] = 2000;\\n        \\n        while(q.size()) {\\n            pair<int, int> p = q.front(); q.pop();\\n            int x = p.first, y = p.second;\\n            bool isBoundary = false;\\n            \\n            for(int k=0; k<4; k++) {\\n                int nx = x + dirx[k];\\n                int ny = y + diry[k];\\n                \\n                if(nx==-1 or nx==m or ny==-1 or ny==n or (grid[nx][ny]!=2000 and grid[nx][ny]!=sc)) {\\n                    isBoundary = true;\\n                }\\n                \\n                if(nx>=0 and nx<m and ny>=0 and ny<n and grid[nx][ny] == sc) {\\n                    grid[nx][ny] = 2000;\\n                    q.push({nx, ny});\\n                }\\n            }\\n            \\n            if(isBoundary) ans[x][y] = color;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dirx[4] = {0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1112872,
                "title": "c-dfs-0-extra-space-and-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int r, int c,int initial_color)\\n    {\\n        \\n        \\n        // Get size of the gird\\n        int n=grid.size(),m=grid[0].size(),check=0;\\n        \\n        // Check if the given row and column are valid and if the element hasnt already been visited\\n        if(r>=n || r<0 || c>=m || c<0 || grid[r][c]!=initial_color) return;\\n        \\n        // Check if the given element is at the border or not(checking if it is adjacent to a square not in the connected component)\\n        if(r+1<n && (grid[r+1][c]!=initial_color && grid[r+1][c]!=1001 && grid[r+1][c]!=1002)) check=1;\\n        if(r-1>=0 && (grid[r-1][c]!=initial_color && grid[r-1][c]!=1001 && grid[r-1][c]!=1002)) check=1;\\n        if(c+1<m && (grid[r][c+1]!=initial_color && grid[r][c+1]!=1001 && grid[r][c+1]!=1002)) check=1;\\n        if(c-1>=0 && (grid[r][c-1]!=initial_color && grid[r][c-1]!=1001 && grid[r][c-1]!=1002)) check=1;\\n        \\n        // Checking if the element is on the boundry and hence a border element\\n        if(c==m-1 || c==0 || r==0 || r==n-1) check=1;\\n        \\n        // Marking it with 1001 if its a border element\\n        if(check)\\n            grid[r][c]=1001;\\n        \\n        // Marking it with 1002 if its a central element(non border)\\n        else\\n            grid[r][c]=1002;\\n        \\n        // checking and visiting all its immediate neighbours\\n        dfs(grid,r+1,c,initial_color);\\n        dfs(grid,r-1,c,initial_color);\\n        dfs(grid,r,c+1,initial_color);\\n        dfs(grid,r,c-1,initial_color);\\n        \\n        // Changing the central element to its original value hence marking it unvisited \\n        if(grid[r][c]==1002) grid[r][c]=initial_color;\\n        return ;\\n        \\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int initial_color=grid[r0][c0];\\n        dfs(grid,r0,c0,initial_color);\\n        \\n        // Changing 1001 to the desired color \\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0;j<grid[0].size();j++)\\n                if(grid[i][j]==1001) grid[i][j]=color;         \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986426,
                "title": "java-easy-solution-beats-100",
                "content": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "solutionTags": [],
                "code": "So, basically we need to color the border of the given cells(r0, c0) connected component.\\nWe can color a cell if \\n\\t(i). It is the cell at the boundary of our matrix or any element from 0th and last row or column.\\n\\t(ii). If one of the adjacent cell is not of the same color as the color of the given cell(r0, c0).\\n\\n\\n    boolean call(int[][] grid, boolean[][] visited, int row, int col, int color, int component)\\n    {\\n        if(row>= grid.length || row<0 || col>= grid[0].length || col<0)\\n            return true;\\n        else if(visited[row][col])\\n            return false;\\n        else if(grid[row][col]!= component)\\n            return true;\\n\\n        visited[row][col]= true;\\n        boolean should_i_color= call(grid, visited, row+1, col, color, component);\\n        should_i_color|= call(grid, visited, row-1, col, color, component);\\n        should_i_color|= call(grid, visited, row, col+1, color, component);\\n        should_i_color|= call(grid, visited, row, col-1, color, component);\\n\\n        if(should_i_color)\\n            grid[row][col]= color;\\n        return false;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) \\n    {\\n        boolean[][] visited= new boolean[grid.length][grid[0].length];\\n        call(grid, visited, r0, c0, color, grid[r0][c0]);\\n\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 906205,
                "title": "c-bfs-solution-explained",
                "content": "Runtime: 32 ms, faster than 74.70% of C++ online submissions for Coloring A Border.\\nMemory Usage: 14.4 MB, less than 13.99% of C++ online submissions for Coloring A Border.\\n\\nColor the border of the connected component. Nodes of connected component has same color and adjacent\\nin any 4 direction. Border of connected component are part of connected component means they have same\\ncolor as the color of the component except -\\na) border node has at least one neighbor node with different color\\nb) border node is in the border of the grid (first or last row or col)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // return true if node position is a border node of connected component\\n    bool isBorder(int &m, int &n, int &tx, int &ty, vector<vector<int>>& grid)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        int px,py;\\n        for(int i=0;i<4;i++)\\n        {\\n            px = tx + rowOffset[i];\\n            py = ty + colOffset[i];\\n            \\n            // node is border node if it has at least one neighbor with different color and so return true\\n            if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]!=grid[px][py]) return true;\\n        }\\n        \\n        // node is border node if it is border of the grid\\n        return (tx==0 || ty==0 || tx==m-1 || ty==n-1);\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // track if the square is visited or a border node of connected component\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        \\n        // push source node (r0, c0) in to queue and also mark visited \\n        queue<pair<int,int>>Q;\\n        Q.push({r0,c0});\\n        visited[r0][c0] = 1;\\n        \\n        int tx,ty,px,py;\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        \\n        // run BFS until queue is empty\\n        while(!Q.empty())\\n        {\\n            tx = Q.front().first;\\n            ty = Q.front().second;\\n            Q.pop();\\n            \\n            // check if the current node is a border node, if then mark it as border node\\n            if(isBorder(m,n,tx,ty,grid))visited[tx][ty] = 2;            \\n\\n            // check the neighbor nodes\\n            for(int i=0;i<4;i++)\\n            {\\n                px = tx + rowOffset[i];\\n                py = ty + colOffset[i];\\n\\n                // push unvisited neighbor nodes with same color (connected component node) of the current node\\n                if(px>=0 && px<m && py>=0 && py<n && grid[tx][ty]==grid[px][py] && visited[px][py]==0)\\n                    visited[px][py] = 1,Q.push({px,py}); \\n            }\\n        }\\n        \\n        // check node positions marked as border node and color them\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(visited[i][j]==2) grid[i][j] = color;\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873995,
                "title": "python-dfs-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        \\n        def dfs(r, c, current, border, seen):\\n            \\n            # if out of range or seen\\n            if r<0 or c<0 or r >= len(grid) or c >= len(grid[0]) or grid[r][c] != current or (r,c) in seen:\\n                return\\n            \\n            seen.add((r,c))\\n            \\n            # if it is a border\\n            if (r==0 or c==0 or r==len(grid)-1 or c==len(grid[0])-1 or grid[r-1][c] != current or grid[r+1][c] != current or grid[r][c-1] != current or grid[r][c+1] != current):\\n                border.add((r,c))\\n                \\n                \\n            dfs(r-1, c, current, border, seen)\\n            dfs(r+1, c, current, border, seen)\\n            dfs(r, c-1, current, border, seen)\\n            dfs(r, c+1, current, border, seen)\\n                \\n            return\\n        \\n        if not grid:\\n            return grid\\n        \\n        current = grid[r0][c0]\\n        border = set()\\n        seen = set()\\n        dfs(r0, c0, current, border, seen)\\n        \\n        for elem in border:\\n            grid[elem[0]][elem[1]] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853190,
                "title": "java-dfs-simple-solution-beats-100-runtime",
                "content": "\\nLogic is an application of *Flood Fill* algorithm. Here, there are two additional conditions to be checked: \\n\\n1. bordering cell of the input grid is always a border of the connected component, hence change the color to ncolor. \\n2. current cell bordering a cell (in the four direction) with a different color is also a border of the connected component. \\n\\t\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r, int c, int color) {\\n        dfs(grid,r,c,color,grid[r][c],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n    \\n    public void dfs(int[][] grid, int r, int c, int ncolor, int ocolor, boolean[][] visited){\\n        \\n        visited[r][c]=true;\\n        \\n\\t\\t//1. grid bordering cell is always a border of the connected component\\n        if( r==grid.length-1 || r==0 || c==0 || c==grid[0].length-1 )\\n                grid[r][c]=ncolor;\\n        \\n\\t\\t//2. if the next cell in the four directions is not of the same color, then the current cell is on border of the connected component\\n        if(r+1<grid.length && !visited[r+1][c]){\\n            if(grid[r+1][c]==ocolor)\\n                dfs(grid,r+1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n        \\n\\t\\tif(r-1>=0 && !visited[r-1][c]){\\n            if(grid[r-1][c]==ocolor)\\n                dfs(grid,r-1,c,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }\\n\\t\\t\\n        if(c+1<grid[0].length && !visited[r][c+1]){\\n            if(grid[r][c+1]==ocolor)\\n                dfs(grid,r,c+1,ncolor,ocolor,visited);  \\n            else\\n                grid[r][c]=ncolor;\\n        }\\n            \\n        if(c-1>=0 && !visited[r][c-1]){\\n            if(grid[r][c-1]==ocolor)\\n                dfs(grid,r,c-1,ncolor,ocolor,visited);\\n            else\\n                grid[r][c]=ncolor;\\n        }      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700798,
                "title": "easy-c-code-using-dfs-with-explanation-easier-to-understand-xd",
                "content": "Temporary visited array is made\\n\\n\\t\\t\\tvis[i][j]=1     -->     point is visited before\\n\\t\\t\\tvis[i][j]=2     -->     point needs to be colored as given color\\n2 conditions to color a point:\\n1) If current point is boundary itself\\n2) if any point adjacent does not have the same color as connected component color\\nIn both these cases... the current point will be coloured\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    void dfs(int u,int v,vector<vector<int>>& A,vector<vector<int>>& vis,int c){\\n        bool ans=false;// denotes weather the color of curent point needs to be changed\\n        vis[u][v]=1;\\n        int n=A.size();\\n        int m=A[0].size();\\n        for(int i=0;i<4;i++){\\n            int x=u+dx[i];\\n            int y=v+dy[i];\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && !vis[x][y] && A[x][y]==c){\\n                dfs(x,y,A,vis,c);//If same color node(unvisited) is found then do the dfs.\\n            }\\n            if(x>=0 && x<=n-1 && y>=0 && y<=m-1 && A[x][y]!=c){\\n                ans=true;// If another color adjacent point is found then current point\\'s color needs to be changed\\n            }\\n        }\\n        if(u==0 || v==0 || u==n-1 || v==m-1 || ans){\\n            vis[u][v]=2;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int c=A[r0][c0];\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        dfs(r0,c0,A,vis,c);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==2){\\n                    A[i][j]=color;\\n                }\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481841,
                "title": "simple-c-dsu-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n        private static readonly (int, int)[] _directions = { (0,1), (0,-1), (1,0), (-1,0) };\\n\\n        public int[][] ColorBorder(int[][] grid, int r0, int c0, int color)\\n        {\\n            int n = grid.Length;\\n            int m = grid[0].Length;\\n\\n            Unions dsu = new Unions(n * m);\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI >= 0 && newI < n && newJ >= 0 && newJ < m && grid[i][j] == grid[newI][newJ])\\n                        {\\n                            dsu.Union(ij, newI * m + newJ);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            var targetRoot = dsu.Find(r0 * m + c0);\\n            ISet<(int,int)> border = new HashSet<(int, int)>();\\n\\n            for (int i = 0; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int ij = i * m + j;\\n\\n                    if (dsu.Find(ij) != targetRoot)\\n                    {\\n                        continue;\\n                    }\\n\\n                    foreach (var dir in _directions)\\n                    {\\n                        int newI = i + dir.Item1;\\n                        int newJ = j + dir.Item2;\\n\\n                        if (newI < 0 || newI >= n || newJ < 0 || newJ >= m || dsu.Find(newI * m + newJ) != targetRoot)\\n                        {\\n                            border.Add((i, j));\\n                        }\\n                    }\\n                }\\n            }\\n\\n            foreach (var cell in border)\\n            {\\n                grid[cell.Item1][cell.Item2] = color;\\n            }\\n\\n            return grid;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294725,
                "title": "java-clean-short-only-one-pass-dfs-with-details-explanation",
                "content": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private static final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if (grid == null || grid.length == 0) return grid;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        visited[r0][c0] = true;\\n        dfs(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int r, int c, int targetColor, int color, boolean[][] visited) {\\n        int count = 0; // the number of neighbors is connected\\n        for (int[] dir : dirs) {\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n            if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length) continue;\\n            if (grid[x][y] == targetColor || visited[x][y]) count++; // If the neighbor is our target, Or if we\\'ve already visited it, which means its connected \\n            if (grid[x][y] == targetColor && !visited[x][y]) { // We only visit the neighbor whose color is our target.\\n                visited[x][y] = true; \\n                dfs(grid, x, y, targetColor, color, visited);\\n            }\\n        }\\n        \\n        if (count != 4) { // if the count < 4, which means its a border, we need to change the color\\n            grid[r][c] = color;\\n        }\\n        return;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991984,
                "title": "dfs-c-clean-and-concise-code-killer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint m,n;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& image, int sr, int sc, int color) \\n    {\\n        m=image.size();\\n        n=image[0].size();\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        int hunt=image[sr][sc];\\n        dfs(sr,sc,image,vis,hunt,color);\\n        return image;\\n    }\\n    void dfs(int i,int j,vector<vector<int>>& image,vector<vector<bool>>& vis,int hunt,int color)\\n    {\\n        if(i<0||j<0||i>=m||j>=n||vis[i][j]||image[i][j]!=hunt)\\n        return;\\n        vis[i][j]=true;\\n        if(i==0||j==0||i>=m-1||j>=n-1)\\n        {\\n            image[i][j]=color;\\n        }\\n        if((i+1<=m-1 && image[i+1][j]!=hunt && !vis[i+1][j]) || (i-1>=0 && image[i-1][j]!=hunt && !vis[i-1][j]) || (j+1<=n-1 && image[i][j+1]!=hunt && !vis[i][j+1]) || (j-1>=0 && image[i][j-1]!=hunt && !vis[i][j-1]))\\n        image[i][j] = color;\\n        dfs(i+1,j,image,vis,hunt,color);\\n        dfs(i-1,j,image,vis,hunt,color);\\n        dfs(i,j+1,image,vis,hunt,color);\\n        dfs(i,j-1,image,vis,hunt,color);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643291,
                "title": "dfs-intuitive-with-is-valid-pixel-and-is-border-helpers",
                "content": "# Intuition\\nAt first glance, the problem requires us to change the color of the border of a region in an image. Since the region is defined as all pixels with the same color that are 4-directionally connected (meaning they are connected either vertically or horizontally), the natural inclination is to solve this problem using depth-first search (DFS), a well-known algorithm used for traversing or searching tree or graph data structures. We use DFS to visit all pixels in the region. While doing this, we also check if the current pixel is on the border of the region, and if so, we color it with the new color.\\n\\n# Approach\\nThe approach to solve this problem involves three helper functions: `is_valid_pixel`, `is_border`, and `dfs`. `is_valid_pixel` checks if a pixel is inside the image and if it has the original color. `is_border` checks if a pixel is on the border of the image or is adjacent to a pixel that is not part of the region and has not yet been visited. If a pixel satisfies these conditions, it\\'s a border pixel.\\n\\nThe `dfs` function is where we perform the depth-first search. It checks if the current pixel is valid and unvisited. If it is a border pixel, we change its color to the new color. We then visit all four directions from the current pixel.\\n\\nFinally, the condition `original_color != newColor` prevents infinite loops when the new color is the same as the original color.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n), where n is the number of pixels in the image. In the worst-case scenario, every pixel in the image is visited once.\\n  \\n- Space complexity: The space complexity is also O(n), where n is the number of pixels in the image. The space complexity comes from the memory used to store the visited set and the memory used for the stack in the recursive DFS function. In the worst-case scenario, the depth of recursion could go up to n. This worst-case scenario would occur if all pixels have the same color and the starting pixel is at one corner of the image.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```\\n\\n# is_border\\n`is_border` determines whether a given pixel, specified by its row and column indices, is on the border of a region with the same color in the image.\\n\\nHere is a detailed explanation of the logic:\\n\\n- `row == 0 or row == R-1 or col == 0 or col == C-1`: This condition checks if the pixel is on the edge of the image. If it is, it\\'s part of the border by definition.\\n\\n- `any(0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited for dr, dc in DIRECTIONS)`: This condition uses the `any` function, which returns `True` if any element in the iterable it\\'s given is `True`. It\\'s iterating over the four possible directions from the current pixel (up, down, left, right) represented by `DIRECTIONS`.\\n\\n  - `0 <= row + dr < R and 0 <= col + dc < C`: These conditions check that the pixel in the direction `(dr, dc)` is still within the image bounds.\\n\\n  - `image[row + dr][col + dc] != original_color`: This condition checks that the color of the pixel in the direction `(dr, dc)` is different from the original color. This would mean that the current pixel is next to a pixel of a different color, and is therefore on the border of its region.\\n\\n  - `(row+dr, col+dc) not in visited`: This condition checks that the pixel in the direction `(dr, dc)` has not been visited. This is to ensure that we don\\'t count pixels that have already been recolored as being different, as they might have been the same color originally. \\nIf any of these conditions is `True`, the function will return `True`, indicating that the pixel is indeed a border pixel.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:\\n        DIRECTIONS = [(0, 1), (0, -1), (-1, 0), (1, 0)]\\n        R = len(image); C = len(image[0])\\n        original_color = image[sr][sc]\\n        visited = set()\\n\\n        # return true if the pixel is in the image\\n        def is_valid_pixel(row, col):\\n            return 0 <= row < R and 0 <= col < C and image[row][col] == original_color\\n\\n        # return True if the pixel is at the border\\n        def is_border(row, col):\\n            return row == 0 or row == R-1 or col == 0 or col == C-1 or any(\\n                0 <= row + dr < R and 0 <= col + dc < C and image[row + dr][col + dc] != original_color and (row+dr, col+dc) not in visited\\n                for dr, dc in DIRECTIONS\\n            )\\n\\n        def dfs(row, col):\\n            if not is_valid_pixel(row, col) or (row, col) in visited:\\n                return\\n            if is_border(row, col):\\n                image[row][col] = newColor\\n            visited.add((row, col))\\n            for dr, dc in DIRECTIONS:\\n                dfs(row + dr, col + dc)\\n\\n        if original_color != newColor:\\n            dfs(sr, sc)\\n        return image\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633496,
                "title": "c-bfs-onepass",
                "content": "\\n# Approach\\nmain idea is that if a node does not have similar values on all 4 sides than it is border cell. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int clr=grid[row][col];\\n\\n        vector<vector<int>> dir = {{-1,0},{1,0},{0,1},{0,-1}};\\n        vector<vector<bool>> vi(m,vector<bool>(n,0));\\n        vi[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n\\n            int cnt=0;\\n            for(int i=0;i<dir.size();i++){\\n                int nr=r+dir[i][0];\\n                int nc=c+dir[i][1];\\n                if(nr<m && nr>=0 && nc<n && nc>=0){\\n                    if(vi[nr][nc]==1) cnt++;\\n                    else if(grid[nr][nc]==clr){\\n                        cnt++;\\n                        vi[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n            if(cnt!=4) grid[r][c]=color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606150,
                "title": "correct-c-solution-with-missing-testcase-so-far",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\\nI HAVE SUBMITTED AN VALID TESTCASE WHERE OTHER SOLUTION LIKE BELOW GIVE TLE BUT GOT ACCEPTED WHEN SUBMITTED: \\nhttps://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/13932\\n\\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```\\n#UPDATED\\n1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\nTHIS TESTCASE HAS BEEN ADDED NOW \\nNOW THE ABOVE WRONG(TLE) ANS WILL NOT BE ACCEPTED\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       \\n    //my solution using visited\\n    //easy to understand\\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color,vector<vector<bool> >& visited){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true; \\n        }\\n        if(visited[r][c]){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            //checking is color is different after checking visited because we ourselves may have had changed the color\\n            return true;\\n        }\\n        visited[r][c] = true;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color,visited);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color,visited);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color,visited);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color,visited);\\n        if(u || f || d || b){\\n            // GETTING TRUE IMPLIES THAT CURRENT VERTEX IS ON BORDER\\n            grid[r][c] = color; // changing to required color\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool> (grid[0].size(),false));\\n        dfsHelper(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n    }\\n    \\n```\n```\\n    /* WRONG(TLE) BUT ACCEPTED SOLUTION\\n\\n    This solution(below) got submitted successfully but it should give TLE for these testcases:\\n    1) Testcase of 10 x 10 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/5krng\\n    2) Testcase of 50 x 50 grid with all 1\\'s, row = 0, col = 0, color = 3: https://justpaste.it/9y9si\\n    */\\n    \\n\\n    bool dfsHelper(vector<vector<int>>&grid, int r, int c,int &componentColor ,int &color){\\n        \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()){\\n            return true;\\n        }\\n        if(grid[r][c] == -1 * componentColor){\\n            return false;\\n        }\\n        if(grid[r][c] != componentColor){\\n            return true;\\n        }\\n\\n        grid[r][c] *= -1;\\n        bool u = dfsHelper(grid,r-1,c,componentColor,color);\\n        bool f = dfsHelper(grid,r,c+1,componentColor,color);\\n        bool d = dfsHelper(grid,r+1,c,componentColor,color);\\n        bool b = dfsHelper(grid,r,c-1,componentColor,color);\\n        if(!u && !f && !d && !b){\\n            grid[r][c] *= -1;\\n        }\\n        return false;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int componentColor = grid[row][col];\\n        dfsHelper(grid,row,col,componentColor,color);\\n        for(int i = 0; i< grid.size(); i++){\\n            for(int j = 0; j< grid[0].size(); j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175011,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar colorBorder = function(grid, row, col, color) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Set();\\n    const isBorder = (row, col, color) => {\\n        const value = grid[row]?.[col];\\n        return value === \\'x\\' || value === color;\\n    };\\n    const coloring = (row, col, color) => {\\n        if (row < 0 || col < 0 || row >= m || col >= n) return;\\n        if (visited.has(`${row}_${col}`)) return;\\n        const value = grid[row][col];\\n        if (value !== color) return;\\n\\n        grid[row][col] = \\'x\\';\\n        coloring(row - 1, col, color);\\n        coloring(row + 1, col, color);\\n        coloring(row, col - 1, color);\\n        coloring(row, col + 1, color);\\n        const checkTop = isBorder(row - 1, col, color);\\n        const checkBottom = isBorder(row + 1, col, color);\\n        const checkLeft = isBorder(row, col - 1, color);\\n        const checkRight = isBorder(row, col + 1, color);\\n        if (checkTop && checkBottom && checkLeft && checkRight) {\\n          grid[row][col] = color;\\n          visited.add(`${row}_${col}`);\\n        }\\n    };\\n\\n    coloring(row, col, grid[row][col]);\\n    return grid.map(col => col.map(value => value === \\'x\\' ? color : value ));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3112503,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nFrog walk Approach\\n\\n# Approach\\ncolorTheComponent (getNeighbors) (coloring the boundary Components as well) with -1 as color\\nfind Components which aren\\'t part of boundary\\nreplace Components which aren\\'t part of boundary with original color\\nreplace all -1 components with original color\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction getNeighbors(grid, row, column) {\\n\\tconst totalRows = grid.length;\\n\\tconst totalColumns = grid[0].length;\\n\\tconst neighbors = [];\\n\\tif (row > 0) {\\n\\t\\tneighbors.push({ rowIndex: row - 1, columnIndex: column });\\n\\t}\\n\\tif (row < totalRows - 1) {\\n\\t\\tneighbors.push({ rowIndex: row + 1, columnIndex: column });\\n\\t}\\n\\n\\tif (column > 0) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column - 1 });\\n\\t}\\n\\n\\tif (column < totalColumns - 1) {\\n\\t\\tneighbors.push({ rowIndex: row, columnIndex: column + 1 });\\n\\t}\\n\\n\\treturn neighbors;\\n}\\n\\nfunction colorTheComponent(grid, row, col, foundColor, color = -1, explored = {}) {\\n\\tconst neighbors = getNeighbors(grid, row, col);\\n\\tfor (const { rowIndex, columnIndex } of neighbors) {\\n\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\tif (!explored[key] && grid[rowIndex][columnIndex] === foundColor) {\\n\\t\\t\\texplored[key] = true;\\n\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\tcolorTheComponent(grid, rowIndex, columnIndex, foundColor, color, explored);\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction isBoundary(grid, rowIndex, columnIndex) {\\n\\tconst response =\\n\\t\\tgrid[rowIndex - 1] &&\\n\\t\\tgrid[rowIndex - 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex + 1] &&\\n\\t\\tgrid[rowIndex + 1][columnIndex] === -1 &&\\n\\t\\tgrid[rowIndex] &&\\n\\t\\tgrid[rowIndex][columnIndex - 1] === -1 &&\\n\\t\\tgrid[rowIndex][columnIndex + 1] === -1\\n\\t\\t\\t? true\\n\\t\\t\\t: false;\\n\\treturn response;\\n}\\n\\nvar colorBorder = function(grid, row, col, color) {\\n\\tconst foundColor = grid[row][col];\\n\\tgrid[row][col] = -1;\\n\\tconst notInBoundary = [];\\n\\tcolorTheComponent(grid, row, col, foundColor);\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tif (isBoundary(grid, rowIndex, columnIndex)) {\\n\\t\\t\\t\\t\\tnotInBoundary.push({ rowIndex, columnIndex });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (const { rowIndex, columnIndex } of notInBoundary) {\\n\\t\\tgrid[rowIndex][columnIndex] = foundColor;\\n\\t}\\n\\n\\tfor (let rowIndex = 0; rowIndex < grid.length; rowIndex++) {\\n\\t\\tfor (let columnIndex = 0; columnIndex < grid[rowIndex].length; columnIndex++) {\\n\\t\\t\\tif (grid[rowIndex][columnIndex] === -1) {\\n\\t\\t\\t\\tgrid[rowIndex][columnIndex] = color;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648186,
                "title": "2ms-java-ac-solution-in-o-1-space-dfs-graph-traversal",
                "content": "\\n\\t\\n\\t\\n\\tclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        return grid;\\n    }\\n    int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void dfs(int[][] grid,int row,int col,int inCo){\\n        \\n        grid[row][col] = -inCo;\\n        int c=0;\\n        for(int i=0;i<4;i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash<0 || coldash<0 || rowdash>=grid.length || coldash>=grid[0].length\\n               || Math.abs(grid[rowdash][coldash]) != inCo)\\n                continue;\\n            c++;\\n            if(grid[rowdash][coldash] != -inCo){\\n                dfs(grid,rowdash,coldash,inCo);\\n            }\\n           \\n        }\\n        if(c==4)\\n            grid[row][col] = inCo;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int ans[][] = grid;\\n        int inCo = grid[row][col];\\n        dfs(grid,row,col,grid[row][col]);\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2635883,
                "title": "c-python-flood-fill-with-condition-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int j, vector<vector<int>>& grid, int orgc, int c, vector<vector<int>> &temp) {\\n        if(i < 0 || i == grid.size() || j < 0 || j == grid[0].size() || grid[i][j] != orgc || grid[i][j] == c) return;\\n        grid[i][j] = c;\\n        \\n        dfs(i + 1, j, grid, orgc, c, temp);\\n        dfs(i - 1, j, grid, orgc, c, temp);\\n        dfs(i, j + 1, grid, orgc, c, temp);\\n        dfs(i, j - 1, grid, orgc, c, temp);\\n        \\n        if(i - 1 >= 0 && i + 1 < grid.size() && j - 1 >= 0 && j + 1 < grid[0].size()) {\\n            if(temp[i - 1][j] == orgc && temp[i + 1][j] == orgc && temp[i][j - 1] == orgc && temp[i][j + 1] == orgc) grid[i][j] = orgc;\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int c) {\\n        vector<vector<int>> temp = grid;\\n        dfs(i, j, grid, grid[i][j], c, temp);\\n        return grid;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        temp = copy.deepcopy(grid)\\n        \\n        def dfs(i, j, g, orgc, c, temp):\\n            if(i < 0 or i == len(g) or j < 0 or j == len(g[0]) or g[i][j] != orgc or g[i][j] == c): return\\n            g[i][j] = c\\n            \\n            dfs(i + 1, j, g, orgc, c, temp)\\n            dfs(i - 1, j, g, orgc, c, temp)\\n            dfs(i, j + 1, g, orgc, c, temp)\\n            dfs(i, j - 1, g, orgc, c, temp)\\n            \\n            if(i - 1 >= 0 and i + 1 < len(g) and j - 1 >= 0 and j + 1 < len(g[0])):\\n                if(temp[i - 1][j] == orgc and temp[i + 1][j] == orgc and temp[i][j - 1] == orgc and temp[i][j + 1] == orgc):\\n                    g[i][j] = orgc\\n        \\n        dfs(row, col, grid, grid[row][col], color, temp)\\n        return grid\\n             \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354488,
                "title": "dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1};\\n    int dc[4] = {0,-1,1,0};\\n    void dfs(int r,int c,int n,int m,vector<vector<int>>& grid){\\n  \\n        \\n        int count = 0;\\n        grid[r][c] = -grid[r][c];\\n        \\n        for(int i=0;i<4;i++){\\n            int x = r + dr[i];\\n            int y = c + dc[i];\\n            \\n            if(x<0 || x>=n || y<0 || y>=m)\\n                continue;\\n            \\n            if(grid[x][y] == grid[r][c]){\\n                count += 1;\\n            }\\n            \\n            else if(-grid[x][y] == grid[r][c]){\\n                count += 1;\\n                dfs(x,y,n,m,grid);\\n            }\\n        }\\n        \\n        if(count == 4){\\n            grid[r][c] = -grid[r][c];\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        dfs(row,col,n,m,grid);\\n        // return grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dr[4] = {-1,0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2303112,
                "title": "80-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tdef calc(i, j, c):\\n\\t\\tif not(0<=i<m and 0<=j<n): return 1\\n\\t\\treturn grid[i][j] != c and grid[i][j] != -1\\n\\t\\t\\n\\tdef dfs(i, j):\\n\\t\\tif not(0<=i<m and 0<=j<n):\\n\\t\\t\\treturn\\n\\t\\tvis.add((i, j))\\n\\t\\tc = grid[i][j]\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<m and 0<=j+y<n and grid[i+x][j+y] == c and (i+x, j+y) not in vis):\\n\\t\\t\\t\\tdfs(i+x, j+y)          \\n\\t\\tif(calc(i-1, j, c) or calc(i+1, j, c) or calc(i, j+1, c) or calc(i, j-1, c)):\\n\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\n\\tvis = set()\\n\\tdfs(row, col)\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == -1):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\treturn(grid)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2163778,
                "title": "dfs-and-bfs",
                "content": "**BFS SOLUTION**\\n\\n\\tclass Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\t\\t\\t\\tint originalColor = grid[row][col];\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\t\\t\\t\\tqueue<Pair> qu;\\n\\t\\t\\t\\tqu.push(Pair(row,col, isBorder(grid,row,col)));\\n\\n\\t\\t\\t\\tvector<Pair> vp;\\n\\t\\t\\t\\twhile(!qu.empty()){\\n\\t\\t\\t\\t\\tauto top = qu.front();\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t\\tif(visited[top.i][top.j])continue;\\n\\t\\t\\t\\t\\tvisited[top.i][top.j] = true;\\n\\t\\t\\t\\t\\t// some checks\\n\\t\\t\\t\\t\\tvp.push_back(top);\\n\\n\\t\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\t\\tint i = d[0] + top.i;\\n\\t\\t\\t\\t\\t\\tint j = d[1] + top.j;\\n\\t\\t\\t\\t\\t\\tif(i>=0 and j>=0 and i<grid.size() and j<grid[0].size() and visited[i][j]==false and grid[i][j]==originalColor){\\n\\t\\t\\t\\t\\t\\t\\tqu.push(Pair(i,j, isBorder(grid,i,j)));\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto p : vp){\\n\\t\\t\\t\\t\\tif(p.border){\\n\\t\\t\\t\\t\\t\\tgrid[p.i][p.j] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool isBorder(vector<vector<int>> &grid,int i,int j){\\n\\t\\t\\t\\tif(i==0 || j == 0 || i==grid.size() -1 || j==grid[0].size() - 1){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + i;\\n\\t\\t\\t\\t\\tint y = d[1] + j;\\n\\n\\t\\t\\t\\t\\tif(grid[i][j]!=grid[x][y])return true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\n**DFS SOLUTION:**\\nNot sure about some check conditions 100% but it passed all testcases \\n\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tvector<vector<bool>> visited;\\n\\t\\t\\tint dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\\n\\t\\tpublic:\\n\\t\\t\\tvoid dfs(vector<vector<int>> &grid,int row,int col,int r,int c,int color){\\n\\t\\t\\t\\tif(visited[r][c])return;\\n\\t\\t\\t\\tif(grid[row][col] != grid[r][c])return;\\n\\t\\t\\t\\tbool current = false;\\n\\t\\t\\t\\tvisited[r][c] = true;\\n\\t\\t\\t\\tfor(auto d : dir){\\n\\t\\t\\t\\t\\tint x = d[0] + r;\\n\\t\\t\\t\\t\\tint y = d[1] + c;\\n\\n\\t\\t\\t\\t\\tif(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() ||(visited[x][y]==false and grid[x][y]!=grid[row][col])){\\n\\t\\t\\t\\t\\t\\tcurrent = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(x >= 0 && y >= 0 && x < grid.size() && y < grid[0].size() && visited[x][y]==false){\\n\\t\\t\\t\\t\\t\\tdfs(grid,row,col,x,y,color);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current){\\n\\t\\t\\t\\t\\tgrid[r][c] = color;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\t\\t\\t\\t// dfs\\n\\n\\t\\t\\t\\tvisited = vector<vector<bool>>(grid.size(),vector<bool>(grid[0].size(),0));\\n\\n\\t\\t\\t\\tdfs(grid,row,col,row,col,color);\\n\\n\\t\\t\\t\\treturn grid;\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\t\\tstruct Pair{\\n\\t\\t\\t\\tint i;\\n\\t\\t\\t\\tint j;\\n\\t\\t\\t\\tbool border;\\n\\n\\t\\t\\t\\tPair(int i,int j,bool border){\\n\\t\\t\\t\\t\\tthis->i = i;\\n\\t\\t\\t\\t\\tthis->j = j;\\n\\t\\t\\t\\t\\tthis->border = border;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2133781,
                "title": "python-standard-dfs-71-faster",
                "content": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: the problem can be tackled using breadth first approach\\n    start the bfs from (row, col) and maintain visited and border_set\\n    \"\"\"\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        start_color = grid[row][col]\\n        visited = set()\\n        \\n        def is_valid(index):\\n            i, j = index\\n            if 0 <= i < m and 0 <= j < n:\\n                return True\\n            return False\\n        \\n        def is_boundary(index):\\n            i, j = index\\n            if i == 0 or i == m-1 or j == 0 or j == n-1:\\n                return True\\n            return False\\n        \\n        def get_neighbors(index):\\n            i, j = index\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(index):\\n            visited.add(index)\\n            \\n            flag = 0\\n            if is_boundary(index):\\n                flag = 1\\n                \\n            for pos in get_neighbors(index):\\n                if is_valid(pos) and pos not in visited: \\n                    if grid[pos[0]][pos[1]] == start_color:\\n                        dfs(pos)\\n                    else:\\n                        # it\\'s a border point, index needs to be colored with color\\n                        flag = 1\\n            if flag:\\n                grid[index[0]][index[1]] = color\\n                \\n        dfs((row, col))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918709,
                "title": "c-easy-solution-dfs-explained",
                "content": "What question has asked?\\nin the connectred component mark all the values to the colored one which are on the border of the sqaure or who has adjacently atleast one square which is not the part of connected component.\\n```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// m,n,co are number of row, column and color to assigned\\nint m,n,co;\\n    void dfs(vector<vector<int>>& grid , vector<vector<bool>>& vis , int i , int j ,int val)\\n    {\\n\\t// base condition to eliminate the coordinate\\n        if(i<0 || j<0 || i>=m || j>=n || vis[i][j] || grid[i][j]!=val)\\n            return;\\n        vis[i][j] = true;\\n\\t\\t// check if present on the border of the square or not\\n        if(i==0 || j==0 || i>=m-1 || j>=n-1)\\n            grid[i][j]=co;\\n\\t\\t\\t// conditon to check if their is present some differnt color square on the border of the connected component\\n        if((i+1<=m-1 && grid[i+1][j]!=val && !vis[i+1][j]) || (i-1>=0 && grid[i-1][j]!=val && !vis[i-1][j]) || (j+1<=n-1 && grid[i][j+1]!=val && !vis[i][j+1]) || (j-1>=0 && grid[i][j-1]!=val && !vis[i][j-1]))\\n            grid[i][j] = co;\\n\\t\\t\\t// do dfs in all 4 directions\\n        dfs(grid,vis,i+1,j,val);\\n        dfs(grid,vis,i,j+1,val);\\n        dfs(grid,vis,i,j-1,val);\\n        dfs(grid,vis,i-1,j,val);\\n        return;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        co = color;\\n        vector<vector<bool>> vis(m,vector<bool>(n,false));\\n        dfs(grid,vis,row,col,grid[row][col]);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905263,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \\n        def dfs(i,j,parent):\\n            if (i,j) in visited:\\n                return\\n            \\n            if i<0 or j<0 or i>=m or j>=n or grid[i][j]!=ic  :\\n                grid[parent[0]][parent[1]]=color\\n                return\\n            \\n            visited.add((i,j))\\n            \\n            dfs(i-1,j,(i,j))\\n            dfs(i+1,j,(i,j))\\n            dfs(i,j-1,(i,j))\\n            dfs(i,j+1,(i,j))\\n            \\n        ic=grid[row][col]\\n        m=len(grid)\\n        n=len(grid[0])\\n        visited=set()\\n        dfs(row,col,(-1,-1))\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850221,
                "title": "java-dfs-recursion-2-passes",
                "content": "Pretty simple solution using DFS recursion. The idea was to mark the component using negatives and then flip them back in a second pass.\\n\\nIf I didn\\'t want to mess with the initial grid I would create a second result grid. Then do a single pass writing to the result grid and use non-zero values in said grid to track visited cells. As the final step I\\'d loop through the origional grid to copy over everything missing in the result grid. \\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        markComponent(grid,row,col,grid[row][col],color);\\n        fixComponent(grid,row,col);\\n        return grid;\\n    }\\n    \\n    int markComponent(int[][] g, int r, int c, int t, int color) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || (g[r][c] != t && g[r][c] > 0)) return 0;\\n        if (g[r][c] > 0) {\\n            g[r][c] = -t;\\n            if (markComponent(g,r-1,c,t,color) +\\n               markComponent(g,r+1,c,t,color) +\\n               markComponent(g,r,c-1,t,color) +\\n               markComponent(g,r,c+1,t,color) < 4)\\n                g[r][c] = -color;\\n        }\\n        return 1;\\n    }\\n    \\n    void fixComponent(int[][] g, int r, int c) {\\n        if (r < 0 || c < 0 || r == g.length || c == g[0].length || g[r][c] > 0) return;\\n        g[r][c] = -g[r][c];\\n        fixComponent(g,r-1,c);\\n        fixComponent(g,r+1,c);\\n        fixComponent(g,r,c-1);\\n        fixComponent(g,r,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615762,
                "title": "c-bfs",
                "content": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint direction[][4] = {{1,-1,0,0}, {0,0,1,-1}};\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int colour = grid[row][col];\\n        if (colour == color) {\\n            return grid;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n\\n       \\n        while (!q.empty()) {\\n            int row = q.front().first, col = q.front().second;\\n            int cnt = 0;\\n            for (int d = 0; d < 4; ++d) {\\n                int r = row + direction[0][d], c = col + direction[1][d];\\n                \\n                if (0 <= r && r < grid.size() && \\n                    0 <= c && c < grid[r].size()) {\\n                    cnt += grid[r][c] == colour || grid[r][c] < 0;\\n                    if (grid[r][c] == colour) {\\n                        q.push({r, c});\\n                    }\\n                }\\n            }\\n            if (cnt < 4) {\\n                grid[row][col] = -color;\\n            } else {\\n                grid[row][col] *= -1;\\n            }\\n            q.pop();\\n        }\\n\\n        for (int i = 0; i < grid.size(); ++i) {\\n            for (int j = 0; j < grid[i].size(); ++j) {\\n                grid[i][j] = abs(grid[i][j]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613627,
                "title": "simple-java-dfs",
                "content": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n   public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if (grid == null || grid.length == 0) {\\n            return grid;\\n        }\\n        int val = grid[row][col];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(grid, row, col, val, visited);\\n        fillGrid(grid, color, visited);\\n        return grid;\\n    }\\n\\n    public void dfs(int[][] grid, int row, int col, int val, boolean[][] visited) {\\n\\n        if (row >= grid.length || col >= grid[0].length || row < 0 || col < 0 || grid[row][col] != val || visited[row][col]) {\\n            return;\\n        }\\n\\n        //LURD\\n        if (grid[row][col] == val) {\\n            visited[row][col] = true;\\n            dfs(grid, row, col - 1, val, visited);\\n            dfs(grid, row + 1, col, val, visited);\\n            dfs(grid, row, col + 1, val, visited);\\n            dfs(grid, row - 1, col, val, visited);\\n        }\\n    }\\n\\n    public void fillGrid(int[][] grid, int color, boolean[][] visited) {\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n\\n                if (visited[i][j]) {\\n\\n                    //color boundary elements\\n                    if (i + 1 >= grid.length || j + 1 >= grid[0].length || i - 1 < 0 || j - 1 < 0) {\\n                        grid[i][j] = color;\\n                    }\\n                    //middle element\\n                    else if ((visited[i + 1][j] && visited[i - 1][j] && visited[i][j - 1] && visited[i][j + 1])) {\\n                        continue;\\n                    }\\n                    else{\\n                        grid[i][j] = color;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602546,
                "title": "java-easy-and-clean-dfs-solution-1ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        find(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n    \\n    public int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    public void find(int[][] grid, int r, int c, int toChange){\\n        grid[r][c] = -toChange;\\n        int count = 0;       \\n        for(int i = 0; i < 4; i++){\\n            int nr = r + dir[i][0];\\n            int nc = c + dir[i][1];         \\n            if(nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || Math.abs(grid[nr][nc]) != toChange)\\n                continue;\\n            count++;\\n            if(grid[nr][nc] == toChange)\\n                find(grid, nr, nc, toChange);\\n        }        \\n        if(count == 4)\\n            grid[r][c] = toChange;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563141,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int s=grid[row][col];\\n        vector<pair<int,int>>indexes;    // storing border indexes\\n        vector<vector<bool>>visited(grid.size(),vector<bool>(grid[0].size(),0)); // checking for visited nodes\\n        if(s!=color)dfs(grid,row,col,s,indexes,visited);\\n        for(int i=0;i<v.size();i++){\\n            grid[v[i].first][v[i].second]=color;\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid,int row,int col,int &s,vector<pair<int,int>>&indexes,vector<vector<bool>>&visited){\\n        if(row<0 or col<0 or row>=grid.size() or col>=grid[0].size() or grid[row][col]!=s )return false;\\n        if(visited[row][col])return true;\\n        visited[row][col]=true;\\n        bool a=dfs(grid,row+1,col,s,indexes,visited);\\n        bool b=dfs(grid,row,col+1,s,indexes,visited);\\n        bool c=dfs(grid,row-1,col,s,indexes,visited);\\n        bool d=dfs(grid,row,col-1,s,indexes,visited);\\n        if(!(a and b and c and d))v.push_back(make_pair(row,col));\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1501918,
                "title": "c-bfs-solution",
                "content": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<vector<int>> res = grid;\\n        vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        set<pair<int, int>> visited;\\n        queue<pair<int, int>> q;\\n        q.push({r0, c0});\\n        visited.insert({r0, c0});\\n        int val = grid[r0][c0];\\n        \\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop();\\n            int notConnected = 0;\\n            for (auto dir : dirs) {\\n                int x = cur.first + dir.first;\\n                int y = cur.second + dir.second;\\n                // check the new point is valid\\n                if (x>=0 && x<grid.size() && y>=0 && y<grid[0].size() && visited.count({x,y})==0) {\\n                    if (grid[x][y] == val) {\\n                        q.push({x, y});\\n                        visited.insert({x, y});\\n                    } else {\\n                        ++notConnected;\\n                    }\\n                } else if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size()) {\\n                    ++notConnected;\\n                }\\n            }\\n            // check if this point is a border or not, if yes, color it !\\n            if (notConnected > 0) res[cur.first][cur.second] = color;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1468590,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows,cols=len(grid),len(grid[0])\\n        g=[x.copy() for x in grid]#Create a copy of grid\\n        def dfs(i,j,n,visit):\\n            cnt=0\\n            for nei in [(i-1,j),(i,j+1),(i+1,j),(i,j-1)]:#Iterate neighbours\\n                nx,ny=nei\\n                if 0<=nx<rows and 0<=ny<cols and grid[nx][ny]==n:\\n                    cnt+=1\\n                    if nei not in visit:\\n                        visit.append(nei)\\n                        dfs(nx,ny,n,visit)\\n            if cnt!=4:#If a neighbour is not at border cnt will be 4\\n                g[i][j]=color\\n        dfs(row,col,grid[row][col],[(row,col)])\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375273,
                "title": "c-dfs-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&v,int i,int j,int c,int color,vector<vector<bool>>&vis)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[0].size() )\\n            return;\\n        if(v[i][j]!=color || vis[i][j])\\n            return;\\n        vis[i][j]=true;\\n        if(i==0 || j==0 || i==v.size()-1 || j==v[0].size()-1)\\n        {v[i][j]=c;}\\n        if(( i+1<v.size()&&v[i+1][j]!=color && !vis[i+1][j] ) || ( i-1>=0 &&v[i-1][j]!=color && !vis[i-1][j] ) || ( j+1<v[0].size() &&v[i][j+1]!=color && !vis[i][j+1]) || ( j-1>=0 &&v[i][j-1]!=color && !vis[i][j-1]))\\n        {v[i][j]=c;}\\n        \\n        dfs(v,i+1,j,c,color,vis);\\n         dfs(v,i-1,j,c,color,vis);\\n         dfs(v,i,j-1,c,color,vis);\\n         dfs(v,i,j+1,c,color,vis);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>>v(n,vector<bool>(m,false));\\n       \\n        dfs(grid,r0,c0,color,grid[r0][c0],v);\\n      \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313469,
                "title": "java-dfs-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1,0} ,{-1 , 0} , {0,1} , {0,-1}};\\n   public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int oldColor = grid[r0][c0];\\n\\n        if (oldColor == color)\\n            return grid;\\n\\n        boolean[][] vis = new boolean[n][m];\\n\\n        paint(grid, r0, c0, vis, color, oldColor);\\n\\n        return grid;\\n    }\\n    public void paint(int[][] grid, int r, int c, boolean[][] vis, int color, int oldColor) {\\n\\n        int count = 0;\\n\\n        grid[r][c] = color;\\n        vis[r][c] = true;\\n\\n        for (int d = 0; d < 4; d++) {\\n            int x = r + dir[d][0];\\n            int y = c + dir[d][1];\\n\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length) {\\n                if (grid[x][y] == oldColor) {\\n                    count++;\\n                    paint(grid, x, y, vis, color, oldColor);\\n                } else if (grid[x][y] == color) {\\n                    if (vis[x][y])\\n                        count++;\\n                }\\n            }\\n        }\\n        if (count == 4)\\n            grid[r][c] = oldColor;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305444,
                "title": "simple-dfs-java-100-faster",
                "content": "```\\nclass Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}\\n// if it is already visited(it means that it was part of same component)         \\n         if(v[i][j]==1){\\n            return 0;\\n        }\\n// if the value is not same as that of current component          \\n        if(g[i][j]!=val)return -1;\\n       \\n         v[i][j]=1;\\n        \\n        int v1=dfs(i+1,j,g,ans,val,v);\\n         int v2=dfs(i-1,j,g,ans,val,v);\\n        int v3=dfs(i,j+1,g,ans,val,v);\\n        int v4=dfs(i,j-1,g,ans,val,v);\\n        \\n         if(v1==0&&v2==0&&v3==0&&v4==0)return 0;\\n        \\n         \\n         \\n         g[i][j]=ans;\\n         return 0;\\n    }\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int[][] v=new int[grid.length][grid[0].length];\\n        dfs(r0,c0,grid,color,grid[r0][c0],v);\\n        return grid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     private int dfs(int i,int j,int[][] g,int ans,int val,int[][] v){\\n//check if it is out of boundary \\n         if(i<0||j<0||i>=g.length||j>=g[0].length){return -1;}",
                "codeTag": "Java"
            },
            {
                "id": 1256359,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n     int defaults = 0; \\n    int dir[][] = {{1, 0} , {-1 , 0} , {0 , 1} , { 0 , -1}}; \\n\\n    public void dfs(int[][] grid , int r ,int c , int color , boolean[][] visited)\\n    {\\n        int count = 0; \\n        visited[r][c] = true; \\n        grid[r][c] = color; \\n        for(int d = 0 ; d < 4 ; d++)\\n        {\\n            int x = r + dir[d][0]; //r =  1 + 1 = 2\\n            int y = c + dir[d][1]; //c =  1 + 0 = 1 \\n            if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) //valid posiiton \\n            {\\n                if(visited[x][y] == true)\\n                   count++;     \\n                else\\n                {\\n                    if(grid[x][y] == defaults) //not visited and \\n                    {\\n                        count++;  \\n                        dfs(grid , x , y , color , visited); \\n                    }\\n                }\\n            }\\n            if(count == 4)\\n                grid[r][c] = defaults;  \\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;  \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        defaults = grid[r0][c0]; \\n        dfs(grid , r0 , c0, color , visited); \\n        return grid; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238412,
                "title": "bfs-using-unordered-set-for-visited-coordinates",
                "content": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "\\n        int dir[4][2] = { {-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        if(grid.size()==0 || grid[0].size()==0) return grid;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       \\n        int cl = grid[r0][c0];\\n       \\n        queue<int>que;\\n        que.push(r0*m+c0);\\n        unordered_set<int>vis;\\n        vis.insert(r0*m+c0);\\n          \\n        while(que.size()!=0){\\n            \\n            int t = que.front();\\n            que.pop();\\n            \\n            int r = t/m;\\n            int c = t%m;\\n                \\n           if (r == 0 || r == n - 1 || c == 0 || c == m - 1) { grid[r][c] = color; }\\n          \\n             \\n            for(int d=0;d<4;d++){\\n                int nr= r + dir[d][0];\\n                int nc= c + dir[d][1];\\n                if(nr>=0 && nr<n && nc>=0 && nc < m && !vis.count(nr*m+nc)){\\n                        if(grid[nr][nc]==cl){\\n                            vis.insert(nr*m+nc);\\n                            que.push(nr*m+nc);\\n                        }else{\\n                                grid[r][c]=color;\\n                             }\\n                        }\\n            \\n                    }\\n                \\n            }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1150961,
                "title": "java-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    boolean[][] visited;\\n    \\n    private void dfs(int[][] grid, int r0, int c0, int origColor, int newColor, int n, int m) {       \\n\\n\\t\\tvisited[r0][c0] = true;\\n        for(int[] d: dir) {\\n            int x = r0 + d[0];\\n            int y = c0 + d[1];\\n            \\n\\t\\t\\t// if next cell is either boundary OR of diff color but not previously visited\\n            if(x>=n || x<0 || y>=m || y<0 || (!visited[x][y] && grid[x][y]!=origColor)) {\\n                grid[r0][c0] = newColor;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// continue if previously visited\\n            if(visited[x][y])\\n                continue;\\n            \\n            dfs(grid, x, y, origColor, newColor, n, m);\\n        }\\n    }\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        if(grid[r0][c0] == color)\\n            return grid;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        visited = new boolean[n][m];\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], color, n, m);\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791470,
                "title": "c-solution-using-dfs-faster-than-99-39-with-explanation",
                "content": "The approach is simple DFS that finds the **connected** component from *r0, c0*. In addition, we need to color the boundary of the connected component with the given *color*.\\n\\nA **boundary** of a connected component is defined as the boxes which are **surrounded 4-directonally by atleast one box that has a different color** other than that of connected component. Consider an example below to understand the boundary, *r0* = 1, *c0* = 1, *color* = 3.\\n\\n![image](https://assets.leetcode.com/users/images/eb05a688-bbbd-41e9-90c6-d4eb4c5bf3f3_1597411149.5754387.png)\\n\\n**Marking Boundary in DFS**\\nUse a variable to keep track of count of same boxes present in 4-directions. Let it be *same*. It is incremented in two cases:\\n1. If a box is already visited, then it must be a part of the connected component.\\n2. When making recursive call for unvisited part of the connected component.\\n\\nIf *same* is less than 4 for a box, change its color to the given *color* as it is the part of the boundary. \\n```\\nclass Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0};\\n    int yDir[4] = {0, 1, 0, -1};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, bool **visited, int color) {\\n        visited[r][c] = true;\\n        \\n\\t\\t// variable to keep track of count of same boxes in 4-directions\\n        int same = 0;\\n        \\n\\t\\t// checking 4-directionally\\n        for(int k = 0; k < 4; k++) {\\n            int i = r + xDir[k], j = c + yDir[k];\\n              \\n            if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\\n                continue;\\n            \\n\\t\\t\\t// if visited, it must a part of the connected component\\n            if(visited[i][j]) {\\n                same++;\\n                continue;\\n            }\\n            \\n\\t\\t\\t// recursive call for unvisited part of the connected component\\n            if(grid[i][j] == grid[r][c]) {\\n                dfs(i, j, grid, visited, color);\\n                same++;\\n            }\\n        }\\n        \\n\\t\\t// if it is the part of the boundary\\n        if(same < 4)\\n            grid[r][c] = color;\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        bool **visited;\\n        visited = new bool*[grid.size()];\\n        \\n        for(int i = 0; i < grid.size(); i++) {\\n            visited[i] = new bool[grid[0].size()];\\n            \\n            for(int j = 0; j < grid[0].size(); j++)\\n                visited[i][j] = false;\\n        }\\n        \\n        dfs(r0, c0, grid, visited, color);\\n        \\n        return grid;\\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int xDir[4] = {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 777088,
                "title": "python-dfs",
                "content": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\ndef colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        visited = [[False for _ in xrange(n)] for _ in xrange(m)]\\n        def check(x, y):\\n            return 0 <= x < m and 0 <= y < n\\n        def findBorder(i, j):\\n            visited[i][j] = True\\n            flag = False\\n            for x, y in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):\\n                if check(x, y) and not visited[x][y] and grid[x][y] == grid[i][j]:\\n                    findBorder(x, y)\\n                if check(x, y) and not visited[x][y] and grid[i][j] != grid[x][y]:\\n                    flag = True\\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1 or flag:\\n                grid[i][j] = color\\n        findBorder(r0, c0)\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768427,
                "title": "intuitive-dfs-sol-python3",
                "content": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n\\n        if not grid or not grid[0]:\\n            return\\n\\n        n = len(grid)\\n        m = len(grid[0])\\n\\n        self.start_color = grid[r0][c0]\\n        self.seen = [[False] * m for i in range(n)]\\n\\n        dr = [-1, 0, 1, 0]\\n        dc = [0, 1, 0, -1]\\n\\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= m or self.seen[i][j]:\\n                return\\n\\n            if grid[i][j] != self.start_color:\\n                return True\\n\\t\\t\\t\\t\\n            self.seen[i][j] = True\\n\\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\\n                grid[i][j] = color\\n\\n            for d in range(4):\\n\\n                if dfs(i + dr[d], j + dc[d]):\\n                    grid[i][j] = color\\n\\n        dfs(r0, c0)\\n\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683364,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int r = 0, c = 0;\\n    vector<vector<bool>>visited;\\n    vector<vector<int>>res;\\n    \\n    bool dfs(vector<vector<int>>& grid, int i, int j, int color, int color0) {\\n        if (i < 0 || j < 0 || i >= r || j >= c || grid[i][j] != color0)\\n            return true;\\n\\n        if (visited[i][j])\\n            return grid[i][j] != color0;\\n        \\n        visited[i][j] = true;\\n        if (dfs(grid, i+1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i-1, j, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j+1, color, color0))\\n            res[i][j] = color;\\n        if (dfs(grid, i, j-1, color, color0))\\n            res[i][j] = color;\\n\\n        return false;\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        r = grid.size();\\n        c = grid[0].size();\\n        \\n        int color0 = grid[r0][c0];\\n        visited.resize(r, vector<bool>(c, false));\\n        res = grid;\\n        \\n        dfs(grid, r0, c0, color, color0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680918,
                "title": "c-bfs-solution",
                "content": "Space Complexity: O(min(n,m)) where m and n are the number of rows, columns on the grid\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    vector<vector<int>> colorBorder(vector<vector<int>>& A, int r0, int c0, int color) {\\n        int r = A.size();\\n        if(r==0) return vector<vector<int>>();\\n        int c = A[0].size();\\n        vector<vector<int>>  visited =  vector<vector<int>> (r, vector<int> (c, 2)); // white\\n        queue<pair<int,int>> q;\\n        q.push({r0, c0});\\n        visited[r0][c0] = 1;\\n        set<pair<int,int>> border;\\n        while(!q.empty()){\\n            auto u = q.front(); q.pop();\\n            int x = u.first, y = u.second;\\n            // cout<<\"Popped: \"<<x<<\" \"<<y<<endl;\\n            for(auto d: dirs){\\n                int i = x + d.first;\\n                int j = y + d.second;\\n                if(i>=0 && i<r && j>=0 && j<c && A[i][j]==A[x][y]){\\n                    if(visited[i][j]==2){\\n                        // cout<<\"pushing \"<<i<<\" \"<<j<<\" color: \"<<A[i][j]<<endl;\\n                        q.push({i,j});\\n                        visited[i][j] = 1;\\n                    }\\n                }\\n                else{\\n                    // cout<<\"Border: \"<<x<<\" \"<<y<<endl;\\n                    border.insert({x,y});\\n                }\\n            }\\n            visited[x][y] = 0;\\n        }\\n        for(auto s: border){\\n            A[s.first][s.second] = color;\\n        }\\n        return A;\\n    }\\n};\\n\\n\\n//  1    1   1\\n//  1   (1)  1  --> this one is surrounded by elements of same color and is not on border- should not be colored\\n//  1    1   1\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645798,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> visited;\\n    vector<vector<int>> copy;\\n    int r, c, original;\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        r = grid.size();\\n        c = grid[0].size();\\n        original = grid[r0][c0];\\n        copy = grid;\\n        visited = vector<vector<bool>>(r, vector<bool>(c, false));\\n        visit(grid, color, r0, c0);\\n        return copy;\\n    }\\n    \\n    void visit(vector<vector<int>>& grid, int color, int x, int y){\\n        visited[x][y] = true;\\n        if (x==0 || grid[x-1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x-1][y]){\\n            visit(grid, color, x-1, y);\\n        }\\n        if (x==r-1 || grid[x+1][y]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x+1][y]){\\n            visit(grid, color, x+1, y);\\n        }\\n        if (y==0 || grid[x][y-1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y-1]){\\n            visit(grid, color, x, y-1);\\n        }\\n        if (y==c-1 || grid[x][y+1]!=original){\\n            copy[x][y] = color;\\n        }else if (!visited[x][y+1]){\\n            visit(grid, color, x, y+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545883,
                "title": "c-solution-simple-dfs-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j});\\n        \\n        visited[i][j] = true ;\\n        dfs(i+1,j,color,color_base,grid,visited) ;\\n        dfs(i-1,j,color,color_base,grid,visited) ;\\n        dfs(i,j+1,color,color_base,grid,visited) ;\\n        dfs(i,j-1,color,color_base,grid,visited) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        \\n        int m = grid.size() ;\\n        int n = grid[0].size() ;\\n        vector<vector<bool>> visited (m, vector<bool>(n, false)) ;\\n        dfs(r0, c0, color, grid[r0][c0], grid, visited) ;\\n        \\n        for (auto x : borders)\\n            grid[x[0]][x[1]] = color ;\\n         \\n        return grid ;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n        \\n    vector<vector<int>> borders ;\\n    void dfs(int i, int j, int color, int color_base, vector<vector<int>>& grid, vector<vector<bool>>& visited)\\n    {   \\n        if (i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return ;\\n        if (grid[i][j]!=color_base)\\n            return ;\\n        if (visited[i][j]==true)\\n            return ;\\n                \\n        // condition (on the border)\\n        bool condition1 = (i*j==0 || i==grid.size()-1 || j==grid[0].size()-1) ;\\n                \\n        // condition (element has a 4 directional adjacent element not in the component)\\n        bool condition3 = (!condition1 && (grid[i+1][j]!=color_base||grid[i-1][j]!=color_base||grid[i][j+1]!=color_base||grid[i][j-1]!=color_base)) ; \\n                \\n        if (condition1 || condition3)\\n            borders.push_back({i,j}",
                "codeTag": "Java"
            },
            {
                "id": 403401,
                "title": "python-dfs-inside-of-the-connected-component-checking-if-current-node-is-on-the-border",
                "content": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "solutionTags": [],
                "code": "```python\\ndef colorBorder(self, grid, r0, c0, color):\\n\\t# True if node (i, j) is inside of the connected component.\\n\\tdef inside_cc(i, j):   \\n\\t\\t# Note: Only nodes inside of the connected component are added to \"visited\".\\n\\t\\tif (i, j) in visited: return True\\n\\t\\telif 0<=i<len(grid) and 0<=j<len(grid[0]) and grid[i][j]==cc_color:\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tneighbors = [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]\\n\\t\\t\\t# If one of the neighbors is not inside of cc, then node (i, j) is a border node.\\n\\t\\t\\tif any([not inside_cc(x, y) for x, y in neighbors]):\\n\\t\\t\\t\\tgrid[i][j] = color\\n\\t\\t\\treturn True\\n\\t\\telse: return False\\n\\tcc_color = grid[r0][c0]\\n\\tvisited = set()\\n\\tinside_cc(r0,c0)\\n\\treturn grid  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 395693,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} r0\\n * @param {number} c0\\n * @param {number} color\\n * @return {number[][]}\\n */\\nconst colorBorder = function(grid, r0, c0, color) {\\n   if (grid[r0][c0] === color) { return grid; }\\n    \\n    const visited = new Array(grid.length).fill(0).map( row => {\\n        return new Array(grid[0].length).fill(false);\\n    })\\n    \\n    dfs(grid, visited, grid[r0][c0], r0, c0, color);\\n        \\n    return grid;\\n};\\n\\nconst dfs = function(grid, visited, prevVal, r, c, color){\\n    /*  Order here matters  */\\n    if ( r < 0 || c < 0 || r === grid.length ||  c === grid[0].length) { return -1; }\\n\\n    if (visited[r][c]) { return color; }\\n    \\n    if(grid[r][c] !== prevVal) { return -1; }\\n    \\n    \\n    visited[r][c] = true;\\n    const v1 = dfs(grid, visited, grid[r][c], r+1, c, color);\\n    const v2 = dfs(grid, visited, grid[r][c], r-1, c, color);\\n    const v3 = dfs(grid, visited, grid[r][c], r, c+1, color);\\n    const v4 = dfs(grid, visited, grid[r][c], r, c-1, color);\\n\\n    if( ![v1, v2, v3, v4].every( val => ( val === color || val === prevVal))){\\n        grid[r][c] = color;\\n    }\\n\\n    return grid[r][c];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 328475,
                "title": "java-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dir = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        \\n        if (grid.length == 0 || grid[0].length == 0) return grid;    \\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        dfs(grid, r0, c0, m, n, color, grid[r0][c0], new boolean[m][n]);\\n        \\n        return grid;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, int m, int n, int color, int ic, boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i == m || j == n || visited[i][j] || grid[i][j] != ic) return;\\n        \\n        if (changeColor(grid, i, j, m, n, ic, visited)) {\\n            grid[i][j] = color;    \\n        } \\n        \\n        visited[i][j] = true;\\n        \\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            \\n            dfs(grid, x, y, m, n, color, ic, visited);\\n        }\\n    }\\n    \\n    private boolean changeColor(int[][] grid, int i, int j, int m, int n, int ic, boolean[][] visited) {\\n        \\n        if (i == 0 || j == 0 || i+1 == m || j+1 == n) return true;\\n        \\n        int borders = 4;\\n        for (int[] d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n        \\n            if (visited[x][y] || grid[x][y] == ic) {\\n                borders--;    \\n            }\\n        }\\n        \\n        return borders > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284393,
                "title": "java-dfs-short-1ms-solution",
                "content": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int m = grid.length, n = grid[0].length, oldColor = grid[r0][c0];\\n        boolean[][] visited = new boolean[m][n];\\n        dfs(grid, r0, c0, m, n, oldColor, color, visited);\\n        for (int i = 1; i < m - 1; i++) {\\n            for (int j = 1; j < n - 1; j++) {\\n                if (visited[i][j] && visited[i - 1][j] && visited[i + 1][j] && visited[i][j + 1] && visited[i][j - 1]) {\\n                    grid[i][j] = oldColor;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void dfs(int[][] grid, int i, int j, int m, int n, int oldColor, int color, boolean[][] visited) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || grid[i][j] != oldColor) return;\\n        visited[i][j] = true;\\n        grid[i][j] = color;\\n        dfs(grid, i + 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i - 1, j, m, n, oldColor, color, visited);\\n        dfs(grid, i, j + 1, m, n, oldColor, color, visited);\\n        dfs(grid, i, j - 1, m, n, oldColor, color, visited);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 283806,
                "title": "java-short-and-simple-dfs-with-explaination",
                "content": "Recursion rule: It will enter the next level of recursion only if current point is not a border. \\nEach time we check 4 directions, say next point:\\n* If current point is a border, we would change current point\\'s color and not enter the recursion with this next point, since it already reaches the border. \\n* If not, we do not change current color and enter the next level of recursion.\\n\\nSo we do not need to test the boundary in the base case, we only test whether it is visted.\\n\\nNoted, when test it is a border:\\nOther than the next point is out of boundary, it also may be an inner point.\\nIf the next point\\'s color is not the original color, we also need to test wehter we have visited before. Because it may be an inner point so that we didn\\'t change its color.\\n\\n```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] dir = { {-1,0}, {1,0}, {0,-1}, {0,1} };\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        colorBorder(grid, r0, c0, grid[r0][c0], color, visited);\\n        return grid;\\n    }\\n    private void colorBorder(int[][] grid, int r, int c, int orig, int color, boolean[][] visited) {\\n        if (visited[r][c]) return;\\n        visited[r][c] = true;\\n        for (int[] d : dir) {\\n            int nr = r + d[0], nc = c + d[1]; // next point\\n            if (nr < 0 || nr == grid.length || nc < 0 || nc == grid[0].length || (grid[nr][nc] != orig && !visited[nr][nc])) {\\n\\t\\t\\t// update current color since either the next point is out of boundary or the next point\\'s color is different and we did not visit it before.\\n                grid[r][c] = color; \\n                continue; // not enter the recursion and go next direction.\\n            }\\n            colorBorder(grid, nr, nc, orig, color, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283054,
                "title": "python",
                "content": "\\u54CE\\u3002\\u3002\\u3002\\u6211\\u5FC5\\u987B\\u5766\\u767D\\u8FD9\\u4E2A\\u9898contest\\u7684\\u65F6\\u5019\\u6CA1\\u505A\\u51FA\\u6765\\uFF0C\\u4E0D\\u662F\\u56E0\\u4E3A\\u4E0D\\u4F1A\\uFF0C\\u800C\\u662F\\u6CA1\\u641E\\u6E05\\u695Aborder\\u7684\\u5B9A\\u4E49\\u88AB\\u5751\\u4E86\\uFF0C\\u7136\\u540E\\u5C31\\u4E00\\u76F4\\u8C03\\u4EE3\\u7801\\uFF0Cgg\\u3002\\u3002\\u3002\\n\\u8FD9\\u79CD\\u9898\\u7684\\u601D\\u8DEF\\u8FD8\\u662F\\u5F88\\u6E05\\u695A\\u7684\\uFF0C\\u5C31\\u662F\\u6F2B\\u6C34\\u7B97\\u6CD5\\uFF08floodfill\\uFF09\\uFF0C\\u6216\\u8005\\u8BF4\\u6DF1\\u5EA6\\u4F18\\u5148\\u641C\\u7D22\\u3002\\u6211\\u4EEC\\u53EF\\u4EE5\\u4ECE\\u7ED9\\u5B9A\\u7684\\u683C\\u70B9\\u5F00\\u59CBdfs\\uFF0C\\u5982\\u679C\\u53D1\\u73B0\\u5F53\\u524D\\u70B9\\u662Fborder\\uFF0C\\u5C31\\u67D3\\u8272\\u3002\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u6709\\u51E0\\u4E2A\\u5751\\uFF1A\\n1. \\u9996\\u5148\\u662F\\u9898\\u76EE\\u5173\\u4E8Eborder\\u7684\\u63CF\\u8FF0\\uFF0C\\u90A3\\u4E2A```4-directionally adjacent```\\u7684\\u610F\\u601D\\u662F\\u53EA\\u8981\\u56DB\\u4E2A\\u90BB\\u5C45\\u91CC\\u9762\\u6709\\u4E00\\u4E2A\\u548C\\u5B83\\u989C\\u8272\\u4E0D\\u4E00\\u6837\\u5C31\\u662Fborder\\u4E86\\uFF0C\\u4E00\\u5F00\\u59CB\\u8FD8\\u4EE5\\u4E3A\\u662F4\\u4E2A\\u90BB\\u5C45\\u90FD\\u8981\\u548C\\u5B83\\u4E0D\\u4E00\\u6837\\u3002\\u3002\\u3002\\u545C\\u545C\\u545C\\n2. \\u5176\\u6B21\\uFF0C\\u6211\\u4EEC\\u4E0D\\u80FD\\u76F4\\u63A5\\u5BF9\\u539F\\u6570\\u7EC4\\u67D3\\u8272\\uFF0C\\u56E0\\u4E3A\\u8FB9dfs\\u8FB9\\u67D3\\u8272\\u53EF\\u80FD\\u5F71\\u54CD\\u5230\\u4E00\\u4E9B\\u8FD8\\u6CA1\\u6709\\u641C\\u7D22\\u5230\\u7684\\u683C\\u70B9\\u7684\\u6761\\u4EF6\\u5224\\u65AD\\uFF0C\\u4FDD\\u9669\\u7684\\u505A\\u6CD5\\u662F\\u7528\\u53E6\\u4E00\\u4E2A\\u4E8C\\u7EF4\\u6570\\u7EC4```should_color```\\u6765\\u6807\\u8BB0\\u67D0\\u4E2A\\u4F4D\\u7F6E\\u8981\\u4E0D\\u8981\\u67D3\\u8272\\n\\n\\u4EE3\\u7801\\uFF1A\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "solutionTags": [],
                "code": "```4-directionally adjacent```\n```should_color```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]:\\n        def is_border(grid, i, j):\\n\\t\\t\\t# \\u6570\\u7EC4\\u8FB9\\u754C\\n            if i == 0 or i == nr - 1 or j == 0 or j == nc - 1:\\n                return True\\n\\t\\t\\t# \\u56DB\\u4E2A\\u65B9\\u5411\\u6709\\u4E00\\u4E2A\\u4E0D\\u4E00\\u6837\\u7684\\u90BB\\u5C45\\t\\n            target = grid[i][j]\\n            left = grid[i][j-1]\\n            right = grid[i][j+1]\\n            top = grid[i-1][j]\\n            down = grid[i+1][j]\\n            if left != target or right != target or top != target or down != target:\\n                return True\\n            return False\\n            \\n        def dfs(grid, i, j, target, visited, color):\\n\\t\\t\\t# \\u641C\\u5230\\u4E86\\u8FB9\\u754C\\uFF0C\\u8FD4\\u56DE\\n            if i < 0  or i >= nr or j < 0 or j >= nc:\\n                return\\n\\t\\t\\t# \\u5DF2\\u7ECF\\u641C\\u8FC7\\uFF0C\\u8FD4\\u56DE\\n            if visited[i][j]:\\n                return\\n\\t\\t\\t# \\u5F53\\u524D\\u989C\\u8272\\u4E0D\\u662Ftarget\\u7684\\u989C\\u8272\\uFF0C\\u4E0D\\u5C5E\\u4E8E\\u8FD9\\u4E2Aconnected component\\uFF0C\\u8FD4\\u56DE\\n            if target != grid[i][j]:\\n                return\\n            visited[i][j] = 1\\n            \\n            if is_border(grid, i, j):\\n                # grid[i][j] = color  # dont do that!\\n                should_color[i][j] = 1\\n            dfs(grid, i, j+1, target, visited, color)\\n            dfs(grid, i, j-1, target, visited, color)\\n            dfs(grid, i-1, j, target, visited, color)\\n            dfs(grid, i+1, j, target, visited, color)\\n        \\n        nr = len(grid)\\n        nc = len(grid[0])\\n        visited = [[0]*nc for _ in range(nr)]\\n        should_color = [[0]*nc for _ in range(nr)]\\n        \\n        dfs(grid, r0, c0, grid[r0][c0], visited, color)\\n        \\n        for i in range(nr):\\n            for j in range(nc):\\n                if should_color[i][j]:\\n                    grid[i][j] = color\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283010,
                "title": "bfs-method-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0, int color) {\\n        vector<pair<int,int>> retv;\\n        queue<pair<int,int>> q;\\n        q.push(pair<int,int>(r0,c0));\\n        vector<vector<bool>> go(grid.size(),vector<bool>(grid[0].size(),false));\\n        vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n        go[r0][c0] = true;\\n        while(!q.empty())\\n        {\\n            auto e = q.front();q.pop();\\n            int x = e.first;\\n            int y = e.second;\\n            for(auto d : dirs)\\n            {\\n                int _x = x+d[0];\\n                int _y = y+d[1];\\n                if(_x>=0&&_x<grid.size()&&_y>=0&&_y<grid[0].size()&&grid[_x][_y] == grid[x][y])\\n                {\\n                    if(go[_x][_y] == false)\\n                    {\\n                        q.push(pair<int,int>(_x,_y));    \\n                        go[_x][_y] = true;\\n                    }\\n                }\\n                else\\n                {\\n                    retv.push_back(pair<int,int>(x,y));\\n                }\\n            }\\n        }\\n        for(auto e: retv)\\n        {\\n            grid[e.first][e.second] = color;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282948,
                "title": "dfs-solution-using-java",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        boolean[][] check = new boolean[grid.length][grid[0].length];\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        int cur_color = grid[r0][c0];\\n        dfs(grid, check, visited, r0, c0, cur_color);\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(check[i][j]){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n    \\n    \\n    public void dfs(int[][] grid, boolean[][] check, boolean[][] visited, int i, int j, int color){\\n        if(visited[i][j] == true){\\n            return;\\n        }\\n        visited[i][j] = true;\\n        \\n        for(int[] dir: dirs){\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y]!=color){\\n                check[i][j] = true;\\n            }\\n            if(x>=0 && x<grid.length && y>=0 && y<grid[0].length && grid[x][y] == color){\\n                dfs(grid, check, visited, x, y, color);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282892,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nPerform dfs from the start poistion and mark with `-1` to remember the visited positions and mark with `0` to cells which are border cells.\\nWe cannot paint a cell with new color yet while doing dfs because that will change the status of its neighbor cells (neighbor cells will think they are on the border).\\n\\n```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] colorBorder(int[][] g, int r0, int c0, int c) {\\n        int old = g[r0][c0];\\n        dfs(g, r0, c0, old);\\n        for(int i=0; i < g.length; i++)\\n            for(int j=0; j < g[0].length; j++)\\n                if(g[i][j] == 0)\\n                    g[i][j] = c;\\n                else if(g[i][j] == -1)\\n                    g[i][j] = old;\\n        return g;\\n    }\\n    private void dfs(int[][] g, int x, int y, int c){\\n        if(x < 0 || x == g.length || y < 0 || y == g[0].length || g[x][y] != c) return;\\n        border(g, x, y, c);\\n        dfs(g, x+1, y, c);\\n        dfs(g, x-1, y, c);\\n        dfs(g, x, y+1, c);\\n        dfs(g, x, y-1, c);\\n    }\\n    private void border(int[][] g, int x, int y, int c){\\n        g[x][y] = -1;\\n        if(isBorder(g, x+1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x-1, y, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y-1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n        if(isBorder(g, x, y+1, c)){\\n            g[x][y] = 0;\\n            return;\\n        }\\n    }\\n    private boolean isBorder(int[][] g, int x, int y, int c){\\n        return x < 0 || x == g.length || y < 0 || y == g[0].length || (g[x][y] != c && g[x][y] != -1 && g[x][y] != 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282852,
                "title": "java-bfs",
                "content": "though not so efficient in space\\n\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int r0, int c0, int color) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        boolean[][] visited = new boolean[row][col];\\n        boolean[][] border = new boolean[row][col];\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{r0,c0});\\n        visited[r0][c0] = true; // visited\\n        \\n        int[][] steps = {{-1,0},{1,0},{0,1},{0,-1}};\\n        //System.out.println(\"now to bfs\");\\n        \\n        while(!queue.isEmpty()) {\\n            int[] item = queue.poll();\\n            int x = item[0];\\n            int y = item[1];\\n            //System.out.println(\"x=\" + x + \", y=\" + y);\\n            for(int i = 0; i < steps.length; ++i) {\\n                int nextx = x + steps[i][0];\\n                int nexty = y + steps[i][1];\\n                if(nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || grid[nextx][nexty] != grid[x][y]) {\\n                    border[x][y] = true; // is border\\n                }\\n                else { // so here, next color is the same \\n                    if(!visited[nextx][nexty]) { // not visited\\n                        queue.add(new int[]{nextx, nexty});\\n                        visited[nextx][nexty] = true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.length; ++i) {\\n            for(int j = 0; j < grid[i].length; ++j) {\\n                if(border[i][j]) {\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282840,
                "title": "python-clean-bfs-solution",
                "content": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\n    def colorBorder(self, grid, r0, c0, color):\\n        queue = deque()\\n\\t\\tqueue.append((r0,c0))\\n        visited = set()\\n        visited.add((r0,c0))\\n        marked = []\\n        direc = [(-1,0), (1,0), (0,1),(0,-1)]\\n        old = grid[r0][c0]\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == 0 or r == len(grid)-1 or c == 0 or c == len(grid[0])-1 or grid[r-1][c] != old or grid[r+1][c] != old or grid[r][c-1] != old or grid[r][c+1] != old:\\n                marked.append((r,c))\\n            for d_x,d_y in direc:\\n                x = r+d_x\\n                y = c+d_y\\n                if x >= 0 and x < len(grid) and y >=0 and y < len(grid[0]) and grid[x][y] == old and (x,y) not in visited:\\n                    visited.add((x,y))\\n                    queue.append((x,y))\\n        for x,y in marked:\\n            grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4097638,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+v) where v is the linear operation for checking visited list and n is for checking through n points.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for a visited list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        rows, cols = len(grid), len(grid[0])\\n        visited = set()\\n        prev_color = grid[row][col]\\n\\n        def dfs(row, col):\\n            # addind the node in visited\\n            visited.add((row, col))\\n\\n            # explore four adjucent node\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n\\n                # check if the new node is already visited or not\\n                if (new_row, new_col) not in visited:\\n\\n                    # check if the new node is out of range or not\\n                    if (0 <= new_row < rows) and (0 <= new_col < cols):\\n\\n                        # check if the new node has the same color or not\\n                        if grid[new_row][new_col]==prev_color:\\n\\n                                # do dfs on new node\\n                                dfs(new_row, new_col)\\n                        \\n                        # If the node is not same color then it is a border node. Change the color        \\n                        else:\\n                            grid[row][col] = color\\n                    \\n                    # if new node out of range, then it is a border node. Change the color\\n                    else:\\n                        grid[row][col] = color\\n    \\n        # start the bfs from the given point\\n        dfs(row, col)\\n\\n        \\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097603,
                "title": "python-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApplying Breadth First Search. The idea is we will take a point and then we will find out if this point is our point of interest. After that, we will look points which is \\'one\\' distance from the first point. We can say this layer 1. In our case, there are total four points as such. Top, bottom, right and left points of the main point. We will check the top point and see if it is desired point or not. Then checke the bottom then right and then left. Layer 1 is complete. Then we will go for layer 2. We will check the 4 neighbors of Top point. And it continues.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a list called components to list down the points that needs to be checked sequntially. And then apply checking on the points from the component list.\\n\\n# Complexity\\n- Time complexity: Although it looks like a $$O(n^3)$$ [while loop for components, inside for loop for neighbors, inside checking the neighbors in visited set] but really the computation is way less. because the for loop only checks four neighbour so instead of $$O(n * n * n)$$ it becomes $$O(n * 4 * n)$$ which is $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nCorrect me if I am wrong.\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        rows, cols = len(grid), len(grid[0])\\n        # co-ordinate that we visited\\n        visited = set()\\n        # co-ordinates that we need to visit\\n        components = [(row, col)]\\n        prev_color = grid[row][col]\\n\\n        def bfs(row, col):\\n            visited.add((row, col))\\n\\n            # checking four neighbors of the point\\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\\n                new_row, new_col = row + dr, col + dc\\n                if (new_row, new_col) not in visited:\\n                    if (0<=new_row<rows) and (0<=new_col<cols):\\n                        # add to the components if the neighboring point is not in perimeter of the matrix\\n                        components.append((new_row, new_col))\\n                        if grid[new_row][new_col] != prev_color:\\n                            # if the color doesn\\'t match, means the new point is not connected component. so we don\\'t need to visit this point anymore.\\n                            components.pop(-1)\\n                            # because colors doesn\\'t match that means this is a border\\n                            grid[row][col] = color\\n\\n                    else:\\n                        # permimeter of the matrix, border by definition\\n                        grid[row][col] = color\\n\\n        # looping through components and do bfs for each point\\n        i = 0\\n        while i < len(components):\\n            bfs(*components[i])\\n            i += 1\\n\\n        return grid\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046648,
                "title": "c-easy-clean-code",
                "content": "=\\n\\n# Code\\n```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:map<pair<int,int>,int> p;\\n    void t(int i,int j,vector<vector<int>> &g,int x, vector<vector<int>> &v)\\n    {\\n        if(i<0 || j<0 || i>=g.size() || j>=g[0].size() || g[i][j]!=x || v[i][j]==1) return ;\\n        v[i][j]=1;\\n        p[{i,j}]++;\\n        t(i+1,j,g,x,v); \\n        t(i-1,j,g,x,v);\\n        t(i,j+1,g,x,v);\\n        t(i,j-1,g,x,v);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int r, int c, int col) {\\n       int m=g.size(),n=g[0].size();\\n       vector<vector<int>> v(m,vector<int> (n,0));\\n       t(r,c,g,g[r][c],v);\\n\\n       for(int i=0;i<g.size();i++)\\n       for(int j=0;j<g[0].size();j++)\\n       {\\n           if(p[{i,j}]>0)\\n           {\\n               if((i-1>=0&&p[{i-1,j}]==0) || (i+1<=g.size()&&p[{i+1,j}]==0) || (j-1>=0&&p[{i,j-1}]==0) || (j+1<=g[0].size()&&p[{i,j+1}]==0))\\n               g[i][j]=col;\\n               \\n               if(i==g.size()-1 || j==g[0].size()-1 || i==0 || j==0)\\n               g[i][j]=col;\\n           }\\n       }\\n       return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031252,
                "title": "bfs-short-precise-easy-to-understand-beats-99-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n# BFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dr[4]={1,0,-1,0};\\n    int dc[4]={0,1,0,-1};\\n\\n    bool isvalid(int i ,int j,int m,int n,vector<vector<int>>& grid,int b){\\n        return (i >= 0 && j >= 0 && i < m && j < n && grid[i][j]==b);\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int t = grid[row][col];\\n\\n        queue<pair<int,int>> q;\\n        vector<vector<int>> visited(m,vector<int> (n,0));\\n        vector<vector<int>> newgrid;\\n\\n        newgrid=grid;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty()){\\n            int r=q.front().first;\\n            int c=q.front().second;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int nr = r+dr[k];\\n                int nc = c+dc[k];\\n                if(isvalid(nr,nc,m,n,grid,t)){\\n                    if(nr >= 0 && nc >= 0 && nr < m && nc < n && !visited[nr][nc]){\\n                        visited[nr][nc]=1;\\n                        q.push({nr,nc});\\n                    }\\n                }else{\\n                    newgrid[r][c]=color;\\n                }\\n            }\\n        }\\n\\n        return newgrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982702,
                "title": "color-border-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971945,
                "title": "dfs-solution-tle-resolved",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid,int i,int j,int curColor,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 or i==grid.size() or j<0 or j==grid[0].size() or grid[i][j]!=curColor or visited[i][j])\\n            return;\\n        \\n        visited[i][j]=true;\\n        grid[i][j]= -curColor;\\n        dfs(grid,i+1,j,curColor,visited);\\n        dfs(grid,i-1,j,curColor,visited);\\n        dfs(grid,i,j-1,curColor,visited);\\n        dfs(grid,i,j+1,curColor,visited);\\n        if(i>0 and i<grid.size()-1 and j>0 and j<grid[0].size()-1 and abs(grid[i+1][j])==curColor and abs(grid[i-1][j])==curColor and abs(grid[i][j-1])==curColor and abs(grid[i][j+1])==curColor)\\n            grid[i][j]=curColor;\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));\\n        dfs(grid,row,col,grid[row][col],visited);\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]<0)\\n                    grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956361,
                "title": "bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>vis(m,vector<int>(n,0));\\n        vector<vector<int>>ans=grid;\\n        int cl=grid[row][col];\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        while(q.size()){\\n            int ro=q.front().first;\\n            int co=q.front().second;\\n            q.pop();\\n            vis[ro][co]=1;\\n            int r[4]={-1,0,0,1};\\n            int c[4]={0,-1,1,0};\\n            int count=0;\\n            for(int k=0;k<4;k++){\\n                int nr=ro+r[k],nc=co+c[k];\\n                if(nr>=0&&nr<m&&nc>=0&&nc<n&&grid[nr][nc]==cl){\\n                    if(vis[nr][nc]==0)q.push({nr,nc});\\n                    count++;\\n                }\\n            }\\n            if(count<4){\\n                ans[ro][co]=color;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949906,
                "title": "basic-solution-explained-in-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// we are supposewd to colour the boarder of the given compomet of the graph\\n// boared cells -> boarder cells are the cells who are not surrounded by the same color cells ( 4 way movement allowed , no diagonal movement allowed )\\n// so we just need to perform dfs on the given row and col \\n// and check if a cell is surronded by all four sides or not ( by the same color cell )\\n// if yes -> update the cell with the new color, else go to next dfs call\\n// there will be one issue when checking for the surrounding color, it\\'ll be because we are updatin the color with the new color so if we go to a new cell and see around it, even if earlier there was the source color to the left/right/up/down of it, we will see the new color and will end up making the wrong judgement, so to avoid this, we will make a copy of the given grid and look for surrounging in the copy vector not in the initailly given grid vector because we are constantly making changes in the grid vector \\n\\n    void dfs(int row, int col, vector<vector<int>>& vis, vector<vector<int>>& grid, int gRow, int gCol, int color, int src, vector<vector<int>>& copy ){\\n        \\n        vis[row][col] = 1; // marking as visited\\n\\n        int surr = 0; // this var will count how many sides our current cell is surrounded by the cell of source color\\n\\n        // checking the surrounding\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row+1][col+0] == src ) surr += 1;\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && copy[row-1][col+0] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && copy[row+0][col+1] == src ) surr += 1;\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && copy[row+0][col-1] == src ) surr += 1;\\n\\n        if( surr != 4 ) grid[row][col] = color; // if .. ( you can see )\\n        \\n        // making the next dfs call\\n        if( (row+1) >= 0 && (row+1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row+1][col+0] == 0 && grid[row+1][col+0] == src ) dfs(row+1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row-1) >= 0 && (row-1) < gRow && (col+0) >= 0 && (col+0) < gCol && vis[row-1][col+0] == 0 && grid[row-1][col+0] == src ) dfs(row-1 , col+0, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col+1) >= 0 && (col+1) < gCol && vis[row+0][col+1] == 0 && grid[row+0][col+1] == src ) dfs(row+0 , col+1, vis, grid, gRow, gCol, color, src,copy);\\n        if( (row+0) >= 0 && (row+0) < gRow && (col-1) >= 0 && (col-1) < gCol && vis[row+0][col-1] == 0 && grid[row+0][col-1] == src ) dfs(row+0 , col-1, vis, grid, gRow, gCol, color, src,copy);\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int gRow = grid.size();\\n        int gCol = grid[0].size();\\n\\n        vector<vector<int>> vis(gRow, vector<int> (gCol,0)); // visited array\\n        int src = grid[row][col]; // source color\\n\\n        vector<vector<int>> copy; // copy vector\\n        for( int i = 0; i<gRow; i++ ){\\n            vector<int> temp = grid[i];\\n            copy.push_back(temp);\\n        }\\n\\n        dfs(row, col, vis, grid, gRow, gCol, color, src,copy); // calling the dfs function\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948118,
                "title": "python-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        queue = [(row, col)]\\n        border = []\\n        seen = set()\\n        \\n        while queue:\\n            nq = []\\n            for r, c in queue:\\n                if (r,c) not in seen:\\n                    seen.add((r,c))\\n                    num = 0\\n                    for i, j in ((r-1,c),(r+1,c),(r,c-1),(r,c+1)):\\n                        if 0 <= i < m and 0 <= j < n and grid[i][j] == grid[row][col]:\\n                            nq.append((i,j))\\n                            num += 1\\n                    if num != 4: border.append((r,c))\\n            queue = nq\\n        \\n        for r, c in border: grid[r][c] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935835,
                "title": "simplified-solution-with-detailed-institution-99-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem description is bit vague in the sense that understanding of border connected components is not very clear.\\nConected components we will all know however a connected components will be fall in the definition of boarder connected components if it has any of the following features:\\n1. Its(grid) belongs to first or last row or grid belongs to first or last columns.\\n2. Its connected components has different color.\\n\\nThen Use the same Traversing approach as that of Flood Fill Algorithm.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n){for calling DFS stack function this number of times} + O(m * n * 4){for Traversing in all 4 direction of a particular grid}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * n) for storing Visited vector  + O(m * n) {for stack memory of DFS call}\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, int row, int col, int startCol, int newColor, int m, int n)\\n    {\\n        //bool border = false;\\n        vis[row][col] = 1;\\n        if(row==0 || row==m-1 || col==0 ||col==n-1)\\n            grid[row][col] = newColor;\\n\\n        int rowArr[] = {0, -1, 0, 1};\\n        int colArr[] = {-1, 0, 1, 0};\\n\\n        for(int i = 0; i<4; i++)\\n        {\\n            int nRow = row + rowArr[i];\\n            int nCol = col + colArr[i];\\n\\n            if(nRow>=0 && nRow<m && nCol>=0 && nCol<n )\\n            {\\n                if(!vis[nRow][nCol])\\n                {\\n                    if(grid[nRow][nCol]==startCol)\\n                        dfs(grid, vis, nRow, nCol, startCol, newColor, m, n);\\n                    else\\n                        grid[row][col] = newColor;\\n                }\\n                \\n            }\\n            else\\n                grid[row][col] = newColor;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> vis(m, vector<int>(n,0));\\n        dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        // for(int i = row; i<m ;i++)\\n        // {\\n        //     for(int j = col;j<n; j++)\\n        //     {\\n        //         if(!vis)\\n        //         dfs(grid, vis, row, col, grid[row][col], color, m, n);\\n        //     }\\n        // }\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916013,
                "title": "easy-python-solution-by-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n    #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n    #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n    #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def colorBorder(self, grid, row, col, color):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type row: int\\n        :type col: int\\n        :type color: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #\\u5728\\u6307\\u5B9A\\u4F4D\\u7F6E\\u5904\\u8FDB\\u884Cdfs, \\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u8FDB\\u884Ccolor\\n        #\\u56E0\\u4E3Acolor\\u540E\\u4F1A\\u5F71\\u54CD\\u5224\\u65ADborder\\uFF0C\\u6240\\u4EE5\\u52062\\u6B65\\n        #1.\\u6EE1\\u8DB3border\\u6761\\u4EF6\\u7684\\u6DFB\\u52A0\\u5230lst\\u4E2D\\n        #2.\\u5BF9lst\\u4E2D\\u7684\\u8FDB\\u884Ccolor\\n        m,n = len(grid),len(grid[0])\\n        visited = [[0 for j in range(n)] for i in range(m)]\\n        target = grid[row][col]\\n        lst = []\\n\\n        def dfs(i,j):\\n            if 0<=i<=m-1 and 0<=j<=n-1 and visited[i][j] == 0:\\n                visited[i][j] = 1\\n                if grid[i][j] == target:\\n                    #\\u4E0A\\u65B9\\u65E0\\n                    flag = False\\n                    if i-1<0 or grid[i-1][j] != target:\\n                        flag = True\\n                    if i+1>m-1 or grid[i+1][j] != target:\\n                        flag = True\\n                    if j-1<0 or grid[i][j-1] != target:\\n                        flag = True\\n                    if j+1>n-1 or grid[i][j+1] != target:\\n                        flag = True\\n                    if flag:\\n                        lst.append((i,j))\\n\\n                    dfs(i-1,j)\\n                    dfs(i+1,j)\\n                    dfs(i,j-1)\\n                    dfs(i,j+1)\\n\\n        dfs(row,col)\\n        for i,j in lst:\\n            grid[i][j] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811935,
                "title": "c-solution-dfs",
                "content": "# Intuition\\nDFS to find the adjecnt elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] dir = new int[][] {new int[]{0,1}, new int[]{0,-1}, new int[]{1, 0}, new int[]{-1, 0}};\\n    int m;\\n    int n;\\n    int toColo;\\n    int[][] visited;\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.Length;\\n        n = grid[0].Length;\\n        visited = new int[m][];\\n        toColo = color;\\n\\n        for(var r=0; r<m; ++r){\\n            visited[r] = new int[n];\\n            for(var c=0; c<n; ++c){\\n                visited[r][c] = -1;\\n            }\\n        }\\n        \\n        DFS(row, col, grid[row][col], grid);\\n\\n        for(int i=0; i<m; i++)\\n        for(int j=0; j<n; j++){\\n            if(visited[i][j]==-1){\\n                visited[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return visited;\\n    }\\n\\n    public void DFS(int row, int col, int color, int[][] grid){\\n        if(visited[row][col]!=-1) return;\\n\\n        visited[row][col] = color;\\n\\n        if(row==0 || row==m-1 || col==0 || col==n-1){\\n            visited[row][col] = toColo;\\n        }\\n\\n        foreach(var coor in dir){\\n            int nx = row + coor[0];\\n            int ny = col + coor[1];\\n\\n            if(nx>=0 && nx<m && ny>=0 && ny<n){\\n                if(grid[nx][ny]==color){\\n                    DFS(nx, ny, color, grid);\\n                }\\n                else if(grid[row][col]!=toColo){\\n                    visited[row][col] = toColo;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779395,
                "title": "c-dfs-solution",
                "content": "# intution\\nfind the neighbours of every cell, if valid neighbour count is 4 , then its not border \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&grid,vector<pair<int,int>>&borders,vector<vector<int>>&visited,int row,int col,int n,int m)\\n    {\\n\\n        int flag =0;\\n        if(row ==0 or col ==0 or row==n-1 or col==m-1)flag =1;\\n\\n        int count =0;\\n        visited[row][col]=1;\\n        int del_row[] = {-1,0,1,0};\\n        int del_col[] = {0,1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ne_row = row+del_row[i];\\n            int ne_col = col+del_col[i];\\n            if(ne_row<n && ne_col <m && ne_row>=0 && ne_col >=0 && !visited[ne_row][ne_col] && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n\\n\\n                dfs(grid,borders,visited,ne_row,ne_col,n,m);\\n            }\\n            if(ne_row<n && ne_col<m && ne_row>=0 && ne_col >=0 && grid[ne_row][ne_col]== grid[row][col])\\n            {\\n                count++;\\n            }\\n\\n        }\\n        \\n        if(flag ==1 or count<4)\\n        {\\n            borders.push_back({row,col});\\n        }\\n\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        vector<pair<int,int>>borders;\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        dfs(grid,borders,visited,row,col,n,m);\\n        for(int i=0;i<borders.size();i++)\\n        {\\n            grid[borders[i].first][borders[i].second]=color;\\n        }\\n        return grid;\\n\\n\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764382,
                "title": "clean-and-easy-c-bfs-solution-beats-40-of-users",
                "content": "# Intuition\\nApply BFS Algorithm in the grid and check whether the front element in the queue is a border square or not ,if yes color it with the given color.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,1,-1};\\n\\n    bool is_valid(vector<vector<int>> &grid,int r,int c){\\n        if(r<0 || c<0 || r>=grid.size() || c>=grid[0].size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool is_border(vector<vector<int>> grid,int r,int c){\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        int og=grid[r][c];\\n        if(r==0 || r==rows-1 || c==0 || c==cols-1){\\n            return true;\\n        }\\n\\n        if(grid[r+1][c]!=og || grid[r-1][c]!=og || grid[r][c-1]!=og || grid[r][c+1]!=og){\\n            return true;\\n        }\\n        return false;\\n\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vector<vector<int>> ans=grid;\\n        vector<vector<int>> visited(rows,vector<int>(cols,-1));\\n        visited[row][col]=1;\\n        int og=grid[row][col];\\n        while(!q.empty()){\\n            int size=q.size();\\n\\n            for(int i=0;i<size;i++){\\n                auto fro=q.front();\\n                q.pop();\\n                int r=fro.first;\\n                int c=fro.second;\\n\\n                if(is_border(grid,r,c)){\\n                    ans[r][c]=color;\\n                }\\n\\n                for(int j=0;j<4;j++){\\n                    int nr=r+dx[j];\\n                    int nc=c+dy[j];\\n\\nif(is_valid(grid,nr,nc) && visited[nr][nc]==-1 && grid[nr][nc]==og){\\n                visited[nr][nc]=1;\\n                q.push({nr,nc});\\n                }\\n\\n                }\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755304,
                "title": "some-modifications-in-standard-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<bool>> &vis, vector<vector<int>> &g, vector<vector<int>> &ans, int &OR_COL, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n        vis[r][c]=1;\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};\\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0){\\n                if((R==0||C==m-1||R==n-1||C==0) && g[R][C]==OR_COL){\\n                    ans[R][C]=newColor;\\n                }\\n\\n                if(!vis[R][C] && g[R][C]==OR_COL) {\\n                    dfs(R,C,vis,g,ans,OR_COL,newColor);\\n                }\\n            }\\n        }\\n    }    \\n\\n    void colorRemaining(int r, int c, vector<vector<bool>> &vis, vector<vector<int>>& g, vector<vector<int>>& ans, int &newColor){\\n        int n=g.size(), m=g[0].size();\\n\\n        int delR[4] = {0,0,-1,1};\\n        int delC[4] = {1,-1,0,0};        \\n\\n        for(int i=0; i<4; i++){\\n            int R = r+delR[i];\\n            int C = c+delC[i];\\n\\n            if(R<n&&R>=0&&C<m&&C>=0 && vis[R][C]){\\n                ans[R][C]=newColor;\\n            }            \\n        }        \\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& g, int row, int col, int color) {\\n        int n=g.size(), m=g[0].size();\\n        int originalColor = g[row][col];\\n        vector<vector<int>> ans = g;\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n\\n        dfs(row,col,vis,g,ans,originalColor,color);\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(!vis[i][j]) colorRemaining(i,j,vis,g,ans,color);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754912,
                "title": "c-dfs-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int r, int c,int ol,int nc,vector<vector<int>>& grid,vector<vector<int>>& ans,vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        int drow[4]={0,1,0,-1};\\n        int dcol[4]={1,0,-1,0};\\n        int cnt=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            int newr = r+drow[i];\\n            int newc = c+dcol[i];\\n            if(newr>=0 and newr<grid.size() and newc>=0 and newc<grid[0].size() and grid[newr][newc]==ol)\\n            {\\n                cnt++;\\n                if(vis[newr][newc]==0)\\n                dfs(newr,newc,ol,nc,grid,ans,vis);\\n            } \\n        }\\n        if(cnt<4)\\n        ans[r][c]=nc;\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        vector<vector<int>> ans = grid;\\n        int p=grid[row][col];\\n        vector<vector<int>> vis(grid.size(),vector<int> (grid[0].size(),0));\\n        //if(p==color)return ans;\\n        dfs(row,col,p,color,grid,ans,vis);\\n        int n=grid.size();int m=grid[0].size();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752956,
                "title": "ruby-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @param {Integer} row\\n# @param {Integer} col\\n# @param {Integer} color\\n# @return {Integer[][]}\\ndef color_border(grid, row, col, color)\\n   @main_color = grid[row][col]\\n   @output = Array.new(grid.size){Array.new(grid[0].size)}\\n   for i in 0..grid.size - 1\\n        for j in 0..grid[0].size - 1\\n            @output[i][j] = grid[i][j]\\n        end\\n    end\\n   visited = Array.new(grid.size){Array.new(grid[0].size)}\\n   dfs([row, col], grid, visited, color)\\n   @output\\nend\\n\\n\\ndef neighbours(location, row_length, col_length)\\n    nb = []\\n    nb << [location[0]+1, location[1]] if location[0] + 1 < row_length\\n    nb << [location[0]-1, location[1]] if location[0] > 0\\n    nb << [location[0], location[1]+1] if location[1] + 1 < col_length\\n    nb << [location[0], location[1]-1] if location[1] > 0\\n    nb\\nend\\n\\ndef dfs(loc, grid, visited, color)\\n    visited[loc[0]][loc[1]] = true\\n    nbrs = neighbours(loc, grid.size, grid[0].size)\\n\\n    if (loc[0] == 0 || loc[0] == grid.size - 1) || (loc[1] == 0 || loc[1] == grid[0].size - 1)\\n        @output[loc[0]][loc[1]] = color\\n    else\\n        for nb in nbrs\\n            if @main_color != grid[nb[0]][nb[1]]            \\n                @output[loc[0]][loc[1]] = color\\n                break\\n            end\\n        end\\n    end\\n\\n    for nb in nbrs\\n        if @main_color == grid[nb[0]][nb[1]] && !visited[nb[0]][nb[1]]\\n            dfs([nb[0],nb[1]], grid, visited, color)\\n        end\\n    end\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3729607,
                "title": "c-dfs-easy",
                "content": "simple dfs , just check for border and the given condition\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void dfs(int row , int col , int color , vector<vector<int>>& vis , vector<vector<int>>& grid , int ogcolor){\\n       int n = grid.size();\\n       int m = grid[0].size();\\n\\n       vis[row][col] = 1;\\n\\n       int delrow[] = {1,0,-1,0};\\n       int delcol[] = {0,-1,0,1};\\n\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow < 0 || ncol < 0 || nrow >= n || ncol >= m || (grid[nrow][ncol] != ogcolor and !vis[nrow][ncol])){\\n                grid[row][col] = color;\\n           } \\n       }\\n       for(int i = 0 ; i < 4 ; i++){\\n           int nrow = row + delrow[i];\\n           int ncol = col + delcol[i];\\n           if(nrow >= 0 and ncol >= 0 and nrow < n and ncol < m and grid[nrow][ncol] == ogcolor and !vis[nrow][ncol]){\\n               vis[nrow][ncol] = 1;\\n                dfs(nrow,ncol,color,vis,grid,ogcolor);\\n           } \\n       }\\n   }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        dfs(row,col,color,vis,grid,grid[row][col]);\\n        return grid;\\n    }\\n};\\n/*\\n1 2 1 2 1 2\\n2 2 2 2 1 2\\n1 2 2 2 1 2\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729232,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        queue<pair<int,int>> q;\\n        q.push({row, col});\\n        int iniCol = grid[row][col];\\n\\n        vector<int> dx = {0 , 1 , 0 , -1};\\n        vector<int> dy = {-1 , 0 , 1 , 0};\\n        vector<vector<int>> vis(m , vector<int> (n , 0));\\n        vis[row][col] = 1;\\n\\n        while (!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            bool temp = false;\\n            if (r==m-1 || r==0 || c==n-1 || c==0)\\n                temp = true;\\n\\n            bool flag = false;\\n            for (int i=0 ; i<4 ; i++){\\n                int nr = r + dx[i];\\n                int nc = c + dy[i];\\n                if (nr>=0 && nr<m && nc>=0 && nc<n && !vis[nr][nc]){\\n                    if (grid[nr][nc]==iniCol){\\n                        vis[nr][nc] = 1;\\n                        q.push({nr,nc});\\n                    }\\n                    else{\\n                        flag = true;\\n                    }\\n                }\\n            }\\n            if (flag || temp)\\n                grid[r][c] = color;\\n        }\\n        return grid;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716069,
                "title": "c-very-simple-bfs-explained",
                "content": "# Intuition\\nThe goal is to color the border cells and cells adjacent to different colors with the target color. To achieve this, we can use Breadth-First Search (BFS) starting from the given cell.\\n\\n\\n# Approach\\nPush the starting cell coordinates into the queue, mark it as visited, and store its color as the original color.\\n\\nPerform BFS traversal:\\n\\nWhile the queue is not empty, do the following:\\nExtract the front element from the queue, representing the current cell coordinates.\\n\\nCheck if the current cell is on the border or adjacent to a different color:\\nInitialize the isBorder flag to check if the cell is on the border (first or last row/column).\\nInitialize the isAdjacentToDifferentColor flag to track if the cell is adjacent to a different color.\\n\\nIterate through the four directions:\\nCalculate the new row and column coordinates.\\nIf the new coordinates are within the grid boundaries and the cell is unvisited:\\n\\nCheck if the cell has the original color.\\nIf so, push it into the queue, mark it as visited, and continue the BFS traversal.\\n\\nOtherwise, set the isAdjacentToDifferentColor flag to true.\\nIf the current cell is on the border or adjacent to a different color, update its color to the target color.\\n\\nAfter the BFS traversal is complete, return the modified grid.\\n# Complexity\\n- Time complexity:\\n O(n * m)\\n- Space complexity:\\n O(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        visited[row][col] = true;\\n\\n        while (!q.empty()) {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            //checking if the row or coloumn are border or not, initially keeping it false.\\n            bool isb=false;\\n            if(r == 0 || r == m - 1 || c == 0 || c ==n - 1)\\n            isb =true;\\n            //initially we keep adj as false, this tells us whether the cell is adjacent to some cell which is not of the same color to any side, that is the outline of the connected component.\\n            bool isad = false;\\n\\n            for (int k = 0; k < 4; k++) {\\n                //iterating on all 4 directions\\n                int nr = r + delr[k];\\n                int nc = c + delc[k];\\n\\n                if (nr >= 0 && nc >= 0 && nr < m && nc < n) {\\n                    if (!visited[nr][nc]) {\\n                        //checking if the new cell is connected component or not, if yes, we take it into consideration for the next iteration and push in the queue.\\n                        if (grid[nr][nc] == originalColor) {\\n                            q.push({nr, nc});\\n                            visited[nr][nc] = true;\\n                        } else {\\n                            //if not connected then we have found one cell which is the outline of the connected component.\\n                            isad = true;\\n                        }\\n                    }\\n                }\\n            }\\n            //at last we are just coloring all the cells are which are either border cells or the outline of the connected component.\\n            if (isb || isad) {\\n                grid[r][c] = color;\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673871,
                "title": "c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool is_safe(int i,int j,int row,int col){\\n    if(i<0 ||j<0 || i>=row || j>=col)return false;\\n    return true;\\n}\\nint deli[4]={0,1,0,-1};\\nint delj[4]={1,0,-1,0};\\nvoid dfs(int i,int j,int row,int col,int curcol,int newcol,vector<vector<int>>& grid,vector<vector<int>>& vis,vector<vector<int>>& ggrid){\\n    int temp=0;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol)temp++;\\n    }\\n    if(temp!=4)ggrid[i][j]=newcol;\\n    for(int k=0;k<4;k++){\\n        int new_i=i+deli[k];\\n        int new_j=j+delj[k];\\n        if(is_safe(new_i,new_j,row,col)&&grid[new_i][new_j]==curcol && !vis[new_i][new_j]){\\n            vis[new_i][new_j]=1;\\n            dfs(new_i,new_j,row,col,curcol,newcol,grid,vis,ggrid);\\n        }\\n    }\\n    \\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int i, int j, int newcol) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curcol=grid[i][j];\\n        if (curcol==newcol)return grid;\\n        vector<vector<int>>vis(row,vector<int>(col,0));\\n        vector<vector<int>>ggrid(row,vector<int>(col,0));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ggrid[i][j]=grid[i][j];\\n            }\\n        }\\n        vis[i][j]=1;\\n        dfs(i,j,row,col,curcol,newcol,grid,vis,ggrid);\\n        return ggrid;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655448,
                "title": "c-dfs-graph-easy-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint row[4] = {1, -1, 0, 0};\\nint col[4] = {0, 0, 1, -1};\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int i, int j, int &target, int& color){\\n    if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || visited[i][j]==1 || grid[i][j]!=target)\\n    return;\\n\\n    visited[i][j] = 1;\\n    bool flag = 0;\\n\\n    for(int p = 0 ;p<4 ;p++){\\n        int newX = i+row[p];\\n        int newY = j+col[p];\\n\\n        if(i==0 || i==grid.size()-1 || j==0 || j==grid[0].size()-1 || (visited[newX][newY] == 0 && grid[i][j]!=grid[newX][newY]) )\\n        flag = 1;\\n\\n        dfs(grid, visited, newX, newY, target, color);\\n    }\\n\\n    if(flag)\\n    grid[i][j] = color;  \\n}\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int target = grid[row][col];\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        dfs(grid, visited, row, col, target, color);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642008,
                "title": "2-bfs-traversal-in-a-single-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        //at first visit all the nodes which have the color = oldcolor and connected to current component \\n        queue<pair<int,int>>q;\\n        vector<pair<int,int>>v;\\n        q.push({row,col});\\n        int oldcolor = grid[row][col];\\n        int delrow[4] = {0,-1,0,+1};\\n        int delcol[4] = {+1,0,-1,0};\\n        vis[row][col] = 1;\\n        //after getting all the nodes of the current component please check which of those nodes lie in the circle \\n        while(q.empty() == false){\\n            int row = q.front().first ;\\n            int col = q.front().second;\\n            v.push_back(make_pair(row,col));\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                && !vis[nrow][ncol] && grid[nrow][ncol] == oldcolor){\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow,ncol});\\n                }\\n            }\\n        }\\n        //now inside v i have got all the nodes which are connected to the current compnent \\n        //and all those nodes have the color oldcolor\\n\\n        //now i have to check all the nodes in the current component which are boundary nodes \\n\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vis[i][j] = 0;\\n            }\\n        }\\n        for(int i=0;i<v.size();i++){\\n            q.push({v[i].first,v[i].second});\\n            cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n            vis[v[i].first][v[i].second] = 1;\\n        }\\n        cout<<v.size()<<endl;\\n        vector<vector<int>> arr = grid;\\n        while(q.empty() == false){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            if(row == 0 || col == 0 || row == n-1 || col == m-1){\\n                arr[row][col] = color;\\n                q.pop();\\n                continue;\\n            }\\n            q.pop();\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(grid[nrow][ncol]!=oldcolor){\\n                        arr[row][col] = color;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3569737,
                "title": "c-fast-dfs",
                "content": "\\nclass Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0};\\n        int c[] = {0,+1,0,-1};\\n        for(int i=0;i<4;i++){\\n            int adjr = row + r[i];\\n            int adjc = col + c[i];\\n            if(adjr<0||adjr>=grid.size()||adjc<0 || adjc>=grid[0].size() || abs(grid[adjr][adjc]) != clr)\\n            {\\n                continue;\\n            }\\n            count++;\\n            if(grid[adjr][adjc] == clr)\\n                dfs(adjr,adjc,clr,grid);\\n        }\\n        if(count==4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n    \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        dfs(row,col,grid[row][col],grid);\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution  {\\n\\npublic:\\n\\n    void dfs(int row,int col,int clr,vector<vector<int>>& grid){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        int r[] = {-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3561284,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    void dfs(vector<vector<int>>& grid, int x, int y, int num){\\n        grid[x][y]= -num;\\n        int cnt=0;\\n        for(int i=0; i<4; ++i){\\n            int x1 = x+dx[i], y1=y+dy[i];\\n            if(x1<0 || x1>=grid.size() || y1<0 || y1>=grid[0].size() || abs(grid[x1][y1]) != num) continue;\\n            cnt+=1;\\n            if(grid[x1][y1] != -num)dfs(grid,x1,y1,num);\\n        }\\n        if(cnt==4) grid[x][y] = num;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int num = grid[row][col];\\n        dfs(grid,row,col,num);\\n        for(int i=0; i<grid.size(); ++i){\\n            for(int j=0; j<grid[0].size(); ++j){\\n                if(grid[i][j] == -num) grid[i][j]=color;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        M, N = len(grid), len(grid[0])\\n        q = collections.deque()\\n        q.append((row, col))\\n        dir_lst = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        seen = set()\\n        seen.add((row, col))\\n        border = set()\\n        while q:\\n            i, j = q.popleft()\\n            is_border = i in [0, M-1] or j in [0, N-1]\\n            for di, dj in dir_lst:\\n                ni, nj = i+di, j+dj\\n                if 0<=ni<M and 0<=nj<N and (ni, nj) not in seen:\\n                    if grid[ni][nj]!=grid[i][j]:\\n                        is_border = True\\n                    else:\\n                        seen.add((ni, nj))\\n                        q.append((ni, nj))\\n            if is_border:\\n                border.add((i, j))\\n        \\n        for i, j in border:\\n            grid[i][j] = color\\n        return grid\\n```\n```Java []\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        if (grid[row][col]==color)\\n            return grid;\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        dfs(grid,row,col,grid[row][col],visited,color,n,m);\\n\\n        return grid;\\n    }\\n    void dfs(int[][] grid,int i,int j,int oldColor,boolean[][] visited,int targetColor,int n,int m) {\\n        if (i>=n || i<0 || j<0 || j>=m || grid[i][j]!=oldColor || visited[i][j])\\n            return;\\n        \\n        visited[i][j] = true;\\n        boolean border = false;\\n\\n        if (i==0 || j==0 || j==m-1 || i==n-1 || grid[i+1][j]!=oldColor || grid[i-1][j]!=oldColor || grid[i][j-1]!=oldColor || grid[i][j+1]!=oldColor)\\n            border = true;\\n        \\n        dfs(grid,i+1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i-1,j,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j+1,oldColor,visited,targetColor,n,m);\\n        dfs(grid,i,j-1,oldColor,visited,targetColor,n,m);\\n\\n        if (border)\\n            grid[i][j] = targetColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513135,
                "title": "souvik-hazra-coloring-a-border",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        if (pre := grid[row][col]) == color:\\n            return grid\\n        m, n, d = len(grid), len(grid[0]), [(0, -1), (0, 1), (1, 0), (-1, 0)]\\n        visited = [[False] * n for _ in range(m)]\\n        \\n        def dfs(x: int, y: int) -> None:\\n            if not -1 < x < m or not -1 < y < n or grid[x][y] != pre:\\n                return\\n            grid[x][y], visited[x][y] = color, True\\n            for dx, dy in d:\\n                dfs(x + dx, y + dy)        \\n        dfs(row, col)\\n        for i in range(1, m - 1):\\n            for j in range(1, n - 1):\\n                if visited[i][j] and all(visited[i + dx][j + dy] for dx, dy in d):\\n                    grid[i][j] = pre\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501355,
                "title": "i-am-trying-with-no-extra-space-but-getting-wrong-answer-can-someone-help-me",
                "content": "\\nm, n is grid size\\nc is color that is to be coloured on the perimeter\\nc1 is color that need to replaced\\n\\nThis code is giving WA at 150/154 case.\\n```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c,m,n,c1;\\n    void solve(vector<vector<int>> &grid, int row,int col){\\n        if(row<0 || row>=m || col<0 || col>=n || grid[row][col]!=c1)return;\\n        grid[row][col] = -c1;\\n        bool tocolor = false;\\n\\n        if(row+1>=m || row-1<0 || col+1>=n || col-1<0){\\n            tocolor = true;\\n        }else if(abs(grid[row+1][col])!=c1 ||\\n                abs(grid[row-1][col])!=c1  ||\\n                abs(grid[row][col-1])!=c1  ||\\n                abs(grid[row][col+1])!=c1){\\n            tocolor=true;\\n        }\\n\\n        solve(grid,row+1,col);\\n        solve(grid,row,col-1);\\n        solve(grid,row-1,col);\\n        solve(grid,row,col+1);\\n\\n        if(tocolor)grid[row][col] = c;\\n        else grid[row][col]*=-1;\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        c = color;\\n        c1=grid[row][col];\\n        m=grid.size(),n=grid[0].size();\\n        solve(grid,row,col);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478110,
                "title": "coloring-a-border",
                "content": "------------------ Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<vector<int>> colorBorder(vector<vector<int>>& grid, int r0, int c0,int color) {\\n    dfs(grid, r0, c0, grid[r0][c0]);\\n\\n    for (int i = 0; i < grid.size(); ++i)\\n      for (int j = 0; j < grid[0].size(); ++j)\\n        if(grid[i][j] < 0)\\n          grid[i][j] = color;\\n\\n    return grid;\\n  }\\n\\n private:\\n  void dfs(vector<vector<int>>& grid, int i, int j, int startColor) {\\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\\n      return;\\n    if (grid[i][j] != startColor)\\n      return;\\n\\n    grid[i][j] = -startColor;\\n    dfs(grid, i + 1, j, startColor);\\n    dfs(grid, i - 1, j, startColor);\\n    dfs(grid, i, j + 1, startColor);\\n    dfs(grid, i, j - 1, startColor);\\n\\n    if (i == 0 || i == grid.size() - 1 || j == 0 || j == grid[0].size() - 1)\\n      return;\\n\\n    if (abs(grid[i + 1][j]) == startColor &&  abs(grid[i - 1][j]) == startColor && abs(grid[i][j + 1]) == startColor &&   abs(grid[i][j - 1]) == startColor)\\n      grid[i][j] = startColor;\\n  }\\n};\\n// [\\n// [1,1],\\n// [1,2]\\n// ]\\n// [\\n// [3,3],\\n// [3,2]\\n// ]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399098,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\nMark the island, calculate gradient in r,c direction. Any non 0 numbers means point r,c is on border\\n\\n# Approach\\nBFS to mark an island. Gradient dr = map[r] - map[r - 1], same for columns. Any non zero dr or dc means we are on border of found island.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n) - you can optimize it all a bit and use original grid and negative numbers to save on separate visited grid.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        static const vector<pair<int, int>> D = { {-1, 0}, {+1, 0}, {0, -1}, {0, +1} };\\n        const int testColor = grid[row][col];\\n\\n        const int R = grid.size();\\n        const int C = grid[0].size();\\n\\n        vector<vector<int>> visited(R, vector<int>(C, 0));\\n        queue<pair<int, int>> q;\\n        \\n        q.push( {row, col} );\\n        visited[row][col] = 1;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\n            for (auto d: D) {\\n                int nr = p.first + d.first;\\n                int nc = p.second + d.second;\\n\\n                if (nr < 0 || nr == R || nc < 0 || nc == C) {\\n                    continue;\\n                }\\n\\n                if (!visited[nr][nc] && grid[nr][nc] == testColor) {\\n                    q.push( {nr, nc} );\\n                    visited[nr][nc] = 1;\\n                }\\n            }\\n        }\\n\\n        for (int r = 0;r < R;r ++) {\\n            for (int c = 0;c < C;c ++) {\\n                if (visited[r][c] == 0) {\\n                    continue;\\n                }\\n\\n                int rm = r - 1;\\n                int rp = r + 1;\\n                int cm = c - 1;\\n                int cp = c + 1;\\n\\n                if (\\n                    (rm < 0 || visited[rm][c] == 0) || (rp == R || visited[rp][c] == 0) || \\n                    (cm < 0 || visited[r][cm] == 0) || (cp == C || visited[r][cp] == 0)\\n                   ) \\n                {\\n                    grid[r][c] = color;\\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392758,
                "title": "2-traversal-solutions-iterative-and-recursive-python",
                "content": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nContinuing on Problem 733 Flood Fill.\\n\\nTreatment: Traversal in both iterative and recursive formats here.\\n\\nFollow up at Youtube channel: \"Code-Yao\"\\n\"\"\"\\n\\nclass SolutionV1:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        iterative format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs fn in iterative format\\n        def get_component(r, c, color):\\n            visited = set()\\n            s = [(r, c)]\\n            while s:\\n                x, y = s.pop()\\n                visited.add((x, y))\\n                for x1, y1 in {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}:\\n                    if (0 <= x1 < m) and (0 <= y1 < n) and ((x1, y1) not in visited) and grid[x1][y1] == color:\\n                        s.append((x1, y1))\\n            return visited\\n        \\n        # step-2 set the \"bdr\" of cc cells to color\\n        cluster = get_component(row, col, grid[row][col])\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n    \\n    \\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        \\n        \"\"\"\\n        recursive format\\n        \"\"\"\\n        # step-0 prep\\n        m, n = len(grid), len(grid[0])\\n        \\n        # step-1 dfs helper fn in recursion\\n        visited = set()\\n        # @cache\\n        def traverse(r, c, color):\\n            if r < 0 or r >= m or c < 0 or c >= n:\\n                return\\n            if grid[r][c] == color and (r, c) not in visited:\\n                visited.add((r, c))\\n                traverse(r-1, c, color)\\n                traverse(r+1, c, color)\\n                traverse(r, c-1, color)\\n                traverse(r, c+1, color)\\n        \\n        # step-2\\n        traverse(row, col, grid[row][col])\\n        \\n        cluster = visited\\n        \\n        # step-3 set the color\\n        res = grid.copy()\\n        for (r, c) in cluster:\\n            if r in {0, m-1} or c in {0, n-1}:\\n                res[r][c] = color\\n            for (x, y) in {(r-1, c), (r+1, c), (r, c+1), (r, c-1)}:\\n                if (x, y) not in cluster:\\n                    res[r][c] = color\\n                    break\\n        return res\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374584,
                "title": "simple-c-solution-with-bfs",
                "content": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int newr,int newc,int n,int m){\\n        return (newr>=0 and newr<n and newc>=0 and newc<m);\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        int clr = grid[row][col];\\n        \\n        int delr[] = {0,1,0,-1};\\n        int delc[] = {1,0,-1,0};\\n        \\n        while(!q.empty()){\\n            auto [r,c] = q.front();\\n            q.pop();\\n \\n            for(int i=0;i<4;i++){\\n                int newr = r+delr[i];\\n                int newc = c+delc[i];\\n                \\n                if(isValid(newr,newc,n,m) and !vis[newr][newc] and grid[newr][newc]==clr){\\n                    q.push({newr,newc});\\n                    vis[newr][newc]=1;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int newr=i+delr[k];\\n                        int newc=j+delc[k];\\n                        \\n                        if(isValid(newr,newc,n,m) and vis[newr][newc]) continue;\\n                        if(newr<0 or newr>=n or newc<0 or newc>=m or grid[newr][newc]!=clr){           \\n                            grid[i][j]=color;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367569,
                "title": "dfs-matrix-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean allSet(int[][] grid,int i,int j,int color){\\n        int cnt=0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if(i==0 || i==m-1 || j==0 || j==n-1) return true;\\n        if(grid[i-1][j]==color) cnt++;\\n        if(grid[i+1][j]==color) cnt++;\\n        if(grid[i][j-1]==color) cnt++;\\n        if(grid[i][j+1]==color) cnt++;\\n        return cnt<4;\\n    }\\n    public void dfs(int[][] grid,int[][] visited,int row,int col,int color,int oldcolor,int[][] board,boolean[][] safe){\\n        visited[row][col]=1;\\n        if(safe[row][col]==true){\\n        board[row][col] = color;\\n        }\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] drow = {-1,0,1,0};\\n        int[] dcol = {0,1,0,-1};   \\n           for(int i=0;i<4;i++){\\n               int newr = row + drow[i];\\n               int newc = col + dcol[i];\\nif(newr>=0 && newr<m && newc>=0 && newc<n && visited[newr][newc]!=1 && grid[newr][newc]==oldcolor){\\n                   dfs(grid,visited,newr,newc,color,oldcolor,board,safe);\\n               }\\n           }\\n\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] visited = new int[m][n];\\n        int[][] board = grid;\\n        boolean[][] safe = new boolean[m][n];\\n        int oldcolor = grid[row][col];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                safe[i][j]=allSet(grid,i,j,oldcolor);\\n            }\\n        }\\n        dfs(grid,visited,row,col,color,oldcolor,board,safe);\\n        return board;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362533,
                "title": "bfs-expalantion-in-comment-java",
                "content": "\\n- Time complexity:M*N\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        /*if value of grid[row][col] is surrounded in 4 adjacent direction and if the value is same then we donot take it*/\\n        /*all adjacent cell which same value as grid[row][col] will be color*/\\n     /*we have used BFS traversal first we are inseting the row col and after removing we are seeing if its adjacent cell has same value then we insert that adjacent cell into the queue and another array we have used so if count <4 so we color that particular res[x][y]=color*/ \\n     /*Also we have used an 2d boolean array of same length as grid so that we marked that cell which is already visited and not to visit again*/\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int res[][]=new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                res[i][j]=grid[i][j];\\n            }\\n        }\\n        Queue<int[]> q=new LinkedList<>();\\n        boolean visited[][]=new boolean[m][n];\\n        int t[]=new int[2];\\n        int v=grid[row][col];\\n        if(v==color)return grid;\\n        t[0]=row;\\n        t[1]=col;\\n        q.add(t);\\n       while(!q.isEmpty()){\\n           int size=q.size();\\n           for(int i=0;i<size;i++){\\n               int arr[]=q.remove();\\n               int x=arr[0];\\n               int y=arr[1];\\n               if(visited[x][y])continue;\\n               visited[x][y]=true;\\n               int c=y+1;\\n               int c1=y-1;\\n               int r=x+1;\\n               int r1=x-1;\\n               int count=0;\\n               if(c<n && grid[x][c]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c;\\n                   q.add(temp);\\n               }\\n                if(c1>=0 && grid[x][c1]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=x;\\n                   temp[1]=c1;\\n                   q.add(temp);\\n               }\\n               if(r<m && grid[r][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n                if(r1>=0 && grid[r1][y]==v){\\n                   count++;\\n                   int temp[]=new int[2];\\n                   temp[0]=r1;\\n                   temp[1]=y;\\n                   q.add(temp);\\n               }\\n               System.out.print(count+\"  \");\\n               if(count!=4){\\n                   res[x][y]=color;\\n               }\\n           }\\n       }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334204,
                "title": "c-92-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBorder(vector<vector<int>> &grid, int i, int j, int n, int m, int val) {\\n        if(i == 0 or j == 0 or i == n - 1 or j == m - 1) return true;\\n        if(grid[i + 1][j] != val or grid[i - 1][j] != val or grid[i][j - 1] != val or grid[i][j + 1] != val) return true;\\n        return false;\\n    }\\n\\n    void dfs(int r, int c, int val, vector<vector<int>> &grid, vector<vector<int>> &temp, vector<vector<int>> &vis, int color, int n, int m) {\\n        vis[r][c] = 1;\\n        \\n        if(isBorder(grid, r, c, n, m, val))\\n            temp[r][c] = color;\\n        \\n        int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n        int cnt = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int nx = r + dx[i], ny = c + dy[i];\\n            if(nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny] == val) \\n                dfs(nx, ny, val, grid, temp, vis, color, n, m);\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>> &grid, int row, int col, int color) {\\n        int val = grid[row][col];\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m)), temp {grid};\\n\\n        dfs(row, col, val, grid, temp, vis, color, n, m);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327373,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        def out_of_boundary(x, y):\\n            return x < 0 or y < 0 or x >= m or y >= n\\n\\n        def get_color(x, y):\\n            if out_of_boundary(x, y):\\n                return -2\\n            return grid[x][y]\\n\\n        def check_inside(x, y, target):\\n            dirs = [1, 0, -1, 0]\\n            for i in range(4):\\n                color = get_color(x + dirs[i], y + dirs[(i + 1) % 4])\\n                if color != -1 and color != target:\\n                    return False\\n            return True\\n\\n        p = []\\n        \\n        def dfs(x, y, target):\\n            if out_of_boundary(x, y):\\n                return\\n            if grid[x][y] != target:\\n                return\\n            if check_inside(x, y, target):\\n                p.append((x, y, grid[x][y]))\\n            grid[x][y] = -1\\n            dfs(x + 1, y, target)\\n            dfs(x - 1, y, target)\\n            dfs(x, y + 1, target)\\n            dfs(x, y - 1, target)\\n        \\n        dfs(row, col, grid[row][col])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == -1:\\n                    grid[i][j] = color\\n\\n        for x, y, color in p:\\n            grid[x][y] = color\\n            \\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327297,
                "title": "c-bfs-using-queue-and-set-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS technique to traverse every cell of the connected component and check if the cell color needs to be changed if its a bordering cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from grid[row][col] cell and traverse all the adjacent cells that are part of same component by BFS technique using queue. While traversing the connected component we also check which cells are border cells by checking if it touches the grid limit (0 <= cell_row < grid_row) or (0 <= cell_col < grid_col) or it touches the cell of another connected component (adjacent cell color != original component color).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where \\'n\\' is the no. of cells in the connected component which can be r*c(no. of rows and coloumns in the grid) in worst case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int gr = grid.size();\\n        int gc = grid[0].size();\\n        int compColor = grid[row][col];\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n        int move[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        set<pair<int, int>> st;\\n        st.insert({row,col});\\n\\n        while(!q.empty()) {\\n            int cr = q.front().first;\\n            int cc = q.front().second;\\n            q.pop();\\n            for(int k=0; k<4; k++) {\\n                int nr = cr + move[k][0];\\n                int nc = cc + move[k][1];\\n\\n                if(nr < 0 || nr >= gr || nc < 0 || nc >= gc) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] != compColor && st.find({nr,nc}) == st.end()) {\\n                    grid[cr][cc] = color;\\n                }\\n                else if(grid[nr][nc] == compColor && st.find({nr,nc}) == st.end()) {\\n                    q.push({nr, nc});\\n                    st.insert({nr,nc});\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303499,
                "title": "python-bfs-solution",
                "content": "# Intuition\\nWe can use BFS solution to solve this problem. Start from point (row, col) and move to the neighbors if neighbour has color that we should repaint. We should use visited and painted set to define visited and painted points.\\n\\n# Approach\\nDefine a queue and first point in the queue as grid[row][col].\\nUse BFS to move to the neigbours of current point if the neigbour has color that should be repainted. If all neigbours should be repainted or were repainted that current point should be leave with current color because the current point in the middle. Otherwise, repaint current point and add the point to repainted.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n        m = len(grid)\\n        if m == 0:\\n            return grid\\n        n = len(grid[0])\\n\\n        dr = [[-1,0],[0,1],[1,0],[0,-1]]\\n        visited = set()\\n        painted = set()\\n        cl = grid[row][col]\\n\\n        q = deque()\\n        q.append([row, col])\\n        while q:\\n            for i in range(len(q)):\\n                paint = False\\n                y, x = q.popleft()\\n                key = str(y) + \\':\\' + str(x)\\n                if key in visited:\\n                    continue\\n                visited.add(key)\\n                for dY, dX in dr:\\n                    newY = y + dY\\n                    newX = x + dX\\n                    if newY >= 0 and newY < m and newX >= 0 and newX < n and grid[newY][newX] == cl:\\n                        q.append([newY, newX])\\n                    elif str(newY) + \\':\\' + str(newX) not in painted:\\n                        paint = True\\n                if paint:\\n                    painted.add(key)\\n                    grid[y][x] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300638,
                "title": "java-dfs-o-n2-self-explained-code",
                "content": "# Complexity\\n- Time complexity: $$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(new Integer[]{0,1},\\n            new Integer[]{0,-1}, new Integer[]{1,0}, new Integer[]{-1,0});\\n    private final Set<String> visited = new HashSet<>();\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color) return grid;\\n        dfs(row, col, grid[row][col], color, grid);\\n        return grid;\\n    }\\n\\n    private void dfs(int row, int col, int componentColor, int newColor, int[][] grid) {\\n        visited.add(row + \",\" + col);\\n        if(isOnBorders(row, col, grid) || isAdjacentToDiffComponent(row, col, componentColor, grid)) \\n            grid[row][col] = newColor;\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid,i,j) && !visited.contains(i + \",\" + j) && grid[i][j] == componentColor)\\n                dfs(i, j, componentColor, newColor, grid);\\n        }\\n    }\\n\\n    private boolean isAdjacentToDiffComponent(int row, int col, int componentColor, int[][] grid) {\\n        for (Integer[] direction: directions) {\\n            int i= row + direction[0], j = col + direction[1];\\n            if(isValidCoordinates(grid, i, j) && !visited.contains(i + \",\" + j)  && grid[i][j] != componentColor)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidCoordinates(int[][] grid, int i, int j) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isOnBorders(int row, int col, int[][] grid) {\\n        return row == 0 || row == grid.length-1 || col == 0 || col == grid[0].length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291684,
                "title": "dfs-iterative-and-recursive-approaches-bfs-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStarting from the given cell (row, col) traverse all the neighbors (UP, DOWN, RIGHT, LEFT neighbors) with the same color, and change the cell\\'s color to given color. But we should only change the color of cell when it is a border.\\n\\nA cell can be a border in 2 cases only:\\n- 1. when it is already in the border of the grid\\n- 2. when it is in the middle of the grid and one of the neighbor has different color\\n\\nWe can solve this problem with either DFS or BFS.\\nFor both of them the approach, intuition, complexity analysis are the same.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. starting from the given cell (row, col)\\n2. mark this cell as visited\\n3. traverse all neighbors [(1,0), (-1, 0), (0,1), (0,-1)] with the same color only\\n4. if one of the neighbors has different color mark `isBorder` flag as true\\n5. if the current cell is border change its color\\n\\n \\n# Complexity\\n- Time complexity: O(MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**DFS (Iteratative Approach)**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\\n\\n**DFS Approach with recursion**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\\n\\n**BFS Approach**\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n\\n        def dfs(row, col, color):\\n            visited.add((row, col))\\n            neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row+r, col+c\\n                \\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                dfs(new_r, new_c, color)\\n            \\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        dfs(r, c, grid[r][c])\\n\\n        return grid\\n```\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], r: int, c: int, new_color: int) -> List[List[int]]:\\n        R, C = len(grid), len(grid[0])\\n        visited = set()\\n        queue = deque([(r, c)])\\n        neighbor = [(1,0), (-1,0), (0,1), (0,-1)]\\n        color = grid[r][c]\\n\\n        while queue:\\n            row, col = queue.popleft()\\n            visited.add((row, col))\\n            isBorder = False\\n\\n            for r, c in neighbor:\\n                new_r, new_c = row + r, col+c\\n\\n                # skip when the neighbor cell (new_r, new_c) is out of bound or already visited\\n                if new_r < 0 or new_r >= R or new_c < 0 or new_c >= C or (new_r, new_c) in visited:\\n                    continue\\n\\n                # mark current cell (row, col) as border, when neighbor cell (new_r, new_c) has a different color\\n                if grid[new_r][new_c] != color:\\n                    isBorder = True\\n                    continue\\n\\n                queue.append((new_r, new_c))\\n            \\n            # if the current (row, col) is already the border of the grid, color the cell with new_color\\n            # if isBorder is true, color the cell with new_color\\n            if row == 0 or row == R-1 or col == 0 or col == C-1 or isBorder:\\n                grid[row][col] = new_color\\n\\n        return grid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267644,
                "title": "1034-coloring-a-border-java-dfs-bit-manipulation-approach",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/4766e2d3-e32d-4122-86db-e060c39a27cf_1678173936.385443.png)\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] ans;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        ans = new int[grid.length][];\\n        for(int i=0;i<grid.length;i++){\\n            ans[i] = grid[i].clone();\\n        }\\n\\n        coloring(grid,row,col,grid[row][col],color,new int[grid.length]);\\n\\n       return ans;\\n    }\\n\\n    public boolean check(int n, int pos){\\n        int mask = 1<<pos;\\n\\n        if((n&mask) == mask){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    public int toggle(int n, int pos){\\n        int mask = 1<<pos;\\n        return (n^mask);\\n    }\\n\\n    public void coloring(int[][] arr, int row, int col, int oCol,int target, int[] visited){\\n        if(row<0 || row>=arr.length || col<0 || col>=arr[0].length || (check(visited[row],col) == true) || arr[row][col] != oCol){\\n            return;\\n        }\\n\\n        if((row == 0 || row == arr.length-1 || col == 0 || col == arr[0].length-1 || (arr[row-1][col] != oCol || arr[row][col-1] != oCol || arr[row+1][col] != oCol || arr[row][col+1] != oCol)) && arr[row][col] == oCol){\\n            ans[row][col] = target;\\n        }\\n\\n        visited[row] = toggle(visited[row], col);\\n        coloring(arr,row-1,col,oCol,target,visited);\\n        coloring(arr,row,col-1,oCol,target,visited);\\n        coloring(arr,row+1,col,oCol,target,visited);\\n        coloring(arr,row,col+1,oCol,target,visited);\\n        visited[row] = toggle(visited[row], col);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191048,
                "title": "c",
                "content": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** colorBorder(int** grid, int gridSize, int* gridColSize, int row, int col, int color, int* returnSize, int** returnColumnSizes){\\n    int m = gridSize;\\n    int n = *gridColSize;\\n    *returnSize = m;\\n    *returnColumnSizes = malloc(m * sizeof(int ));\\n    for(int i = 0; i < m; i++){\\n        returnColumnSizes[0][i] = n;\\n    }\\n    if(grid[row][col] == color)\\n        return grid ;\\n    \\n    bool** used = malloc(m * sizeof(bool*));\\n    for(int i = 0; i < m; i++){\\n        used[i] = calloc(n , sizeof(bool));            \\n    }\\n    \\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}} ;\\n    \\n    int** queue = malloc(m * n * sizeof(int*));\\n    int org = grid[row][col] ;\\n    int idx = 0;\\n    queue[idx] = malloc(2 * sizeof(int));\\n    queue[idx][0] = row;\\n    queue[idx][1] = col;\\n    idx++;\\n    int pos = 0;\\n      \\n    used[row][col] = true ;\\n    grid[row][col] = -1*color ;\\n    while(pos < idx){\\n        int x = queue[pos][0];\\n        int y = queue[pos][1];\\n        for(int i = 0; i < 4; i++){\\n            int xx = x + dir[i][0] ;\\n            int yy = y + dir[i][1] ;\\n            if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                continue ;\\n            if(used[xx][yy] || grid[xx][yy] != org)\\n                continue ;\\n            used[xx][yy] = true ;\\n            queue[idx] = malloc(2 * sizeof(int)) ;\\n            queue[idx][0] = xx ;\\n            queue[idx][1] = yy ;\\n            idx++ ;\\n            grid[xx][yy] = -1 * color ;\\n        }\\n        pos++;\\n    }\\n\\n    for(int i = 0; i < m; i++){\\n        for(int j = 0; j < n; j++){\\n            if(grid[i][j] == -1 * color){\\n                if(i == 0 || j == 0 || (i == (m-1)) || (j == (n-1)) ){\\n                    grid[i][j] = color ;\\n                    continue ;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int ii = i + dir[k][0] ;\\n                    int jj = j + dir[k][1] ;\\n                    if(used[ii][jj] == false){\\n                        grid[i][j] = color ;\\n                        break ;\\n                    }\\n                    if(k == 3)\\n                        grid[i][j] = org ;\\n                }\\n            }\\n        }\\n    }\\n    \\n    for(int i = 0; i < idx; i++)\\n        free(queue[i]) ;\\n    free(queue) ;\\n    for(int i = 0; i < m; i++)\\n        free(used[i]) ;\\n    free(used) ;\\n    return grid;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152022,
                "title": "easy-iterative-bfs-c-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSimple Bfs using Queue , just one make sure when you are performing Bfs from a node check whether all it 4 adjacent sides have same intial given color or not. If yes , then no need to color it , else color that node with given final color.\\nAll everything else like visited array , queue processing ,is same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int iniColor = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> vis (n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        vis[row][col] = 1;\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            int cnt = 0;\\n            for(int i=0;i<4;i++){\\n                int newrow = row + delrow[i];\\n                int newcol = col + delcol[i];\\n                if(newrow >= 0 && newrow < n && newcol >=0 && newcol < m && grid[newrow][newcol] == iniColor){\\n                    cnt++;\\n                    if(!vis[newrow][newcol]){\\n                        vis[newrow][newcol] = 1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            if(cnt != 4) ans[row][col] = color;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103474,
                "title": "easy-java-dfs-solution-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * We should only color the border not the elements inside the border.\\n     * Approach:\\n     * 1.Run a dfs from row,col and find all the elements in the connected component\\n     * 2.Once we get elements in the connected component, we can check if we have to color a element or not by following the below given rules\\n     * i)If the node is surrounded by all same color nodes don\\'t color it\\n     * ii)If the node at-least have one non-same color node adjacent to it, then color it\\n     */\\n    private static int prevColor;\\n    private static HashSet<Pair<Integer, Integer>> visited;\\n    private static ArrayList<Pair<Integer, Integer>> connectedComponent;\\n\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        prevColor = grid[row][col];\\n        visited = new HashSet<>();\\n        connectedComponent = new ArrayList<>();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean flag = false;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == prevColor) {\\n                    dfs(grid, row, col);\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) break;\\n        }\\n\\n        int newGrid[][] = new int[m][n];\\n        //copy grid to newGrid\\n        for (int i = 0; i < m; i++) {\\n            newGrid[i] = grid[i].clone();\\n        }\\n        for (int i = 0; i < connectedComponent.size(); i++) {\\n            Pair<Integer, Integer> p = connectedComponent.get(i);\\n\\n            if (!isSame(grid, p.getKey(), p.getValue(), prevColor)) {\\n                newGrid[p.getKey()][p.getValue()] = color;\\n            }\\n\\n        }\\n        return newGrid;\\n    }\\n\\n\\n    //Helper method to determine if we have to color or not\\n    private boolean isSame(int[][] grid, Integer row, Integer col, int prevColor) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        //iterate all the four directions and see if it is surrounded by same color\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (!isValid(nextRow, nextCol, m, n) || grid[nextRow][nextCol] != prevColor) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        visited.add(new Pair<Integer, Integer>(row, col));\\n        connectedComponent.add(new Pair<Integer, Integer>(row, col));\\n\\n        int dirX[] = {0, -1, 0, 1};\\n        int dirY[] = {-1, 0, 1, 0};\\n        for (int i = 0; i < dirX.length; i++) {\\n            int nextRow = dirX[i] + row;\\n            int nextCol = dirY[i] + col;\\n            if (isValid(nextRow, nextCol, grid.length, grid[0].length) && !visited.contains(new Pair<Integer, Integer>(nextRow, nextCol)) && grid[nextRow][nextCol] == prevColor) {\\n                dfs(grid, nextRow, nextCol);\\n            }\\n        }\\n    }\\n\\n    private boolean isValid(int nextRow, int nextCol, int m, int n) {\\n        return nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078407,
                "title": "c-bfs-easy-understanding-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are using bfs here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe start bfs from the given node (row,col).\\nnow we check it\\'s neighbours if it is has same color then we push in queue and increment the counter .\\nif value of counter is less than 4 than we have to recolor to thisw node with given color.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,m;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,1,0,-1};\\nvector<vector<int>>vis,ans;\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        ans.resize(n,vector<int>(m,0));\\n        vis.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        int c=grid[row][col];\\n        q.push({row,col});\\n        vis[row][col]=1;\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            q.pop();\\n            int cnt=0;\\n             for(int i=0;i<4;i++){\\n                 int nx=x+dx[i];\\n                 int ny=y+dy[i];\\n                 if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny]==c){\\n                     cnt++;\\n                     \\n                     if(!vis[nx][ny]){\\n                      q.push({nx,ny});\\n                      vis[nx][ny]=1;\\n                     }\\n                 }\\n             }\\n\\n             if(cnt<4){\\n                 ans[x][y]=color;\\n             }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067884,
                "title": "backtracking-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] arr, int row, int col, int color) {\\n        check(arr,row,col,arr[row][col]);\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i][j]<0){\\n                    arr[i][j] = color;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    int[][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public void check(int[][] arr,int row,int col,int clr){\\n        arr[row][col] = -clr;\\n\\n        // check in 4 direction\\n        int count=0;\\n        for(int i=0;i<4;i++){\\n            // check coonected component;\\n            int r = row + dir[i][0];\\n            int c = col + dir[i][1];\\n\\n            if(r<0 || r>=arr.length || c<0 || c>=arr[0].length || Math.abs(arr[r][c]) != clr){\\n                continue;\\n            }\\n\\n            count++;\\n            if(arr[r][c]==clr){\\n                check(arr,r,c,clr);\\n            }\\n        }\\n\\n        // check if all dir same or not\\n        if(count==4){\\n            arr[row][col]=clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056667,
                "title": "clean-python-9-lines-high-speed-o-n-time-o-1-space-beats-96-9",
                "content": "\\n# Python, DFS:\\n##### We can color the border inside the DFS.\\n\\n```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\\n\\n# Python, BFS:\\n\\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid, r0, c0, color):\\n        seen, m, n = set(), len(grid), len(grid[0])\\n        def dfs(x, y):\\n            if (x, y) in seen: return True\\n            if not (0 <= x < m and 0 <= y < n and grid[x][y] == grid[r0][c0]): return False\\n            seen.add((x, y))\\n            if dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) < 4: grid[x][y] = color\\n            return True\\n        dfs(r0, c0)\\n        return grid\\n```\n```\\n    def colorBorder(self, grid, r0, c0, color):\\n        m, n = len(grid), len(grid[0])\\n        bfs, component, border = [[r0, c0]], set([(r0, c0)]), set()\\n        for r0, c0 in bfs:\\n            for i, j in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                r, c = r0 + i, c0 + j\\n                if 0 <= r < m and 0 <= c < n and grid[r][c] == grid[r0][c0]:\\n                    if (r, c) not in component:\\n                        bfs.append([r, c])\\n                        component.add((r, c))\\n                else: border.add((r0, c0))\\n        for x, y in border: grid[x][y] = color\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049602,
                "title": "simple-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int len, wid;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        this.len = grid.length;\\n        this.wid = grid[0].length;\\n        Dfs(grid, row, col, grid[row][col]);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = 0; j < wid; j++) {\\n                if(grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void Dfs(int[][] grid, int row, int col, int color) {\\n        grid[row][col] = -color; \\n        int count = 0;\\n        for(int i = 0; i < 4; i++) {\\n            int rowdash = row + dir[i][0];\\n            int coldash = col + dir[i][1];\\n            if(rowdash < 0 || coldash < 0 || rowdash >= len || coldash >= wid \\n            || Math.abs(grid[rowdash][coldash]) != color) {\\n                continue;\\n            }\\n            count++; \\n            if(grid[rowdash][coldash] == color)\\n                Dfs(grid, rowdash, coldash, color);\\n        }\\n        if(count == 4)\\n            grid[row][col] = color;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041332,
                "title": "95-faster-easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>g(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                g[i][j]=grid[i][j];\\n            }\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        int y=grid[row][col];\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int dr[]={0,-1,0,1};\\n        int dc[]={1,0,-1,0};\\n        while(!q.empty()){\\n            auto it=q.front();\\n            q.pop();\\n            int r=it.first;\\n            int c=it.second;\\n            if(vis[r][c]==1)continue;\\n            vis[r][c]=1;\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0&&nr<n&&nc>=0&&nc<m){\\n                    if(grid[nr][nc]==y){\\n                        q.push({nr,nc});\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    if((i==0&&j>=0&&j<m)||(i==n-1&&j>=0&&j<m)\\n                    ||(j==0&&i>=0&&i<n)||(j==m-1&&i>=0&&i<n)){\\n                        g[i][j]=color;\\n                        continue;\\n\\n                    }\\n                    for(int x=0;x<4;x++){\\n                        int nr=i+dr[x];\\n                        int nc=j+dc[x];\\n                        \\n                        if((nr>=0&&nr<n&&nc>=0&&nc<m&&grid[nr][nc]!=y)){\\n                            g[i][j]=color;\\n                            continue;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034757,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn color_border(grid: Vec<Vec<i32>>, row: i32, col: i32, color: i32) -> Vec<Vec<i32>> {\\n        fn dfs(grid: &mut Vec<Vec<i32>>, r: i32, c: i32, cl: i32) {\\n            if r < 0\\n                || r >= grid.len() as i32\\n                || c < 0\\n                || c >= grid[r as usize].len() as i32\\n                || grid[r as usize][c as usize] != cl\\n            {\\n                return;\\n            }\\n            grid[r as usize][c as usize] = -cl;\\n            dfs(grid, r - 1, c, cl);\\n            dfs(grid, r + 1, c, cl);\\n            dfs(grid, r, c - 1, cl);\\n            dfs(grid, r, c + 1, cl);\\n            if r > 0\\n                && r < grid.len() as i32 - 1\\n                && c > 0\\n                && c < grid[r as usize].len() as i32 - 1\\n                && cl == grid[(r - 1) as usize][c as usize].abs()\\n                && cl == grid[(r + 1) as usize][c as usize].abs()\\n                && cl == grid[r as usize][(c - 1) as usize].abs()\\n                && cl == grid[r as usize][(c + 1) as usize].abs()\\n            {\\n                grid[r as usize][c as usize] = cl;\\n            }\\n        }\\n\\n        let mut grid = grid;\\n        let cl = grid[row as usize][col as usize];\\n        dfs(&mut grid, row, col, cl);\\n        for item in grid.iter_mut() {\\n            for pt in item.iter_mut() {\\n                *pt = if *pt < 0 { color } else { *pt };\\n            }\\n        }\\n        grid\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031681,
                "title": "cpp-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col});\\n        visited[row][col] = 1;\\n        while(!q.empty()) {\\n           \\n            int row = q.front().first;\\n            int col = q.front().second;\\n            \\n            q.pop();\\n            int a = row + 1;\\n            int b = row - 1;\\n            int c = col + 1;\\n            int d = col - 1;\\n            if(a>=0&&col>=0&&a<grid.size()&&col<grid[0].size()&&grid[a][col]==value&&visited[a][col]==0){\\n                \\n                q.push({a,col});\\n                visited[a][col] = 1;\\n            }\\n                   if(b>=0&&col>=0&&b<grid.size()&&col<grid[0].size()&&grid[b][col]==value&&visited[b][col]==0){\\n                      \\n                q.push({b,col});\\n                visited[b][col] = 1;\\n            }\\n                             if(row>=0&&c>=0&&row<grid.size()&&c<grid[0].size()&&grid[row][c]==value&&visited[row][c]==0){\\n                                \\n                q.push({row,c});\\n                visited[row][c] = 1;\\n            }\\n                                         if(row>=0&&d>=0&&row<grid.size()&&d<grid[0].size()&&grid[row][d]==value&&visited[row][d]==0){\\n                                             \\n                q.push({row,d});\\n                visited[row][d] = 1;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n \\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        int val=grid[row][col];\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        ans=grid;\\n        bfs(grid,visited,row,col,val);\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     {\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            for(int j=0;j<m;j++){\\n          \\n              \\n                if(i>0&&j>0&&i<grid.size()-1&&j<grid[i].size()-1)\\n                {\\n                     int a = i + 1;\\n                     int b = i - 1;\\n                     int c = j + 1;\\n                     int d = j - 1; \\n                    \\n                     if(grid[a][j]==val&&grid[b][j]==val&&grid[i]                                     [c]==val&&grid[i][d]==val)\\n                     {\\n                       \\n                             ans[i][j]=grid[i][j];\\n                         \\n                         \\n                     }\\n                    else\\n                    {\\n                          if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                    }\\n        \\n         \\n                   }\\n                else\\n                {\\n                    if(visited[i][j]==1)\\n                    {\\n                        ans[i][j]=color;\\n                    }\\n                    else\\n                    {\\n                        ans[i][j]=grid[i][j];\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        return ans;\\n        \\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void bfs(vector<vector<int>>grid,vector<vector<int>>&visited,int row,int col,int value) {\\n        \\n        queue<pair<int,int>>q;\\n        q.push({row,col}",
                "codeTag": "Java"
            },
            {
                "id": 3027562,
                "title": "go-bfs-beat-100",
                "content": "# Code\\n```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    directions := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\\n    borders := make([][]int, 0, 10)\\n    queue := make([][]int, 0, 10)\\n    visited := make([][]int, m)\\n    for i := 0; i < m; i++ {\\n        visited[i] = make([]int, n)\\n    }\\n\\n    queue = append(queue, []int{row, col})\\n    connectedValue := grid[row][col]\\n    for len(queue) > 0 {\\n        i, j := queue[0][0], queue[0][1]\\n        queue = queue[1:]\\n        visited[i][j] = 1\\n        \\n        isBorder := false\\n        for _, d := range directions {\\n            di, dj := i+d[0], j+d[1]\\n            if di >= 0 && di < m && dj >= 0 && dj < n {\\n                if grid[di][dj] == connectedValue {\\n                    if visited[di][dj] == 0 {\\n                        queue = append(queue, []int{di, dj})\\n                    }\\n                } else {\\n                    isBorder = true\\n                }\\n            } else {\\n                isBorder = true\\n            }\\n        }\\n        if isBorder {\\n            borders = append(borders, []int{i, j})\\n        }\\n\\n    }\\n    for _, b := range borders {\\n        i, j := b[0], b[1]\\n        grid[i][j] = color\\n    }\\n\\n    return grid \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011082,
                "title": "easy-java-dfs-with-comments",
                "content": "# Intuition\\n4 directions neighbor tells if a cell is border or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private boolean[][] visited;\\n    \\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        visited = new boolean[m][n];\\n        process(grid, row, col, grid[row][col], color);\\n        return grid;\\n    }\\n\\n    private int process(int[][] grid, int row, int col, int origColor, int color) {\\n        // out of bundary\\n        if (row < 0 || row >= m || col < 0 || col >= n) {\\n            return 0;\\n        }\\n\\n        // already visited\\n        if (visited[row][col]) {\\n            return 1;\\n        }\\n\\n        // different color\\n        if (grid[row][col] != origColor) {\\n            return 0;\\n        }\\n\\n        visited[row][col] = true;\\n\\n        // sum up score from 4 directions\\n        int score = process(grid, row - 1, col, origColor, color) + process(grid, row, col + 1, origColor, color) + process(grid, row + 1, col, origColor, color) + process(grid, row, col - 1, origColor, color);\\n\\n        // if score is less than 4, the cell (x, y) is a border\\n        if (score < 4) {\\n            grid[row][col] = color;\\n        }\\n\\n        // inner component cell, return 1 \\n        return 1;\\n    }\\n}\\n\\n\\n/*\\n\\nKey point is to understand what \"border\" is.\\n1. a border cell must belong to connected component \\n2. a border cell is either:\\n    a. connected to a different color cell\\n    b. boundary\\n\\ne.g.\\n\\n[0, 0, 0]\\n[1, 1, 1]\\n[1, 1, 1]\\n[1, 1, 1]\\n\\nrow = 2, col = 1, color = 2\\ncell(2, 1) \\n\\n[0, 0, 0]\\n[2, 2, 2]\\n[2, 1, 2]\\n[2, 2, 2]\\n\\nfor a cell (x, y)\\nif it\\'s inner component, it is surrounded by 4 same-color cells\\nif it\\'s border,\\n    1. it\\'s bundary\\n    2. it\\'s connected to a different color\\n\\nto determine if a cell(x, y) is inner component, we can ask its surranders.\\nif a surrander is same color, it returns 1\\notherwise, bundary returns 0, different color returns 0.\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991007,
                "title": "simple-c-solution-by-breaking-into-steps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , m;\\n    void markMinusOne(int i , int j , int color , vector<vector<int>> &grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=color) return;\\n\\n        grid[i][j] = -1;\\n\\n        markMinusOne(i+1 , j , color, grid);\\n        markMinusOne(i-1 , j , color, grid);\\n        markMinusOne(i , j+1 , color, grid);\\n        markMinusOne(i , j-1 , color, grid);\\n    }\\n\\n\\n\\n    bool isSurrounded(int i , int j , vector<vector<int>>&grid){\\n        if(i==0 or  j==0 or  i==n-1 or  j==m-1) return false;\\n        if(i!=0 && !(grid[i-1][j]==-1 or grid[i-1][j]==0)) return false;\\n        if(j!=0 && !(grid[i][j-1]==-1 or grid[i][j-1]==0)) return false;\\n        if(i!=n-1 && !(grid[i+1][j]==-1 or grid[i+1][j]==0)) return false;\\n        if(j!=m-1 && !(grid[i][j+1]==-1 or grid[i][j+1]==0)) return false;\\n        return true;\\n    }\\n\\n    void undoInner(int i , int j ,int color ,vector<vector<bool>>&vis  ,vector<vector<int>>&grid){\\n        if(i<0 or j<0 or i>=n or j>=m) return;\\n        if(grid[i][j]!=-1 or vis[i][j]) return;\\n        vis[i][j] = true;\\n\\n        if(isSurrounded(i , j , grid)){\\n            grid[i][j] = 0;\\n        }\\n\\n        undoInner(i+1 , j , color, vis ,grid);\\n        undoInner(i-1 , j , color, vis ,grid);\\n        undoInner(i , j+1 , color,  vis ,grid);\\n        undoInner(i , j-1 , color, vis ,grid);\\n\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int x = grid[row][col];\\n        n = grid.size();\\n        m = grid[0].size();\\n        // -1 -> with color x\\n        // 0 -> inner x within the component\\n\\n        // marking the x as -1 in the connected component\\n        markMinusOne(row , col , x , grid);\\n\\n        // marking the inner x as 0 in the connected component\\n        vector<vector<bool>> vis(n , vector<bool>(m , false));\\n        undoInner(row , col , x , vis ,grid);\\n\\n        // coloring the -1 with color in the connected component and inner blocks as x\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                if(grid[i][j]==-1)grid[i][j] = color;\\n                if(grid[i][j]==0) grid[i][j] = x;\\n            }\\n        }\\n\\n\\n        // returning the final grid\\n\\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981040,
                "title": "java-solution-0ms-100-faster",
                "content": "Start **DFS** from current point \\n-> If current point is on border of the matrix,mark it with border color\\n->Check 4 directions, If a non-same region,non-border element found,mark current point with border color\\n\\nNote:Here, **```borderValidity```** is a number indicating number of foreign regions or grid borders are in the neighborhood of current cell\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```borderValidity```\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        dfs(grid,row,col,grid.length,grid[0].length,\\n        color,grid[row][col],new boolean[grid.length][grid[0].length]);\\n        return grid;\\n    }\\n\\n   int dfs(int[][] arr,int i,int j,int row,int col,\\n    int borderColor,int regionColor,boolean[][] visited){\\n        if(i<0 || i>=row || j<0 || j>=col) return 1;\\n        if(visited[i][j]) return 0;\\n        if(arr[i][j]!=regionColor) return 1;\\n        visited[i][j] = true;\\n\\n        int borderValidity = 0;\\n        borderValidity+=dfs(arr,i+1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j+1,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i-1,j,row,col,borderColor,regionColor,visited);\\n        borderValidity+=dfs(arr,i,j-1,row,col,borderColor,regionColor,visited);\\n\\n        if(borderValidity>0) arr[i][j] = borderColor;\\n        return 0;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937057,
                "title": "beats-98-8-1-ms-java-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# We should color the cell iff:\\n- The cell is on the grid border\\n- or any of its neighbours does not have the same color\\n\\n# Complexity\\n- Time complexity: O(nxm) won\\'t visit the same cell more than once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nxm) for the visited array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        return dfs(grid, row, col, color, visited);\\n    }\\n    public int[][] dfs(int[][] grid, int row, int col, int color, boolean[][] visited){\\n        visited[row][col] = true;\\n        boolean isBoundry = false;\\n        if(row == 0 || row == grid.length - 1 || col == 0 || col == grid[0].length - 1)\\n            isBoundry = true;\\n        int[] rd = {1, 0, -1, 0};\\n        int[] cd = {0, 1, 0, -1};\\n        for(int i = 0; i < 4; i++){\\n            int newRow = row + rd[i];\\n            int newCol = col + cd[i];\\n            if(isValid(grid, newRow, newCol) && !visited[newRow][newCol]){\\n                if(grid[newRow][newCol] == grid[row][col])\\n                    dfs(grid, newRow, newCol, color, visited);\\n                else isBoundry = true;\\n            }\\n        }\\n        if(isBoundry) grid[row][col] = color;\\n        return grid;\\n    }\\n    public boolean isValid(int[][] grid, int row, int col){\\n        return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914741,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} row\\n * @param {number} col\\n * @param {number} color\\n * @return {number[][]}\\n */\\nvar colorBorder = function(grid, row, col, color) {\\n    const borderCells = getSolution(grid, row, col, color)()\\n\\n    for(let i=0; i < borderCells.length; i++){\\n        const {row,col} = borderCells[i]\\n\\n        grid[row][col] = color\\n    }\\n\\n    return grid\\n};\\n\\nfunction getSolution(grid, row, col, color){\\n    const visited = {}\\n    const borderCells = []\\n\\n    const componentColor = grid[row][col]\\n    return function(){\\n        const queue = [{row,col}]\\n\\n        while (queue.length) {\\n            const currentPos = queue.shift();\\n            visited[`${currentPos.row}|${currentPos.col}`] = true\\n\\n            if (isABorderCell(currentPos, grid)) {\\n                borderCells.push(currentPos);\\n            }\\n\\n            queue.push(\\n                ...getNeighbouringCells(currentPos, grid).filter(\\n                    pos =>\\n                        Boolean(pos) &&\\n                        visited[`${pos.row}|${pos.col}`] !== true &&\\n                        grid[pos.row][pos.col] === componentColor\\n                )\\n            );\\n        }\\n\\n        return borderCells\\n    }\\n}\\n\\nfunction isABorderCell({ row, col }, grid) {\\n  return (\\n    row === 0 ||\\n    col === 0 ||\\n    row === grid.length - 1 ||\\n    col === grid[0].length - 1 ||\\n    (\\n        grid[row - 1][col] !== grid[row][col]\\n        || grid[row + 1][col] !== grid[row][col]\\n        || grid[row][col - 1] !== grid[row][col]\\n        || grid[row][col + 1] !== grid[row][col]\\n    )\\n  );\\n}\\n\\nfunction getNeighbouringCells({ row, col }, grid){\\n    return [\\n        getNextPos(\"l\", { row, col }, grid),\\n        getNextPos(\"r\", { row, col }, grid),\\n        getNextPos(\"u\", { row, col }, grid),\\n        getNextPos(\"d\", { row, col }, grid),\\n    ]\\n}\\n\\nfunction getNextPos(dir, { row, col }, grid) {\\n  if (dir === \"l\") {\\n    if (col - 1 >= 0) return { row, col: col - 1 };\\n  } else if (dir === \"r\") {\\n    if (col + 1 < grid[0].length) return { row, col: col + 1 };\\n  } else if (dir === \"u\") {\\n    if (row - 1 >= 0) return { row: row - 1, col };\\n  } else if (dir === \"d\") {\\n    if (row + 1 < grid.length) return { row: row + 1, col };\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908771,
                "title": "python-3-dfs-quite-simple-solution-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/0eb25c3a-eb99-4568-8ea1-9d9e8a3e822f_1670961669.9535344.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:\\n\\n        visited, changed = set(), set()\\n        stack = deque()\\n        \\n        color_initial = grid[row][col]\\n        row_n, col_n  = len(grid), len(grid[0])\\n        \\n        # add initial cell to stack\\n        stack.append([row, col])\\n        while stack:\\n            r, c = stack.pop()\\n            if (r, c) in visited:   continue\\n            visited.add((r, c))\\n\\n            ind_brd = False   # indicator of border \\n            for r_dlt, c_dlt in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\\n                if 0 <= r + r_dlt < row_n and \\\\\\n                   0 <= c + c_dlt < col_n: \\n                    \\n                    new_cell = grid[r + r_dlt][c + c_dlt]\\n\\n                    # cell on boundary of the grid     or\\n                    # adjacent cell has another color  --> ind = True\\n                    if r in (0, row_n - 1) or \\\\\\n                       c in (0, col_n - 1) or  new_cell != color_initial:\\n                        ind_brd = True\\n                    \\n                    # cell has the same color --> add to stack \\n                    if new_cell == color_initial:\\n                        stack.append([r + r_dlt, c + c_dlt])\\n\\n            # we should change color in the end, otherwise we could paint cells inside              \\n            # add cell to the set\\n            if ind_brd:\\n                changed.add((r, c))\\n        \\n        # paint borders\\n        for (r, c) in changed:\\n            grid[r][c] = color\\n\\n        return grid\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862569,
                "title": "java-solution-bfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    int row;\\n    int col;\\n\\n    public Pair(int row, int col)\\n    {\\n        this.row = row;\\n        this.col = col;\\n    }\\n}\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        int vis[][] = new int [r][c];\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(row , col));\\n        vis[row][col]=1;\\n        int val = grid[row][col];\\n        int ans[][] = new int[r][c];\\n\\n        for(int i=0; i< r; i++)\\n        {\\n            for(int j=0; j< c ; j++)\\n            {\\n                ans[i][j]= grid[i][j];\\n            }\\n        }\\n\\n\\n        int delRow [] = {-1,0,0,1};\\n        int delCol [] = {0,1,-1,0};\\n\\n\\n        while(!queue.isEmpty())\\n        {\\n            int qr = queue.peek().row;\\n            int qc = queue.peek().col;\\n            queue.remove();\\n            int cnt = 0;\\n            for(int i=0; i<4 ; i++)\\n            {\\n                int nrow = qr + delRow[i];\\n                int ncol = qc + delCol[i];\\n\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && vis[nrow][ncol] != 1 && grid[nrow][ncol] == val)\\n                {\\n                  queue.add(new Pair(nrow, ncol));\\n                  vis[nrow][ncol] =1;\\n                \\n                }\\n                if(nrow >=0 && ncol >=0 && nrow < r && ncol < c && grid[nrow][ncol] == val)\\n                {\\n                  cnt++;              \\n                }\\n            }\\n            if(cnt != 4)\\n            {\\n               ans[qr][qc] = color;\\n            }\\n             \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861615,
                "title": "simple-solution-in-c-using-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\nbool solve(int i,int j,vector<vector<int>>&grid,int color,int n,int m,int t,vector<vector<bool>>&visited)\\n{\\n    if(i<0||j<0||i==n||j==m||grid[i][j]!=t||visited[i][j])\\n    return false;\\n    visited[i][j]=true;\\n    bool bod=false;\\n    if(i==0||j==0||i==n-1||j==m-1||grid[i-1][j]!=t||grid[i+1][j]!=t||grid[i][j-1]!=t||grid[i][j+1]!=t)\\n    bod=true ;\\n    solve(i-1,j,grid,color,n,m,t,visited);\\n    solve(i+1,j,grid,color,n,m,t,visited);\\n    solve(i,j-1,grid,color,n,m,t,visited);\\n    solve(i,j+1,grid,color,n,m,t,visited);\\n    if(bod)\\n    grid[i][j]=color;\\n    return bod;\\n}\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int n=grid.size(),m=grid[0].size(),t=grid[row][col];\\n        if(grid[row][col]==color)\\n        return grid;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        solve(row,col,grid,color,n,m,t,visited);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848632,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis type of problem, it is good to use recursion. isSafe is very important to have this function for further move and identyfy the boundary.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursion move to adjacent block\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isBoundary(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, const int& myColor) {\\n        if (row < 0 || col < 0 || row >= ROWS || col >= COLS) {\\n            return true;\\n        } else if (grid[row][col] != myColor) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void markBoundary(vector<vector<int> >& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<int>>& maze) {\\n        if (isBoundary(grid, row, col - 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row, col + 1, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row - 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n        if (isBoundary(grid, row + 1, col, ROWS, COLS, myColor)) {\\n            maze[row][col] = color;\\n            return;\\n        }\\n    }\\n\\n    bool isSafe(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int myColor, vector<vector<bool> >& visited) {\\n        if (row >= 0 && col >= 0 && row < ROWS && col < COLS && grid[row][col] == myColor && !visited[row][col]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    void colorGrid(vector<vector<int>>& grid, int row, int col, const int& ROWS, const int& COLS, int color, const int& myColor, vector<vector<bool> >& visited, vector<vector<int> >& maze) {\\n        visited[row][col] = true;\\n        markBoundary(grid, row, col, ROWS, COLS, color, myColor, maze);\\n        if (isSafe(grid, row - 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row - 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row + 1, col, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row + 1, col, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col - 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col - 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n        if (isSafe(grid, row, col + 1, ROWS, COLS, myColor, visited)) {\\n            colorGrid(grid, row, col + 1, ROWS, COLS, color, myColor, visited, maze);\\n        }\\n\\n    }\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        const int ROWS = grid.size();\\n        const int COLS = grid[0].size();\\n        vector<bool> vc(COLS, false);\\n        vector<vector<bool> > visited(ROWS, vc);\\n        const int myColor = grid[row][col];\\n        vector<vector<int> > maze = grid;\\n        colorGrid(grid, row, col, ROWS, COLS, color, myColor, visited, maze);\\n        return maze;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833475,
                "title": "simple-dfs-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recursive(vector<vector<int>>& grid, vector<vector<int>>& ans, int row, int col, int color, int comp, vector<vector<int>>& visited){\\n        if(row>=grid.size() || row<0 || col>=grid[0].size() || col<0 || grid[row][col]!=comp || visited[row][col]) return;\\n\\n        visited[row][col] = 1;\\n        if(row<1 || col<1 || row==grid.size()-1 || col==grid[0].size()-1 || grid[row+1][col]!=comp || grid[row-1][col]!=comp || grid[row][col+1]!=comp || grid[row][col-1]!=comp)\\n        ans[row][col] = color;\\n\\n        recursive(grid, ans, row+1, col, color, comp, visited);\\n        recursive(grid, ans, row-1, col, color, comp, visited);\\n        recursive(grid, ans, row, col+1, color, comp, visited);\\n        recursive(grid, ans, row, col-1, color, comp, visited);\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        int component = grid[row][col];\\n        vector<vector<int>> ans = grid;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(), 0));\\n        recursive(grid, ans, row, col, color, component, visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832809,
                "title": "simple-dfs-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<vector<int>> ans;\\n    bool isValid(int r, int c)\\n    {\\n        if(r<0 || c<0 || r==rows || c==cols) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> &vis, int co, int r, int c, int color)\\n    {\\n        vis[r][c]=1;\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        for(int x=0; x<4; x++)\\n        {\\n            int dr=r+directions[x][0], dc=c+directions[x][1];\\n            if(isValid(dr,dc) && grid[dr][dc]==co) \\n            {\\n                if(!vis[dr][dc]) dfs(grid,vis,co,dr,dc,color);\\n            }\\n            else if(!isValid(dr,dc) || (isValid(dr,dc) && grid[dr][dc]!=co)) ans[r][c]=color;\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) \\n    {\\n        ans=grid;\\n        int co=grid[row][col];\\n        rows=grid.size(), cols=grid[0].size();\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        dfs(grid,vis,co,row,col,color);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832752,
                "title": "dfs",
                "content": "# Intuition\\nsimple dfs\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,int c,vector<vector<int>>& grid,vector<vector<int>>& vis,int m,int n,int color,vector<vector<int>>&ans)\\n    {\\n        vis[row][col]=1;\\n        int di[]={-1,1,0,0};\\n        int dj[]={0,0,-1,1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int ni=row+di[i];\\n            int nj=col+dj[i];\\n            if (ni<m && nj<n && ni>=0 && nj>=0 && grid[ni][nj]==c)\\n            {\\n                if (!vis[ni][nj])\\n                {\\n                dfs(ni,nj,c,grid,vis,m,n,color,ans);\\n                }\\n            }\\n            else{\\n               ans[row][col]=color;\\n                \\n            }\\n        }\\n    }\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     vector<vector<int>>ans(m,vector<int>(n,-1));\\n     int c=grid[row][col];\\n      dfs(row,col,c,grid,vis,m,n,color,ans);\\n      for (int i=0;i<m;i++)\\n      {\\n          for (int j=0;j<n;j++)\\n          {\\n              if (ans[i][j]==-1)\\n              {\\n                  ans[i][j]=grid[i][j];\\n              }\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829527,
                "title": "beats-99-java-easy-solution-dfs-graph",
                "content": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int initial = 0;\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        boolean[][] visi = new boolean[grid.length][grid[0].length];\\n        initial = grid[row][col];\\n        call(grid,row,col,color,visi);\\n        \\n        return grid;\\n    }\\n    \\n    public boolean  call(int[][] grid,int i,int j,int color,boolean[][] visi){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length){\\n            return true;\\n        }\\n        if(visi[i][j] == true)return false;\\n        \\n        if(grid[i][j] != initial){\\n            return true;\\n        }\\n        \\n        \\n        visi[i][j] = true;      \\n        boolean r = call(grid,i,j + 1,color,visi);\\n        boolean d = call(grid,i + 1,j,color,visi);\\n        boolean u = call(grid,i - 1,j,color,visi);\\n        boolean l = call(grid,i,j - 1,color,visi);\\n        \\n        if(r || d || u || l){\\n            grid[i][j] = color;\\n        }\\n       \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808321,
                "title": "java-dfs",
                "content": "# Intuition\\nwe will make DFS on the graph and make a flage to check for each nodes if it totally have 4  neighbors with th same color if it does not, this means it is a boundary so we should change its color.\\n# Approach\\nDepth First Search \\n# Complexity\\n- Time complexity:\\nO(n*m + E)\\n- Space complexity:\\nO(n*m) due to recursive calls\\n# Code\\n```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color)\\n    {\\n        Set<Integer> visited = new HashSet<>();\\n        dfs(grid,row,col,grid[row][col],color,visited);\\n        return grid;\\n\\n        \\n    }\\n\\n    public int dfs(int[][] grid, int row, int col,int targetColor, int newColor, Set<Integer> visited)\\n    {\\n        if(visited.contains(row*50+col))\\n        return 1;\\n        if(row<0||col<0||row>=grid.length||col>=grid[0].length||grid[row][col]!=targetColor)\\n        return 0;\\n\\n        int flag = 1;\\n        visited.add(row*50+col);\\n        flag*=dfs(grid,row-1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row+1,col,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col-1,targetColor,newColor,visited);\\n        flag*=dfs(grid,row,col+1,targetColor,newColor,visited);\\n\\n        if(flag==0)\\n        grid[row][col] = newColor;\\n\\n        return 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805987,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        dfs(grid , row , col , grid[row][col]);\\n        for(int i = 0 ; i < grid.length ; i++){\\n            for(int j = 0 ; j < grid[0].length ; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    int[][] dirs = {{1,0} , {0,1}, {-1,0},{0,-1}};\\n    public void dfs(int[][] grid , int row, int col , int clr){\\n        \\n        grid[row][col] = -clr;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < 4 ; i++){\\n            int rowdash = row + dirs[i][0];\\n            int coldash = col + dirs[i][1];\\n            \\n            if(rowdash < 0 || coldash < 0 || rowdash >= grid.length || coldash >= grid[0].length || Math.abs(grid[rowdash][coldash]) != clr){\\n                continue;\\n            } \\n            \\n                count++;\\n                if(grid[rowdash][coldash] == clr){\\n                    dfs(grid,rowdash , coldash,clr);\\n                }       \\n        }\\n        \\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788861,
                "title": "java-solution-beats-98",
                "content": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n /**\\n     * [1,1,1],\\n     * [1,1,1],\\n     * [1,1,1]\\n     * @param grid\\n     * @param row\\n     * @param col\\n     * @param color\\n     * @return\\n     */\\n public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int org = grid[row][col];\\n        colorBorder_DFS(row,col,grid,org);\\n        for(int i =0;i<grid.length;i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] < 0) grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n\\n    private void colorBorder_DFS(int row_i, int col_j, int[][] grid, int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row || grid[row_i][col_j] != org) return;\\n\\n        grid[row_i][col_j] = -org;\\n        colorBorder_DFS(row_i + 1, col_j, grid, org);\\n        colorBorder_DFS(row_i - 1, col_j, grid, org);\\n        colorBorder_DFS(row_i, col_j + 1, grid, org);\\n        colorBorder_DFS(row_i, col_j - 1, grid, org);\\n\\n        if (colorBorder_DFS_abs(grid, row_i + 1, col_j,org) && colorBorder_DFS_abs(grid, row_i - 1, col_j,org)\\n                && colorBorder_DFS_abs(grid, row_i, col_j + 1,org) && colorBorder_DFS_abs(grid, row_i, col_j - 1,org)) {\\n\\t\\t\\t\\t// if the val in 4-diretion is equal to the Math.abs( orginal color ), which means current location is not border, so we don\\'t need to change the color\\n\\t\\t\\t\\t/**\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t-1, [1],-1\\n\\t\\t\\t\\t1,  -1,  1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif  the neighbor of mat[1][1]  all equal -1,  mat[1][1] still is original color 1\\n\\t\\t\\t\\t*/\\n\\t\\t\\n            grid[row_i][col_j] = org;\\n        }\\n\\n    }\\n\\n    private boolean colorBorder_DFS_abs(int[][] grid, int row_i, int col_j,int org) {\\n        int col = grid[0].length;\\n        int row = grid.length;\\n\\t\\t// Beyond the Boundary \\n        if (col_j < 0 || col_j >= col || row_i < 0 || row_i >= row ) return false;\\n\\n       if(grid[row_i][col_j]  ==org ||grid[row_i][col_j]  == -org  ) return true;\\n       return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782694,
                "title": "java-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nborder rules\\nany adjacent box which can not be colored\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public class Node{\\n        int i;\\n        int j;\\n        public Node(int ii,int jj)\\n        {\\n            i=ii;\\n            j=jj;\\n        }\\n    }\\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\\n        int comp=grid[row][col];\\n        boolean[][] visited=new boolean[grid.length][grid[0].length];\\n        int[][] dir={{-1,0,1,0},{0,-1,0,1}};\\n        LinkedList<Node> li=new LinkedList<>();\\n        li.addFirst(new Node(row,col));\\n        while(li.size()!=0)\\n        {\\n            Node temp=li.removeFirst();\\n            visited[temp.i][temp.j]=true;\\n            for(int z=0;z<dir[0].length;z++)\\n            {\\n                int i=temp.i+dir[0][z];\\n                int j=temp.j+dir[1][z];\\n                if(i<0 || j<0 || i==grid.length || j==grid[0].length || grid[i][j]!=comp && !visited[i][j])\\n                {\\n                    grid[temp.i][temp.j]=color;\\n                    continue;\\n                }\\n                if(!visited[i][j])\\n                {\\n                    li.addFirst(new Node(i,j));\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754832,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        if(grid[row][col] == color){\\n            return grid;\\n        }\\n        DFS(grid,row,col,grid[row][col]);\\n        for(int i = 0 ; i < grid.Length; i++){\\n            for(int j = 0 ; j < grid[0].Length; j++){\\n                if(grid[i][j] < 0){\\n                    grid[i][j] = color;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n    int[,] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n    private void DFS(int[][] grid, int row, int col, int clr){\\n        grid[row][col] = -clr;\\n        int count = 0;\\n        for(int i = 0 ; i < 4 ; i++){\\n            int r = row + dir[i,0];\\n            int c = col + dir[i,1];\\n            \\n            if( r < 0 || c < 0 || r >= grid.Length || c >= grid[0].Length || Math.Abs(grid[r][c]) != clr){\\n                continue;\\n            }\\n            ++count;\\n            if(grid[r][c] == clr){\\n                DFS(grid,r,c,clr);\\n            }\\n        }\\n        if(count == 4){\\n            grid[row][col] = clr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730663,
                "title": "dfs-solution",
                "content": "# Complexity\\n- Time complexity:\\n O(NxM) N is no of rows and M is no of columns\\n\\n- Space complexity:\\nO(NxM) + auxiliary stack space\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] ColorBorder(int[][] grid, int row, int col, int color) {\\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        int givenColor = grid[row][col];\\n        bool[,] visited = new bool[r,c];\\n        int[][] finalGrid = new int[r][];\\n        for(int i=0;i<r;i++)\\n          finalGrid[i] = new int[c];\\n          \\n        for(int i=0;i<r;i++)\\n        {\\n          for(int j=0;j<c;j++)\\n            finalGrid[i][j] = grid[i][j];\\n        }\\n        dfs(grid, row, col, givenColor, color, visited);\\n        void dfs(int[][] grid, int row, int col, int givenColor, int color, bool[,] visited)\\n        {\\n          if(row < 0 || col < 0 || row >= r || col >= c) return;\\n          if(grid[row][col] == givenColor && !visited[row,col])\\n          {\\n              visited[row,col] = true;\\n              if((row ==0 || col ==0 || row == r-1 || col == c-1)) \\n              {\\n                    finalGrid[row][col] = color;\\n              }\\n              else if(row-1 >= 0 && !(grid[row-1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(row+1 <= r-1 && !(grid[row+1][col] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col-1 >= 0 && !(grid[row][col-1] == givenColor))\\n                  finalGrid[row][col] = color;\\n              else if(col+1 <= c-1 && !(grid[row][col+1] == givenColor))\\n                  finalGrid[row][col] = color;\\n\\n              dfs(grid,row-1,col,givenColor,color, visited);\\n              dfs(grid,row+1,col,givenColor,color, visited);\\n              dfs(grid,row,col-1,givenColor,color, visited);\\n              dfs(grid,row,col+1,givenColor,color, visited);\\n          }\\n        }\\n        return finalGrid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1564824,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1570928,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1575145,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955641,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1944275,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1942977,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1918113,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1572643,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 2037655,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            },
            {
                "id": 1955696,
                "content": [
                    {
                        "username": "danielkua",
                        "content": "The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).\\n\\nWhat is this english lmao? Total BS.\\n\\nthe border of a connected component is all the squares in the connected component that are 4-directionally adjacent to a square not in the component. How is this possible?\\nIt is connected and are 4-directionally adjacent to a square not in the component at the same time?\\n\\n"
                    },
                    {
                        "username": "indsonu",
                        "content": "![image](https://assets.leetcode.com/users/images/b0131d7b-f5d7-4ba0-b9e3-797a4cd9988a_1656059908.4762526.png)\\n\\n***The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).***\\n\\n**Meaning :**\\nBorder of connect component means all the cell which has src color in a connected component ( in our diagram it is 2 ) which are not 4 directionally connected with the src color\\n\\n![image](https://assets.leetcode.com/users/images/318439bd-9369-489b-b758-8c55fe279e28_1656061269.7932894.png)\\n\\n![image](https://assets.leetcode.com/users/images/46708bdf-0e76-4e16-83fd-71baeb8cecde_1656061021.343119.png)\\n\\n**Answer of the image matrix : **\\n![image](https://assets.leetcode.com/users/images/2b7f3e60-f13f-46a9-b9e4-0a58414dae00_1656061153.3725455.png)\\n\\n\\nSolution :  **Try yourself first**\\nSolution for referemce  : https://www.toptal.com/developers/hastebin/efaqavaniy.cpp\\n"
                    },
                    {
                        "username": "ChanVerz",
                        "content": "No offense but, i think leetcode is employing aliens\\nAnyone who understand the problem fully and has a heart to explain to us who dont, are the real MVP"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "mujhe ulti aa gai"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) i actually solved it using dfs initially, that gave me tle then i used bfs, solved it, thank you anyway aman :)\\n"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha, Follow Along With Me... \\nLink: https://leetcode.com/problems/coloring-a-border/description/comments/1918113"
                    },
                    {
                        "username": "speedyy",
                        "content": "Leetcode forgot to add the prerequisite of this Q.\nIELTS 10\n\nI don't know how to add the picture here, so I tried my best to explain easily with pictures in my solution from scratch to the end . [Here](https://leetcode.com/problems/coloring-a-border/solutions/3686098/detailed-explanation-with-pictures/)"
                    },
                    {
                        "username": "hosua",
                        "content": "If you\\'re gonna word the problem statement poorly, the least you could do is provide some explanations in the examples..."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "- **We have ambiguity in the statement:**\n*The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).*\n\n- **Here is the logic, to make your understanding to question better:**\n ```\n// Input 1 :  (1,1)\n\n// 1 1 1      2 2 2\n// 1 1 1  --> 2 1 2\n// 1 1 1      2 2 2\n\n// Input 1.2 : (1,1)\n\n// 2 4 5 3 1      2 4 5 3 1      F F F F F\n// 3 1 1 1 4      3 2 2 2 4      F T T T F\n// 2 1 1 1 6  --> 2 2 1 2 6  --> F T F T F  --> And all the T will be colored with color \n// 9 1 1 1 7      9 2 2 2 7      F T T T F \n// 2 8 3 2 9      2 8 3 2 9      F F F F F\n\n// Input 2 : (0,1)\n\n// 1 2 2  --> 1 3 3\n// 2 3 2      2 3 3\n\n// Input 3 : (0,0)\n\n// 1 1 --> 3 3\n// 1 2     3 2\n```\n\n- **Now lets have a look at my well structured code**\n```\nclass Solution {\n\n    private static void dfs(int row, int col, int Row, int Col, int[] dRow, int[] dCol,\n    int srcColor, int[][] grid, int[][] visited){\n        visited[row][col] = 1;\n        for(int move=0;move<4;move++){\n            int row_ = row + dRow[move], col_ = col + dCol[move];\n            if(row_>=0 && col_>=0 && row_<Row && col_<Col){\n                if(grid[row_][col_]==srcColor && visited[row_][col_]==0){\n                    visited[row_][col_] = 1;\n                    dfs(row_,col_,Row,Col,dRow,dCol,srcColor,grid,visited);\n                }\n            }\n        }\n    }\n\n    public int[][] colorBorder(int[][] grid, int row, int col, int color) {\n        int Row = grid.length, Col = grid[0].length, srcColor = grid[row][col];\n        int[][] visited = new int[Row][Col];\n        int[] dRow = new int[]{-1,0,1,0}, dCol = new int[]{0,1,0,-1};\n        dfs(row,col,Row,Col,dRow,dCol,srcColor,grid,visited);\n        for(int i=0;i<Row;i++){\n            for(int j=0;j<Col;j++){\n                if(visited[i][j]==1){\n                    if(i==0||i==Row-1||j==0||j==Col-1){ visited[i][j] = color; }\n                    else{\n                        boolean isBoundaryCell = false;\n                        for(int move=0;move<4;move++){\n                            int i_ = i + dRow[move], j_ = j + dCol[move];\n                            if(grid[i_][j_]!=srcColor) isBoundaryCell = true;\n                        }\n                        if(isBoundaryCell) visited[i][j] = color;\n                        else visited[i][j] = grid[i][j];\n                    }\n                }else visited[i][j] = grid[i][j];\n            }\n        }\n        return visited;\n    }\n}\n\n// Time Complexity : O(Row x Col)\n// Space Complexity : O(Row x Col)\n```"
                    },
                    {
                        "username": "wangjian4814",
                        "content": "The example[[1,1,1], [1, 1, 1], [1, 1, 1]] ..."
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_Color(int r, int c, vector<vector<int>>& matrix, vector<vector<bool>>& visited, int oldColour, int newColour) {\\n\\t\\tif (!isValid(r, c, matrix) || visited[r][c] || matrix[r][c] != oldColour)\\n\\t\\t\\treturn;\\n\\t\\t\\t\\n    visited[r][c] = true; matrix[r][c] = newColour;\\n\\n\\t\\tint dr[] = { -1, 0 , 1 , 0 }; // up , right , down , left\\n\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\t\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\t\\tdfs_Color(r + dr[d], c + dc[d], matrix, visited, oldColour, newColour);\\n}\\n\\npublic:\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n       vector<vector<bool>>visited(grid.size(), vector<bool>(grid[0].size()));\\n\\t\\t\\t\\tvector<vector<int>>temp(grid);\\n\\t\\t\\t\\tint oldcolor = grid[row][col];\\n\\n\\t\\t\\t\\tdfs_Color(row, col, grid, visited, grid[row][col], color);\\n\\n\\t\\t\\t\\tint dr[] = { -1, 0 , 1 , 0 };\\n\\t\\t\\t\\tint dc[] = { 0 , 1 , 0 , -1 };\\n\\n\\t\\t\\t\\tfor (auto i = 0; i < (int)grid.size(); ++i) {\\n\\t\\t\\t\\t\\tfor (auto j = 0; j < (int)grid[i].size(); ++j) {\\n\\t\\t\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\t\\t\\tif (temp[i][j] == oldcolor) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor (auto d = 0; d < 4; ++d) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif (isValid(i + dr[d], j + dc[d], temp)) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif (temp[i + dr[d]][j + dc[d]] == oldcolor) ++cnt;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif (cnt == 4) {\\n\\t\\t\\t\\t\\t\\t\\tgrid[i][j] = oldcolor;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn grid;\\n    }\\n};"
                    },
                    {
                        "username": "saumyagupta1",
                        "content": " `class Solution {\\npublic:\\n    int n, m;\\n    int delr[4] = {0, 0, 1, -1};\\n    int delc[4] = {1, -1, 0, 0};\\n\\n    void dfs(int r, int c, vector<vector<int>>& grid, int color) {\\n        grid[r][c] = -color;\\n        for (int k = 0; k < 4; k++) {\\n            int nr = r + delr[k];\\n            int nc = c + delc[k];\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || grid[nr][nc] != color)\\n                continue;\\n            dfs(nr, nc, grid, color);\\n        }\\n        if (r > 0 && r < m - 1 && c > 0 && c < n - 1) {\\n            if (color == abs(grid[r + 1][c]) && color == abs(grid[r - 1][c]) && color == abs(grid[r][c + 1]) && color == abs(grid[r][c - 1]))\\n                grid[r][c] = color;\\n        }\\n    }\\n\\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        int originalColor = grid[row][col];\\n\\n        if (color == originalColor)\\n            return grid;\\n        dfs(row, col, grid, originalColor);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] < 0)\\n                    grid[i][j] = color;\\n            }\\n        }\\n        return grid;\\n    }\\n};`\\n\\n\\nTLE FOR DFS, 154/155 passed, i solved it later using bfs but can someone help me optimise this dfs approach plox"
                    },
                    {
                        "username": "A_Y",
                        "content": "can you see my solution with dfs here https://leetcode.com/problems/coloring-a-border/solutions/3982702/color-border-dfs/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Possible Integer After at Most K Adjacent Swaps On Digits",
        "question_content": "<p>You are given a string <code>num</code> representing <strong>the digits</strong> of a very large integer and an integer <code>k</code>. You are allowed to swap any two adjacent digits of the integer <strong>at most</strong> <code>k</code> times.</p>\n\n<p>Return <em>the minimum integer you can obtain also as a string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/06/17/q4_1.jpg\" style=\"width: 500px; height: 40px;\" />\n<pre>\n<strong>Input:</strong> num = &quot;4321&quot;, k = 4\n<strong>Output:</strong> &quot;1342&quot;\n<strong>Explanation:</strong> The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;100&quot;, k = 1\n<strong>Output:</strong> &quot;010&quot;\n<strong>Explanation:</strong> It&#39;s ok for the output to have leading zeros, but the input is guaranteed not to have any leading zeros.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;36789&quot;, k = 1000\n<strong>Output:</strong> &quot;36789&quot;\n<strong>Explanation:</strong> We can keep the number without any swaps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>num</code> consists of only <strong>digits</strong> and does not contain <strong>leading zeros</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 720548,
                "title": "o-n-logn-detailed-explanation",
                "content": "A hard question = Lots of observation + data structures \\n\\nLet\\'s figure out observations and then find out data structure to implement them.\\n\\n>Observation 0: Well, we know that if we could get smallest digit to the left, then we will be able to make number smaller than we currently have. In that sense, a sorted number(Ascending) will already be smallest. \\n\\nSo, let\\'s take pen and paper and try to find smallest number we can form for this:\\n\\n```\"4321\", k = 4```\\n\\nSo, let\\'s try to move 1 to left most postion. From now on, I\\'ll call the current digit we are moving to left as ```d```:\\n```\"4321\", k = 4```\\n```\"4312\", k = 3```\\n```\"4132\", k = 2```\\n```\"1432\", k = 1```\\nHmm, we can clearly observe: \\n\\n>Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n\\nBut, wait.  What if there was another digit to right of ```d```?\\n```\"43219\", k = 4```\\n```\"43129\", k = 3```\\n```\"41329\", k = 2```\\n```\"14329\", k = 1```\\n\\nWell, location of 9 didn\\'t change. Therefore, we can make some correction to our above observation. \\n\\n>Corrected observation 1: Only digits to the left of ```d``` get their position shifted.\\n\\nAlright, what\\'s next?\\n\\nBut what if the ```k``` was really small and we couldn\\'t move 1 to left most?\\n```\"43219\", k = 2```\\n```\"43129\", k = 1```\\n```\"41329\", k = 0```\\n\\nHmm, something is fishy, we clearly didn\\'t reach smallest number here. Smallest for ```k=2``` would be ```24319```.\\n\\nWe can observe here, that we should choose smallest ```d``` that is in the reach of ```k```. \\n\\n>Observation 2: Choose first smallest ```d``` that is in reach of ```k```. \\n\\nIf we combine all the observation, we can see that we will iterate from left to right and try to place digits 0 through 9.\\nLet\\'s work through a bigger example:\\n\\n```\"9438957234785635408\", k = 23```\\n\\nWe will start from left. Let\\'s try to place 0 here. ```0``` is within reach of ```k```,  ```0``` is 17 shifts away to right. So, we will get:\\n```\"0943895723478563548\", k = 6```\\n\\nObserve that all the number got shifted to right except the once to the right of ```d``` (8, here).  \\n\\nNow, let\\'s move to next position:\\nLet\\'s try to place 0 here, again. But wait, we don\\'t 0 left, so try 1, which is not there also. So let\\'s try 2, 2 is 8 distance away from this position. ```8 > k```, so we cannot choose 2. Let\\'s try 3, 3 is 2 distance away. 2 < k, therefore let\\'s choose 3.\\n\\n```\"0394895723478563548\", k = 4```\\n\\nand we can continue like this.\\n\\n>For observation 1, to calculate the correct number of shifts, we will need to also store how many elements before ```d``` already shifted. We will use segment tree for this.\\n>For observation 2, We will use queue to choose latest occurence of each digit.\\n\\n\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        //pqs stores the location of each digit.\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        String ans = \"\";\\n        SegmentTree seg = new SegmentTree(num.length());\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            // At each location, try to place 0....9\\n            for (int digit = 0; digit <= 9; ++digit) {\\n                // is there any occurrence of digit left?\\n                if (pqs.get(digit).size() != 0) {\\n                    // yes, there is a occurrence of digit at pos\\n                    Integer pos = pqs.get(digit).peek();\\n\\t\\t\\t\\t\\t// Since few numbers already shifted to left, this `pos` might be outdated.\\n                    // we try to find how many number already got shifted that were to the left of pos.\\n                    int shift = seg.getCountLessThan(pos);\\n                    // (pos - shift) is number of steps to make digit move from pos to i.\\n                    if (pos - shift <= k) {\\n                        k -= pos - shift;\\n                        seg.add(pos); // Add pos to our segment tree.\\n                        pqs.get(digit).remove();\\n                        ans += digit;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class SegmentTree {\\n        int[] nodes;\\n        int n;\\n\\n        public SegmentTree(int max) {\\n            nodes = new int[4 * (max)];\\n            n = max;\\n        }\\n\\n        public void add(int num) {\\n            addUtil(num, 0, n, 0);\\n        }\\n\\n        private void addUtil(int num, int l, int r, int node) {\\n            if (num < l || num > r) {\\n                return;\\n            }\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            addUtil(num, l, mid, 2 * node + 1);\\n            addUtil(num, mid + 1, r, 2 * node + 2);\\n            nodes[node] = nodes[2 * node + 1] + nodes[2 * node + 2];\\n        }\\n\\n        // Essentialy it tells count of numbers < num.\\n        public int getCountLessThan(int num) {\\n            return getUtil(0, num, 0, n, 0);\\n        }\\n\\n        private int getUtil(int ql, int qr, int l, int r, int node) {\\n            if (qr < l || ql > r) return 0;\\n            if (ql <= l && qr >= r) {\\n                return nodes[node];\\n            }\\n\\n            int mid = (l + r) / 2;\\n            return getUtil(ql, qr, l, mid, 2 * node + 1) + getUtil(ql, qr, mid + 1, r, 2 * node + 2);\\n        }\\n    }\\n\\n}\\n```\\n\\nIf you don\\'t know about segment tree. This is simplest segment tree and you can look up ```sum of ranges using segment tree``` on Google and you will find million articles. You can also use Balanced BST, BIT (Thanks @giftwei for suggestion) to get same complexity.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\"4321\", k = 4```\n```d```\n```\"4321\", k = 4```\n```\"4312\", k = 3```\n```\"4132\", k = 2```\n```\"1432\", k = 1```\n```d```\n```\"43219\", k = 4```\n```\"43129\", k = 3```\n```\"41329\", k = 2```\n```\"14329\", k = 1```\n```d```\n```k```\n```\"43219\", k = 2```\n```\"43129\", k = 1```\n```\"41329\", k = 0```\n```k=2```\n```24319```\n```d```\n```k```\n```d```\n```k```\n```\"9438957234785635408\", k = 23```\n```0```\n```k```\n```0```\n```\"0943895723478563548\", k = 6```\n```d```\n```8 > k```\n```\"0394895723478563548\", k = 4```\n```d```\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        //pqs stores the location of each digit.\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        String ans = \"\";\\n        SegmentTree seg = new SegmentTree(num.length());\\n\\n        for (int i = 0; i < num.length(); ++i) {\\n            // At each location, try to place 0....9\\n            for (int digit = 0; digit <= 9; ++digit) {\\n                // is there any occurrence of digit left?\\n                if (pqs.get(digit).size() != 0) {\\n                    // yes, there is a occurrence of digit at pos\\n                    Integer pos = pqs.get(digit).peek();\\n\\t\\t\\t\\t\\t// Since few numbers already shifted to left, this `pos` might be outdated.\\n                    // we try to find how many number already got shifted that were to the left of pos.\\n                    int shift = seg.getCountLessThan(pos);\\n                    // (pos - shift) is number of steps to make digit move from pos to i.\\n                    if (pos - shift <= k) {\\n                        k -= pos - shift;\\n                        seg.add(pos); // Add pos to our segment tree.\\n                        pqs.get(digit).remove();\\n                        ans += digit;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    class SegmentTree {\\n        int[] nodes;\\n        int n;\\n\\n        public SegmentTree(int max) {\\n            nodes = new int[4 * (max)];\\n            n = max;\\n        }\\n\\n        public void add(int num) {\\n            addUtil(num, 0, n, 0);\\n        }\\n\\n        private void addUtil(int num, int l, int r, int node) {\\n            if (num < l || num > r) {\\n                return;\\n            }\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (l + r) / 2;\\n            addUtil(num, l, mid, 2 * node + 1);\\n            addUtil(num, mid + 1, r, 2 * node + 2);\\n            nodes[node] = nodes[2 * node + 1] + nodes[2 * node + 2];\\n        }\\n\\n        // Essentialy it tells count of numbers < num.\\n        public int getCountLessThan(int num) {\\n            return getUtil(0, num, 0, n, 0);\\n        }\\n\\n        private int getUtil(int ql, int qr, int l, int r, int node) {\\n            if (qr < l || ql > r) return 0;\\n            if (ql <= l && qr >= r) {\\n                return nodes[node];\\n            }\\n\\n            int mid = (l + r) / 2;\\n            return getUtil(ql, qr, l, mid, 2 * node + 1) + getUtil(ql, qr, mid + 1, r, 2 * node + 2);\\n        }\\n    }\\n\\n}\\n```\n```sum of ranges using segment tree```",
                "codeTag": "Java"
            },
            {
                "id": 720215,
                "title": "the-constraint-was-not-very-helpful-c-python-clean-56ms-o-n2-solution",
                "content": "1 <= num.length <= 30000\\n1 <= k <= 10^9\\n\\nGiven these two constraints, how could leetcode expect someone to know that O(n2) and O(n2logn) would pass the OJ?\\nIt was not hard to figure out the bubble sort as a naive solution (pick the smallest possible number and move to the front) and think about fast return with sorted digits if k >= n*(n-1)//2 (when all numbers can be rearranged freely), but I spent the last hour trying to implement a clever solution, but failed...\\nI think BIT or segment tree will do, but didn\\'t manage to get them right.\\n\\nI would suggest either make the constraint less daunting, or reinforce the constraint as claimed...\\nWell, I guess maybe sometimes we just need to be bold enough and jump off the cliff to realize it was just a pit...\\n\\nUsually, I would think the total number of computation acceptable would be below 10^8. So, if n > 10000, I would hesitate to try O(n2).\\n\\n--------------------\\nWow, so many people voted up, so I attached a solution below, beat 100% in Python (56ms in total).\\nThis is an O(n2) solution just for fun.\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t    # base case\\n\\t\\t    if k <= 0: return num\\n\\t\\t    # the total number of swaps if you need to reverse the whole string is n*(n-1)//2.\\n\\t\\t\\t# therefore, if k is >= this number, any order is achievable.\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n            \\n\\t\\t    # starting from the smallest number\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t    # find the smallest index\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\t# if this index is valid\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t    # move the digit to the front and deal with the rest of the string recursively.\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\nTo copy and paste:\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tif k <= 0: return num\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n\\n\\t\\t\\t# for each number, find the first index\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\t\\t\\t\\t\\t\\nC++ version by @wanli2019. Thank you.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tif(k <= 0) \\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tif(k>=n*(n+1)/2){ \\n\\t\\t\\t\\tsort(num.begin(), num.end());\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<10; i++){\\n\\t\\t\\t\\tint idx = num.find(to_string(i));\\n\\t\\t\\t\\tif(idx>=0 && idx<=k)\\n\\t\\t\\t\\t\\treturn num[idx]+minInteger(num.substr(0,idx)+num.substr(idx+1), k-idx);\\n\\t\\t\\t}\\n\\t\\t\\treturn num;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t    # base case\\n\\t\\t    if k <= 0: return num\\n\\t\\t    # the total number of swaps if you need to reverse the whole string is n*(n-1)//2.\\n\\t\\t\\t# therefore, if k is >= this number, any order is achievable.\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n            \\n\\t\\t    # starting from the smallest number\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t    # find the smallest index\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\t# if this index is valid\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t    # move the digit to the front and deal with the rest of the string recursively.\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\nTo copy and paste:\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tif k <= 0: return num\\n\\t\\t\\tn = len(num)\\n\\t\\t\\tif k >= n*(n-1)//2: \\n\\t\\t\\t\\treturn \"\".join(sorted(list(num)))\\n\\n\\t\\t\\t# for each number, find the first index\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tind = num.find(str(i))\\n\\t\\t\\t\\tif 0 <= ind <= k:\\n\\t\\t\\t\\t\\treturn str(num[ind]) + self.minInteger(num[0:ind] + num[ind+1:], k-ind)\\n\\t\\t\\t\\t\\t\\nC++ version by @wanli2019. Thank you.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tif(k <= 0) \\n\\t\\t\\t\\treturn num;\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tif(k>=n*(n+1)/2){ \\n\\t\\t\\t\\tsort(num.begin(), num.end());\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 720650,
                "title": "python-17-lines-o-nlogn-solution",
                "content": "The idea is quite straightforward: \\n`In each round, pick the smallest number within k distance and move it to the front.`\\nFor each number, we save its indexes in a deque.\\nIn each round, we check from 0 to 9 to see if the nearest index is within k distance.\\nBut here comes the tricky part:\\n`The index of a number may change due to the swaps we made in the previous rounds.`\\nFor example, if 3 numbers after `num[i]` are moved to the front,\\nthen the index of `num[i]` becomes `i + 3` in the new array.\\nSo we need a data structure to store the indexes of picked numbers,\\nto support fast calculation of the new index of each remaining number.\\nBIT, Segment Tree and Balanced Binary Search Tree can do this.\\nHere I use `sortedcontainers`, which is an implementation of Balanced Binary Search Tree.\\n\\n```\\nfrom collections import defaultdict, deque\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        d = defaultdict(deque)\\n        for i, a in enumerate(num):\\n            d[a].append(i)\\n        ans, seen = \\'\\', SortedList()\\n        for _ in range(len(num)):\\n            for a in digits:\\n                if d[a]:\\n                    i = d[a][0]\\n                    ni = i + (len(seen) - seen.bisect(i))\\n                    dis = ni - len(seen)\\n                    if dis <= k:\\n                        k -= dis\\n                        d[a].popleft()\\n                        ans += a\\n                        seen.add(i)\\n                        break\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict, deque\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        d = defaultdict(deque)\\n        for i, a in enumerate(num):\\n            d[a].append(i)\\n        ans, seen = \\'\\', SortedList()\\n        for _ in range(len(num)):\\n            for a in digits:\\n                if d[a]:\\n                    i = d[a][0]\\n                    ni = i + (len(seen) - seen.bisect(i))\\n                    dis = ni - len(seen)\\n                    if dis <= k:\\n                        k -= dis\\n                        d[a].popleft()\\n                        ans += a\\n                        seen.add(i)\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720101,
                "title": "java-bubblesort-16-lines-with-detailed-explanation-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/9cf54b34-103f-4cf0-bd37-1509056dffde_1593921654.0422919.png)\\n\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k){\\n        if (k==0 || I==ca.length) return;\\n        int min = ca[I], minIdx = I;\\n        for (int i = I+1; i<Math.min(I+k+1, ca.length); i++)\\n            if (ca[i]<min){\\n                min=ca[i];\\n                minIdx=i;\\n            }\\n        char temp = ca[minIdx];\\n        for (int i = minIdx; i>I; i--) ca[i]=ca[i-1];\\n        ca[I] = temp;\\n        helper(ca, I+1, k-(minIdx-I));\\n    }\\n}\\n```\\n\\nTime : \\u041E(n^2), In the worst case, k will be very large, and it becomes bubble sort.\\n\\nHappy Coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k){\\n        if (k==0 || I==ca.length) return;\\n        int min = ca[I], minIdx = I;\\n        for (int i = I+1; i<Math.min(I+k+1, ca.length); i++)\\n            if (ca[i]<min){\\n                min=ca[i];\\n                minIdx=i;\\n            }\\n        char temp = ca[minIdx];\\n        for (int i = minIdx; i>I; i--) ca[i]=ca[i-1];\\n        ca[I] = temp;\\n        helper(ca, I+1, k-(minIdx-I));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720235,
                "title": "c-o-n-log-n-fenwick-bit-solution-196ms-with-explanation",
                "content": "```\\nclass Solution {\\n    vector<pair<int, int>> resort;\\n    \\n    priority_queue<int, vector<int>, greater<int>> nums[10];\\n    int used[30001];\\n    int n;\\n    int getSum(int index)  {\\n        int sum = 0;\\n        while (index > 0) { \\n            sum += used[index];\\n            index -= index & (-index); \\n        } \\n        return sum; \\n    } \\n    \\n    void updateBIT(int index, int val) \\n    { \\n        while (index <= n) \\n        { \\n        used[index] += val;\\n        index += index & (-index); \\n        } \\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        memset(used, 0, sizeof(used));\\n        \\n        int ctr = 0;\\n        n = num.size();\\n        for (int i = 0; i < n; i++) {\\n            nums[num[i] - \\'0\\'].push(i + 1);\\n        }\\n        string res;\\n        while (ctr < n && k > 0) {\\n            for (int i = 0; i <= 9; i++) {\\n                if (!nums[i].empty()) {\\n                    int cur = nums[i].top();\\n                    \\n                    int holes = getSum(cur - 1);\\n                    int act = cur - holes;\\n                    if (act - 1 <= k) {\\n                        res += (\\'0\\' + i);\\n                        k -= (act - 1);\\n                        updateBIT(cur, 1);\\n                        nums[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            while (!nums[i].empty()) {\\n                resort.emplace_back(nums[i].top(), i);\\n                nums[i].pop();\\n            }\\n        }\\n        \\n        sort(resort.begin(), resort.end());\\n        for (auto &p : resort) {\\n            res += (\\'0\\' + p.second);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# General Idea:\\nWe greedily take the smallest digit in the range of remaining ```k``` from the current index we are filling (start from 1st position) and swap it all the way left to the current index. We make sure that we have the right updated cost to take a digit by using BIT to store how many digits have been taken to the left of that digit. The actual cost of taking that digit to the current index is its position subtracted by how many digits have been taken to the left of this digit.\\n\\nThe remaining digts not taken is then put to the back of the answer string.\\n\\n# Explanation of getting the actual cost of taking a digit and swapping it all the way to the current index:\\nWhen there are no swaps done, the cost of taking a digit and swapping it to the first position is its position (subtracted by 1). Say we take the digit in position ```x``` for the first index. When we move to the next index (2nd position), the cost for all digits in front of  ```x``` (to the left) is still its position (since they were all shifted right during the swapping and their distance from the current index stays the same). However, all digits to the right of ```x``` will cost less (since the current index is closer by 1, but their positions have not changed). \\n\\nThis continues for the rest and the actual cost of taking a digit ```x``` to the current index is its position subtracted by how many digits to the left of ```x``` has been taken. We keep track of this efficiently using the Fenwick tree.\\n\\n# Implementation:\\nIn the code above, I first store the positions for each digit in priority queues (Can be done in a vector and sorted after as well). \\n\\nThen, while I am still taking digits (```ctr < n```) and I still have remaining swaps (```k > 0```), I will look for the smallest affordable digit by looking at each priority queue for each digit, then if the furthest left untaken digit\\'s actual cost is affordable, I will take it and update the Fenwick tree.\\n\\nThe last sorting using ```resort``` empties out the priority queues since they are filled with digits that have not been taken and I will append them to the string according to their positions since their ordering stays the same throughout all the swapping.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<pair<int, int>> resort;\\n    \\n    priority_queue<int, vector<int>, greater<int>> nums[10];\\n    int used[30001];\\n    int n;\\n    int getSum(int index)  {\\n        int sum = 0;\\n        while (index > 0) { \\n            sum += used[index];\\n            index -= index & (-index); \\n        } \\n        return sum; \\n    } \\n    \\n    void updateBIT(int index, int val) \\n    { \\n        while (index <= n) \\n        { \\n        used[index] += val;\\n        index += index & (-index); \\n        } \\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        memset(used, 0, sizeof(used));\\n        \\n        int ctr = 0;\\n        n = num.size();\\n        for (int i = 0; i < n; i++) {\\n            nums[num[i] - \\'0\\'].push(i + 1);\\n        }\\n        string res;\\n        while (ctr < n && k > 0) {\\n            for (int i = 0; i <= 9; i++) {\\n                if (!nums[i].empty()) {\\n                    int cur = nums[i].top();\\n                    \\n                    int holes = getSum(cur - 1);\\n                    int act = cur - holes;\\n                    if (act - 1 <= k) {\\n                        res += (\\'0\\' + i);\\n                        k -= (act - 1);\\n                        updateBIT(cur, 1);\\n                        nums[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            while (!nums[i].empty()) {\\n                resort.emplace_back(nums[i].top(), i);\\n                nums[i].pop();\\n            }\\n        }\\n        \\n        sort(resort.begin(), resort.end());\\n        for (auto &p : resort) {\\n            res += (\\'0\\' + p.second);\\n        }\\n        return res;\\n    }\\n};\\n```\n```k```\n```x```\n```x```\n```x```\n```x```\n```x```\n```ctr < n```\n```k > 0```\n```resort```",
                "codeTag": "Java"
            },
            {
                "id": 720127,
                "title": "python-bytedance-interview-question",
                "content": "**Idea**\\nGreedily select the smallest number we can reach, and push it all the way to the front.\\n\\n**Complexity**\\n- time: O(n^2)\\n- space: O(n)\\n\\n**Python**\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        num = [*map(int, num)]\\n        if k >= (len(num) ** 2) // 2:\\n            return \\'\\'.join(map(str, sorted(num)))\\n        \\n        res = []\\n        q = [(v, i) for i, v in enumerate(num)]\\n        while k and q:\\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\\n            k -= idx\\n            del q[idx]\\n            res += v,\\n            \\n        res += [v for v, _ in q]\\n        return \\'\\'.join(map(str, res))\\n```\\n\\nPlease please don\\'t downvote unless necessary bro.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        num = [*map(int, num)]\\n        if k >= (len(num) ** 2) // 2:\\n            return \\'\\'.join(map(str, sorted(num)))\\n        \\n        res = []\\n        q = [(v, i) for i, v in enumerate(num)]\\n        while k and q:\\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\\n            k -= idx\\n            del q[idx]\\n            res += v,\\n            \\n        res += [v for v, _ in q]\\n        return \\'\\'.join(map(str, res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720487,
                "title": "detailed-c-segment-tree-solution-88ms-might-not-be-optimal",
                "content": "Here is my first post on leetcode. I would like to share my segment tree solution to this problem. My time complexity is **O(nlognlogn)** so it might not be the optimal solution.\\n\\nWell, let us analyze this problem. If we want to construct the mininal number, we need to force the leftmost digit as small as possible. So we can go though the string from left to right, pick the smallest one while the swap operation number does not exceeding the threshold(at first it is **K**). And we do the same operation for the next digit, until we run out our operations.\\n\\nWe can easily find a O(n^2) algorithm following this idea. But it is not YOUXIU (good) enough, we need to optimize it.\\n\\nIn general, we use three steps to pick digits from left to right. \\n\\n1. Calculate the right most index(**1-based**) we can pick in the threshold;\\n2. Pick the smallest one(among smallest ones we choose the left most one), and declare that it has been picked so we can not pick it again;\\n3.  Update the threshold.\\n\\nWe can use Segment Tree. I won\\'t talk about basic knowledge of segment tree(without lazy-tag) in this post, just to show how to use it in this problem.\\n\\nFirst let\\'s talk about the threshold. Threshold here means the largest index that we can pick. We can use the prefix sum to calculate it.\\nFor instance,\\n```\\noriginal string: \"1 2 4 3 5 6 7\", original k = 3;\\nuse/not state:    1 1 1 1 1 1 1 (1: not been used, 0: used);\\nprefix sum:       1 2 3 4 5 6 7 ;\\n```\\nSo the largest index we can pick is 4 = k + 1;\\nAnother instance:\\n```\\noriginal string: \"1 4 2 5 6 7\", k = 2;\\nuse/not state:    0 1 0 1 1 1 (1: not been used, 0: used);\\nprefix sum:       0 1 1 2 3 4; \\n```\\nSo the largest index we can pick is 5 since presum[5] = 3 = k + 1;\\n\\nAt this point, we can design the tree node;\\n```\\ntypedef long long ll;\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n\\t/* minv: min value in [l...r] in the original string;\\n\\t    idx: the index of minv;\\n\\t\\tsum: sum of use/not use in [l...r] period;*/\\n} tree[4*N];\\n```\\nAnd we can write the push_up method carefully.\\n```\\nvoid push_up(Node& a, Node& b, Node & c) {\\n   // Use information from b and c to update Node a, b.idx is always <= c.idx\\n   if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n```\\nWe can use binary search to find the right most idx that we can pick;\\n```\\nint get_idx(int presum, int len) {\\n    // O(lognlogn)\\n    int l = 1;\\n    int r = len;\\n    int res = len; // If we can not find it, we should return the last index\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\\nAfter we pick one, we should declare that this number has been picked and we should not pick it again by setting it to 10 and set the use/not use state to 0 and we should update our threshold. Details are in the code.\\n\\nFull code:\\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        // build the SegTree;\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n\\t\\t\\t// unused digits\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nThe time complexity is O(nlognlogn), space complexity is O(n).\\nThanks for reading.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\noriginal string: \"1 2 4 3 5 6 7\", original k = 3;\\nuse/not state:    1 1 1 1 1 1 1 (1: not been used, 0: used);\\nprefix sum:       1 2 3 4 5 6 7 ;\\n```\n```\\noriginal string: \"1 4 2 5 6 7\", k = 2;\\nuse/not state:    0 1 0 1 1 1 (1: not been used, 0: used);\\nprefix sum:       0 1 1 2 3 4; \\n```\n```\\ntypedef long long ll;\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n\\t/* minv: min value in [l...r] in the original string;\\n\\t    idx: the index of minv;\\n\\t\\tsum: sum of use/not use in [l...r] period;*/\\n} tree[4*N];\\n```\n```\\nvoid push_up(Node& a, Node& b, Node & c) {\\n   // Use information from b and c to update Node a, b.idx is always <= c.idx\\n   if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n```\n```\\nint get_idx(int presum, int len) {\\n    // O(lognlogn)\\n    int l = 1;\\n    int r = len;\\n    int res = len; // If we can not find it, we should return the last index\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        // build the SegTree;\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n\\t\\t\\t// unused digits\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723457,
                "title": "a-simple-c-o-n-solution-100ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.size();\\n        string res;\\n        res.reserve(n);\\n        vector<int> q(10, n);\\n        for (int i = 0; i < n; ++i) {\\n            const int d = num[i] - \\'0\\';\\n            if (q[d] == n)\\n                q[d] = i;\\n        }\\n        vector<bool> used(n);\\n        vector<int> q_used(10);\\n        for (int i = 0; i < n; ++i) {\\n            for (int d = 0; d < 10; ++d) {\\n                if (q[d] == n)\\n                    continue;\\n                const int c = q[d] - q_used[d];\\n                \\n                if (c <= k) {\\n                    k -= c;\\n                    res.push_back(\\'0\\' + d);\\n                    used[q[d]] = true;\\n                    for (int d1 = 0; d1 < 10; ++d1) {\\n                        if (q[d1] > q[d])\\n                            q_used[d1]++;\\n                    }\\n                    while (q[d] < n) {\\n                        if (used[q[d]])\\n                            ++q_used[d];\\n                        if (num[++q[d]] == \\'0\\' + d)\\n                            break;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.size();\\n        string res;\\n        res.reserve(n);\\n        vector<int> q(10, n);\\n        for (int i = 0; i < n; ++i) {\\n            const int d = num[i] - \\'0\\';\\n            if (q[d] == n)\\n                q[d] = i;\\n        }\\n        vector<bool> used(n);\\n        vector<int> q_used(10);\\n        for (int i = 0; i < n; ++i) {\\n            for (int d = 0; d < 10; ++d) {\\n                if (q[d] == n)\\n                    continue;\\n                const int c = q[d] - q_used[d];\\n                \\n                if (c <= k) {\\n                    k -= c;\\n                    res.push_back(\\'0\\' + d);\\n                    used[q[d]] = true;\\n                    for (int d1 = 0; d1 < 10; ++d1) {\\n                        if (q[d1] > q[d])\\n                            q_used[d1]++;\\n                    }\\n                    while (q[d] < n) {\\n                        if (used[q[d]])\\n                            ++q_used[d];\\n                        if (num[++q[d]] == \\'0\\' + d)\\n                            break;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720554,
                "title": "java-27ms-o-nlogn-fenwick-bit-solution",
                "content": "Had the rough idea during the contest but got stuck at how to update INDEX using BIT. Checked @tian-tang-6\\'s answer and this tutorial: https://www.hackerearth.com/practice/data-structures/advanced-data-structures/fenwick-binary-indexed-trees/tutorial/, realized that instead of updating INDEX, we should: \\n1. Initialize BIT with 1 for all indices, which is the character count;\\n2. Update the count to 0 ( count--) when a character at index i is swapped to the beginning.\\n\\n```\\n    public String minInteger(String num, int k) {\\n        char[] cs = num.toCharArray();\\n        int n = cs.length;\\n        StringBuilder sb = new StringBuilder();\\n        IntegerBIT bit = new IntegerBIT(n);\\n        for (int i = 1; i <= n; i++) {\\n            bit.update(i, 1);\\n        }\\n        Deque<Integer>[] dq = new ArrayDeque[10];\\n        for (int i = 0; i < 10; i++) {\\n            dq[i] = new ArrayDeque<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dq[cs[i] - \\'0\\'].offerLast(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                Integer index = dq[j].peekFirst();\\n                if (!dq[j].isEmpty() && bit.query(index) <= k) {\\n                    //number of \\'1\\'s before index is the number of swaps\\n                    k -= bit.query(index);\\n                    //index in string is represented in BIT at index + 1\\n                    bit.update(index + 1, -1);\\n                    dq[j].pollFirst();\\n                    sb.append((char)(\\'0\\' + j));\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public static class IntegerBIT {\\n        int n;\\n        int[] data;\\n\\n        public IntegerBIT(int n) {\\n            this.n = n;\\n            data = new int[n + 1];//1 based\\n        }\\n\\n        /**\\n         * Queries sum of A[1]..A[x] inclusive. A is the underlying array this BIT represents.\\n         */\\n        public int query(int x) {\\n            int sum = 0;\\n            for (; x > 0 ; x -= x & (-x)) {\\n                sum += data[x];\\n            }\\n            return sum;\\n        }\\n\\n        /**\\n         * Queries sum of A[i]..A[j] inclusive\\n         */\\n        public int query(int i, int j) {\\n            return query(i) - query(j - 1);\\n        }\\n\\n        /**\\n         * Updates A[i] by d\\n         */\\n        public void update(int i, int d) {\\n            for (; i <= n; i += i & (-i)) {\\n                data[i] += d;\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\n    public String minInteger(String num, int k) {\\n        char[] cs = num.toCharArray();\\n        int n = cs.length;\\n        StringBuilder sb = new StringBuilder();\\n        IntegerBIT bit = new IntegerBIT(n);\\n        for (int i = 1; i <= n; i++) {\\n            bit.update(i, 1);\\n        }\\n        Deque<Integer>[] dq = new ArrayDeque[10];\\n        for (int i = 0; i < 10; i++) {\\n            dq[i] = new ArrayDeque<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dq[cs[i] - \\'0\\'].offerLast(i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                Integer index = dq[j].peekFirst();\\n                if (!dq[j].isEmpty() && bit.query(index) <= k) {\\n                    //number of \\'1\\'s before index is the number of swaps\\n                    k -= bit.query(index);\\n                    //index in string is represented in BIT at index + 1\\n                    bit.update(index + 1, -1);\\n                    dq[j].pollFirst();\\n                    sb.append((char)(\\'0\\' + j));\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public static class IntegerBIT {\\n        int n;\\n        int[] data;\\n\\n        public IntegerBIT(int n) {\\n            this.n = n;\\n            data = new int[n + 1];//1 based\\n        }\\n\\n        /**\\n         * Queries sum of A[1]..A[x] inclusive. A is the underlying array this BIT represents.\\n         */\\n        public int query(int x) {\\n            int sum = 0;\\n            for (; x > 0 ; x -= x & (-x)) {\\n                sum += data[x];\\n            }\\n            return sum;\\n        }\\n\\n        /**\\n         * Queries sum of A[i]..A[j] inclusive\\n         */\\n        public int query(int i, int j) {\\n            return query(i) - query(j - 1);\\n        }\\n\\n        /**\\n         * Updates A[i] by d\\n         */\\n        public void update(int i, int d) {\\n            for (; i <= n; i += i & (-i)) {\\n                data[i] += d;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720270,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=1wjYXKeGtOc",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=1wjYXKeGtOc",
                "codeTag": "Unknown"
            },
            {
                "id": 720352,
                "title": "c-preprocess-120-ms",
                "content": "The first function is just a greedy brute-force algorithm that checks for the minimal character within K, and bubbles it up.\\n\\nIt\\'s O(n * n) so you will get TLE. I saw folks solved it using logarithmic structures, but all I got is this silly idea.\\n\\nI think that we first need to reduce K. Obviously, if K is large, we would move all zeros, ones, and so on to the front. We can get positions of a given number in one scan, and we do it for each digit `\\'0\\' - \\'9\\'`. Note that we need to quit as soon as the next smallest character cannot be moved to the front, and do brute-force for reduced K.\\n\\n\\n```cpp\\nstring minInteger(string num, int k) {\\n    string pre;\\n    preprocess(pre, num, k);\\n    while (k > 0 && !num.empty()) {\\n        auto pos = 0;\\n        for (auto i = 1; i < num.size() && i <= k; ++i)\\n            if (num[i] < num[pos]) \\n                pos = i;\\n        pre += num[pos];\\n        k -= pos;\\n        num = num.substr(0, pos) + num.substr(pos + 1);\\n    }\\n    return pre + num;\\n}\\nvoid preprocess(string &pre, string &num, int &k) {\\n    for (auto n = \\'0\\'; n < \\'9\\'; ++n) {\\n        vector<int> pos;\\n        for (auto i = 0; i < num.size(); ++i)\\n            if (num[i] == n)\\n                pos.push_back(i);\\n        if (!pos.empty() && k < pos[0])\\n            break;\\n        int cnt = 0;            \\n        for (auto i = 0; i < pos.size() && pos[i] <= k + cnt; ++i) {\\n            k -= pos[i] - cnt;\\n            ++cnt;   \\n        }\\n        pre += string(cnt, n);\\n        string num1;\\n        for (auto ch : num) {\\n            if (ch == n && cnt > 0)\\n                --cnt;\\n            else\\n                num1 += ch;\\n        }\\n        swap(num, num1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstring minInteger(string num, int k) {\\n    string pre;\\n    preprocess(pre, num, k);\\n    while (k > 0 && !num.empty()) {\\n        auto pos = 0;\\n        for (auto i = 1; i < num.size() && i <= k; ++i)\\n            if (num[i] < num[pos]) \\n                pos = i;\\n        pre += num[pos];\\n        k -= pos;\\n        num = num.substr(0, pos) + num.substr(pos + 1);\\n    }\\n    return pre + num;\\n}\\nvoid preprocess(string &pre, string &num, int &k) {\\n    for (auto n = \\'0\\'; n < \\'9\\'; ++n) {\\n        vector<int> pos;\\n        for (auto i = 0; i < num.size(); ++i)\\n            if (num[i] == n)\\n                pos.push_back(i);\\n        if (!pos.empty() && k < pos[0])\\n            break;\\n        int cnt = 0;            \\n        for (auto i = 0; i < pos.size() && pos[i] <= k + cnt; ++i) {\\n            k -= pos[i] - cnt;\\n            ++cnt;   \\n        }\\n        pre += string(cnt, n);\\n        string num1;\\n        for (auto ch : num) {\\n            if (ch == n && cnt > 0)\\n                --cnt;\\n            else\\n                num1 += ch;\\n        }\\n        swap(num, num1);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826459,
                "title": "c-o-nlogn-binary-search-with-logic",
                "content": "\\n```\\n/** <Greedy Approach>\\nWe take 10 queues for digits 0 to 9 and store their occurence(index in the original string) in the queues (clearly all the queues are sorted by default) \\nNow we want the most significant digit to be the smallest so we try all the 0-9 digits at position i .\\nSuppose we want to place any digit j in range [0,9] at a position i we do a binay search on all the 10 queues to find the number of digits \\nwith index smaller than the current chosen digits index then we will check if the swaps are less than or equal to the current k value if yes\\nwe put the current digit in new string and go for the (i+1)th place else we will continue to check for digit j+1 .\\nBelow is the implementation\\n*/\\nint bs(vector<int> &v,int l,int r,int key){\\n\\n        if(l>r) return l;\\n        int mid=l+(r-l)/2;\\n\\n        if(v[mid]>key) return bs(v,l,mid-1,key);\\n        return bs(v,mid+1,r,key);\\n}\\nstring minInteger(string num, int k) {\\n     int n=num.size();\\n\\t //trivial case\\n     if(k>=(n*(n-1))/2){\\n        sort(num.begin(),num.end());\\n        return num;\\n     }\\n\\t //queues\\n     vector<vector<int> >v(10);\\n     for(int i=0;i<n;++i){\\n        v[num[i]-\\'0\\'].push_back(i);\\n     }\\n\\t //head for every queue to store the queue state\\n     vector<int> head(10);\\n     string ans=\"\";\\n      vector<bool> visit(n);\\n     for(int i=0;i<n && k>0;++i){\\n        for(int j=0;j<10;++j){\\n\\n            if(head[j]<v[j].size()){\\n\\n\\t\\t\\t\\t// total count of digits with smaller index than the current chosen digit\\n                int idx=0;\\n\\t\\t\\t\\t//binary search on all the 10 queues\\n                for(int l=0;l<10;++l){\\n                    if(l!=j){\\n                        idx+=bs(v[l],0,head[l]-1,v[j][head[j]]);\\n                    }\\n                    else\\n                        idx+=head[l];\\n                }\\n//                cout<<k<<\" \"<<idx<<\" \"<<j<<\"\\\\n\";\\n                if(k>=(v[j][head[j]]-idx)){\\n\\n                    ans.push_back((char)(j+\\'0\\'));\\n                    visit[v[j][head[j]]]=true;\\n                    k-=(v[j][head[j]]-idx);\\n                    ++head[j];\\n                    break;\\n                }\\n            }\\n        }\\n     }\\n\\t// appending the remaining string\\n     for(int i=0;i<n;++i) if(!visit[i]) ans.push_back(num[i]);\\n    \\n     return ans;\\n\\n}",
                "solutionTags": [],
                "code": "\\n```\\n/** <Greedy Approach>\\nWe take 10 queues for digits 0 to 9 and store their occurence(index in the original string) in the queues (clearly all the queues are sorted by default) \\nNow we want the most significant digit to be the smallest so we try all the 0-9 digits at position i .\\nSuppose we want to place any digit j in range [0,9] at a position i we do a binay search on all the 10 queues to find the number of digits \\nwith index smaller than the current chosen digits index then we will check if the swaps are less than or equal to the current k value if yes\\nwe put the current digit in new string and go for the (i+1)th place else we will continue to check for digit j+1 .\\nBelow is the implementation\\n*/\\nint bs(vector<int> &v,int l,int r,int key){\\n\\n        if(l>r) return l;\\n        int mid=l+(r-l)/2;\\n\\n        if(v[mid]>key) return bs(v,l,mid-1,key);\\n        return bs(v,mid+1,r,key);\\n}\\nstring minInteger(string num, int k) {\\n     int n=num.size();\\n\\t //trivial case\\n     if(k>=(n*(n-1))/2){\\n        sort(num.begin(),num.end());\\n        return num;\\n     }\\n\\t //queues\\n     vector<vector<int> >v(10);\\n     for(int i=0;i<n;++i){\\n        v[num[i]-\\'0\\'].push_back(i);\\n     }\\n\\t //head for every queue to store the queue state\\n     vector<int> head(10);\\n     string ans=\"\";\\n      vector<bool> visit(n);\\n     for(int i=0;i<n && k>0;++i){\\n        for(int j=0;j<10;++j){\\n\\n            if(head[j]<v[j].size()){\\n\\n\\t\\t\\t\\t// total count of digits with smaller index than the current chosen digit\\n                int idx=0;\\n\\t\\t\\t\\t//binary search on all the 10 queues\\n                for(int l=0;l<10;++l){\\n                    if(l!=j){\\n                        idx+=bs(v[l],0,head[l]-1,v[j][head[j]]);\\n                    }\\n                    else\\n                        idx+=head[l];\\n                }\\n//                cout<<k<<\" \"<<idx<<\" \"<<j<<\"\\\\n\";\\n                if(k>=(v[j][head[j]]-idx)){\\n\\n                    ans.push_back((char)(j+\\'0\\'));\\n                    visit[v[j][head[j]]]=true;\\n                    k-=(v[j][head[j]]-idx);\\n                    ++head[j];\\n                    break;\\n                }\\n            }\\n        }\\n     }\\n\\t// appending the remaining string\\n     for(int i=0;i<n;++i) if(!visit[i]) ans.push_back(num[i]);\\n    \\n     return ans;\\n\\n}",
                "codeTag": "C++"
            },
            {
                "id": 721509,
                "title": "python-straight-forward-short-greedy-algorithm",
                "content": "A greedy approach will do the job.\\nIterate the index i from the left to right. Each iteration do a swap in a greedy way, i.e. swap num[i] with the smallest number within num[i+1:]\\n\\n```\\nclass Solution:\\n    \\'\\'\\' greedy approach. start from the left side, \\n\\t    and everytime pick the smallest number on the right side that is able to swap, then do the swap\\n    \\'\\'\\'\\n    def minInteger(self, num: str, k: int) -> str:\\n        min_num = sorted(list(num))\\n        min_num = \\'\\'.join(min_num)\\n        i = 0\\n        to_find = 0\\n        while num != min_num and k > 0 and i < len(num):\\n            indx = num.find(str(to_find), i)\\n            while indx != -1:\\n                if indx - i <= k:   # able to swap\\n                    num = num[:i] + num[indx] + num[i:indx] + num[indx+1:]  # the swap\\n                    k -= (indx - i)\\n                    i += 1\\n                    to_find = 0     # restart the to_find variable\\n                    indx = num.find(str(to_find), i)\\n                else:\\n                    break\\n            to_find += 1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\' greedy approach. start from the left side, \\n\\t    and everytime pick the smallest number on the right side that is able to swap, then do the swap\\n    \\'\\'\\'\\n    def minInteger(self, num: str, k: int) -> str:\\n        min_num = sorted(list(num))\\n        min_num = \\'\\'.join(min_num)\\n        i = 0\\n        to_find = 0\\n        while num != min_num and k > 0 and i < len(num):\\n            indx = num.find(str(to_find), i)\\n            while indx != -1:\\n                if indx - i <= k:   # able to swap\\n                    num = num[:i] + num[indx] + num[i:indx] + num[indx+1:]  # the swap\\n                    k -= (indx - i)\\n                    i += 1\\n                    to_find = 0     # restart the to_find variable\\n                    indx = num.find(str(to_find), i)\\n                else:\\n                    break\\n            to_find += 1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906381,
                "title": "java-treemap-headmap-size-time-complexity-is-not-o-1",
                "content": "I was surprised that no one consider using treemap at first, but found out I didn\\'t quite understand the time complexity of treemap api.\\nImplemente the idea of this [post](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720548/O(n-logn)-or-Detailed-Explanation) using treemap, but got TLE\\n\\nheadMap().size() complexity is O(k) not O(1): https://stackoverflow.com/questions/14750374/what-is-complexity-of-size-for-treeset-portion-view-in-java\\n\\n```\\n  public String minInteger(String num, int k) {\\n    Queue<Integer>[] qArr = new ArrayDeque[10];\\n    char[] arr = num.toCharArray();\\n    int n = num.length();\\n    \\n    for (int d = 0; d < 10; d++) {\\n      qArr[d] = new ArrayDeque<>();\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n      qArr[arr[i] - \\'0\\'].offer(i);\\n    }\\n    TreeSet<Integer> treeSet = new TreeSet<>();\\n    \\n    StringBuilder res = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n      for (int d = 0; d < 10; d++) {\\n        Queue<Integer> q = qArr[d];\\n        if (q.isEmpty()) {\\n          continue;\\n        }\\n        int idx = q.peek();\\n        int numLessOrEqual = treeSet.headSet(idx).size();\\n        int requiredSteps = idx - numLessOrEqual; \\n        if (k >= requiredSteps) {\\n          q.poll();\\n          k -= requiredSteps;\\n          res.append(d);\\n          treeSet.add(idx);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    return res.toString();\\n    \\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String minInteger(String num, int k) {\\n    Queue<Integer>[] qArr = new ArrayDeque[10];\\n    char[] arr = num.toCharArray();\\n    int n = num.length();\\n    \\n    for (int d = 0; d < 10; d++) {\\n      qArr[d] = new ArrayDeque<>();\\n    }\\n    \\n    for (int i = 0; i < n; i++) {\\n      qArr[arr[i] - \\'0\\'].offer(i);\\n    }\\n    TreeSet<Integer> treeSet = new TreeSet<>();\\n    \\n    StringBuilder res = new StringBuilder();\\n    for (int i = 0; i < n; i++) {\\n      for (int d = 0; d < 10; d++) {\\n        Queue<Integer> q = qArr[d];\\n        if (q.isEmpty()) {\\n          continue;\\n        }\\n        int idx = q.peek();\\n        int numLessOrEqual = treeSet.headSet(idx).size();\\n        int requiredSteps = idx - numLessOrEqual; \\n        if (k >= requiredSteps) {\\n          q.poll();\\n          k -= requiredSteps;\\n          res.append(d);\\n          treeSet.add(idx);\\n          break;\\n        }\\n      }\\n    }\\n    \\n    return res.toString();\\n    \\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720229,
                "title": "java-nlogn-binary-tree",
                "content": "* Store indexes of all digits in a list.\\n* Start putting from 0 to 9 whichever satisfy the condition first.\\n* Condition is satisfied if number of swaps remaining (k) >= number of swaps required (val - count) => `k >= val - count`\\n* `val = index of the digit`\\n* ` count = number of elements used before that index`\\n* To find the number of elements used , maintain a Binary Tree with left count.\\n\\n\\n\\n\\n```\\nclass Solution { \\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int val;\\n        int leftcount;\\n        TreeNode(int val){\\n            this.val = val;\\n        }\\n    }\\n    int count;\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Integer> al[] = new ArrayList[10];\\n        for(int i=0;i<10;i++){\\n            al[i] = new ArrayList();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            al[num.charAt(i) - 48].add(i);\\n        }\\n        Set<Integer> hs = new HashSet();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        TreeNode root = null;\\n        while(n-- > 0 && k > 0){\\n            for(int ind=0;ind<10;ind++){\\n                if(al[ind].size() == 0){\\n                    continue ;\\n                }\\n                int val = al[ind].get(al[ind].size()-1);\\n                count = 0;\\n                search(root, val);\\n                if(k >= val - count){\\n                    sb.append(ind);\\n                    root = add(root, val);\\n                    al[ind].remove(al[ind].size()-1);\\n                    hs.add(val);\\n                    k -= val-count;\\n                    break ;\\n                }\\n            }\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(!hs.contains(i)){\\n                sb.append(num.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void search(TreeNode root, int val){\\n        if(root == null){\\n            return ;\\n        }\\n        if(val < root.val){\\n            search(root.left, val);\\n        }else{\\n            count += 1+root.leftcount;\\n            search(root.right, val);\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, int val){\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val < root.val){\\n            root.left = add(root.left, val);\\n            root.leftcount += 1;\\n        }else{\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    class TreeNode{\\n        TreeNode left;\\n        TreeNode right;\\n        int val;\\n        int leftcount;\\n        TreeNode(int val){\\n            this.val = val;\\n        }\\n    }\\n    int count;\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Integer> al[] = new ArrayList[10];\\n        for(int i=0;i<10;i++){\\n            al[i] = new ArrayList();\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            al[num.charAt(i) - 48].add(i);\\n        }\\n        Set<Integer> hs = new HashSet();\\n        StringBuilder sb = new StringBuilder(\"\");\\n        TreeNode root = null;\\n        while(n-- > 0 && k > 0){\\n            for(int ind=0;ind<10;ind++){\\n                if(al[ind].size() == 0){\\n                    continue ;\\n                }\\n                int val = al[ind].get(al[ind].size()-1);\\n                count = 0;\\n                search(root, val);\\n                if(k >= val - count){\\n                    sb.append(ind);\\n                    root = add(root, val);\\n                    al[ind].remove(al[ind].size()-1);\\n                    hs.add(val);\\n                    k -= val-count;\\n                    break ;\\n                }\\n            }\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(!hs.contains(i)){\\n                sb.append(num.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void search(TreeNode root, int val){\\n        if(root == null){\\n            return ;\\n        }\\n        if(val < root.val){\\n            search(root.left, val);\\n        }else{\\n            count += 1+root.leftcount;\\n            search(root.right, val);\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, int val){\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val < root.val){\\n            root.left = add(root.left, val);\\n            root.leftcount += 1;\\n        }else{\\n            root.right = add(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389405,
                "title": "python-3-solutions-with-thought-process-when-being-asked-during-interviews",
                "content": "### Binary Search\\nIn order to construct the minimum number, we want to find the minimum digit within the window of size of *k*, which determine the range of digits that can be moved.\\nThe naive solution I came up first is to find out the minimum digit adhoc, which takes many unnecessary comparision. Because the digit is limited from 0 to 9, we can iterate from 0 to 9 to pick the first digit that is within the window. \\nThe key point is that the index of digits after the moved one have to be updated accordingly after moving. For example, `4203 => 0423`, the index of `3` changed from `3` to `2` since we won\\'t consider `0` by excluding it. In another word, the *num* bacomes `423`. However, all digits before `0` are not changed. \\nSo each time we get the index of digit from 0 to 9, we have to update it with the *offset* that is the number of moved digits that appear before it.\\nSo we can use binary search to find the number of moved indices that is smaller than each index we want to pick. If the `index - offset <= k`, we can pick that digit and move on to next digit.\\nOne improvement is that we can quickly return the sorted *num* if *k* is larger than *n^2* since the complexity is O(N^2) for sorting algorithm based on comparision. Then we can append each digit from 0 to 9 instead of actual sorting it, which takes linear time.\\n\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[int(c)].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\tused = []\\n    for _ in range(n):\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = bisect.bisect_left(used, index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    used.insert(offset, counter[i].popleft())\\n                    break\\n\\treturn \\'\\'.join(map(str, res))\\n```\\nNote, since `insert` takes linear time, the complexity is actual N^2, while it\\'d be NlgN if you use SortedList or Binary Search Tree.\\n\\n*Time Complexity* = **O(NlgN)**\\n*Space Complexity* =**O(N)**\\n\\n### Binary Indexed Tree\\nThe idea is the same, but with a different data structure, binary indexed tree, to query the number of indices of moved digits that is smaller than current index. Binary Indexed Tree is more balanced natually than binary search tree written by manually. \\nActually, BIT is quite easy to wirte and use if you are familiar with the template of BIT.\\n\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# bit template, will always be the same when you use it\\n\\tbit = [0] * (n + 1)\\n    def query(i):\\n\\t\\ttotal = 0\\n        while i:\\n\\t\\t\\ttotal += bit[i]\\n            i -= i & -i\\n\\t\\treturn total\\n        \\n\\tdef update(i, value):\\n\\t\\twhile i < len(bit):\\n\\t\\t\\tbit[i] += value\\n\\t\\t\\ti += i & -i\\n\\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\\n\\n### Segment Tree\\nSame idea with different data structure, the only difference between Segment Tree and Binary Indexed Tree here is Segement Tree is more flexible supporting customized merge function, such as range minimum/maximum/sum, while BIT supports limited functions, most of cases is sum. for this problem, both works.\\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# segment tree template, modify for use cases\\n\\theight = ceil(log(n, 2))\\n    leaf = 2 ** height - 1\\n    st = [0] * (2 ** (height + 1) - 1)\\n        \\n    def query(i, j):\\n\\t\\ti, j = i + leaf, j + leaf\\n        total = 0\\n        while i <= j:\\n\\t\\t\\tif not i % 2:\\n\\t\\t\\t\\ttotal += st[i]\\n                i += 1\\n\\t\\t\\tif j % 2:\\n\\t\\t\\t\\ttotal += st[j]\\n                j -= 1\\n\\t\\t\\ti = (i - 1) // 2\\n            j = j // 2 - 1 \\n\\t\\treturn total\\n                    \\n\\tdef update(i, value):\\n\\t\\ti += leaf\\n        while i >= 0:\\n\\t\\t\\tst[i] += value\\n            if i % 2:\\n\\t\\t\\t\\ti = (i - 1) // 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti = i // 2 - 1\\n             \\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[int(c)].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\tused = []\\n    for _ in range(n):\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = bisect.bisect_left(used, index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    used.insert(offset, counter[i].popleft())\\n                    break\\n\\treturn \\'\\'.join(map(str, res))\\n```\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# bit template, will always be the same when you use it\\n\\tbit = [0] * (n + 1)\\n    def query(i):\\n\\t\\ttotal = 0\\n        while i:\\n\\t\\t\\ttotal += bit[i]\\n            i -= i & -i\\n\\t\\treturn total\\n        \\n\\tdef update(i, value):\\n\\t\\twhile i < len(bit):\\n\\t\\t\\tbit[i] += value\\n\\t\\t\\ti += i & -i\\n\\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```\n```python\\ndef minInteger(self, num: str, k: int) -> str:\\n\\tn = len(num)\\n    num = list(num)\\n    res = []\\n\\n    counter = defaultdict(deque)\\n    for i, c in enumerate(num):\\n\\t\\tcounter[c].append(i)\\n\\tif k >= n**2:\\n\\t\\treturn \\'\\'.join(sorted(num))\\n\\n\\t# segment tree template, modify for use cases\\n\\theight = ceil(log(n, 2))\\n    leaf = 2 ** height - 1\\n    st = [0] * (2 ** (height + 1) - 1)\\n        \\n    def query(i, j):\\n\\t\\ti, j = i + leaf, j + leaf\\n        total = 0\\n        while i <= j:\\n\\t\\t\\tif not i % 2:\\n\\t\\t\\t\\ttotal += st[i]\\n                i += 1\\n\\t\\t\\tif j % 2:\\n\\t\\t\\t\\ttotal += st[j]\\n                j -= 1\\n\\t\\t\\ti = (i - 1) // 2\\n            j = j // 2 - 1 \\n\\t\\treturn total\\n                    \\n\\tdef update(i, value):\\n\\t\\ti += leaf\\n        while i >= 0:\\n\\t\\t\\tst[i] += value\\n            if i % 2:\\n\\t\\t\\t\\ti = (i - 1) // 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\ti = i // 2 - 1\\n             \\n\\tfor _ in range(n):\\n\\t\\tfor i in \\'0123456789\\':\\n\\t\\t\\tif counter[i]:\\n\\t\\t\\t\\tindex = counter[i][0]\\n                offset = query(index)\\n                if index - offset <= k:\\n\\t\\t\\t\\t\\tk -= index - offset\\n                    res.append(i)\\n                    counter[i].popleft()\\n                    update(index + 1, 1)\\n                    break\\n\\treturn \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 735476,
                "title": "python-o-n-10-deques-with-1-stack",
                "content": "# Idea\\n\\nThe first digit of the output should be the minimum of the first `k + 1` digits in `num`, i.e., `min(num[:k+1])`. Similarly, the `i`-th digit of the output should be `min(num[i:i+k+1])`, where we assume\\n* The digits of `num` are swapped in-place. That is, `num[:i]` are already the first `i` digits of the output.\\n* `k` is the remaining number of moves, which decreases as more and more digits are swapped.\\n\\nIf we swap digits one by one, we will end up with a `O(n^2)` algorithm because there will be a maximum of `O(n^2)` swaps needed. Therefore, we need a more efficient way to swap the digits.\\n\\nInstead of actually swapping *adjacent* digits, assume we store all the digits of interest (`num[i:i+k+1]`) as a **sequence** in a data structure `D`, which supports the following 4 operations:\\n1. `push(x)`: Push `x` to the end of `D`.\\n2. `pop()`: Pop the last element of `D`.\\n3. `pop_min()`: Pop the minimum digit in `D`. If there are multiple ones, return the first one.\\n4. `get_min_position()`: Get the position of the minimum digit in `D`. Here the *position* is the 0-based index in the sequence.\\n\\nThen, we can solve the problem this way.\\n\\n```py\\ndef minInteger(self, num: str, k: int) -> str:\\n    data = D()   # Empty sequence\\n    output = \\'\\'  # Output string\\n    for i in range(len(num)):\\n\\t    # Make sure data contains the (k + 1) digits of interest\\n\\t    while data.count < k + 1:\\n\\t\\t    x = next_digit_in_num()\\n\\t\\t    data.push(x)\\n\\t\\twhile data.count > k + 1:\\n\\t\\t    data.pop()\\n\\t\\t# data.get_min_position() is the number of swaps to move the minimum digit to\\n\\t\\t# the desired position (output[i])\\n\\t\\tk -= data.get_min_position()\\n\\t\\t# Find the minimum number in data\\n\\t\\tx = data.pop_min()\\n\\t\\t# x is the i-th digit of output\\n\\t\\toutput += x\\n\\treturn output\\n```\\n\\nBy `next_digit_in_num()`, we mean to find the first digit in `num` which is neither in `output` nor `data`.\\n\\n# Achieving O(n)\\n\\nThe remaining question is how to implement `D` efficiently. It\\'s easier to explain with an example. Suppose in some iteration `data` contains `[1, 0, 2, 1, 0]`. We store 2 attributes for each element `x` in `data`:\\n* `x.index`: The index of `x` in the input string `num`.\\n* `x.moves`: The number of elements preceding `x` in `data` that are **greater than** `x`. It will become clear later why this is called *moves*.\\n\\nSince there are only 10 possible digits (`0` to `9`), we can store these elements in 10 lists, one per digit:\\n```py\\n# The tuples stand for (index, moves)\\ndigits[0] = [(1, 1), (4, 3)]\\ndigits[1] = [(0, 0), (3, 1)]\\ndigits[2] = [(2, 0)]\\n...\\n```\\n\\nThis way, all the 4 operations of `D` can be done in `O(1)` time.\\n1. `push(x)`: To calculate `x.moves`, we only need to count the total number of elements in `digits[x+1]`, ..., `digits[9]`. Then, simply append `x` as well as its index to `digits[x]`.\\n2. `pop()`: Compare the last element of `digits[x]` for `x in range(10)` and pop the one with minimum index.\\n3. `pop_min()`: Find the minimum `x` with non-empty `digits[x]` and remove the first element of `digits[x]`. **Note that we don\\'t need to update any `moves` attributes of the remaining elements in `data`**, because all the elements after `x` should be greater than or equal to `x`.\\n4. `get_min_position()`: Find the minimum `x` with non-empty `digits[x]`, and return `x.moves`. **`x.moves` will be exactly its position in the sequence** because all the elements preceding `x` should be greater than `x`. In other words, `x.moves` is the **number of moves** required to swap `x` all the way to the front of the sequence.\\n\\n# Complete code\\n\\n```py\\nfrom collections import deque, namedtuple\\n\\nDigit = namedtuple(\\'Digit\\', [\\'index\\', \\'moves\\'])\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        remain_num = [(i, ord(x) - ord(\\'0\\')) for i, x in enumerate(num)][::-1]\\n        digits = [deque() for _ in range(10)]\\n        count = 0   # Number of elements in digits\\n        output = []\\n        for _ in range(n):\\n            # Ensure digits has (k + 1) elements (unless insufficient)\\n            while remain_num and count < k + 1:\\n                index, x = remain_num.pop()\\n                # moves: Number of elements before x that are greater than x\\n                moves = sum(map(len, digits[x+1:]))    \\n                digits[x].append(Digit(index, moves))\\n                count += 1\\n            while count > k + 1:\\n                # Find digit with maximum index\\n                d = max((digit[-1], i) for i, digit in enumerate(digits) if digit)[1]\\n                x = digits[d].pop()\\n                remain_num.append((x.index, d))\\n                count -= 1\\n            # Find the minimum element in the list\\n            d = min(i for i, digit in enumerate(digits) if digit)\\n            x = digits[d].popleft()\\n            count -= 1\\n            k -= x.moves\\n            output.append(d)\\n        return \\'\\'.join(chr(ord(\\'0\\') + d) for d in output)\\n```\\n\\n# Analysis of time complexity\\n\\nLet `r1[i]` and `r2[i]` be the number of iterations of the first and second while loop, in the `i`-th iteration of the for loop. We will show that `sum(r1) + sum(r2) = O(n)`, where `n` is the length of the input string `num`.\\n\\nIn the first iteration of the for loop (`i = 0`), since `k >= 1`, `r1[0] = k + 1` and `r2[0] = 0`.\\n\\nTo find the upper bound of `r1[i]` and `r2[i]` for `i > 0`, we need to define some terms first. Let `T0[i]` be the moment right before entering the `i`-th iteration of the for loop, and `T1[i]` be the moment at the end of the `i`-th iteration. We use `k[i]` to denote the value of `k` in the code at `T0[i]`, and similarly `count[i]` for the value of `count` at `T0[i]`.\\n\\nNow assume `i > 0`. Observe that if `count[i] <= k[i] - 1`, then `count` must be no greater than `k` *right before `digits[d].popleft()` is called in the previous iteration*, which means that `remain_num` must be empty in previous iteration, and hence in `T0[i]`. This observation shows that we either have `count[i] >= k[i]` or `remain_num` is empty in `T0[i]`, which proves that `r1[i] <= 1` for all `i > 0`. Therefore, `sum(r1) <= n`.\\n\\nIn `T1[i-1]`, it\\'s clear that `count <= k` (because of the `count -= 1`), which is equivalent to `count[i] <= k[i-1]`. As a result,\\n```py\\n(*)  r2[i] <= count - (k[i] + 1)\\n           <= k[i-1] - (k[i] + 1)\\n```\\n\\nNow we claim that `sum(r2) <= 2n`. Let `j` be the minimum `i` with `k[i] < n - 1`. If such `i` doesn\\'t exist, then `r2[i] = 0` for all `i > 0` (because `count` is always at most `n`) and we\\'re done. Otherwise, by `(*)`,\\n```py\\nsum(r2[j+1:n]) <= k[j] - k[n-1] - 1 <= k[j] <= n\\n```\\nCombining all the results,\\n```py\\nsum(r2) = r2[0] + sum(r2[0:j]) + r2[j] + sum(r2[j+1:n])\\n        = r2[j] + sum(r2[j+1:n])\\n        <= n + n\\n```\\nwhich proves the claim.",
                "solutionTags": [],
                "code": "```py\\ndef minInteger(self, num: str, k: int) -> str:\\n    data = D()   # Empty sequence\\n    output = \\'\\'  # Output string\\n    for i in range(len(num)):\\n\\t    # Make sure data contains the (k + 1) digits of interest\\n\\t    while data.count < k + 1:\\n\\t\\t    x = next_digit_in_num()\\n\\t\\t    data.push(x)\\n\\t\\twhile data.count > k + 1:\\n\\t\\t    data.pop()\\n\\t\\t# data.get_min_position() is the number of swaps to move the minimum digit to\\n\\t\\t# the desired position (output[i])\\n\\t\\tk -= data.get_min_position()\\n\\t\\t# Find the minimum number in data\\n\\t\\tx = data.pop_min()\\n\\t\\t# x is the i-th digit of output\\n\\t\\toutput += x\\n\\treturn output\\n```\n```py\\n# The tuples stand for (index, moves)\\ndigits[0] = [(1, 1), (4, 3)]\\ndigits[1] = [(0, 0), (3, 1)]\\ndigits[2] = [(2, 0)]\\n...\\n```\n```py\\nfrom collections import deque, namedtuple\\n\\nDigit = namedtuple(\\'Digit\\', [\\'index\\', \\'moves\\'])\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        remain_num = [(i, ord(x) - ord(\\'0\\')) for i, x in enumerate(num)][::-1]\\n        digits = [deque() for _ in range(10)]\\n        count = 0   # Number of elements in digits\\n        output = []\\n        for _ in range(n):\\n            # Ensure digits has (k + 1) elements (unless insufficient)\\n            while remain_num and count < k + 1:\\n                index, x = remain_num.pop()\\n                # moves: Number of elements before x that are greater than x\\n                moves = sum(map(len, digits[x+1:]))    \\n                digits[x].append(Digit(index, moves))\\n                count += 1\\n            while count > k + 1:\\n                # Find digit with maximum index\\n                d = max((digit[-1], i) for i, digit in enumerate(digits) if digit)[1]\\n                x = digits[d].pop()\\n                remain_num.append((x.index, d))\\n                count -= 1\\n            # Find the minimum element in the list\\n            d = min(i for i, digit in enumerate(digits) if digit)\\n            x = digits[d].popleft()\\n            count -= 1\\n            k -= x.moves\\n            output.append(d)\\n        return \\'\\'.join(chr(ord(\\'0\\') + d) for d in output)\\n```\n```py\\n(*)  r2[i] <= count - (k[i] + 1)\\n           <= k[i-1] - (k[i] + 1)\\n```\n```py\\nsum(r2[j+1:n]) <= k[j] - k[n-1] - 1 <= k[j] <= n\\n```\n```py\\nsum(r2) = r2[0] + sum(r2[0:j]) + r2[j] + sum(r2[j+1:n])\\n        = r2[j] + sum(r2[j+1:n])\\n        <= n + n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720783,
                "title": "java-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        int[] nums = new int[n];\\n        for(int i = 0; i < n; i++) nums[i] = Character.getNumericValue(num.charAt(i));\\n        helper(nums, k);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(nums[i] + \"\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[] nums, int k) {\\n        int n = nums.length;\\n        for(int i = 0; i < n && k > 0; i++) {\\n            int index = i;\\n            for(int j = i + 1; j < n; j++) {\\n                if(k < j - i) break;\\n                if(nums[j] < nums[index]) {\\n                    index = j;\\n                }\\n            }\\n            for(int j = index; j > i; j--) {\\n                swap(nums, j, j - 1);\\n            }\\n            k -= (index - i);\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int a, int b) {\\n        int tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```\\n\\nThe essence lies within the helper function. The idea is to get the smallest digit to the front as best as it could (withing k_curr steps).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        int[] nums = new int[n];\\n        for(int i = 0; i < n; i++) nums[i] = Character.getNumericValue(num.charAt(i));\\n        helper(nums, k);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(nums[i] + \"\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void helper(int[] nums, int k) {\\n        int n = nums.length;\\n        for(int i = 0; i < n && k > 0; i++) {\\n            int index = i;\\n            for(int j = i + 1; j < n; j++) {\\n                if(k < j - i) break;\\n                if(nums[j] < nums[index]) {\\n                    index = j;\\n                }\\n            }\\n            for(int j = index; j > i; j--) {\\n                swap(nums, j, j - 1);\\n            }\\n            k -= (index - i);\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int a, int b) {\\n        int tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720572,
                "title": "c-o-nlogn-solution-using-segment-tree",
                "content": "I applied the greedy approach where I will move the smallest possible digit to the leftmost unfixed position. Instead of updating all the ununsed indices to the left, I used a segement tree to find the number of digits on the right side of each digit which crossed over the current digit and go left. This brought down the complexity to O(nlogn).\\n    \\n    void update_seg_tree(vector<int>& seg_tree,int idx,int sidx,int ssrt, int send)\\n    {\\n        if(idx<ssrt or idx>send)    return;\\n        \\n        if(ssrt==send)\\n        {\\n            seg_tree[sidx]=1;\\n            return;\\n        }\\n        \\n        int smid=(ssrt+send)/2;\\n        update_seg_tree(seg_tree,idx,2*sidx+1,ssrt,smid);\\n        update_seg_tree(seg_tree,idx,2*sidx+2,smid+1,send);\\n        \\n        seg_tree[sidx]=seg_tree[2*sidx+1]+seg_tree[2*sidx+2];\\n    }\\n    \\n    int calcte_seg_tree(vector<int>& seg_tree,int srt,int end,int sidx,int ssrt, int send)\\n    {\\n        if(end<ssrt or srt>send)        return 0;\\n        \\n        if(ssrt>=srt and send<=end)     return seg_tree[sidx];\\n        \\n        int smid=(ssrt+send)/2;\\n        int left = calcte_seg_tree(seg_tree,srt,end,2*sidx+1,ssrt,smid);\\n        int rigt = calcte_seg_tree(seg_tree,srt,end,2*sidx+2,smid+1,send);\\n        \\n        return left+rigt;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        \\n        //Calculating the height of the segment tree(starting from 0)\\n        int height=0;\\n        \\n        int p=n-1;\\n        while(p)\\n        {\\n            p/=2;\\n            height++;\\n        }\\n        \\n        //For a tree of height h, the total number of nodes till height h is 2*(2^h)-1\\n        vector<int> seg_tree(2*(1<<height)-1,0);\\n        \\n        list<int> lst[10];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lst[num[i]-\\'0\\'].push_back(i);\\n        }\\n        \\n        string ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int digit=-1;\\n            int kminus=0;\\n            for(int j=0;j<10;j++)\\n            {\\n                if(!lst[j].empty())\\n                {\\n                    int pos=lst[j].front();\\n                    int right_shift=calcte_seg_tree(seg_tree,pos,n-1,0,0,n-1);\\n                    \\n                    if(pos+right_shift-i<=k)\\n                    {\\n                        kminus=pos+right_shift-i;\\n                        digit=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(\\'0\\'+digit);\\n            \\n            update_seg_tree(seg_tree,lst[digit].front(),0,0,n-1);\\n            \\n            k-=kminus;\\n            \\n            lst[digit].pop_front();\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "I applied the greedy approach where I will move the smallest possible digit to the leftmost unfixed position. Instead of updating all the ununsed indices to the left, I used a segement tree to find the number of digits on the right side of each digit which crossed over the current digit and go left. This brought down the complexity to O(nlogn).\\n    \\n    void update_seg_tree(vector<int>& seg_tree,int idx,int sidx,int ssrt, int send)\\n    {\\n        if(idx<ssrt or idx>send)    return;\\n        \\n        if(ssrt==send)\\n        {\\n            seg_tree[sidx]=1;\\n            return;\\n        }\\n        \\n        int smid=(ssrt+send)/2;\\n        update_seg_tree(seg_tree,idx,2*sidx+1,ssrt,smid);\\n        update_seg_tree(seg_tree,idx,2*sidx+2,smid+1,send);\\n        \\n        seg_tree[sidx]=seg_tree[2*sidx+1]+seg_tree[2*sidx+2];\\n    }\\n    \\n    int calcte_seg_tree(vector<int>& seg_tree,int srt,int end,int sidx,int ssrt, int send)\\n    {\\n        if(end<ssrt or srt>send)        return 0;\\n        \\n        if(ssrt>=srt and send<=end)     return seg_tree[sidx];\\n        \\n        int smid=(ssrt+send)/2;\\n        int left = calcte_seg_tree(seg_tree,srt,end,2*sidx+1,ssrt,smid);\\n        int rigt = calcte_seg_tree(seg_tree,srt,end,2*sidx+2,smid+1,send);\\n        \\n        return left+rigt;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        \\n        //Calculating the height of the segment tree(starting from 0)\\n        int height=0;\\n        \\n        int p=n-1;\\n        while(p)\\n        {\\n            p/=2;\\n            height++;\\n        }\\n        \\n        //For a tree of height h, the total number of nodes till height h is 2*(2^h)-1\\n        vector<int> seg_tree(2*(1<<height)-1,0);\\n        \\n        list<int> lst[10];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            lst[num[i]-\\'0\\'].push_back(i);\\n        }\\n        \\n        string ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int digit=-1;\\n            int kminus=0;\\n            for(int j=0;j<10;j++)\\n            {\\n                if(!lst[j].empty())\\n                {\\n                    int pos=lst[j].front();\\n                    int right_shift=calcte_seg_tree(seg_tree,pos,n-1,0,0,n-1);\\n                    \\n                    if(pos+right_shift-i<=k)\\n                    {\\n                        kminus=pos+right_shift-i;\\n                        digit=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(\\'0\\'+digit);\\n            \\n            update_seg_tree(seg_tree,lst[digit].front(),0,0,n-1);\\n            \\n            k-=kminus;\\n            \\n            lst[digit].pop_front();\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 720157,
                "title": "javascript-specific-bubble-sorting-problem-with-limited-steps-k",
                "content": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {string}\\n \\n Idea is based on bubble sorting with limited steps k\\n \\n */\\n\\nvar minInteger = function(num, k) {\\n    if (num.length == 1)\\n        return num;\\n    \\n    let nums = num.split(\\'\\');\\n    let i = 0, j = 0;\\n    \\n    while (k && i < num.length-1) {\\n//         step 0: if leading zero, check the next digit\\n        if (nums[i] == \\'0\\') {\\n            i++;\\n            j++;\\n            continue;\\n        }\\n        \\n//         step 1: find the min digit \\n        let p = j, steps = 0;\\n        while (nums[p] !== \\'0\\' && j < nums.length && steps <= k) {\\n            if (nums[j] < nums[p])\\n                p = j;\\n            j++;\\n            steps++;\\n        }\\n        \\n//         step 2: nums[i] is the current minimum digit --> check next digit\\n        if (p == i) {\\n            i++;\\n            j = i;\\n            continue;\\n        }\\n            \\n//          step 3: move the min digit to i\\n        for (; p > i; p--) {\\n            [nums[p], nums[p-1]] = [nums[p-1], nums[p]];\\n            k--;\\n        }\\n        \\n        i++;\\n        j = i;\\n        \\n    }\\n    \\n    return nums.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {string}\\n \\n Idea is based on bubble sorting with limited steps k\\n \\n */\\n\\nvar minInteger = function(num, k) {\\n    if (num.length == 1)\\n        return num;\\n    \\n    let nums = num.split(\\'\\');\\n    let i = 0, j = 0;\\n    \\n    while (k && i < num.length-1) {\\n//         step 0: if leading zero, check the next digit\\n        if (nums[i] == \\'0\\') {\\n            i++;\\n            j++;\\n            continue;\\n        }\\n        \\n//         step 1: find the min digit \\n        let p = j, steps = 0;\\n        while (nums[p] !== \\'0\\' && j < nums.length && steps <= k) {\\n            if (nums[j] < nums[p])\\n                p = j;\\n            j++;\\n            steps++;\\n        }\\n        \\n//         step 2: nums[i] is the current minimum digit --> check next digit\\n        if (p == i) {\\n            i++;\\n            j = i;\\n            continue;\\n        }\\n            \\n//          step 3: move the min digit to i\\n        for (; p > i; p--) {\\n            [nums[p], nums[p-1]] = [nums[p-1], nums[p]];\\n            k--;\\n        }\\n        \\n        i++;\\n        j = i;\\n        \\n    }\\n    \\n    return nums.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720149,
                "title": "concise-javascript-solution",
                "content": "```\\nvar minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInteger = function(num, k) {\\n    var arr = num.split(\"\");\\n    var n = arr.length;\\n\\t\\tfor (var i = 0; i < n-1 && k > 0; ++i) \\n        {\\n            var pos = i; \\n            for (var j = i+1; j < n ; ++j) \\n            {\\n                if (j - i > k) \\n                    break; \\n       \\n                if (arr[j] < arr[pos]) \\n                    pos = j; \\n            }\\n            var temp;\\n            for (var j = pos; j>i; --j) \\n            { \\n                temp=arr[j]; \\n                arr[j]=arr[j-1]; \\n                arr[j-1]=temp; \\n            }\\n            k -= pos-i; \\n        }\\n    return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871251,
                "title": "easy-cpp-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string a, int k) {\\n        int n=a.length();\\n        int req=(n+1)*n/2;       // upper limit for the number of swaps that is also less than 10^9 lowering our time complexity\\n        if(k>req){                    // that means we can try all swaps so returning minimum of all these by sorting \\n            sort(a.begin(),a.end());   \\n            return a;\\n        }\\n        for(int i=0;i<n-1 && k>0;i++){\\n            //iterate in a window of size k \\n            int pos=i;\\n            int j;\\n            for(j=i+1;j<n;j++){\\n                //out of window bound\\n                if(j-i>k){break;}\\n                //else if we actually wanna swap, we do\\n                if(a[j]<a[pos]){pos=j;}\\n            }\\n            //now assuming we swapped we have pos=j\\n            char temp;\\n            for(j=pos;j>i;j--){\\n                //we are swapping a[j] and a[j-1] finally we will have a[pos] swapped with a[i]\\n                temp=a[j];\\n                a[j]=a[j-1];\\n                a[j-1]=temp;\\n            }\\n            //now update k value and do over if we wanna change the second most significant element to\\n            k-=pos-i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string a, int k) {\\n        int n=a.length();\\n        int req=(n+1)*n/2;       // upper limit for the number of swaps that is also less than 10^9 lowering our time complexity\\n        if(k>req){                    // that means we can try all swaps so returning minimum of all these by sorting \\n            sort(a.begin(),a.end());   \\n            return a;\\n        }\\n        for(int i=0;i<n-1 && k>0;i++){\\n            //iterate in a window of size k \\n            int pos=i;\\n            int j;\\n            for(j=i+1;j<n;j++){\\n                //out of window bound\\n                if(j-i>k){break;}\\n                //else if we actually wanna swap, we do\\n                if(a[j]<a[pos]){pos=j;}\\n            }\\n            //now assuming we swapped we have pos=j\\n            char temp;\\n            for(j=pos;j>i;j--){\\n                //we are swapping a[j] and a[j-1] finally we will have a[pos] swapped with a[i]\\n                temp=a[j];\\n                a[j]=a[j-1];\\n                a[j-1]=temp;\\n            }\\n            //now update k value and do over if we wanna change the second most significant element to\\n            k-=pos-i;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398914,
                "title": "segment-tree-and-queue",
                "content": "\\tclass SegmentTree {\\n\\t\\tpublic:\\n\\t\\tvector<int> arr;\\n\\t\\tint n;\\n\\t\\tSegmentTree(int n) {\\n\\t\\t\\tthis->n=n;\\n\\t\\t\\tarr = vector<int>(4*n);\\n\\t\\t}\\n\\t\\tvoid add(int i) {\\n\\t\\t\\taddUtil(0,n-1,i,0);\\n\\t\\t}\\n\\n\\t\\tint addUtil(int l, int r, int ind, int node) {\\n\\t\\t\\tif(l == r && l == ind){\\n\\t\\t\\t\\tarr[node]++;\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\t}\\n\\t\\t\\tif(ind < l || ind > r)\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\tint m = l + (r-l)/2;\\n\\t\\t\\tint le = addUtil(l,m,ind,2*node+1);\\n\\t\\t\\tint ri = addUtil(m+1,r,ind,2*node+2);\\n\\t\\t\\tarr[node] = le+ri;\\n\\t\\t\\treturn arr[node];\\n\\t\\t}\\n\\n\\t\\tint getSum(int ql, int qr, int l, int r, int node) {\\n\\t\\t\\tif(l >= ql && r <= qr)\\n\\t\\t\\t\\treturn arr[node];\\n\\t\\t\\tif(r < ql || l > qr)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\tint m = l + (r-l)/2;\\n\\t\\t\\treturn arr[node] = getSum(ql,qr,l,m,2*node+1) + getSum(ql,qr,m+1,r,2*node+2);\\n\\t\\t}\\n\\t};\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tvector<queue<int>> arr(10);\\n\\t\\t\\tSegmentTree *tree = new SegmentTree(n);\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[num[i]-\\'0\\'].push(i);\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i = 0; i < num.size(); i++) {\\n\\t\\t\\t\\tfor(int digit = 0; digit <= 9; digit++) {\\n\\t\\t\\t\\t\\tif(arr[digit].size() != 0) {\\n\\t\\t\\t\\t\\t\\tint pos = arr[digit].front();\\n\\t\\t\\t\\t\\t\\tint shift = tree->getSum(0,pos,0,n,0);\\n\\t\\t\\t\\t\\t\\tif(pos-shift <= k) {\\n\\t\\t\\t\\t\\t\\t\\tk -= pos-shift;\\n\\t\\t\\t\\t\\t\\t\\ttree->add(pos);\\n\\t\\t\\t\\t\\t\\t\\tarr[digit].pop();\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(digit+\\'0\\');\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring minInteger(string num, int k) {\\n\\t\\t\\tint n = num.size();\\n\\t\\t\\tvector<queue<int>> arr(10);\\n\\t\\t\\tSegmentTree *tree = new SegmentTree(n);\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tarr[num[i]-\\'0\\'].push(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1639812,
                "title": "c-time-o-n-space-o-n",
                "content": "// The solution is base on:\\n// 1) position queue for each digit\\n// 2) The entries that removed before the first psition for each digit\\n// 3) The next digit to add to the return string is the lowest digit which the position minus removed entries not greater than k;\\n// 4) Update return string; ( time n)\\n// 5) Update removed entries for each digit; (time 10xn)\\n// 6) calculate the removed entries for the entry that moved to queue front (for the digit that added to return string); (time nx10)\\n//  Return to (3)\\n// Time complexity ~n*22 which is O(n)\\n```\\ntemplate <class T>\\nclass simple_queue    \\n{\\n    int out_ix;\\n    vector<T> q;\\npublic:\\n    simple_queue() : out_ix(0) {}\\n    ~simple_queue()  { /* delete [] q;*/ }\\n    void push(T t)   { q.push_back(t);  }\\n    T    pop(void)   { return q[out_ix++]; }\\n    T    front(void) { return q[out_ix]; }\\n    bool empty(void) { return (out_ix == q.size());}\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        ans[n] = \\'\\\\0\\';\\n        int i = 0;\\n        int first = 0;\\n        int start = 0;\\n        bool found = true;\\n        vector<simple_queue<int>> pos(10);\\n        vector<int> first_pos_sub(10,0);\\n\\n        for(int j=0; j<n; j++)\\n            pos[num[j]-\\'0\\'].push(j);\\n        \\n        while (found == true && i<n)\\n        {\\n            found = false;\\n            while(first<=9 && pos[first].empty())  first++;  \\n            for (int d = first; d<=9 && !found; d++)\\n            {\\n                while (!pos[d].empty() && pos[d].front()  - first_pos_sub[d]  <= k)\\n                {\\n                    // cout << d << \", \" << k << \", \" << pos[d].front()- first_pos_sub[d] << endl;\\n                    found = true;\\n                    int p = pos[d].pop();\\n                    k -= (p -first_pos_sub[d]);\\n                    ans[i++] = \\'0\\'+d;\\n                    for (int d1 = first; d1<=9; d1++)\\n                    {\\n                        if (!pos[d1].empty() && pos[d1].front() > p) first_pos_sub[d1]++;\\n                    }\\n                    num[p] = \\'-\\';\\n                    if (!pos[d].empty())\\n                    {\\n                        for (int j=p+1; j<pos[d].front(); j++)\\n                        {\\n                            if (num[j] == \\'-\\') first_pos_sub[d]++;\\n                        }\\n                    }\\n\\n                    if (d != first) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate <class T>\\nclass simple_queue    \\n{\\n    int out_ix;\\n    vector<T> q;\\npublic:\\n    simple_queue() : out_ix(0) {}\\n    ~simple_queue()  { /* delete [] q;*/ }\\n    void push(T t)   { q.push_back(t);  }\\n    T    pop(void)   { return q[out_ix++]; }\\n    T    front(void) { return q[out_ix]; }\\n    bool empty(void) { return (out_ix == q.size());}\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        ans[n] = \\'\\\\0\\';\\n        int i = 0;\\n        int first = 0;\\n        int start = 0;\\n        bool found = true;\\n        vector<simple_queue<int>> pos(10);\\n        vector<int> first_pos_sub(10,0);\\n\\n        for(int j=0; j<n; j++)\\n            pos[num[j]-\\'0\\'].push(j);\\n        \\n        while (found == true && i<n)\\n        {\\n            found = false;\\n            while(first<=9 && pos[first].empty())  first++;  \\n            for (int d = first; d<=9 && !found; d++)\\n            {\\n                while (!pos[d].empty() && pos[d].front()  - first_pos_sub[d]  <= k)\\n                {\\n                    // cout << d << \", \" << k << \", \" << pos[d].front()- first_pos_sub[d] << endl;\\n                    found = true;\\n                    int p = pos[d].pop();\\n                    k -= (p -first_pos_sub[d]);\\n                    ans[i++] = \\'0\\'+d;\\n                    for (int d1 = first; d1<=9; d1++)\\n                    {\\n                        if (!pos[d1].empty() && pos[d1].front() > p) first_pos_sub[d1]++;\\n                    }\\n                    num[p] = \\'-\\';\\n                    if (!pos[d].empty())\\n                    {\\n                        for (int j=p+1; j<pos[d].front(); j++)\\n                        {\\n                            if (num[j] == \\'-\\') first_pos_sub[d]++;\\n                        }\\n                    }\\n\\n                    if (d != first) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 815261,
                "title": "java-super-easy-insertion-sort-o-n-2-w-explanation",
                "content": "In the window of length k, the optimal solution is when the smallest integer in the window is occupying the MSB. So, for each position, find the minimum element in that window, perform the swaps and update the MSB.\\n```\\npublic String minInteger(String num, int k) \\n{\\n\\tchar[] arr=num.toCharArray();\\n\\tint n=arr.length;\\n\\tfor(int i=0;i<n;++i)\\n\\t{\\n\\t\\tint pos=i;\\n\\t\\tfor(int j=i+1;j<n&&j<=i+k;++j)\\n\\t\\t\\tif(arr[pos]>arr[j])\\n\\t\\t\\t\\tpos=j;\\n\\t\\tchar temp=arr[pos];\\n\\t\\twhile(pos!=i)// the swaps are being performed.\\n\\t\\t{\\n\\t\\t\\tarr[pos]=arr[pos-1];\\n\\t\\t\\t--k;\\n\\t\\t\\t--pos;\\n\\t\\t}\\n\\t\\tarr[pos]=temp;\\n\\t}\\n\\treturn new String(arr);\\n}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String minInteger(String num, int k) \\n{\\n\\tchar[] arr=num.toCharArray();\\n\\tint n=arr.length;\\n\\tfor(int i=0;i<n;++i)\\n\\t{\\n\\t\\tint pos=i;\\n\\t\\tfor(int j=i+1;j<n&&j<=i+k;++j)\\n\\t\\t\\tif(arr[pos]>arr[j])\\n\\t\\t\\t\\tpos=j;\\n\\t\\tchar temp=arr[pos];\\n\\t\\twhile(pos!=i)// the swaps are being performed.\\n\\t\\t{\\n\\t\\t\\tarr[pos]=arr[pos-1];\\n\\t\\t\\t--k;\\n\\t\\t\\t--pos;\\n\\t\\t}\\n\\t\\tarr[pos]=temp;\\n\\t}\\n\\treturn new String(arr);\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 732932,
                "title": "python-detailed-comments-with-explanation-using-bsearch-only",
                "content": "The `O(N*logN)` solution requires a bit of leap of faith and view the problem from a different angle. I\\'ve also left in my first attempt that TLEs which would give some motivation to the `O(N*logN)`\\nsolution.\\n\\nThe key to understanding the solution is viewing it as a selection problem instead of a swapping problem. You have n position to fill with the best digit possible, from n candidate digits. For each position i, you have n - i candidate digits to choose from such that the digit chosen must not be too far away from index i. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    # O(N*LogN) solution\\n    def minInteger(self, num: str, k: int) -> str:            \\n        smaller_digit_indexes = collections.defaultdict(collections.deque)\\n        A = [int(d) for d in num]\\n        for i in range(len(A)):\\n            smaller_digit_indexes[A[i]].append(i)\\n        \\n        result = \\'\\'\\n        pulled_to_front_indexes = SortedList()\\n        # This problem requires a leap of faith. Instead of thinking how we could replace\\n        # each individual digit at index i by swapping, let\\'s view it as a selecting problem\\n        # where we continously try to select the smallest digit possible, from all that are\\n        # available, and add them into a result list.\\n        n = len(A)\\n        for _ in range(n):\\n            # Given n digits that are available for selection, we\\'ve so far selected len(result)\\n            # number of digits and is now looking for the best digit to add to result. Since\\n            # we want the smallest digit possible, we go through digit 0-9 (at a constant loop cost\\n            # of 10) and stop at the first available digit.\\n            for d in range(0, 10):\\n                if len(smaller_digit_indexes[d]) == 0:\\n                    continue\\n                \\n                # Okay, we have `d` that we could potentially add to result. To build some intuition,\\n                # let\\'s forget about all the swapping business and simply imagine we\\'ve so far pulled \\n\\t\\t\\t\\t# len(result) digits out of A, each digit pulled out leaving a hole in A, and the \\n                # remaining digits in A remains in-place in their original index. And, `d`, the potential \\n                # candidate for selection is at A[j]. In other words, in each iteration of the loop\\n                # (from 0 to n - 1), we are looking to see if the first digit in those that remain in A\\n                # could be replaced by `d` at A[j]. If so, we simply pull `d` out of its position at j\\n                # and place it into `result`.\\n                j = smaller_digit_indexes[d][0]\\n                \\n                # Now the question is, could we possibly choose `d` at its original index j given the\\n                # constraint that we cannot touch digits that are more than k digits away? (Here k\\n                # digits away means number of digits between some start and some end, inclusive, minus 1)\\n                # Well we could if the number of digits from `d` at the j original index j, to the \\n                # first digit remaining in A that we\\'ve not yet pulled out (and put into `result`) is <= k.\\n                # Why? Because if you were to do the swapping process step by step, you\\'ll notice that\\n                # other than digits we\\'ve pulled and put into `result`, the remaining digits\\n                # in A have remained in the same relative order, except for the holes. We only need to\\n                # deduct for the holes they are between the first digit of A and j, to arrive at the \\n                # true distance\\n                nb_moved_to_front = pulled_to_front_indexes.bisect_right(j)\\n                dist = j - nb_moved_to_front\\n                if dist == 0 or dist <= k:\\n                    # dist == 0 means `d` happens to be the first digit remaining in A\\n                    result += str(d)\\n                    pulled_to_front_indexes.add(j)\\n                    smaller_digit_indexes[d].popleft()\\n                    k -= dist\\n                    break\\n\\n        return result\\n\\n    # First O(N^2) attempt that will LTE\\n    def minInteger2(self, num: str, k: int) -> str:\\n        def bubble_up(A, i, j):\\n            t = A[j]\\n            for x in range(j, i, -1):\\n                A[x] = A[x - 1]\\n            A[i] = t\\n                \\n            \\n        A = [int(d) for d in num]\\n        \\n        i = 0\\n        while i < len(A) and k > 0:\\n            # Given A[i], let\\'s see if we can find the smallest possible A[j] such that j - i <= k.\\n            # That is, the smallest possible A[j], k-swap distance away that we could swap with A[i] \\n            # and get a smallest possible number\\n            j = i + 1\\n            min_digit_idx = None\\n            while j < len(A) and j - i <= k:\\n                if A[j] < A[i]:\\n                    if min_digit_idx is None or A[j] < A[min_digit_idx]:\\n                        min_digit_idx = j\\n                j += 1\\n            \\n            if min_digit_idx != None:\\n                bubble_up(A, i, min_digit_idx)\\n                k -= min_digit_idx - i\\n            \\n            i += 1\\n        \\n        return \\'\\'.join([str(d) for d in A])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    # O(N*LogN) solution\\n    def minInteger(self, num: str, k: int) -> str:            \\n        smaller_digit_indexes = collections.defaultdict(collections.deque)\\n        A = [int(d) for d in num]\\n        for i in range(len(A)):\\n            smaller_digit_indexes[A[i]].append(i)\\n        \\n        result = \\'\\'\\n        pulled_to_front_indexes = SortedList()\\n        # This problem requires a leap of faith. Instead of thinking how we could replace\\n        # each individual digit at index i by swapping, let\\'s view it as a selecting problem\\n        # where we continously try to select the smallest digit possible, from all that are\\n        # available, and add them into a result list.\\n        n = len(A)\\n        for _ in range(n):\\n            # Given n digits that are available for selection, we\\'ve so far selected len(result)\\n            # number of digits and is now looking for the best digit to add to result. Since\\n            # we want the smallest digit possible, we go through digit 0-9 (at a constant loop cost\\n            # of 10) and stop at the first available digit.\\n            for d in range(0, 10):\\n                if len(smaller_digit_indexes[d]) == 0:\\n                    continue\\n                \\n                # Okay, we have `d` that we could potentially add to result. To build some intuition,\\n                # let\\'s forget about all the swapping business and simply imagine we\\'ve so far pulled \\n\\t\\t\\t\\t# len(result) digits out of A, each digit pulled out leaving a hole in A, and the \\n                # remaining digits in A remains in-place in their original index. And, `d`, the potential \\n                # candidate for selection is at A[j]. In other words, in each iteration of the loop\\n                # (from 0 to n - 1), we are looking to see if the first digit in those that remain in A\\n                # could be replaced by `d` at A[j]. If so, we simply pull `d` out of its position at j\\n                # and place it into `result`.\\n                j = smaller_digit_indexes[d][0]\\n                \\n                # Now the question is, could we possibly choose `d` at its original index j given the\\n                # constraint that we cannot touch digits that are more than k digits away? (Here k\\n                # digits away means number of digits between some start and some end, inclusive, minus 1)\\n                # Well we could if the number of digits from `d` at the j original index j, to the \\n                # first digit remaining in A that we\\'ve not yet pulled out (and put into `result`) is <= k.\\n                # Why? Because if you were to do the swapping process step by step, you\\'ll notice that\\n                # other than digits we\\'ve pulled and put into `result`, the remaining digits\\n                # in A have remained in the same relative order, except for the holes. We only need to\\n                # deduct for the holes they are between the first digit of A and j, to arrive at the \\n                # true distance\\n                nb_moved_to_front = pulled_to_front_indexes.bisect_right(j)\\n                dist = j - nb_moved_to_front\\n                if dist == 0 or dist <= k:\\n                    # dist == 0 means `d` happens to be the first digit remaining in A\\n                    result += str(d)\\n                    pulled_to_front_indexes.add(j)\\n                    smaller_digit_indexes[d].popleft()\\n                    k -= dist\\n                    break\\n\\n        return result\\n\\n    # First O(N^2) attempt that will LTE\\n    def minInteger2(self, num: str, k: int) -> str:\\n        def bubble_up(A, i, j):\\n            t = A[j]\\n            for x in range(j, i, -1):\\n                A[x] = A[x - 1]\\n            A[i] = t\\n                \\n            \\n        A = [int(d) for d in num]\\n        \\n        i = 0\\n        while i < len(A) and k > 0:\\n            # Given A[i], let\\'s see if we can find the smallest possible A[j] such that j - i <= k.\\n            # That is, the smallest possible A[j], k-swap distance away that we could swap with A[i] \\n            # and get a smallest possible number\\n            j = i + 1\\n            min_digit_idx = None\\n            while j < len(A) and j - i <= k:\\n                if A[j] < A[i]:\\n                    if min_digit_idx is None or A[j] < A[min_digit_idx]:\\n                        min_digit_idx = j\\n                j += 1\\n            \\n            if min_digit_idx != None:\\n                bubble_up(A, i, min_digit_idx)\\n                k -= min_digit_idx - i\\n            \\n            i += 1\\n        \\n        return \\'\\'.join([str(d) for d in A])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729917,
                "title": "python-o-n-log-n-binarysearch-solution",
                "content": "In this post I will focus on stepping through my thought process in solving this question and only post the full solution at the end. So a word of warning: **long post**. But hopefully some may find this useful :) You can also practice implementing after reading analysis instead of refering to the full solution.\\n\\n**Initial Analysis**\\n1) Understand the questions first, realize that *optimal is just the sorted array of digits given* and that greedily making permissible moves of smallest digit to the front will always be optimal. I.e. no movement of digits near the end of the number will yield as large a decrease as *decreasing the leading (leftmost) digit*.\\n2) Look for bounds, `1 <= num.length <= 30000`, and `1 <= k <= 10^9` suggests we cannot use O(k) solution and need faster than O(N^2) to AC. The bounds also give some hints to what\\'s permissible in solution, in this case, O(N\\\\*log(N)) will be ok. (And generally is the case except for very large bounds, hard to distinguish between O(N) vs O(N\\\\*log(N)) solution timings - unless you\\'re using python T.T)\\n\\n**First-pass *(horribly wrong)***\\n- Insight 1: Index of digit determines least number of swaps needed to move it to the front\\n- Insight 2: Number of digits moved before will decrease this cost proportionately (wrong)\\n- So we can do *O(N)* scan while keeping counter for number of previously moved digits?\\n- Since we need to move smaller digits first, if we have a sorted list of digits by index per digit, then doing repeated greedy scans from `0` to `9` always picking from smaller digit first will give us the order of digits to move? (also actually wrong)\\n- That\\'s not too bad, we can init queues for each digit type and push index of each digit as we encounter them by scanning through `num` once with O(N) time and space (number of digit types is constant) then pop them as we consider each digit O(1) time.\\n\\n*code, code, code, Run, Failed!* :O\\n\\n**Ofc, LC-hard, not so easy - Second Try**\\n- Does not pass first test case, seems like we are missing caveat from Insight 1&2. Not the case that number of digits previously moved discounts the next move proportionately, rather:\\n- Insight 3: Number of digits with indices smaller than current digit\\'s index will discount number of swaps to move current digit to front\\n- So we have to not only keep track of how many moves-to-front we\\'ve made but at which indices we\\'ve made them from\\n- Naive Solution:\\n  - Keep list of moved digit indices\\n  - Scan through list when computing next move feasibility (cost) and count number of smaller indices for discount\\n  - O(N) scan per digit => O(N^2) overall, TLE (oops)\\n- Have to think of better way to store and lookup number of indices smaller than current\\n  - This is the actual issue in this problem\\n\\n**Abstract the problem a bit -> Reduce to a familiar classic problem**\\n- Given a list of numbers, find how many are smaller than a given query\\n- We have a time-budget of O(log(N)) -> What algos do we know that can do this? BinarySearch\\n- Problem: BinarySearch only works when the given list of numbers are already sorted.\\n  - Time cost incurred to sort again: O(N\\\\*log(N)) => TLE\\n- **Insight 4** (what needed to click for me to solve this):\\n  - Instead of thinking of *the* (single) list of previously moved digits, we know that the order in which we move a certain type of digit (say all `0`s moved so far) have strictly increasing indices!\\n  - In other words, we already have 10 sorted lists of previously moved indices and we can just do multiple searches for each type of digit previously moved and take the sum as total \\'discount\\' for currently considered move.\\n  - If we just store a \\'taken\\' index for which index we have already taken for this digit type and increment this each time we move a digit to the front rather than using queues, we can reuse sorted arrays for each digit type with `digit[i][:taken[i]+1]` (this store indices of previously moved digits of type `i`)\\n- Time analysis:\\n  - 10\\\\*O(log(N)) ~ O(log(N)) => AC :) at least on time\\n\\n**Yay! AC?**\\n- Nope...\\n- Failed Testcase:\\n  - \"294984148179\"\\n11\\n- Output:\\n  - \"124499488179\"\\n- Expected:\\n  - \"124498948179\"\\n- Notice that in this case, our solution chose to move the third \\'4\\' rather than the first \\'8\\' ahead by 1 position\\n- Stepping through algo to debug:\\n  - We notice that after [1244]99848179, we move \\'up\\' (retain) \\'9\\' in what\\'s currently at index 5, thereafter, as per our greedy strategy, we look for more digits of type \\'9\\' to move, which is in the next position, and so we end up with [124499]848179 and then restart from \\'0\\' and end up moving \\'4\\' up one position since with `k=1` left, that is the next most optimal choice we have\\n- Insight 5 (last one, I promise): When it is impossible to move up any digit smaller than at the current index, we need to consider moving smaller digits into the next position instead and restart from \\'0\\'\\n- With this last modification, our solution will restart the greedy scan from \\'0\\' after [12449]9848179 and consider moving up \\'8\\' with the last swap instead of retaining \\'9\\' and moving \\'4\\'.\\n- But does this restart hurt our time?\\n  - Each time we choose to move a digit, we reduce the number of digits we have to look at by 1\\n  - For each choice of digit movement, we consider moving up at most 10 digits (0-9 and only if our current digit is 9) and to compute each digit\\'s cost, we do at most 10\\\\*O(log(N))\\n  - Worst case: 100\\\\*O(log(N)) per digit in given `num` string ~ O(N\\\\*log(N)) time complexity, should be ok.\\n- AC :D\\n\\nThanks for reading, hopefully stepping through my approach was helpful to some of you!\\n\\n**TL;DR:** realize we need to find how many digits we\\'ve moved prior (smaller than) current digit\\'s index in O(log(N)) time, use BinarySearch, problem: sorted array of previously moved digits\\' index? No problem, we are already picking them in sorted order for each type `0-9`, just whack with 10xBinarySearch, still asymptotically overall O(N\\\\*log(N)) solution => AC :)\\n\\n**A bit lengthly solution, but with comments and debugging output to help with understanding**\\n```python\\n# Turn on for debugging output\\nDEBUG = False\\n\\n# Generic binary search to return insertion index\\ndef binarySearch(arr, s, t, n):\\n    m = (s+t)//2\\n    if (s == t):\\n        return s\\n    if (arr[m] > n):\\n        return binarySearch(arr, s, m, n)\\n    else:\\n        return binarySearch(arr, m+1, t, n)\\n    \\nclass Solution:\\n    def __init__(self):\\n        self.digits = dict()\\n        self.taken = [-1 for i in range(10)]\\n    \\n    # Compute how much it costs to move this digit to the front\\n    def cost(self, cur):\\n        discount = 0\\n\\t\\t# Sum previously moved digits with index less than cur for each type\\n        for i in range(10):\\n            discount += binarySearch(self.digits[i], 0, self.taken[i]+1, cur)\\n\\t\\t\\t\\n            if (DEBUG):\\n                if (self.taken[i] >= 0):\\n                    print(f\"{i}: [{self.digits[i][:self.taken[i]+1]}] search:{cur} discount:{binarySearch(self.digits[i],0,self.taken[i]+1,cur)}\")\\n        return cur - discount\\n    \\n    def minInteger(self, num: str, k: int) -> str:\\n        if (DEBUG):\\n            print(f\"Testcase: [{num}] k={k}\")\\n        \\n        # Keep sorted arrays (by index) for each occurance of digits\\n        self.digits = {i:[] for i in range(10)}\\n        for i,n in enumerate(num):\\n            self.digits[int(n)].append(i)\\n        \\n        extracted = set()\\n        head = \"\" # constructed \\'front\\' of string\\n        \\n        # Terminating conditions:\\n        # 1) No more swaps left\\n        # 2) We have sorted our array\\n        while k > 0 and len(head) < len(num):\\n            i = 0\\n            # Scan each digit occurances from smalled (0) to largest (9) in order\\n            # to greedily make best permissible moves to front\\n            while i < 10:\\n                # Sanity check that we still have digits not yet moved to front\\n                while k > 0 and len(self.digits[i]) and self.taken[i]+1 < len(self.digits[i]):\\n                    # Get number of swaps to move current digit to front\\n\\t\\t\\t\\t\\tcurCost = self.cost(self.digits[i][self.taken[i]+1])\\n                    \\n                    if (DEBUG):\\n                        print(f\"move to head:{i}@{self.digits[i][self.taken[i]+1]} cost: {curCost}\")\\n                    \\n                    # If we can move this digit, move it\\n                    if (curCost <= k):\\n                        self.taken[i] += 1\\n                        k -= curCost\\n                        extracted.add(self.digits[i][self.taken[i]])\\n                        head += str(i)\\n                        \\n                        if (DEBUG):\\n                            print(f\"[{head}]\",end=\"\")\\n                            for j in range(len(num)):\\n                                if j in extracted:\\n                                    continue\\n                                print(num[j],end=\"\")\\n                            print(f\" k={k}\")\\n                    # Otherwise, no further digit of this kind could possible be moved\\n                    # since our self.digits[i] array is sorted (move onto the next digit)\\n                    else:\\n                        break\\n                    # When we move a digit \\'for free\\', we reset our search as a previously seen\\n                    # not-possible but more optimal (smaller) digit could now be moved to front\\n                    if (curCost == 0):\\n                        i = 0\\n                # remember to increment our search onto the next smallest digit\\n                i += 1\\n                \\n        # Parse and output final answer\\n        for i in range(len(num)):\\n            if i in extracted:\\n                continue\\n            head += num[i]\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\n# Turn on for debugging output\\nDEBUG = False\\n\\n# Generic binary search to return insertion index\\ndef binarySearch(arr, s, t, n):\\n    m = (s+t)//2\\n    if (s == t):\\n        return s\\n    if (arr[m] > n):\\n        return binarySearch(arr, s, m, n)\\n    else:\\n        return binarySearch(arr, m+1, t, n)\\n    \\nclass Solution:\\n    def __init__(self):\\n        self.digits = dict()\\n        self.taken = [-1 for i in range(10)]\\n    \\n    # Compute how much it costs to move this digit to the front\\n    def cost(self, cur):\\n        discount = 0\\n\\t\\t# Sum previously moved digits with index less than cur for each type\\n        for i in range(10):\\n            discount += binarySearch(self.digits[i], 0, self.taken[i]+1, cur)\\n\\t\\t\\t\\n            if (DEBUG):\\n                if (self.taken[i] >= 0):\\n                    print(f\"{i}: [{self.digits[i][:self.taken[i]+1]}] search:{cur} discount:{binarySearch(self.digits[i],0,self.taken[i]+1,cur)}\")\\n        return cur - discount\\n    \\n    def minInteger(self, num: str, k: int) -> str:\\n        if (DEBUG):\\n            print(f\"Testcase: [{num}] k={k}\")\\n        \\n        # Keep sorted arrays (by index) for each occurance of digits\\n        self.digits = {i:[] for i in range(10)}\\n        for i,n in enumerate(num):\\n            self.digits[int(n)].append(i)\\n        \\n        extracted = set()\\n        head = \"\" # constructed \\'front\\' of string\\n        \\n        # Terminating conditions:\\n        # 1) No more swaps left\\n        # 2) We have sorted our array\\n        while k > 0 and len(head) < len(num):\\n            i = 0\\n            # Scan each digit occurances from smalled (0) to largest (9) in order\\n            # to greedily make best permissible moves to front\\n            while i < 10:\\n                # Sanity check that we still have digits not yet moved to front\\n                while k > 0 and len(self.digits[i]) and self.taken[i]+1 < len(self.digits[i]):\\n                    # Get number of swaps to move current digit to front\\n\\t\\t\\t\\t\\tcurCost = self.cost(self.digits[i][self.taken[i]+1])\\n                    \\n                    if (DEBUG):\\n                        print(f\"move to head:{i}@{self.digits[i][self.taken[i]+1]} cost: {curCost}\")\\n                    \\n                    # If we can move this digit, move it\\n                    if (curCost <= k):\\n                        self.taken[i] += 1\\n                        k -= curCost\\n                        extracted.add(self.digits[i][self.taken[i]])\\n                        head += str(i)\\n                        \\n                        if (DEBUG):\\n                            print(f\"[{head}]\",end=\"\")\\n                            for j in range(len(num)):\\n                                if j in extracted:\\n                                    continue\\n                                print(num[j],end=\"\")\\n                            print(f\" k={k}\")\\n                    # Otherwise, no further digit of this kind could possible be moved\\n                    # since our self.digits[i] array is sorted (move onto the next digit)\\n                    else:\\n                        break\\n                    # When we move a digit \\'for free\\', we reset our search as a previously seen\\n                    # not-possible but more optimal (smaller) digit could now be moved to front\\n                    if (curCost == 0):\\n                        i = 0\\n                # remember to increment our search onto the next smallest digit\\n                i += 1\\n                \\n        # Parse and output final answer\\n        for i in range(len(num)):\\n            if i in extracted:\\n                continue\\n            head += num[i]\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721206,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(char *array, int k, int start, int n){\\n        if (k == 0 or start >= n) // no moves left, done modifying the string\\n            return; \\n        int min_idx = start;       // position of the closest min digit within k\\n        for(int i = start+1; i < min(n, start + k + 1); i++)\\n            if (array[i] < array[min_idx])\\n                min_idx = i;\\n\\t\\t// found a smaller digit within k steps\\n        if (min_idx > start){                       \\n            char temp = array[min_idx];      // memorize the min\\n            for(int j = min_idx; j > start; j--) //shift all digits\\n                array[j] = array[j-1];\\n            array[start] = temp;   // update the first digit\\n            k -= (min_idx - start); // reduce k\\n        }\\n        return helper(array, k, start+1, n); // go to the next digit\\n    }\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n\\t\\t// worst case digits in number in reverse sorted order, need (n-1) steps to move last to front, then (n-2) mooving new last and so on\\n\\t\\t// so we need max (n-1) + (n-2)+... + 1 = (n-1)*n/2 to sort\\n        if (k >= (n*(n-1)) / 2){ \\n            sort(num.begin(),num.end());\\n            return num;\\n        }\\n        \\n        helper(&num[0], k, 0, n); // strings in c++ already array of chars\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(char *array, int k, int start, int n){\\n        if (k == 0 or start >= n) // no moves left, done modifying the string\\n            return; \\n        int min_idx = start;       // position of the closest min digit within k\\n        for(int i = start+1; i < min(n, start + k + 1); i++)\\n            if (array[i] < array[min_idx])\\n                min_idx = i;\\n\\t\\t// found a smaller digit within k steps\\n        if (min_idx > start){                       \\n            char temp = array[min_idx];      // memorize the min\\n            for(int j = min_idx; j > start; j--) //shift all digits\\n                array[j] = array[j-1];\\n            array[start] = temp;   // update the first digit\\n            k -= (min_idx - start); // reduce k\\n        }\\n        return helper(array, k, start+1, n); // go to the next digit\\n    }\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n\\t\\t// worst case digits in number in reverse sorted order, need (n-1) steps to move last to front, then (n-2) mooving new last and so on\\n\\t\\t// so we need max (n-1) + (n-2)+... + 1 = (n-1)*n/2 to sort\\n        if (k >= (n*(n-1)) / 2){ \\n            sort(num.begin(),num.end());\\n            return num;\\n        }\\n        \\n        helper(&num[0], k, 0, n); // strings in c++ already array of chars\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720794,
                "title": "python-nlogn-fenwick-bit-solution",
                "content": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        mp = defaultdict(deque)\\n        for i,v in enumerate(num):\\n            mp[v].append(i)\\n        res = \"\"\\n        def lowbit(x):\\n            return x & (-x)\\n        def query(x):\\n            sums = 0\\n            while x:\\n                sums += arr[x]\\n                x -= lowbit(x)\\n            return sums\\n        def update(x,delta):\\n            while x <= n:\\n                arr[x] += delta\\n                x += lowbit(x)\\n\\n        arr = [0]*(n+1)\\n        for i in range(n):\\n            update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if mp[v]:\\n                    idx = mp[v][0]\\n                    cnt = query(idx)\\n                    if cnt > k: continue\\n                    mp[v].popleft()\\n                    k -= cnt\\n                    res += v\\n                    update(idx+1,-1)\\n                    break\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        mp = defaultdict(deque)\\n        for i,v in enumerate(num):\\n            mp[v].append(i)\\n        res = \"\"\\n        def lowbit(x):\\n            return x & (-x)\\n        def query(x):\\n            sums = 0\\n            while x:\\n                sums += arr[x]\\n                x -= lowbit(x)\\n            return sums\\n        def update(x,delta):\\n            while x <= n:\\n                arr[x] += delta\\n                x += lowbit(x)\\n\\n        arr = [0]*(n+1)\\n        for i in range(n):\\n            update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if mp[v]:\\n                    idx = mp[v][0]\\n                    cnt = query(idx)\\n                    if cnt > k: continue\\n                    mp[v].popleft()\\n                    k -= cnt\\n                    res += v\\n                    update(idx+1,-1)\\n                    break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720123,
                "title": "python3-brute-force",
                "content": "Algo\\nScan through the string. At each index, look for the smallest element behind it within k swaps. Upon finding such minimum, swap it to replece the current element, and reduce k to reflect the swaps. Do this for all element until k becomes 0. \\n\\n`O(N^2)` time & `O(N)` space \\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        if k >= n*(n-1)//2: return \"\".join(sorted(num)) #special case\\n        \\n        #find smallest elements within k swaps \\n        #and swap it to current position \\n        num = list(num)\\n        for i in range(n):\\n            if not k: break \\n            #find minimum within k swaps\\n            ii = i\\n            for j in range(i+1, min(n, i+k+1)): \\n                if num[ii] > num[j]: ii = j \\n            #swap the min to current position \\n            if ii != i: \\n                k -= ii-i\\n                for j in range(ii, i, -1):\\n                    num[j-1], num[j] = num[j], num[j-1]\\n        return \"\".join(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        if k >= n*(n-1)//2: return \"\".join(sorted(num)) #special case\\n        \\n        #find smallest elements within k swaps \\n        #and swap it to current position \\n        num = list(num)\\n        for i in range(n):\\n            if not k: break \\n            #find minimum within k swaps\\n            ii = i\\n            for j in range(i+1, min(n, i+k+1)): \\n                if num[ii] > num[j]: ii = j \\n            #swap the min to current position \\n            if ii != i: \\n                k -= ii-i\\n                for j in range(ii, i, -1):\\n                    num[j-1], num[j] = num[j], num[j-1]\\n        return \"\".join(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688655,
                "title": "c-easy-segment-tree",
                "content": "\\n# Code\\n```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nconst int N =30010;\\nll w[N];\\nll st[N];\\n\\nstruct Node {\\n    ll l,r;\\n    ll minv, idx, sum;\\n} tree[4*N];\\n\\nvoid push_up(Node& a, Node& b, Node & c) {\\n    if(b.minv <= c.minv) {\\n        a.minv = b.minv;\\n        a.idx = b.idx;\\n    } else {\\n        a.minv = c.minv;\\n        a.idx = c.idx;\\n    }\\n    a.sum = b.sum + c.sum;\\n}\\n\\nvoid push_up(ll u) {\\n    push_up(tree[u], tree[2*u], tree[2*u+1]);\\n}\\n\\nvoid build(ll u, ll l, ll r) {\\n    tree[u].l = l;\\n    tree[u].r = r;\\n    if(l == r) {\\n        ll b = w[l];\\n        tree[u].minv = b;\\n        tree[u].idx = l;\\n        tree[u].sum = st[l];\\n    } else {\\n        ll mid = (l + r) / 2;\\n        build(2*u, l, mid);\\n        build(2*u+1, mid+1, r);\\n        push_up(u);\\n    }\\n}\\n\\nvoid update(ll u, ll idx, ll x) {\\n    if(tree[u].l == tree[u].r) {\\n        tree[u].minv = x;\\n        tree[u].sum = 0;\\n        st[tree[u].l] = 0;\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(idx <= mid) update(2*u, idx, x);\\n        else update(2*u+1, idx, x);\\n        push_up(u);\\n    }\\n}\\n\\nNode query(ll u, ll l, ll r) {\\n    if(tree[u].l >= l && tree[u].r <= r) {\\n        return tree[u];\\n    } else {\\n        ll mid = (tree[u].l + tree[u].r)/2;\\n        if(l > mid) {\\n            return query(2*u+1, l, r);\\n        } else if (r <= mid) {\\n            return query(2*u, l, r);\\n        } else {\\n            auto left = query(2*u, l, r);\\n            auto right = query(2*u+1, l, r);\\n            Node res;\\n            push_up(res, left, right);\\n            return res;\\n        }\\n    }\\n}\\n\\nint get_idx(int presum, int len) {\\n    int l = 1;\\n    int r = len;\\n    int res = len;\\n    while(l <= r) {\\n        int mid = (l + r) / 2;\\n        if(query(1, 1, mid).sum >= presum) {\\n            res = mid;\\n            r = mid - 1;\\n        } else {\\n            l = mid + 1;\\n        }\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        return solve(num, k);\\n    }\\n    void init(string & num) {\\n        int n = num.size();\\n        memset(tree, 0, sizeof tree);\\n        for(int i = 1; i <= n; i ++) w[i] = num[i-1] - \\'0\\';\\n        for(int i = 1; i <= n; i ++) st[i] = 1;\\n        build(1, 1, n);\\n    }\\n    string solve(string & num, int k) {\\n        init(num);\\n        string res;\\n        while(k) {\\n            int max_sum = min(k+1, (int)num.size());\\n            int threshold = get_idx(max_sum, num.size());\\n            Node curr = query(1, 1, threshold);\\n            if(curr.minv == 10) break;\\n            res.push_back(curr.minv + \\'0\\');\\n            update(1, curr.idx, 10);\\n            k -= query(1, 1, curr.idx).sum;\\n        }\\n        for(int i = 1; i <= num.size(); i ++) {\\n            if(st[i] == 1) {\\n                res.push_back(num[i-1]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438941,
                "title": "java-simple-implementation-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public static String minInteger(String num, int k) {\\n        char[] array = num.toCharArray(); // returns a newly allocated character array.\\n        int length = array.length;\\n        int pointer = 0; // the index replaced at most K times by the smallest possible digit\\n        while (k > 0 && pointer < length) {\\n            int minDigit = array[pointer] - \\'0\\', minIndex = pointer;\\n            int limit = Math.min(length - 1, pointer + k); // when k is too large -> pointer + k is too large, run out\\n                                                           // of range -> min(length-1, pointer+k)\\n            for (int i = pointer + 1; i <= limit; i++) {\\n                // take smallest digit from position: pointer -> limit\\n                int temp = array[i] - \\'0\\';\\n                if (temp < minDigit) {\\n                    minDigit = temp; // smallest digit\\n                    minIndex = i; // smallest digit\\'s index\\n                }\\n            }\\n            k -= (minIndex - pointer); // swapping times needed to move smallest digit to pointer position\\n            char c = array[minIndex]; // smallest digit: c (char)\\n            // move c = array[minIndex] to be array[pointer]: line 21 -> 23\\n            for (int i = minIndex - 1; i >= pointer; i--)\\n                array[i + 1] = array[i];\\n            array[pointer] = c;\\n            pointer++; // continue with next array[pointer]\\n        }\\n        return new String(array);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String minInteger(String num, int k) {\\n        char[] array = num.toCharArray(); // returns a newly allocated character array.\\n        int length = array.length;\\n        int pointer = 0; // the index replaced at most K times by the smallest possible digit\\n        while (k > 0 && pointer < length) {\\n            int minDigit = array[pointer] - \\'0\\', minIndex = pointer;\\n            int limit = Math.min(length - 1, pointer + k); // when k is too large -> pointer + k is too large, run out\\n                                                           // of range -> min(length-1, pointer+k)\\n            for (int i = pointer + 1; i <= limit; i++) {\\n                // take smallest digit from position: pointer -> limit\\n                int temp = array[i] - \\'0\\';\\n                if (temp < minDigit) {\\n                    minDigit = temp; // smallest digit\\n                    minIndex = i; // smallest digit\\'s index\\n                }\\n            }\\n            k -= (minIndex - pointer); // swapping times needed to move smallest digit to pointer position\\n            char c = array[minIndex]; // smallest digit: c (char)\\n            // move c = array[minIndex] to be array[pointer]: line 21 -> 23\\n            for (int i = minIndex - 1; i >= pointer; i--)\\n                array[i + 1] = array[i];\\n            array[pointer] = c;\\n            pointer++; // continue with next array[pointer]\\n        }\\n        return new String(array);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939797,
                "title": "why-test-case-has-leading-zero",
                "content": "In constraints, said that would not contain leading zeros.\\n```\\nnum consists of only digits and does not contain leading zeros.\\n```\\nHowever, when I submit my answer, show my answer is `Memory Limit Exceeded`\\nAnd I look the Input, there have leading zero in input.\\n![image](https://assets.leetcode.com/users/images/87388602-904d-4511-8b15-a17341f48c59_1649774847.1689444.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nnum consists of only digits and does not contain leading zeros.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240212,
                "title": "c-o-nlogn-with-segment-tree",
                "content": "```\\nstruct Node {\\n    int l, r;\\n    int v;\\n    Node() {\\n        v = 0;\\n    };\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<Node> tree;\\n    void build(int l, int r, int p) {\\n        tree[p].l = l;\\n        tree[p].r = r;\\n        if (l != r) {\\n            int mid = (l + r) >> 1;\\n            build(l, mid, 2 * p);\\n            build(mid+1, r, 2 * p + 1);\\n        }\\n    }\\n    void insert(int x, int p) {\\n        tree[p].v--;\\n        if (tree[p].l != tree[p].r) {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (x <= mid) insert(x, 2*p);\\n            else insert(x, 2*p+1);\\n        }\\n    }\\n    int query(int l, int r, int p) {\\n        if (tree[p].l == l && tree[p].r == r) return tree[p].v;\\n        else {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (r <= mid) return query(l, r, 2*p);\\n            else if (l >= mid+1) return query(l, r, 2*p + 1);\\n            else return query(l, mid, 2*p) + query(mid+1, r, 2*p + 1);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        string result;\\n        \\n        vector<int> offset(num.size(), 0);\\n        vector<deque<int>> pos(10);\\n        for (int i = 0; i < num.size(); i++) pos[num[i]-\\'0\\'].push_back(i);\\n        \\n        tree = vector<Node>(4 * num.size() + 10);\\n        build(0, num.size() - 1, 1);\\n        \\n        int i = 0;\\n        while(true) {\\n            while (i < num.size() && offset[i] < 0) i++;\\n            if (i >= num.size()) break;\\n            \\n            int cp = i;\\n            if (cp - 1 >= 0) cp += query(0, cp - 1, 1);\\n            \\n            for (int p = 0; p <= 9; p++) {\\n                if (pos[p].size() > 0) {\\n                    \\n                    int fp = pos[p].front();\\n                    if (fp - 1 >= 0) fp += query(0, fp - 1, 1);\\n                    \\n                    if (fp - cp <= k) {\\n                        k -= fp - cp;\\n                        offset[pos[p].front()] = -1;\\n                        insert(pos[p].front(), 1);\\n                        \\n                        pos[p].pop_front();\\n                        result += char(\\'0\\' + p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\n    int l, r;\\n    int v;\\n    Node() {\\n        v = 0;\\n    };\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<Node> tree;\\n    void build(int l, int r, int p) {\\n        tree[p].l = l;\\n        tree[p].r = r;\\n        if (l != r) {\\n            int mid = (l + r) >> 1;\\n            build(l, mid, 2 * p);\\n            build(mid+1, r, 2 * p + 1);\\n        }\\n    }\\n    void insert(int x, int p) {\\n        tree[p].v--;\\n        if (tree[p].l != tree[p].r) {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (x <= mid) insert(x, 2*p);\\n            else insert(x, 2*p+1);\\n        }\\n    }\\n    int query(int l, int r, int p) {\\n        if (tree[p].l == l && tree[p].r == r) return tree[p].v;\\n        else {\\n            int mid = (tree[p].l + tree[p].r) >> 1;\\n            if (r <= mid) return query(l, r, 2*p);\\n            else if (l >= mid+1) return query(l, r, 2*p + 1);\\n            else return query(l, mid, 2*p) + query(mid+1, r, 2*p + 1);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        string result;\\n        \\n        vector<int> offset(num.size(), 0);\\n        vector<deque<int>> pos(10);\\n        for (int i = 0; i < num.size(); i++) pos[num[i]-\\'0\\'].push_back(i);\\n        \\n        tree = vector<Node>(4 * num.size() + 10);\\n        build(0, num.size() - 1, 1);\\n        \\n        int i = 0;\\n        while(true) {\\n            while (i < num.size() && offset[i] < 0) i++;\\n            if (i >= num.size()) break;\\n            \\n            int cp = i;\\n            if (cp - 1 >= 0) cp += query(0, cp - 1, 1);\\n            \\n            for (int p = 0; p <= 9; p++) {\\n                if (pos[p].size() > 0) {\\n                    \\n                    int fp = pos[p].front();\\n                    if (fp - 1 >= 0) fp += query(0, fp - 1, 1);\\n                    \\n                    if (fp - cp <= k) {\\n                        k -= fp - cp;\\n                        offset[pos[p].front()] = -1;\\n                        insert(pos[p].front(), 1);\\n                        \\n                        pos[p].pop_front();\\n                        result += char(\\'0\\' + p);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092447,
                "title": "java-brute-force-via-bubble-sort",
                "content": "In short, the idea is to bubble up the smallest element so far (need to consider k swaps constraint)\\n\\n\\tpublic class Solution1505 {\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tString num = \"9438957234785635408\";\\n\\t\\t\\tint k = 23;\\n\\n\\t\\t\\tSolution1505 solution1505 = new Solution1505();\\n\\n\\t\\t\\tSystem.out.println(solution1505.minInteger(num, k));\\n\\n\\n\\t\\t}\\n\\n\\t\\tpublic String minInteger(String num, int k) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\t\\tchar[] input = num.toCharArray();\\n\\n\\t\\t\\tint idx = 0;\\n\\n\\t\\t\\twhile (idx < input.length && k > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint minValue = input[idx] - \\'0\\';\\n\\t\\t\\t\\tint minIndex = idx;\\n\\n\\t\\t\\t\\tint j = idx + 1;\\n\\n\\t\\t\\t\\tint tempK = k;\\n\\t\\t\\t\\twhile (j < input.length && tempK > 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint curValue = input[j] - \\'0\\';\\n\\t\\t\\t\\t\\tif (curValue < minValue) {\\n\\t\\t\\t\\t\\t\\tminValue = curValue;\\n\\t\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\ttempK--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsb.append(input[minIndex]);\\n\\n\\t\\t\\t\\tfor (int i = minIndex; i > idx; --i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tswap(input, i, i - 1);\\n\\t\\t\\t\\t\\tk--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = idx; i < input.length; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsb.append(input[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sb.toString();\\n\\n\\t\\t}\\n\\n\\t\\tprivate void swap(char[] input, int i, int j)\\n\\t\\t{\\n\\t\\t\\tchar temp = input[i];\\n\\n\\t\\t\\tinput[i] = input[j];\\n\\n\\t\\t\\tinput[j] = temp;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution1505 {\\n\\t\\tpublic static void main(String[] args) {\\n\\t\\t\\tString num = \"9438957234785635408\";\\n\\t\\t\\tint k = 23;\\n\\n\\t\\t\\tSolution1505 solution1505 = new Solution1505();\\n\\n\\t\\t\\tSystem.out.println(solution1505.minInteger(num, k));\\n\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1087455,
                "title": "python3-o-n-2-and-o-n-log-n",
                "content": "**Solution 1**: The straightfoward O(n^2) solution will use a similar technique as the bubble sort; this will be TLE.\\n```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \"\"\"O(n^2) TLE\"\"\"\\n        i, size = 0, len(num)\\n        while k > 0 and i < size:\\n            mini = num[i]\\n            j_mini = i\\n            for j in range(i,min(i+k+1,size)):\\n                if num[j]<mini:\\n                    mini = num[j]\\n                    j_mini = j\\n            k -= (j_mini - i)\\n            num = num[:i] + mini + num[i:j_mini] + num[j_mini+1:]\\n            i += 1\\n        return num\\n```\\n**Solution 2**: The trickiest part is to convert this problem into a prefix sum problem. We will need to find the cost to move a digit up front. Consider the following case:\\n* 6,5,4,3,2,1 - the move of 1 to the front will be 5, which is its index (5), straightfoward.\\n* 5,1,0,4,3,2 - the move of 2 to the front will be 3, why? Because by the time we start to move 2, the digits 0 and 1 are already upfront by previous operations. Remember, you never want the digit 2 to be in front of digits 0 and 1. Since we have already moved those 2 digits, we need to exclude that cost (2) from its index (5). So the actual cost of moving 2 upfront, is 5-2 =3. How do we get the cost number 2? We can use an array (BIT) to store a 1 for each already moved position, and do a prefix sum up to the current index (5). \\n\\nWe break out from the loop either we run out of budget k, or we have sorted the string fully. Finally, if we have some leftover in the original string (digits that we have not moved because of shortage of k), we need to append the unused digits to our construted answer.\\n\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.bit = [0]*(n+1)\\n        \\n    def update(self, index, value):\\n        index += 1\\n        while index < len(self.bit):\\n            self.bit[index] += value\\n            index += index & -index\\n        \\n    def query(self, index):\\n        index += 1\\n        value = 0\\n        while index > 0:\\n            value += self.bit[index]\\n            index -= index & -index\\n        return value\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        # Fenwick tree\\n        n = len(num)\\n        tree = BIT(n)\\n        queues = defaultdict(lambda:deque([]))\\n        for i,j in enumerate(num):\\n            queues[int(j)].append(i)\\n        used = set()\\n        ans = \\'\\'\\n        while k > 0 and len(ans) < n:\\n            for digit in range(10):\\n                if digit not in queues:\\n                    continue\\n                i = queues[digit][0]\\n                cost = i - tree.query(i-1)\\n                if cost > k:\\n                    continue\\n                queues[digit].popleft()\\n                if not queues[digit]:\\n                    del queues[digit]\\n                k -= cost\\n                tree.update(i,1)\\n                used.add(i)\\n                ans += num[i]\\n                break\\n                \\n        for i,j in enumerate(num):\\n            if i not in used:\\n                ans += j\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \"\"\"O(n^2) TLE\"\"\"\\n        i, size = 0, len(num)\\n        while k > 0 and i < size:\\n            mini = num[i]\\n            j_mini = i\\n            for j in range(i,min(i+k+1,size)):\\n                if num[j]<mini:\\n                    mini = num[j]\\n                    j_mini = j\\n            k -= (j_mini - i)\\n            num = num[:i] + mini + num[i:j_mini] + num[j_mini+1:]\\n            i += 1\\n        return num\\n```\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.bit = [0]*(n+1)\\n        \\n    def update(self, index, value):\\n        index += 1\\n        while index < len(self.bit):\\n            self.bit[index] += value\\n            index += index & -index\\n        \\n    def query(self, index):\\n        index += 1\\n        value = 0\\n        while index > 0:\\n            value += self.bit[index]\\n            index -= index & -index\\n        return value\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        # Fenwick tree\\n        n = len(num)\\n        tree = BIT(n)\\n        queues = defaultdict(lambda:deque([]))\\n        for i,j in enumerate(num):\\n            queues[int(j)].append(i)\\n        used = set()\\n        ans = \\'\\'\\n        while k > 0 and len(ans) < n:\\n            for digit in range(10):\\n                if digit not in queues:\\n                    continue\\n                i = queues[digit][0]\\n                cost = i - tree.query(i-1)\\n                if cost > k:\\n                    continue\\n                queues[digit].popleft()\\n                if not queues[digit]:\\n                    del queues[digit]\\n                k -= cost\\n                tree.update(i,1)\\n                used.add(i)\\n                ans += num[i]\\n                break\\n                \\n        for i,j in enumerate(num):\\n            if i not in used:\\n                ans += j\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977611,
                "title": "java-solution",
                "content": "java\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k) {\\n        if(k==0 || I==ca.length)\\n            return ;\\n        int min=ca[I], minindex=I;\\n        for(int i=I+1;i<Math.min( I+k+1, ca.length);i++) {\\n            \\n            if(ca[i]<min) {\\n                min=ca[i];\\n                minindex=i;\\n            }\\n        }\\n        char temp=ca[minindex];\\n        \\n        for(int i=minindex;i>I;i--) {\\n            ca[i]=ca[i-1];\\n        }\\n        ca[I]=temp;\\n        helper(ca, I+1, k-(minindex-I));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        char[] ca = num.toCharArray();\\n        helper(ca, 0, k);\\n        return new String(ca);\\n    }\\n    \\n    public void helper(char[] ca, int I, int k) {\\n        if(k==0 || I==ca.length)\\n            return ;\\n        int min=ca[I], minindex=I;\\n        for(int i=I+1;i<Math.min( I+k+1, ca.length);i++) {\\n            \\n            if(ca[i]<min) {\\n                min=ca[i];\\n                minindex=i;\\n            }\\n        }\\n        char temp=ca[minindex];\\n        \\n        for(int i=minindex;i>I;i--) {\\n            ca[i]=ca[i-1];\\n        }\\n        ca[I]=temp;\\n        helper(ca, I+1, k-(minindex-I));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800836,
                "title": "c-fenwick-tree-o-n-log-n",
                "content": "```\\nclass FenwickTree\\n{\\n public:\\n    explicit FenwickTree(int size)\\n        : arr(size + 1, 0)\\n    {\\n    }\\n    \\n    int get(int index)\\n    {\\n        ++index;\\n        int value = 0;\\n        \\n        while (index)\\n        {\\n            value += arr[index];\\n            index -= index & (-index);\\n        }\\n        \\n        return value;\\n    }\\n    \\n    void set(int index)\\n    {\\n        ++index;\\n        \\n        while (index < arr.size())\\n        {\\n            ++arr[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> arr;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) \\n    {\\n        vector<deque<int>> indexes(10, deque<int>());\\n        string result;\\n        FenwickTree tree(num.size());\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n            indexes[num[i] - \\'0\\'].push_back(i);\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n        {\\n            auto digit = num[i] - \\'0\\';\\n            \\n            if (indexes[digit].empty() || indexes[digit].front() != i)\\n                continue;\\n            \\n            indexes[digit].pop_front();\\n           \\n            for (int d = 0; d < digit; ++d)\\n            {\\n                if (!indexes[d].empty() && indexes[d].front() - i - \\n                    tree.get(indexes[d].front()) + tree.get(i) <= k)\\n                {\\n                    k -= indexes[d].front() - i - \\n                        tree.get(indexes[d].front()) + tree.get(i);\\n                    \\n                    tree.set(indexes[d].front());\\n                    \\n                    indexes[d].pop_front();\\n                    result += (char)(d-- + \\'0\\');\\n                }\\n            }\\n            \\n            result += num[i];\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FenwickTree\\n{\\n public:\\n    explicit FenwickTree(int size)\\n        : arr(size + 1, 0)\\n    {\\n    }\\n    \\n    int get(int index)\\n    {\\n        ++index;\\n        int value = 0;\\n        \\n        while (index)\\n        {\\n            value += arr[index];\\n            index -= index & (-index);\\n        }\\n        \\n        return value;\\n    }\\n    \\n    void set(int index)\\n    {\\n        ++index;\\n        \\n        while (index < arr.size())\\n        {\\n            ++arr[index];\\n            index += index & (-index);\\n        }\\n    }\\n    \\nprivate:\\n    vector<int> arr;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) \\n    {\\n        vector<deque<int>> indexes(10, deque<int>());\\n        string result;\\n        FenwickTree tree(num.size());\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n            indexes[num[i] - \\'0\\'].push_back(i);\\n        \\n        for (int i = 0; i < num.size(); ++i)\\n        {\\n            auto digit = num[i] - \\'0\\';\\n            \\n            if (indexes[digit].empty() || indexes[digit].front() != i)\\n                continue;\\n            \\n            indexes[digit].pop_front();\\n           \\n            for (int d = 0; d < digit; ++d)\\n            {\\n                if (!indexes[d].empty() && indexes[d].front() - i - \\n                    tree.get(indexes[d].front()) + tree.get(i) <= k)\\n                {\\n                    k -= indexes[d].front() - i - \\n                        tree.get(indexes[d].front()) + tree.get(i);\\n                    \\n                    tree.set(indexes[d].front());\\n                    \\n                    indexes[d].pop_front();\\n                    result += (char)(d-- + \\'0\\');\\n                }\\n            }\\n            \\n            result += num[i];\\n        }\\n       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727273,
                "title": "java-fenwick-tree-o-nlogn-solution",
                "content": "Video:\\nhttps://www.youtube.com/watch?v=GYin0E1ENWM\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        FenwickTree ft = new FenwickTree(n);\\n        for(int i = 0; i < n; i++) {\\n            ft.update(i, 1);\\n        }\\n        Queue[] arr = new Queue[10];\\n        for(int i = 0; i < 10; i++) arr[i] = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            arr[num.charAt(i) - \\'0\\'].offer(i);\\n        }\\n        int idx = 0;\\n        String res = \"\";\\n        while(idx < n) {\\n            for(int i = 0; i < 10; i++) {\\n                if(arr[i].size() > 0) {\\n                    int bestIdx = (int)arr[i].peek();\\n                    int cost = ft.getSum(bestIdx) - 1;\\n                    if(cost <= k) {\\n                        res += (char)(\\'0\\' + i);\\n                        arr[i].poll();\\n                        k -= cost;\\n                        if(bestIdx < n - 1) ft.update(bestIdx + 1, -1);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            idx += 1;\\n        }\\n        return res;  \\n    }\\n}\\n\\nclass FenwickTree {\\n    int[] tree;\\n    public FenwickTree(int n) {\\n        this.tree = new int[n + 1];\\n    }\\n    \\n    private int getNext(int x) {\\n        return x + (x & (-x));\\n    }\\n    \\n    private int getParent(int x) {\\n        return x - (x & (-x));\\n    }\\n    \\n    public void update(int idx, int diff) {\\n        idx += 1;\\n        while(idx < tree.length) {\\n            tree[idx] += diff;\\n            idx = getNext(idx);\\n        }\\n        return;\\n    }\\n    \\n    public int getSum(int idx) {\\n        idx += 1;\\n        int sum = 0;\\n        while(idx > 0) {\\n            sum += tree[idx];\\n            idx = getParent(idx);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        FenwickTree ft = new FenwickTree(n);\\n        for(int i = 0; i < n; i++) {\\n            ft.update(i, 1);\\n        }\\n        Queue[] arr = new Queue[10];\\n        for(int i = 0; i < 10; i++) arr[i] = new LinkedList<>();\\n        for(int i = 0; i < n; i++) {\\n            arr[num.charAt(i) - \\'0\\'].offer(i);\\n        }\\n        int idx = 0;\\n        String res = \"\";\\n        while(idx < n) {\\n            for(int i = 0; i < 10; i++) {\\n                if(arr[i].size() > 0) {\\n                    int bestIdx = (int)arr[i].peek();\\n                    int cost = ft.getSum(bestIdx) - 1;\\n                    if(cost <= k) {\\n                        res += (char)(\\'0\\' + i);\\n                        arr[i].poll();\\n                        k -= cost;\\n                        if(bestIdx < n - 1) ft.update(bestIdx + 1, -1);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            idx += 1;\\n        }\\n        return res;  \\n    }\\n}\\n\\nclass FenwickTree {\\n    int[] tree;\\n    public FenwickTree(int n) {\\n        this.tree = new int[n + 1];\\n    }\\n    \\n    private int getNext(int x) {\\n        return x + (x & (-x));\\n    }\\n    \\n    private int getParent(int x) {\\n        return x - (x & (-x));\\n    }\\n    \\n    public void update(int idx, int diff) {\\n        idx += 1;\\n        while(idx < tree.length) {\\n            tree[idx] += diff;\\n            idx = getNext(idx);\\n        }\\n        return;\\n    }\\n    \\n    public int getSum(int idx) {\\n        idx += 1;\\n        int sum = 0;\\n        while(idx > 0) {\\n            sum += tree[idx];\\n            idx = getParent(idx);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723148,
                "title": "python-o-nogn-bit-fenwicktree-solution",
                "content": "`BIT` :  to get number of elements shifted before processing index\\n`ind`  :  to store occurence of digit\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def update(ind,bit):\\n            ind=ind+1\\n            while ind<len(bit):\\n                bit[ind]+=1\\n                ind += (ind&-ind)\\n        \\n        def getSum(ind,bit):\\n            ind+=1\\n            res=0\\n            while ind>0:\\n                res+=bit[ind]\\n                ind-=(ind&-ind)\\n            return res\\n        \\n        bit = [0]*(1+len(num))\\n        \\n        ind = {i:deque([]) for i in range(10)}\\n        for i,n in enumerate(num):\\n            ind[int(n)].append(i)\\n        res = []\\n        for i in range(len(num)):\\n            for dig in range(10):\\n                if ind[dig]:\\n                    pos = ind[dig][0]\\n                    dist = pos-getSum(pos,bit)\\n                    if dist<=k:\\n                        k-=dist\\n                        res.append(str(dig))\\n                        ind[dig].popleft()\\n                        update(pos,bit)\\n                        break\\n                        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def update(ind,bit):\\n            ind=ind+1\\n            while ind<len(bit):\\n                bit[ind]+=1\\n                ind += (ind&-ind)\\n        \\n        def getSum(ind,bit):\\n            ind+=1\\n            res=0\\n            while ind>0:\\n                res+=bit[ind]\\n                ind-=(ind&-ind)\\n            return res\\n        \\n        bit = [0]*(1+len(num))\\n        \\n        ind = {i:deque([]) for i in range(10)}\\n        for i,n in enumerate(num):\\n            ind[int(n)].append(i)\\n        res = []\\n        for i in range(len(num)):\\n            for dig in range(10):\\n                if ind[dig]:\\n                    pos = ind[dig][0]\\n                    dist = pos-getSum(pos,bit)\\n                    if dist<=k:\\n                        k-=dist\\n                        res.append(str(dig))\\n                        ind[dig].popleft()\\n                        update(pos,bit)\\n                        break\\n                        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723146,
                "title": "c-o-n-count-the-used-index",
                "content": "The ituition of the problem is to collect the smallest reachable number iteratively.\\nObviously, Greedy method will be used by looping from 0 to 9, and check if any index reachable.\\n\\nThere are several ways to check if the index is reachable.\\nThe straightfoward way is to loop and find number within K, by recording if the index is used. This will be O(N\\\\*N) and TLE.\\nThis can also be implemented by the elegant Fenwick tree. By updating/querying the used count before the index in O(logN), this solution will be accepted in O(NlogN)\\n\\n\\nHere I proposed the alternative solution of O(N). \\n\\nWhen we look into the chosing history of one number, the used count before the index is  increasing.\\nTherefore we can record the used count before the next candidate (smallest index) of number 0-9.\\nWe update all the other 9 skipped counts after chosing a number. We will find the next candidate index and update the skip count for the chosen number.\\n \\n[main variables]\\n  \\\\- Used[i] : to check if the num[i] is used\\n \\\\- NextIndex[n] : next index of specific number n\\n \\\\- Skipped[n] : total skipped count before next candidate NextIndex[n]\\n\\n```\\nclass Solution {\\nprivate:\\n    int N;\\n    void Update(string& num, vector<int>& NextIndex, vector<int>& Skipped, vector<bool>& Used, int n) {\\n        int idx = NextIndex[n];\\n        \\n        // update the Skipped arrays except n\\n        for (int i = 0; i < 10; i++) {\\n            if (NextIndex[i] > idx)\\n                Skipped[i]++;\\n        }\\n        Used[idx] = true;\\n        NextIndex[n] = -1;\\n        \\n        // update the Skipped array of n\\n        for (int i = idx; i < N; i++) {\\n            if (Used[i])\\n                Skipped[n]++;\\n            else if (num[i] == n + \\'0\\') {\\n                NextIndex[n] = i;\\n                break;\\n            }\\n        }\\n    }\\n\\npublic:\\n    string minInteger(string num, int k) {\\n        N = num.size();\\n        vector<bool> Used(N, false);\\n        vector<int> NextIndex(10, -1);\\n        vector<int> Skipped(10, 0);\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (NextIndex[num[i] - \\'0\\'] == -1)\\n                NextIndex[num[i] - \\'0\\'] = i;\\n        }\\n        \\n        string result;\\n        int i = 0;\\n        while (i < N && k) {\\n            if (Used[i]) {\\n                i++;\\n                continue;\\n            }\\n\\n            // choose the reachable smallest number to swap\\n            int n = 0;\\n            for (; n < 10; n++) {\\n                if (NextIndex[n] == -1)\\n                    continue;\\n                \\n                if (NextIndex[n] - Skipped[n] <= k) {\\n                    k -= (NextIndex[n] - Skipped[n]);\\n                    break;\\n                }\\n            }\\n            \\n            if (n == 10) {              // no swap\\n                n = num[i] - \\'0\\';\\n                i++;\\n            }\\n\\n            result.push_back(n + \\'0\\');\\n            Update(num, NextIndex, Skipped, Used, n);\\n        }\\n        \\n        for (; i < N; i++) {\\n            if (!Used[i])\\n                result.push_back(num[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N;\\n    void Update(string& num, vector<int>& NextIndex, vector<int>& Skipped, vector<bool>& Used, int n) {\\n        int idx = NextIndex[n];\\n        \\n        // update the Skipped arrays except n\\n        for (int i = 0; i < 10; i++) {\\n            if (NextIndex[i] > idx)\\n                Skipped[i]++;\\n        }\\n        Used[idx] = true;\\n        NextIndex[n] = -1;\\n        \\n        // update the Skipped array of n\\n        for (int i = idx; i < N; i++) {\\n            if (Used[i])\\n                Skipped[n]++;\\n            else if (num[i] == n + \\'0\\') {\\n                NextIndex[n] = i;\\n                break;\\n            }\\n        }\\n    }\\n\\npublic:\\n    string minInteger(string num, int k) {\\n        N = num.size();\\n        vector<bool> Used(N, false);\\n        vector<int> NextIndex(10, -1);\\n        vector<int> Skipped(10, 0);\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (NextIndex[num[i] - \\'0\\'] == -1)\\n                NextIndex[num[i] - \\'0\\'] = i;\\n        }\\n        \\n        string result;\\n        int i = 0;\\n        while (i < N && k) {\\n            if (Used[i]) {\\n                i++;\\n                continue;\\n            }\\n\\n            // choose the reachable smallest number to swap\\n            int n = 0;\\n            for (; n < 10; n++) {\\n                if (NextIndex[n] == -1)\\n                    continue;\\n                \\n                if (NextIndex[n] - Skipped[n] <= k) {\\n                    k -= (NextIndex[n] - Skipped[n]);\\n                    break;\\n                }\\n            }\\n            \\n            if (n == 10) {              // no swap\\n                n = num[i] - \\'0\\';\\n                i++;\\n            }\\n\\n            result.push_back(n + \\'0\\');\\n            Update(num, NextIndex, Skipped, Used, n);\\n        }\\n        \\n        for (; i < N; i++) {\\n            if (!Used[i])\\n                result.push_back(num[i]);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721944,
                "title": "c-o-n-log-n-fenwick-tree-solution-inspired-by-awice",
                "content": "You can watch his full explanation starting at 33:47: https://www.youtube.com/watch?v=pO_TtGTe6GQ\\n```\\nclass FenwickTree {\\nprivate:\\n    vector<int> arr; \\n\\npublic:\\n    FenwickTree(int n) {\\n        n++;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    void add(int index, const int num) {\\n        index++;\\n        while (index < static_cast<int>(arr.size())) {\\n            arr[index] += num;\\n            index += (~index + 1) & index; \\n        }\\n    }\\n    \\n    int getPrefixSum(int index) const {\\n        int sum = 0;\\n        index++;\\n        while (index > 0) {\\n            sum += arr[index];\\n            index -= (~index + 1) & index; \\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        FenwickTree tree(n);\\n        vector<int> numArr(n);\\n        for (int i = 0; i < n; i++) {\\n            numArr[i] = num[i] - \\'0\\';\\n        }\\n        unordered_map<int,vector<int>> indexMap;\\n        for (int i = 0; i < n; i++) {\\n            if (indexMap.count(numArr[i]) == 0) {\\n                indexMap[numArr[i]] = {i};\\n            }\\n            else {\\n                indexMap[numArr[i]].push_back(i);\\n            }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n            if (indexMap.count(i) != 0) {\\n                reverse(indexMap[i].begin(), indexMap[i].end());\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            int i;\\n            for (i = 0; i < 10; i++) {\\n                if (indexMap.count(i) == 0) {\\n                    continue;\\n                }\\n                int leftMostIndex = indexMap[i].back();\\n                int usedIndices = tree.getPrefixSum(leftMostIndex);\\n                int rank = leftMostIndex - usedIndices;\\n                if (rank <= k) {\\n                    k -= rank;\\n                    res.push_back(i + \\'0\\');\\n                    indexMap[i].pop_back();\\n                    if (indexMap[i].empty()) {\\n                        indexMap.erase(i);\\n                    }\\n                    tree.add(leftMostIndex, 1);\\n                    break;\\n                }\\n            }\\n            if (i == 10) {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> remaining;\\n        for (auto& [digit,row] : indexMap) {\\n            for (int i : row) {\\n                remaining.push_back({i,digit});\\n            }\\n        }\\n        sort(remaining.begin(), remaining.end(), \\n            [](const vector<int>& a, const vector<int>& b) -> bool\\n        { \\n            return a[0] < b[0]; \\n        });\\n        for (vector<int>& entry : remaining) {\\n            res.push_back(entry[1] + \\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```\\nHaven\\'t write C++ in a while. So please forgive me if there are any stylistic issues...",
                "solutionTags": [],
                "code": "```\\nclass FenwickTree {\\nprivate:\\n    vector<int> arr; \\n\\npublic:\\n    FenwickTree(int n) {\\n        n++;\\n        arr = vector<int>(n, 0);\\n    }\\n    \\n    void add(int index, const int num) {\\n        index++;\\n        while (index < static_cast<int>(arr.size())) {\\n            arr[index] += num;\\n            index += (~index + 1) & index; \\n        }\\n    }\\n    \\n    int getPrefixSum(int index) const {\\n        int sum = 0;\\n        index++;\\n        while (index > 0) {\\n            sum += arr[index];\\n            index -= (~index + 1) & index; \\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        FenwickTree tree(n);\\n        vector<int> numArr(n);\\n        for (int i = 0; i < n; i++) {\\n            numArr[i] = num[i] - \\'0\\';\\n        }\\n        unordered_map<int,vector<int>> indexMap;\\n        for (int i = 0; i < n; i++) {\\n            if (indexMap.count(numArr[i]) == 0) {\\n                indexMap[numArr[i]] = {i};\\n            }\\n            else {\\n                indexMap[numArr[i]].push_back(i);\\n            }\\n        }\\n        for (int i = 0; i < 10; i++) {\\n            if (indexMap.count(i) != 0) {\\n                reverse(indexMap[i].begin(), indexMap[i].end());\\n            }\\n        }\\n        string res = \"\";\\n        while (k > 0) {\\n            int i;\\n            for (i = 0; i < 10; i++) {\\n                if (indexMap.count(i) == 0) {\\n                    continue;\\n                }\\n                int leftMostIndex = indexMap[i].back();\\n                int usedIndices = tree.getPrefixSum(leftMostIndex);\\n                int rank = leftMostIndex - usedIndices;\\n                if (rank <= k) {\\n                    k -= rank;\\n                    res.push_back(i + \\'0\\');\\n                    indexMap[i].pop_back();\\n                    if (indexMap[i].empty()) {\\n                        indexMap.erase(i);\\n                    }\\n                    tree.add(leftMostIndex, 1);\\n                    break;\\n                }\\n            }\\n            if (i == 10) {\\n                break;\\n            }\\n        }\\n        vector<vector<int>> remaining;\\n        for (auto& [digit,row] : indexMap) {\\n            for (int i : row) {\\n                remaining.push_back({i,digit});\\n            }\\n        }\\n        sort(remaining.begin(), remaining.end(), \\n            [](const vector<int>& a, const vector<int>& b) -> bool\\n        { \\n            return a[0] < b[0]; \\n        });\\n        for (vector<int>& entry : remaining) {\\n            res.push_back(entry[1] + \\'0\\');\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720607,
                "title": "c-greedy-with-index-preprocessing",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        std::vector<std::vector<int>> digit_to_inds(10);\\n        std::vector<int> voids; // locations that are empty, no price to pay\\n        for (int i = num.size() - 1; i >= 0; --i) {\\n            digit_to_inds[static_cast<int>(num[i] - \\'0\\')].push_back(i);\\n        }       \\n        constexpr char VOID_MARK = \\'X\\';\\n        int reserved = k;\\n        std::vector<int> res;\\n        while ((reserved > 0) && (res.size() < num.size())) {\\n            for (int d = 0; d <= 9; ++d) {\\n                auto &inds = digit_to_inds[d];\\n                if (inds.empty()) {\\n                    continue;\\n                }\\n                const int i = inds.back(); // smallest index for `d`\\n                // There were `j` elements prior to the index `i`\\n                // removed from `num`. There\\'s no need to swap with them.\\n                const int j = std::distance(\\n                    voids.begin(), \\n                    std::lower_bound(voids.begin(), voids.end(), i)\\n                );\\n\\t\\t\\t\\t// Number of swap ops needed to bubble this to top.\\n                const int price = i - 0 - j;\\n                if (price > reserved) {\\n                    continue;\\n                }\\n                // Housekeeping.\\n                reserved -= price;\\n                res.push_back(d);\\n                voids.insert(voids.begin() + j, i);      \\n                num[i] = VOID_MARK;\\n                inds.pop_back();\\n                break;\\n            }\\n        }\\n\\t\\t// Results come from the elements pushed to `res`, \\n\\t\\t// as well as the remaining ones in `num`.\\n        std::stringstream ss;\\n        for (int d : res) {\\n            ss << d;\\n        }\\n        for (char ch : num) {\\n            if (ch != VOID_MARK) {\\n                ss << ch;\\n            }\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        std::vector<std::vector<int>> digit_to_inds(10);\\n        std::vector<int> voids; // locations that are empty, no price to pay\\n        for (int i = num.size() - 1; i >= 0; --i) {\\n            digit_to_inds[static_cast<int>(num[i] - \\'0\\')].push_back(i);\\n        }       \\n        constexpr char VOID_MARK = \\'X\\';\\n        int reserved = k;\\n        std::vector<int> res;\\n        while ((reserved > 0) && (res.size() < num.size())) {\\n            for (int d = 0; d <= 9; ++d) {\\n                auto &inds = digit_to_inds[d];\\n                if (inds.empty()) {\\n                    continue;\\n                }\\n                const int i = inds.back(); // smallest index for `d`\\n                // There were `j` elements prior to the index `i`\\n                // removed from `num`. There\\'s no need to swap with them.\\n                const int j = std::distance(\\n                    voids.begin(), \\n                    std::lower_bound(voids.begin(), voids.end(), i)\\n                );\\n\\t\\t\\t\\t// Number of swap ops needed to bubble this to top.\\n                const int price = i - 0 - j;\\n                if (price > reserved) {\\n                    continue;\\n                }\\n                // Housekeeping.\\n                reserved -= price;\\n                res.push_back(d);\\n                voids.insert(voids.begin() + j, i);      \\n                num[i] = VOID_MARK;\\n                inds.pop_back();\\n                break;\\n            }\\n        }\\n\\t\\t// Results come from the elements pushed to `res`, \\n\\t\\t// as well as the remaining ones in `num`.\\n        std::stringstream ss;\\n        for (int d : res) {\\n            ss << d;\\n        }\\n        for (char ch : num) {\\n            if (ch != VOID_MARK) {\\n                ss << ch;\\n            }\\n        }\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720338,
                "title": "python-bisect-o-nlgn-pass-so-hard",
                "content": "\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\n\\t\\t\\tnum = list(num)\\n\\t\\t\\tsmall = sorted(list(num))\\n\\n\\t\\t\\tif k > len(num) ** 2:\\n\\t\\t\\t\\treturn \\'\\'.join(small)\\n\\n\\t\\t\\td = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\td[num[i]].append(i)\\n\\n\\t\\t\\tindexs = []\\n\\t\\t\\tfor char in sorted(d.keys()):\\n\\t\\t\\t\\tindexs += d[char]\\n\\n\\t\\t\\tdone = []\\n\\t\\t\\thead = 0\\n\\n\\t\\t\\twhile k > 0 and indexs:\\n\\t\\t\\t\\tif num == small:\\n\\t\\t\\t\\t\\treturn \\'\\'.join(num)\\n\\t\\t\\t\\tfor i in range(len(indexs)):\\n\\t\\t\\t\\t\\tpre = bisect.bisect(done, indexs[i])\\n\\t\\t\\t\\t\\tnewi = indexs[i] + len(done) - pre\\n\\t\\t\\t\\t\\tif newi >= head and newi - head <= k:\\n\\t\\t\\t\\t\\t\\tbisect.insort(done, indexs[i])\\n\\t\\t\\t\\t\\t\\tnum = num[:head] + [num[newi]] + num[head:newi] + num[newi + 1:]\\n\\t\\t\\t\\t\\t\\tk -= newi - head\\n\\t\\t\\t\\t\\t\\thead += 1\\n\\t\\t\\t\\t\\t\\tindexs.pop(i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn \\'\\'.join(num)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\n\\t\\t\\tnum = list(num)\\n\\t\\t\\tsmall = sorted(list(num))\\n\\n\\t\\t\\tif k > len(num) ** 2:\\n\\t\\t\\t\\treturn \\'\\'.join(small)\\n\\n\\t\\t\\td = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\td[num[i]].append(i)\\n\\n\\t\\t\\tindexs = []\\n\\t\\t\\tfor char in sorted(d.keys()):\\n\\t\\t\\t\\tindexs += d[char]\\n\\n\\t\\t\\tdone = []\\n\\t\\t\\thead = 0\\n\\n\\t\\t\\twhile k > 0 and indexs:\\n\\t\\t\\t\\tif num == small:\\n\\t\\t\\t\\t\\treturn \\'\\'.join(num)\\n\\t\\t\\t\\tfor i in range(len(indexs)):\\n\\t\\t\\t\\t\\tpre = bisect.bisect(done, indexs[i])\\n\\t\\t\\t\\t\\tnewi = indexs[i] + len(done) - pre\\n\\t\\t\\t\\t\\tif newi >= head and newi - head <= k:\\n\\t\\t\\t\\t\\t\\tbisect.insort(done, indexs[i])\\n\\t\\t\\t\\t\\t\\tnum = num[:head] + [num[newi]] + num[head:newi] + num[newi + 1:]\\n\\t\\t\\t\\t\\t\\tk -= newi - head\\n\\t\\t\\t\\t\\t\\thead += 1\\n\\t\\t\\t\\t\\t\\tindexs.pop(i)\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn \\'\\'.join(num)",
                "codeTag": "Java"
            },
            {
                "id": 720337,
                "title": "python-nlogn-using-binary-index-tree",
                "content": "Well.. the average performance should be NlogN, but it is hard to prove whether the worst case still holds. Anyway, I still share my solution.\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\ndef getsum(tree, i): \\n    s = 0\\n    i += 1\\n    while i > 0: \\n        s += tree[i] \\n        i -= i & (-i) \\n    return s \\n  \\n# modify the value from the original one,\\n# v is diff/increment.\\ndef update(tree, i ,v): \\n    i += 1\\n    while i < len(tree): \\n        tree[i] += v \\n        i += i & (-i)\\n        \\ndef construct(arr): \\n    tree = [0] * (len(arr) + 1) \\n  \\n    for i in range(len(arr)): \\n        update(tree, i, arr[i]) \\n\\n    return tree \\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        pq = []\\n        ans = []\\n        \\n        # the input array looks like [0, 1,1,1,1,...]\\n        tree = construct([0] + [1] * len(num))\\n        \\n\\n        used = set()\\n        # a heap to store un-unsed indices\\n        wait_queue = list(range(len(num)))\\n        heapify(wait_queue)\\n        \\n        \\n        while k > 0:\\n            # getsum(tree, idx) is to get the actual index of an element whose original index\\n            # is idx.\\n            while len(wait_queue) > 0 and getsum(tree, wait_queue[0]) <= len(ans) + k: \\n                idx = heappop(wait_queue)\\n                heappush(pq, (num[idx], idx))\\n                \\n            if len(pq) == 0:\\n                break\\n            ch, i = heappop(pq)\\n            \\n            \\n            cost = getsum(tree, i) - len(ans)\\n            if cost > k:\\n                heappush(wait_queue, i)\\n                continue\\n                \\n            k -= cost\\n            \\n            # move the one from i and add to zero.\\n            update(tree, i + 1, -1)\\n            update(tree, 0, 1)    \\n            \\n            \\n            ans.append(ch)\\n            used.add(i)\\n            \\n        for i, ch in enumerate(num):\\n            if i not in used:\\n                ans.append(ch)\\n        \\n        return \"\".join(ans)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\ndef getsum(tree, i): \\n    s = 0\\n    i += 1\\n    while i > 0: \\n        s += tree[i] \\n        i -= i & (-i) \\n    return s \\n  \\n# modify the value from the original one,\\n# v is diff/increment.\\ndef update(tree, i ,v): \\n    i += 1\\n    while i < len(tree): \\n        tree[i] += v \\n        i += i & (-i)\\n        \\ndef construct(arr): \\n    tree = [0] * (len(arr) + 1) \\n  \\n    for i in range(len(arr)): \\n        update(tree, i, arr[i]) \\n\\n    return tree \\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        pq = []\\n        ans = []\\n        \\n        # the input array looks like [0, 1,1,1,1,...]\\n        tree = construct([0] + [1] * len(num))\\n        \\n\\n        used = set()\\n        # a heap to store un-unsed indices\\n        wait_queue = list(range(len(num)))\\n        heapify(wait_queue)\\n        \\n        \\n        while k > 0:\\n            # getsum(tree, idx) is to get the actual index of an element whose original index\\n            # is idx.\\n            while len(wait_queue) > 0 and getsum(tree, wait_queue[0]) <= len(ans) + k: \\n                idx = heappop(wait_queue)\\n                heappush(pq, (num[idx], idx))\\n                \\n            if len(pq) == 0:\\n                break\\n            ch, i = heappop(pq)\\n            \\n            \\n            cost = getsum(tree, i) - len(ans)\\n            if cost > k:\\n                heappush(wait_queue, i)\\n                continue\\n                \\n            k -= cost\\n            \\n            # move the one from i and add to zero.\\n            update(tree, i + 1, -1)\\n            update(tree, 0, 1)    \\n            \\n            \\n            ans.append(ch)\\n            used.add(i)\\n            \\n        for i, ch in enumerate(num):\\n            if i not in used:\\n                ans.append(ch)\\n        \\n        return \"\".join(ans)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 720191,
                "title": "python-o-n-log-n-316ms-greedy-solution-finished-5-min-after-contest-end",
                "content": "Probably being distracted by the Independence Day fireworks, I finished coding this O(N log N) solution 5 min after the end of the weekly contest \\uD83D\\uDE2D\\n\\n\\n**O(N log N)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        ind = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            ind[int(num[i])].append(i)\\n        i = 0\\n        res = []\\n        picked = []\\n        moveright = {}\\n        for i in range(len(num) - 1):\\n            for _ in range(10):\\n                if ind[_]:\\n                    if _  not in moveright:\\n                        moveright[_] = len(picked) - bisect.bisect(picked, ind[_][-1])\\n                    if ind[_][-1] + moveright[_] - i <= k:\\n                        k -= ind[_][-1] + moveright[_] - i\\n                        insort(picked, ind[_][-1])\\n                        res.append(str(_))\\n                        ind[_].pop()\\n                        moveright.pop(_)\\n                        break\\n            if k == 0:\\n                break\\n        unpicked = []\\n        pickedset = set(picked)\\n        for i in range(len(num)):\\n            if i not in pickedset:\\n                unpicked.append(i)\\n        return \"\".join(res) + \"\".join([num[j] for j in unpicked])\\n```\\n\\n------------------------------------\\nDuring the contest I figured out two \\uFF2F(N^2) solutions (the first one is actually O(10\\\\*N^2)), but both of them result in TLE.\\n\\nI see some other posts in which their O(N^2) solutions pass the OJ. Is it because my way is recursive?  Does `newstr = \"a\" + oldstr_of_length_N` takes O(1) or O(N) time in Python? But anyway my solutions are O(N^2)\\n**O(10\\\\*N^2)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        for i in range(10):\\n            for j in range(min(k+1, len(num))):\\n                if num[j] == str(i):\\n                    return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n```\\n**O(N^2)** Solution\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        m = 10\\n        for j in range(min(k+1, len(num))):\\n            if num[j] == \"0\":\\n                return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n            if int(num[j]) < m:\\n                m = int(num[j])\\n                i = j\\n        return num[i] + self.minInteger(num[:i] + num[i+1:], k - i)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        ind = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            ind[int(num[i])].append(i)\\n        i = 0\\n        res = []\\n        picked = []\\n        moveright = {}\\n        for i in range(len(num) - 1):\\n            for _ in range(10):\\n                if ind[_]:\\n                    if _  not in moveright:\\n                        moveright[_] = len(picked) - bisect.bisect(picked, ind[_][-1])\\n                    if ind[_][-1] + moveright[_] - i <= k:\\n                        k -= ind[_][-1] + moveright[_] - i\\n                        insort(picked, ind[_][-1])\\n                        res.append(str(_))\\n                        ind[_].pop()\\n                        moveright.pop(_)\\n                        break\\n            if k == 0:\\n                break\\n        unpicked = []\\n        pickedset = set(picked)\\n        for i in range(len(num)):\\n            if i not in pickedset:\\n                unpicked.append(i)\\n        return \"\".join(res) + \"\".join([num[j] for j in unpicked])\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        for i in range(10):\\n            for j in range(min(k+1, len(num))):\\n                if num[j] == str(i):\\n                    return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) == 1 or k == 0:\\n            return num\\n        m = 10\\n        for j in range(min(k+1, len(num))):\\n            if num[j] == \"0\":\\n                return num[j] + self.minInteger(num[:j] + num[j+1:], k - j)\\n            if int(num[j]) < m:\\n                m = int(num[j])\\n                i = j\\n        return num[i] + self.minInteger(num[:i] + num[i+1:], k - i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003143,
                "title": "very-easy-c-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n- O(3*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string s, int k) {\\n        int n=s.size();\\n        vector<int> prefix(n,0),prefix1(n,0),visited(n,0);\\n        string ans=\"\";\\n        int cnt;\\n        bool tp=false;\\n        int current=n;\\n        for(int i=0;i<9;i++){\\n            cnt=0;\\n        for(int j=0;j<n;j++){\\n            if(current<j)break;\\n            if(s[j]==(i+\\'0\\')){\\n                if((j-prefix1[j]-cnt)<=k){\\n                prefix[j]++;\\n                // cout<<prefix1[j]<<\" \"<<i<<\" \"<<cnt<<endl;\\n                k-=(j-prefix1[j]-cnt);\\n                ans+=s[j];\\n                visited[j]=1;\\n                cnt++;\\n                // cout<<k<<\" \"<<i<<endl;\\n                }\\n                else{\\n                    // tp=true;\\n                    current=j;\\n                    break;\\n                }\\n                // else{\\n\\n                // }\\n            }\\n        }\\n        // if(tp)break;\\n            prefix1=prefix;\\n            for(int j=1;j<n;j++){\\n                prefix1[j]+=prefix1[j-1];\\n            }\\n        }\\n        cout<<k<<\" \";\\n        for(int i=0;i<n;i++){\\n           if(!visited[i]){\\n               ans+=s[i];\\n           }\\n        }\\n        cout<<ans<<endl;\\n        for(int i=0;i<n-1;i++){\\n            if(ans[i]>ans[i+1]){\\n                current=i+1;\\n                break;\\n            }\\n        }\\n        // cout<<current<<\" \";\\n        while(current!=n && current>0 && k>0){\\n            swap(ans[current],ans[current-1]);\\n            current--;\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string s, int k) {\\n        int n=s.size();\\n        vector<int> prefix(n,0),prefix1(n,0),visited(n,0);\\n        string ans=\"\";\\n        int cnt;\\n        bool tp=false;\\n        int current=n;\\n        for(int i=0;i<9;i++){\\n            cnt=0;\\n        for(int j=0;j<n;j++){\\n            if(current<j)break;\\n            if(s[j]==(i+\\'0\\')){\\n                if((j-prefix1[j]-cnt)<=k){\\n                prefix[j]++;\\n                // cout<<prefix1[j]<<\" \"<<i<<\" \"<<cnt<<endl;\\n                k-=(j-prefix1[j]-cnt);\\n                ans+=s[j];\\n                visited[j]=1;\\n                cnt++;\\n                // cout<<k<<\" \"<<i<<endl;\\n                }\\n                else{\\n                    // tp=true;\\n                    current=j;\\n                    break;\\n                }\\n                // else{\\n\\n                // }\\n            }\\n        }\\n        // if(tp)break;\\n            prefix1=prefix;\\n            for(int j=1;j<n;j++){\\n                prefix1[j]+=prefix1[j-1];\\n            }\\n        }\\n        cout<<k<<\" \";\\n        for(int i=0;i<n;i++){\\n           if(!visited[i]){\\n               ans+=s[i];\\n           }\\n        }\\n        cout<<ans<<endl;\\n        for(int i=0;i<n-1;i++){\\n            if(ans[i]>ans[i+1]){\\n                current=i+1;\\n                break;\\n            }\\n        }\\n        // cout<<current<<\" \";\\n        while(current!=n && current>0 && k>0){\\n            swap(ans[current],ans[current-1]);\\n            current--;\\n            k--;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4002027,
                "title": "bit-commented-queue",
                "content": "****Binary Indexed Tree (BIT):\\n****\\nPurpose: The Binary Indexed Tree, also known as a Fenwick Tree, is used to efficiently perform prefix sum queries and updates. It helps keep track of the number of digits that have been removed from the original string, which is essential for selecting and processing digits during the optimization process.\\nHow It\\'s Used:\\nThe BIT is initialized with a size of \\'n+1,\\' where \\'n\\' is the number of elements (positions in the string).\\nThe update method is used to increment the value at a specific index (position) by a given delta (usually 1). This operation marks that a digit has been removed from the original string.\\nThe query method is used to efficiently compute the prefix sum up to a specific index. It helps determine how many digits have been removed from positions preceding a given position.\\nQueues (qs - Vector of Queues):\\n**\\nPurpose: Queues **are used to keep track of the positions of each digit in the original string. Each queue corresponds to a digit from 0 to 9, and it stores the positions of that digit in the string.\\nHow They\\'re Used:\\nDuring the initialization of qs, each digit\\'s queue is populated with its respective positions in the original string.\\nThe queues are used to efficiently select and process digits during the process of minimizing the integer:\\nDigits that can be moved to the left-hand side (i.e., smaller digits that have sufficient available swaps) are selected from their respective queues and added to the result.\\nPositions of processed digits are marked as \"removed\" in the BIT using the update method.\\nThis process continues until \\'k\\' swaps are exhausted or no more valid swaps are possible.\\n\\n# Code\\n```\\nclass BIT {\\npublic:\\n    int n;               // Number of elements\\n    vector<int> nodes;   // Binary Indexed Tree (Fenwick Tree)\\n\\n    BIT(int n) {\\n        this->n = n;\\n        nodes = vector<int>(n + 1);  // Initialize the BIT with size (n + 1)\\n    }\\n\\n    // Function to update a value at index \\'i\\' by adding \\'delta\\'\\n    void update(int i, int delta) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        while (i <= n) {\\n            nodes[i] += delta;  // Update the BIT node at index \\'i\\' by adding \\'delta\\'\\n            i += (i & -i);     // Move to the parent node (next node with a higher significant bit)\\n        }\\n    }\\n\\n    // Function to query the prefix sum up to index \\'i\\'\\n    int query(int i) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += nodes[i];   // Accumulate the sum from the current node\\n            i -= (i & -i);    // Move to the previous node (next node with a lower significant bit)\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        BIT* tree = new BIT(n);  // Create a Binary Indexed Tree (BIT) to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->query(pos - 1);  // Query the BIT to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->update(pos, 1);  // Mark the current digit as removed in the BIT\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BIT {\\npublic:\\n    int n;               // Number of elements\\n    vector<int> nodes;   // Binary Indexed Tree (Fenwick Tree)\\n\\n    BIT(int n) {\\n        this->n = n;\\n        nodes = vector<int>(n + 1);  // Initialize the BIT with size (n + 1)\\n    }\\n\\n    // Function to update a value at index \\'i\\' by adding \\'delta\\'\\n    void update(int i, int delta) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        while (i <= n) {\\n            nodes[i] += delta;  // Update the BIT node at index \\'i\\' by adding \\'delta\\'\\n            i += (i & -i);     // Move to the parent node (next node with a higher significant bit)\\n        }\\n    }\\n\\n    // Function to query the prefix sum up to index \\'i\\'\\n    int query(int i) {\\n        ++i;  // Increment \\'i\\' to convert 0-based indexing to 1-based indexing\\n        int sum = 0;\\n        while (i > 0) {\\n            sum += nodes[i];   // Accumulate the sum from the current node\\n            i -= (i & -i);    // Move to the previous node (next node with a lower significant bit)\\n        }\\n        return sum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        BIT* tree = new BIT(n);  // Create a Binary Indexed Tree (BIT) to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->query(pos - 1);  // Query the BIT to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->update(pos, 1);  // Mark the current digit as removed in the BIT\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001961,
                "title": "commented-segment-tree-queue",
                "content": "see this for best explanation\\nhttps://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solutions/720548/o-n-logn-detailed-explanation/\\n\\nwhy\\n\\n1. **Segment Tree (`SegTree`):**\\n   - **Purpose:** The segment tree is used to keep track of which digits have been removed from the original string during the process of minimizing the integer.\\n   - **How It\\'s Used:**\\n     - The segment tree maintains information about the positions of removed digits, allowing quick queries to find the count of removed digits before a given position.\\n     - The `update` method is used to mark a position as \"removed\" in the segment tree when a digit is moved to the left-hand side of the result.\\n     - The `queryLessThan` method is used to find the count of removed digits before a specified position.\\n\\n\\nwhy\\n2. **Queues (`qs` - Vector of Queues):**\\n   - **Purpose:** Queues are used to keep track of the positions of each digit in the original string. Each queue corresponds to a digit from 0 to 9, and it stores the positions of that digit in the string.\\n   - **How They\\'re Used:**\\n     - During the initialization of `qs`, each digit\\'s queue is populated with its respective positions in the original string.\\n     - The queues are used to efficiently select and process digits during the process of minimizing the integer:\\n       - Digits that can be moved to the left-hand side (i.e., smaller digits that have sufficient available swaps) are selected from their respective queues and added to the result.\\n       - Positions of processed digits are marked as \"removed\" in the segment tree.\\n       - This process continues until \\'k\\' swaps are exhausted or no more valid swaps are possible.\\n\\nIn summary, the segment tree is employed to keep track of removed digits and efficiently answer queries about the number of removed digits before a given position. The queues are used to manage the positions of digits in the original string and facilitate the selection and processing of digits during the optimization process. Together, these data structures enable an efficient solution to the problem of minimizing the integer while respecting the swap limit \\'k\\'.\\n\\n# Code\\n```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;  // Array representing the segment tree\\n    int n;              // Number of elements in the original array\\n\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);  // Initialize the segment tree with size 4 * n\\n    }\\n\\n    // Function to update a node in the segment tree\\n    void update(int treeIdx, int l, int r, int ql, int val) {\\n        if (ql < l || ql > r) {\\n            return;  // If the query index is out of the current segment, return\\n        }\\n\\n        if (l == r) {\\n            nodes[treeIdx] += val;  // If the segment has only one element, update it and return\\n            return;\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (ql <= mid) {\\n            update((treeIdx << 1) | 1, l, mid, ql, val);  // Recursively update the left subtree\\n        } else {\\n            update((treeIdx << 1) + 2, mid + 1, r, ql, val);  // Recursively update the right subtree\\n        }\\n\\n        nodes[treeIdx] = nodes[(treeIdx << 1) | 1] + nodes[(treeIdx << 1) + 2];  // Update the current node based on child nodes\\n    }\\n\\n    // Function to increase the value at a specific index in the segment tree\\n    void increase(int ql) {\\n        update(0, 0, n - 1, ql, 1);  // Start the update process from the root of the segment tree\\n    }\\n\\n    // Function to query the sum of elements in a specific range [ql, qr] in the segment tree\\n    int query(int treeIdx, int l, int r, int ql, int qr) {\\n        if (l > qr || r < ql) {\\n            return 0;  // If the current segment is completely outside the query range, return 0\\n        }\\n\\n        if (ql <= l && r <= qr) {\\n            return nodes[treeIdx];  // If the current segment is completely inside the query range, return its value\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (qr <= mid) {\\n            return query((treeIdx << 1) | 1, l, mid, ql, qr);  // Recursively query the left subtree\\n        } else if (ql > mid) {\\n            return query((treeIdx << 1) + 2, mid + 1, r, ql, qr);  // Recursively query the right subtree\\n        }\\n\\n        // If the query range partially overlaps with both left and right subtrees\\n        int leftRes = query((treeIdx << 1) | 1, l, mid, ql, mid);  // Query the left subtree\\n        int rightRes = query((treeIdx << 1) + 2, mid + 1, r, mid + 1, qr);  // Query the right subtree\\n\\n        return leftRes + rightRes;  // Return the sum of results from both subtrees\\n    }\\n\\n    // Function to query the sum of elements less than a given value qnum in the segment tree\\n    int queryLessThan(int qnum) {\\n        return query(0, 0, n - 1, 0, qnum - 1);  // Start the query from the root with the specified query range\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        SegTree* tree = new SegTree(n);  // Create a segment tree to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->queryLessThan(pos);  // Query the segment tree to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->increase(pos);  // Mark the current digit as removed in the segment tree\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;  // Array representing the segment tree\\n    int n;              // Number of elements in the original array\\n\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);  // Initialize the segment tree with size 4 * n\\n    }\\n\\n    // Function to update a node in the segment tree\\n    void update(int treeIdx, int l, int r, int ql, int val) {\\n        if (ql < l || ql > r) {\\n            return;  // If the query index is out of the current segment, return\\n        }\\n\\n        if (l == r) {\\n            nodes[treeIdx] += val;  // If the segment has only one element, update it and return\\n            return;\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (ql <= mid) {\\n            update((treeIdx << 1) | 1, l, mid, ql, val);  // Recursively update the left subtree\\n        } else {\\n            update((treeIdx << 1) + 2, mid + 1, r, ql, val);  // Recursively update the right subtree\\n        }\\n\\n        nodes[treeIdx] = nodes[(treeIdx << 1) | 1] + nodes[(treeIdx << 1) + 2];  // Update the current node based on child nodes\\n    }\\n\\n    // Function to increase the value at a specific index in the segment tree\\n    void increase(int ql) {\\n        update(0, 0, n - 1, ql, 1);  // Start the update process from the root of the segment tree\\n    }\\n\\n    // Function to query the sum of elements in a specific range [ql, qr] in the segment tree\\n    int query(int treeIdx, int l, int r, int ql, int qr) {\\n        if (l > qr || r < ql) {\\n            return 0;  // If the current segment is completely outside the query range, return 0\\n        }\\n\\n        if (ql <= l && r <= qr) {\\n            return nodes[treeIdx];  // If the current segment is completely inside the query range, return its value\\n        }\\n\\n        int mid = (l + r) >> 1;  // Calculate the middle index of the segment\\n\\n        if (qr <= mid) {\\n            return query((treeIdx << 1) | 1, l, mid, ql, qr);  // Recursively query the left subtree\\n        } else if (ql > mid) {\\n            return query((treeIdx << 1) + 2, mid + 1, r, ql, qr);  // Recursively query the right subtree\\n        }\\n\\n        // If the query range partially overlaps with both left and right subtrees\\n        int leftRes = query((treeIdx << 1) | 1, l, mid, ql, mid);  // Query the left subtree\\n        int rightRes = query((treeIdx << 1) + 2, mid + 1, r, mid + 1, qr);  // Query the right subtree\\n\\n        return leftRes + rightRes;  // Return the sum of results from both subtrees\\n    }\\n\\n    // Function to query the sum of elements less than a given value qnum in the segment tree\\n    int queryLessThan(int qnum) {\\n        return query(0, 0, n - 1, 0, qnum - 1);  // Start the query from the root with the specified query range\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> qs(10);  // An array of queues to store positions of each digit\\n        int n = num.size();\\n\\n        // Populate queues with the positions of each digit\\n        for (int i = 0; i < n; ++i) {\\n            qs[num[i] - \\'0\\'].push(i);\\n        }\\n\\n        string lhs;  // Left-hand side of the result string\\n        vector<bool> removed(n, false);  // Indicates if a digit has been removed from the original string\\n        SegTree* tree = new SegTree(n);  // Create a segment tree to track removed digits\\n\\n        while (k > 0) {\\n            bool found = false;\\n            for (int d = 0; d <= 9; ++d) {\\n                if (!qs[d].empty()) {\\n                    int pos = qs[d].front();  // Get the position of the current digit\\n                    int shifted = tree->queryLessThan(pos);  // Query the segment tree to find the number of removed digits before pos\\n                    if (pos - shifted <= k) {\\n                        k -= pos - shifted;  // Update remaining swaps\\n                        tree->increase(pos);  // Mark the current digit as removed in the segment tree\\n                        qs[d].pop();  // Remove the position from the queue\\n                        lhs += (\\'0\\' + d);  // Append the digit to the left-hand side\\n                        removed[pos] = true;  // Mark the digit as removed\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!found) break;  // If no valid swap is possible, exit the loop\\n        }\\n\\n        string rhs;  // Right-hand side of the result string\\n        for (int i = 0; i < n; ++i) {\\n            if (!removed[i]) {\\n                rhs += num[i];  // Append the remaining digits to the right-hand side\\n            }\\n        }\\n\\n        return lhs + rhs;  // Concatenate the left-hand and right-hand sides to form the final result\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903770,
                "title": "c-most-intuitive",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n+1)/2)\\n        {\\n            sort(num.begin(), num.end());\\n        }\\n\\n        for(int i=0;i<n && k >0;i++)\\n        {\\n            int pos = i;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j-i > k)\\n                    break;\\n                if(num[j] < num[pos])\\n                    pos = j;\\n            }\\n\\n            while(pos > i)\\n            {\\n                swap(num[pos], num[pos-1]);\\n                pos--;\\n                k--;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k > n*(n+1)/2)\\n        {\\n            sort(num.begin(), num.end());\\n        }\\n\\n        for(int i=0;i<n && k >0;i++)\\n        {\\n            int pos = i;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(j-i > k)\\n                    break;\\n                if(num[j] < num[pos])\\n                    pos = j;\\n            }\\n\\n            while(pos > i)\\n            {\\n                swap(num[pos], num[pos-1]);\\n                pos--;\\n                k--;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774607,
                "title": "easy-java-solution",
                "content": "# Intuition\\nGet the minimum in window of size k that starts from i+1. bring that minimum to front and decerease k accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        char[] arr = num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            if(k<=0){\\n                break;\\n            }\\n            char minChar = arr[i];\\n            int minCharIndex = -1;\\n            // System.out.println(i+\" \"+minChar+\" \"+ minCharIndex+\" \"+new String(arr));\\n            //for each index get index of min in window of k;\\n            for(int j=i+1; j<Math.min(i+k+1, n); j++){\\n                // System.out.println(minChar+\" \"+ arr[j]);\\n                if(minChar > arr[j]){\\n                    minChar = arr[j];\\n                    minCharIndex = j;\\n                }\\n            }\\n            if(minCharIndex == -1){\\n                continue;\\n            }\\n            while(minCharIndex > i){\\n                swap(arr, minCharIndex);\\n                k--;\\n                minCharIndex--;\\n            }\\n            // System.out.println(new String(arr));\\n            // System.out.println();\\n        }\\n        return new String(arr);\\n    }\\n    private void swap(char[] arr, int i){\\n        char temp = arr[i];\\n        arr[i] = arr[i-1];\\n        arr[i-1] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        char[] arr = num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            if(k<=0){\\n                break;\\n            }\\n            char minChar = arr[i];\\n            int minCharIndex = -1;\\n            // System.out.println(i+\" \"+minChar+\" \"+ minCharIndex+\" \"+new String(arr));\\n            //for each index get index of min in window of k;\\n            for(int j=i+1; j<Math.min(i+k+1, n); j++){\\n                // System.out.println(minChar+\" \"+ arr[j]);\\n                if(minChar > arr[j]){\\n                    minChar = arr[j];\\n                    minCharIndex = j;\\n                }\\n            }\\n            if(minCharIndex == -1){\\n                continue;\\n            }\\n            while(minCharIndex > i){\\n                swap(arr, minCharIndex);\\n                k--;\\n                minCharIndex--;\\n            }\\n            // System.out.println(new String(arr));\\n            // System.out.println();\\n        }\\n        return new String(arr);\\n    }\\n    private void swap(char[] arr, int i){\\n        char temp = arr[i];\\n        arr[i] = arr[i-1];\\n        arr[i-1] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611810,
                "title": "simple-segment-tree-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void build(int nl, int nr, int tidx, vector<int> &nums, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {nums[nl], nl};\\n            return;\\n        }\\n        int mid = (nl+nr)/2;\\n\\n        build(nl, mid, 2*tidx+1, nums, tree);\\n        build(mid+1, nr, 2*tidx+2, nums, tree);\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    void update(int nl, int nr, int tidx, int idx, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {INT_MAX, INT_MAX};\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2;\\n\\n        if(idx <= mid) {\\n            update(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update(mid+1, nr, 2*tidx+2, idx, tree); \\n        }\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    pair<int, int> query(int nl, int nr, int tidx, int l, int r, vector<pair<int, int>> &tree) {\\n        if(nl > r or nr < l) return {INT_MAX, INT_MAX};\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n\\n        pair<int, int> left = query(nl, mid, 2*tidx+1, l, r, tree);\\n        pair<int, int> right = query(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        if(left.first < right.first)  {\\n            return left;\\n        } else if(left.first > right.first) {\\n            return right; \\n        } else {\\n            if(left.second < right.second) {\\n                return left;\\n            } \\n        }\\n\\n        return right;\\n    }\\n\\n    void build2(int nl, int nr, int tidx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 1;\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2; \\n        build2(nl, mid, 2*tidx+1, tree);\\n        build2(mid+1, nr, 2*tidx+2, tree);\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    void update2(int nl, int nr, int tidx, int idx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 0; \\n            return; \\n        }\\n        int mid = (nl+nr)/2; \\n\\n        if(idx <= mid){\\n            update2(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update2(mid+1, nr, 2*tidx+2, idx, tree);\\n        }\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    int query2(int nl, int nr, int tidx, int l, int r, vector<int> &tree) {\\n        if(nl > r or nr < l) return 0;\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n        int left = query2(nl, mid, 2*tidx+1, l, r, tree);\\n        int right = query2(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        return left + right;\\n    }  \\n\\n    int getIdx(int n, int k, vector<int> &tree, int i) {\\n        int lo = 0, hi = n-1;\\n        int idx = -1; \\n        while(lo <= hi) {\\n            int mid = (lo+hi)/2; \\n            \\n            int sum = query2(0, n-1, 0, 0, mid, tree); \\n            // if(i == 1) {\\n            //     cout<<mid<<\" \"<<sum<<\" \"<<lo<<\" \"<<hi<<\" \"<<k<<endl;\\n            // }\\n            \\n            if(sum-1 > k) {\\n                hi=mid-1; \\n            } else {\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n        }\\n\\n        return idx; \\n    }\\n\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\n        vector<int> nums(n);\\n        for(int i = 0; i < n; i++) {\\n            nums[i] = num[i]-\\'0\\'; \\n        }\\n\\n        vector<pair<int, int>> tree1(4*n+1, {0, 0});\\n        build(0,n-1,0, nums, tree1);\\n        vector<int> tree2(4*n+1, 1); \\n        build2(0, n-1, 0, tree2); \\n\\n        string ans = num;\\n\\n        int i = 0; \\n        vector<bool> vis(n,false);\\n        while(k > 0 and i < n) {\\n            \\n            int idx = getIdx(n, k, tree2, i); \\n            pair<int, int> mini = query(0, n-1, 0, 0, idx, tree1);\\n\\n            int valIdx = mini.second;\\n            int val = mini.first;\\n            // cout<<valIdx<<endl;\\n            int temp = query2(0, n-1, 0, valIdx, n-1, tree2); \\n            int numberOfZeroes = n-valIdx-temp; \\n            \\n            int realIdx = numberOfZeroes + valIdx;\\n\\n            int reqOp = abs(i-realIdx); \\n            if(k >= reqOp) {\\n                k -= reqOp;\\n                ans[i] = num[valIdx];\\n            } else {\\n                break;\\n            }\\n\\n            update2(0, n-1, 0, valIdx, tree2);\\n            update(0, n-1, 0, valIdx, tree1);\\n\\n            vis[valIdx] = true; \\n            i++;     \\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            if(not vis[j]) {\\n                ans[i++] = num[j];\\n            }\\n        }\\n        return ans; \\n\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void build(int nl, int nr, int tidx, vector<int> &nums, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {nums[nl], nl};\\n            return;\\n        }\\n        int mid = (nl+nr)/2;\\n\\n        build(nl, mid, 2*tidx+1, nums, tree);\\n        build(mid+1, nr, 2*tidx+2, nums, tree);\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    void update(int nl, int nr, int tidx, int idx, vector<pair<int, int>> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = {INT_MAX, INT_MAX};\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2;\\n\\n        if(idx <= mid) {\\n            update(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update(mid+1, nr, 2*tidx+2, idx, tree); \\n        }\\n\\n        if(tree[2*tidx+1].first < tree[2*tidx+2].first)  {\\n            tree[tidx] = tree[2*tidx+1];\\n        } else if(tree[2*tidx+1].first > tree[2*tidx+2].first) {\\n            tree[tidx] = tree[2*tidx+2];\\n        } else {\\n            if(tree[2*tidx+1].second < tree[2*tidx+2].second) {\\n                tree[tidx] = tree[2*tidx+1];\\n            } else {\\n                tree[tidx] = tree[2*tidx+2]; \\n            }\\n        }\\n    }\\n\\n    pair<int, int> query(int nl, int nr, int tidx, int l, int r, vector<pair<int, int>> &tree) {\\n        if(nl > r or nr < l) return {INT_MAX, INT_MAX};\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n\\n        pair<int, int> left = query(nl, mid, 2*tidx+1, l, r, tree);\\n        pair<int, int> right = query(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        if(left.first < right.first)  {\\n            return left;\\n        } else if(left.first > right.first) {\\n            return right; \\n        } else {\\n            if(left.second < right.second) {\\n                return left;\\n            } \\n        }\\n\\n        return right;\\n    }\\n\\n    void build2(int nl, int nr, int tidx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 1;\\n            return; \\n        }\\n\\n        int mid = (nl+nr)/2; \\n        build2(nl, mid, 2*tidx+1, tree);\\n        build2(mid+1, nr, 2*tidx+2, tree);\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    void update2(int nl, int nr, int tidx, int idx, vector<int> &tree) {\\n        if(nl == nr) {\\n            tree[tidx] = 0; \\n            return; \\n        }\\n        int mid = (nl+nr)/2; \\n\\n        if(idx <= mid){\\n            update2(nl, mid, 2*tidx+1, idx, tree);\\n        } else {\\n            update2(mid+1, nr, 2*tidx+2, idx, tree);\\n        }\\n\\n        tree[tidx] = tree[2*tidx+1] + tree[2*tidx+2];\\n    }\\n\\n    int query2(int nl, int nr, int tidx, int l, int r, vector<int> &tree) {\\n        if(nl > r or nr < l) return 0;\\n        if(nl >= l and nr <= r) return tree[tidx];\\n\\n        int mid = (nl+nr)/2;\\n        int left = query2(nl, mid, 2*tidx+1, l, r, tree);\\n        int right = query2(mid+1, nr, 2*tidx+2, l, r, tree);\\n\\n        return left + right;\\n    }  \\n\\n    int getIdx(int n, int k, vector<int> &tree, int i) {\\n        int lo = 0, hi = n-1;\\n        int idx = -1; \\n        while(lo <= hi) {\\n            int mid = (lo+hi)/2; \\n            \\n            int sum = query2(0, n-1, 0, 0, mid, tree); \\n            // if(i == 1) {\\n            //     cout<<mid<<\" \"<<sum<<\" \"<<lo<<\" \"<<hi<<\" \"<<k<<endl;\\n            // }\\n            \\n            if(sum-1 > k) {\\n                hi=mid-1; \\n            } else {\\n                idx=mid;\\n                lo=mid+1;\\n            }\\n        }\\n\\n        return idx; \\n    }\\n\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\n        vector<int> nums(n);\\n        for(int i = 0; i < n; i++) {\\n            nums[i] = num[i]-\\'0\\'; \\n        }\\n\\n        vector<pair<int, int>> tree1(4*n+1, {0, 0});\\n        build(0,n-1,0, nums, tree1);\\n        vector<int> tree2(4*n+1, 1); \\n        build2(0, n-1, 0, tree2); \\n\\n        string ans = num;\\n\\n        int i = 0; \\n        vector<bool> vis(n,false);\\n        while(k > 0 and i < n) {\\n            \\n            int idx = getIdx(n, k, tree2, i); \\n            pair<int, int> mini = query(0, n-1, 0, 0, idx, tree1);\\n\\n            int valIdx = mini.second;\\n            int val = mini.first;\\n            // cout<<valIdx<<endl;\\n            int temp = query2(0, n-1, 0, valIdx, n-1, tree2); \\n            int numberOfZeroes = n-valIdx-temp; \\n            \\n            int realIdx = numberOfZeroes + valIdx;\\n\\n            int reqOp = abs(i-realIdx); \\n            if(k >= reqOp) {\\n                k -= reqOp;\\n                ans[i] = num[valIdx];\\n            } else {\\n                break;\\n            }\\n\\n            update2(0, n-1, 0, valIdx, tree2);\\n            update(0, n-1, 0, valIdx, tree1);\\n\\n            vis[valIdx] = true; \\n            i++;     \\n        }\\n\\n        for(int j = 0; j < n; j++) {\\n            if(not vis[j]) {\\n                ans[i++] = num[j];\\n            }\\n        }\\n        return ans; \\n\\n    }   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3393147,
                "title": "python-simple-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def minInteger(self, num, k):\\n        n, dict1, res = len(num), defaultdict(deque), \"\"\\n\\n        for i,x in enumerate(num):\\n            dict1[x].append(i)\\n\\n        result = BIT(n)\\n\\n        for i in range(n):\\n            result.update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if dict1[v]:\\n                    idx = dict1[v][0]\\n                    cnt = result.query(idx)\\n                    if cnt <= k:\\n                        dict1[v].popleft()\\n                        k -= cnt\\n                        res += v\\n                        result.update(idx+1,-1)\\n                        break\\n\\n        return res\\n\\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT:\\n    def __init__(self,n):\\n        self.ans = [0]*(n+1)\\n\\n    def query(self,i):\\n        res = 0\\n        while i > 0:\\n            res += self.ans[i]\\n            i -= i&-i\\n        return res\\n\\n    def update(self,i,val):\\n        while i < len(self.ans):\\n            self.ans[i] += val\\n            i += i&-i\\n\\nclass Solution:\\n    def minInteger(self, num, k):\\n        n, dict1, res = len(num), defaultdict(deque), \"\"\\n\\n        for i,x in enumerate(num):\\n            dict1[x].append(i)\\n\\n        result = BIT(n)\\n\\n        for i in range(n):\\n            result.update(i+1,1)\\n\\n        for i in range(n):\\n            for v in \"0123456789\":\\n                if dict1[v]:\\n                    idx = dict1[v][0]\\n                    cnt = result.query(idx)\\n                    if cnt <= k:\\n                        dict1[v].popleft()\\n                        k -= cnt\\n                        res += v\\n                        result.update(idx+1,-1)\\n                        break\\n\\n        return res\\n\\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281150,
                "title": "c-segment-tree-with-46ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    int tree[12*10001],lazy[12*10001],count;\\n    void Lazy(int id)\\n    {\\n        tree[id*2]+=lazy[id];\\n        lazy[id*2]+=lazy[id];\\n        tree[id*2+1]+=lazy[id];\\n        lazy[id*2+1]+=lazy[id];\\n        lazy[id]=0;\\n    }\\n    void update(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return;\\n        if(l>=x&&r<=y)\\n        {\\n            tree[id]++;\\n            lazy[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        update(id*2,l,mid,x,y);\\n        update(id*2+1,mid+1,r,x,y);\\n        tree[id]++;\\n    }\\n    int query(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return 0;\\n        if(l==r) return tree[id];\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        return query(id*2,l,mid,x)+query(id*2+1,mid+1,r,x);\\n    }\\n    string minInteger(string & num, int k) {\\n        vector<queue<int>> A(10);\\n        vector<int> kt(num.size(),0);\\n        for(int i=0;i<=num.size()-1;i++)\\n            A[int(num[i])-\\'0\\'].push(i);\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(k==0) break;\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(A[j].empty()!=0) continue;\\n                count=A[j].front()+query(1,0,num.size()-1,A[j].front())-i;\\n                if(count<=k)\\n                {\\n                    kt[A[j].front()]=1;\\n                    ans+=num[A[j].front()];\\n                    k=k-count;\\n                    update(1,0,num.size()-1,0,A[j].front());\\n                    A[j].pop();\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(kt[i]==0) ans+=num[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    int tree[12*10001],lazy[12*10001],count;\\n    void Lazy(int id)\\n    {\\n        tree[id*2]+=lazy[id];\\n        lazy[id*2]+=lazy[id];\\n        tree[id*2+1]+=lazy[id];\\n        lazy[id*2+1]+=lazy[id];\\n        lazy[id]=0;\\n    }\\n    void update(int id,int l,int r,int x,int y)\\n    {\\n        if(l>y||r<x) return;\\n        if(l>=x&&r<=y)\\n        {\\n            tree[id]++;\\n            lazy[id]++;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        update(id*2,l,mid,x,y);\\n        update(id*2+1,mid+1,r,x,y);\\n        tree[id]++;\\n    }\\n    int query(int id,int l,int r,int x)\\n    {\\n        if(l>x||r<x) return 0;\\n        if(l==r) return tree[id];\\n        int mid=(l+r)/2;\\n        Lazy(id);\\n        return query(id*2,l,mid,x)+query(id*2+1,mid+1,r,x);\\n    }\\n    string minInteger(string & num, int k) {\\n        vector<queue<int>> A(10);\\n        vector<int> kt(num.size(),0);\\n        for(int i=0;i<=num.size()-1;i++)\\n            A[int(num[i])-\\'0\\'].push(i);\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(k==0) break;\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(A[j].empty()!=0) continue;\\n                count=A[j].front()+query(1,0,num.size()-1,A[j].front())-i;\\n                if(count<=k)\\n                {\\n                    kt[A[j].front()]=1;\\n                    ans+=num[A[j].front()];\\n                    k=k-count;\\n                    update(1,0,num.size()-1,0,A[j].front());\\n                    A[j].pop();\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0;i<=num.size()-1;i++)\\n        {\\n            if(kt[i]==0) ans+=num[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162681,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let mut k = k as usize;\\n        let num = num.into_bytes();\\n        let n = num.len();\\n        let mut res = Vec::with_capacity(n);\\n        let mut q = vec![n; 10];\\n        for (i, &item) in num.iter().enumerate() {\\n            let d = (item - b\\'0\\') as usize;\\n            if q[d] == n {\\n                q[d] = i;\\n            }\\n        }\\n        let mut used = vec![false; n];\\n        let mut q_used = vec![0; 10];\\n        for _ in 0..n {\\n            for d in 0..10_usize {\\n                if q[d] == n {\\n                    continue;\\n                }\\n                let c = q[d] - q_used[d];\\n                if c <= k {\\n                    k -= c;\\n                    res.push(b\\'0\\' + d as u8);\\n                    used[q[d]] = true;\\n                    for d1 in 0..10_usize {\\n                        if q[d1] > q[d] {\\n                            q_used[d1] += 1;\\n                        }\\n                    }\\n                    while q[d] < n {\\n                        if used[q[d]] {\\n                            q_used[d] += 1;\\n                        }\\n                        q[d] += 1;\\n                        let &c = num.get(q[d]).unwrap_or(&0_u8);\\n                        if c == b\\'0\\' + d as u8 {\\n                            break;\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let mut k = k as usize;\\n        let num = num.into_bytes();\\n        let n = num.len();\\n        let mut res = Vec::with_capacity(n);\\n        let mut q = vec![n; 10];\\n        for (i, &item) in num.iter().enumerate() {\\n            let d = (item - b\\'0\\') as usize;\\n            if q[d] == n {\\n                q[d] = i;\\n            }\\n        }\\n        let mut used = vec![false; n];\\n        let mut q_used = vec![0; 10];\\n        for _ in 0..n {\\n            for d in 0..10_usize {\\n                if q[d] == n {\\n                    continue;\\n                }\\n                let c = q[d] - q_used[d];\\n                if c <= k {\\n                    k -= c;\\n                    res.push(b\\'0\\' + d as u8);\\n                    used[q[d]] = true;\\n                    for d1 in 0..10_usize {\\n                        if q[d1] > q[d] {\\n                            q_used[d1] += 1;\\n                        }\\n                    }\\n                    while q[d] < n {\\n                        if used[q[d]] {\\n                            q_used[d] += 1;\\n                        }\\n                        q[d] += 1;\\n                        let &c = num.get(q[d]).unwrap_or(&0_u8);\\n                        if c == b\\'0\\' + d as u8 {\\n                            break;\\n                        }\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        String::from_utf8(res).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3064438,
                "title": "o-nlogn-a-sortedlist-and-10-queues",
                "content": "# Intuition\\nIterating from the left, we want to find the smallest reacheable digit and put it on each place.\\n\\n# Approach\\nWe keep 10 queues, containing sequences of indices for each digit. At each step we pick the smallest digit that is not further than `k` steps away. After that we remove it from its queue, and reduce `k` by the number of steps used.\\n\\nThe question, then, rises, how to recalculate the correct indices and distances after a digit is removed from its place. Of course, we don\\'t want to modify the queues, that would be too slow. But, it can be seen that the correction to every index is simply the number of used indices to the left of it, which we can calculate efficiently with `SortedList`.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$, dominated by `SortedList` operations, at most `n` inserts and `n` bisections. Technically, `SortedList` has larger [time complexity](https://grantjenks.com/docs/sortedcontainers/performance-scale.html), but in practice it is fast.\\n\\n- Space complexity: $$O(n)$$, one `SortedList` and 10 queues each\\n\\n# Code\\n```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        N = len(num)\\n        lists = [deque() for _ in range(10)]\\n        for i,c in enumerate(num):\\n            lists[int(c)].append(i)\\n        res = []\\n        used = SortedList()\\n        unused = set(range(N))\\n        while k and len(res) < N:\\n            for d in range(10):\\n                if not lists[d]:\\n                    continue\\n                i = lists[d][0]\\n                i -= used.bisect_left(i)\\n                if i <= k:\\n                    k -= i\\n                    i = lists[d].popleft()\\n                    used.add(i)\\n                    unused.remove(i)\\n                    res.append(i)\\n                    break\\n        res.extend(unused)\\n        return \\'\\'.join(num[x] for x in res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        N = len(num)\\n        lists = [deque() for _ in range(10)]\\n        for i,c in enumerate(num):\\n            lists[int(c)].append(i)\\n        res = []\\n        used = SortedList()\\n        unused = set(range(N))\\n        while k and len(res) < N:\\n            for d in range(10):\\n                if not lists[d]:\\n                    continue\\n                i = lists[d][0]\\n                i -= used.bisect_left(i)\\n                if i <= k:\\n                    k -= i\\n                    i = lists[d].popleft()\\n                    used.add(i)\\n                    unused.remove(i)\\n                    res.append(i)\\n                    break\\n        res.extend(unused)\\n        return \\'\\'.join(num[x] for x in res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006259,
                "title": "python-sliding-window-avl-tree-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a window of size ```k``` in a AVL Tree, pop out the minimum element in the index in $$O(log(n))$$ time, find its index, decrement ```k``` accordingly until ```k``` becomes ```0```.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        sz, window = len(num), SortedList()\\n        remainedIndices, poppedIndices = SortedList(range(sz)), []\\n        while k > 0:\\n            while len(window) < k + 1 and len(window) < len(remainedIndices):\\n                idx = remainedIndices[len(window)]\\n                window.add((num[idx], idx))\\n            if not window:\\n                break\\n            index = window.pop(0)[1]\\n            k -= remainedIndices.bisect_left(index)\\n            remainedIndices.remove(index)\\n            poppedIndices.append(index)\\n            for idx in remainedIndices[k + 1: len(window)]:\\n                window.remove((num[idx], idx))\\n        poppedSet = set(poppedIndices)\\n        return \"\".join(num[idx] for idx in poppedIndices) + \"\".join(num[idx] for idx in range(sz) if idx not in poppedSet)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy",
                    "Binary Search Tree",
                    "Sliding Window"
                ],
                "code": "```k```\n```k```\n```k```\n```0```\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        sz, window = len(num), SortedList()\\n        remainedIndices, poppedIndices = SortedList(range(sz)), []\\n        while k > 0:\\n            while len(window) < k + 1 and len(window) < len(remainedIndices):\\n                idx = remainedIndices[len(window)]\\n                window.add((num[idx], idx))\\n            if not window:\\n                break\\n            index = window.pop(0)[1]\\n            k -= remainedIndices.bisect_left(index)\\n            remainedIndices.remove(index)\\n            poppedIndices.append(index)\\n            for idx in remainedIndices[k + 1: len(window)]:\\n                window.remove((num[idx], idx))\\n        poppedSet = set(poppedIndices)\\n        return \"\".join(num[idx] for idx in poppedIndices) + \"\".join(num[idx] for idx in range(sz) if idx not in poppedSet)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903739,
                "title": "dart-solution-o-n-2-linkedlist",
                "content": "# Intuition\\nWhen swapping (similar to bubble sort) numbers in a string - we should start minimising number from the left side by swapping every digit with the lowest possible number from the remaining ight side within the K limit.\\n\\n\\n# Approach\\n\\nWhile the idea is prerry simple I faced timeout error on submission when result was kept in the array (List<int>) and swapping was perfomed by internal cycle.\\nReplacing array with the LinkedList (where swap costs O(1) instead of O(N) ) helped to submit solution within the Leetcode time limits.\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N) for the linked list\\n\\n# Code\\n```\\n\\nimport \\'dart:collection\\';\\n\\nclass IntEntry extends LinkedListEntry<IntEntry> {\\n  int val;\\n  IntEntry(this.val);\\n}\\n\\nclass Solution {\\n  static int zeroCode = \\'0\\'.codeUnitAt(0);\\n\\n  String minInteger(String num, int k) {\\n    int L = num.length;\\n    if (L == 0) return \"\";\\n\\n    final List<int> arr = num.codeUnits.map((e) => e - zeroCode).toList();\\n    final LinkedList<IntEntry> lst = LinkedList<IntEntry>();\\n    lst.addAll(arr.map((e) => IntEntry(e)));\\n\\n    int i = 0;\\n    int r = k;\\n\\n    IntEntry next = lst.first;\\n    while (next.next != null && r > 0) {\\n      int swapLess = 0;\\n      var minIdx = 0;\\n      var minPtr = next;\\n\\n      var findMinIdx = 1;\\n      var findMinPtr = next.next;\\n\\n      for (;\\n          findMinPtr != null && findMinIdx <= r;\\n          findMinPtr = findMinPtr.next, findMinIdx++)\\n        if (findMinPtr.val < minPtr.val) {\\n          minPtr = findMinPtr;\\n          minIdx = findMinIdx;\\n        }\\n\\n      if (minPtr != next) {\\n        r -= minIdx;\\n        minPtr.unlink();\\n        next.insertBefore(minPtr);\\n      } else\\n        next = next.next!;\\n    }\\n\\n    final ret = StringBuffer();\\n    lst.forEach((entry) {\\n      ret.write(entry.val);\\n    });\\n    return ret.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nimport \\'dart:collection\\';\\n\\nclass IntEntry extends LinkedListEntry<IntEntry> {\\n  int val;\\n  IntEntry(this.val);\\n}\\n\\nclass Solution {\\n  static int zeroCode = \\'0\\'.codeUnitAt(0);\\n\\n  String minInteger(String num, int k) {\\n    int L = num.length;\\n    if (L == 0) return \"\";\\n\\n    final List<int> arr = num.codeUnits.map((e) => e - zeroCode).toList();\\n    final LinkedList<IntEntry> lst = LinkedList<IntEntry>();\\n    lst.addAll(arr.map((e) => IntEntry(e)));\\n\\n    int i = 0;\\n    int r = k;\\n\\n    IntEntry next = lst.first;\\n    while (next.next != null && r > 0) {\\n      int swapLess = 0;\\n      var minIdx = 0;\\n      var minPtr = next;\\n\\n      var findMinIdx = 1;\\n      var findMinPtr = next.next;\\n\\n      for (;\\n          findMinPtr != null && findMinIdx <= r;\\n          findMinPtr = findMinPtr.next, findMinIdx++)\\n        if (findMinPtr.val < minPtr.val) {\\n          minPtr = findMinPtr;\\n          minIdx = findMinIdx;\\n        }\\n\\n      if (minPtr != next) {\\n        r -= minIdx;\\n        minPtr.unlink();\\n        next.insertBefore(minPtr);\\n      } else\\n        next = next.next!;\\n    }\\n\\n    final ret = StringBuffer();\\n    lst.forEach((entry) {\\n      ret.write(entry.val);\\n    });\\n    return ret.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851740,
                "title": "o-nlogn-sliding-window-and-avl-tree",
                "content": "```\\n        from sortedcontainers import SortedList\\n\\n        n = len(num)\\n        window = SortedList()  # sliding window of size k + 1, store (value, index) of num\\n        remains = SortedList(range(n))  # remained remains\\n        pops = []  # popped indices\\n\\n        while k > 0:\\n            # add to keep window size to k + 1\\n            while len(window) < k + 1 and len(window) < len(remains):\\n                _ = remains[len(window)]\\n                window.add((num[_], _))\\n\\n            # empty window, break\\n            if not window:\\n                break\\n\\n            # pop minimum value\\n            index = window.pop(0)[1]\\n            k -= remains.bisect_left(index)\\n            remains.remove(index)\\n            pops.append(index)\\n\\n            # remove to keep window size to k + 1\\n            for _ in remains[k + 1: len(window)]:\\n                window.remove((num[_], _))\\n\\n        s0 = set(pops)\\n        return \"\".join(num[j] for j in pops) + \"\".join(num[j] for j in range(n) if j not in s0)\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n        from sortedcontainers import SortedList\\n\\n        n = len(num)\\n        window = SortedList()  # sliding window of size k + 1, store (value, index) of num\\n        remains = SortedList(range(n))  # remained remains\\n        pops = []  # popped indices\\n\\n        while k > 0:\\n            # add to keep window size to k + 1\\n            while len(window) < k + 1 and len(window) < len(remains):\\n                _ = remains[len(window)]\\n                window.add((num[_], _))\\n\\n            # empty window, break\\n            if not window:\\n                break\\n\\n            # pop minimum value\\n            index = window.pop(0)[1]\\n            k -= remains.bisect_left(index)\\n            remains.remove(index)\\n            pops.append(index)\\n\\n            # remove to keep window size to k + 1\\n            for _ in remains[k + 1: len(window)]:\\n                window.remove((num[_], _))\\n\\n        s0 = set(pops)\\n        return \"\".join(num[j] for j in pops) + \"\".join(num[j] for j in range(n) if j not in s0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2669347,
                "title": "c-segment-tree-explained-solution",
                "content": "```\\n/*\\n\\nswap any two adjacent digits atmost k times -> minimum integer formed after this??\\n\\nwill greedy approach works here ?\\n\\nbringing all smaller no\\' ahead as possible as\\n \\n \\n(bring that smallest no. here which is towards right of it and can be brought here within k steps) () () ()...\\n\\n\\nValue of k decreases..\\n\\n(.)(bring that smallest no. here which is towards right of it and can be brought here within remaining k steps) () () () () () ...\\n\\nValue of k decreases..\\n\\nand so on till k>0\\n\\n\\nNOTE:\\n\\n7683(1)67 => (1)768367\\n\\n\\nby doing this, index of all no\\'s toward left of (1) increases by 1\\n\\n\\n O(n*n), for each position i, check minimum digit within the range (among next k digits) , and put that minimum digit at this position\\n\\n O(n logn) , for each position i, we check Is it possible to place any digit [0-9] at this position, let we can place \\'3\\' at this position , and index of this \\'3\\' is idx, so no. of swaps we needs to do to bring \\'3\\' from index idx towards left to index i = idx- (no of digits from [0,idx] that have already used)\\n\\nif we are at index i, it means we are already done with [0...i-1]\\n\\n\\n let num= 872124652 , k=20\\n\\n S.T = 0 0 0 0 0 0 0 0 0\\n \\n num= 872124652\\n for i=0, 872124652 => ans=1(87224652)\\n nextIdx=3, alreadyUsed=0, countSwap=3-0=3, k=k-3=17\\n S.T = 0 0 0 1 0 0 0 0 0\\n \\n num= 872124652\\n for i=1, 1|87224652  => ans=12(8724652)\\n nextIdx=2, alreadyUsed=0, countSwap=2-0=2, k=17-2=15\\n S.T = 0 0 1 1 0 0 0 0 0\\n \\n num= 872124652\\n for i=2, 12|8724652 => ans=122(874652)\\n nextIdx=4, alreadyUsed=2, countSwap=4-2=2, k=15-2=13\\n  S.T = 0 0 1 1 1 0 0 0 0\\n\\n num= 87212465(2)\\n for i=3, 122|874652 => ans=1222(87465)\\n nextIdx=8, alreadyUsed=3, countSwap=8-3=5, k=13-5=8\\n  S.T = 0 0 1 1 1 0 0 0 1\\n\\nnum= 87212(4)652\\n for i=4, 1222|87465 => ans=12224(8765)\\n nextIdx=5, alreadyUsed=3, countSwap=5-3=2, k=8-2=6\\n S.T = 0 0 1 1 1 1 0 0 1\\n \\n num= 8721246(5)2\\n for i=5, 12224|8765 => ans=122245(876)\\n nextIdx=7, alreadyUsed=4, countSwap=7-4=3, k=6-3=3\\n S.T = 0 0 1 1 1 1 0 1 1\\n \\n  num= 872124(6)52\\n for i=5, 122245|876 => ans=1222456(87)\\n nextIdx=6, alreadyUsed=4, countSwap=6-4=2, k=3-2=1\\n S.T = 0 0 1 1 1 1 1 1 1\\n \\n num= 8(7)2124652\\n for i=5, 1222456|87 => ans=12224567(8)\\n nextIdx=1, alreadyUsed=0, countSwap=1-0=1, k=1-1=0\\n S.T = 0 1 1 1 1 1 1 1 1\\n \\n k=0\\n \\n return ans=122245678 \\n\\n\\n\\n to keep track of how many digits have been used in range [0....idx] we use segment tree\\n\\n let we shifting digit at index i1 or using digit at index i1 at any left side index , than we update our segment tree by adding 1 at index i1 in the segment tree \\n\\n*/\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        \\n    int n=num.length();\\n    \\n    if(k>n*n){\\n        sort(num.begin(),num.end());\\n        \\n        return num;\\n    }\\n        \\n        \\nunordered_map<int,deque<int>>mp;\\n        \\nint arr[n];\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]=0;\\n        }\\n        \\nint *st=constructST(arr,n);\\n        \\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\'].push_back(i);\\n        }\\n       \\n        string ans;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int d=0;d<=9;d++){\\n                \\n                if(mp[d].size()>0){\\n                    \\n                    int nextIdx=mp[d].front();\\n                    \\n                    // no. of digits that already used\\n                    int alreadyUsed=getsum(st,0,0,n-1,0,nextIdx);\\n                    \\n                    int countSwap=nextIdx-alreadyUsed;\\n                    \\n                    if(k>=countSwap){\\n                        ans+=to_string(d);\\n                        mp[d].pop_front();\\n                        k-=countSwap;\\n                        update(st,0,0,n-1,nextIdx,1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n    \\n    }\\n    \\n    \\n    \\nvoid update(int *st,int si,int sl,int sr,int pos,int diff)\\n{\\nif(sl>pos || sr<pos)\\nreturn ;\\nst[si]=st[si]+diff;\\nif(sl!=sr){\\nint mid=(sl+sr)/2;\\nupdate(st,2*si+1,sl,mid,pos,diff);\\nupdate(st,2*si+2,mid+1,sr,pos,diff);\\n}}\\n\\n\\n\\nint getsum(int *st,int si,int sl,int sr,int l,int r)\\n{\\nif(l<=sl && r>=sr)\\nreturn st[si];\\nif(l>sr || r<sl)\\nreturn 0;\\nint mid=(sl+sr)/2;\\nreturn (getsum(st,2*si+1,sl,mid,l,r)+\\ngetsum(st,2*si+2,mid+1,sr,l,r));\\n}\\n\\n\\n\\nint constructSTUL(int *st,int si,int arr[],int l,int r){\\nif(l==r){\\nst[si]=arr[l];\\nreturn arr[l];\\n}\\nint mid=(l+r)/2;\\n\\nst[si]=(constructSTUL(st,2*si+1,arr,l,mid)\\n+ constructSTUL(st,2*si+2,arr,mid+1,r));\\nreturn st[si];\\n}\\n\\n\\n\\nint *constructST(int arr[],int n){\\n\\nint h=(int)(ceil(log2(n)));\\nint max_size_st=2*(int)pow(2,h)-1;\\nint *st=new int[max_size_st];\\n\\nconstructSTUL(st,0,arr,0,n-1);\\n\\nreturn st;\\n}\\n\\n};",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "class Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        \\n    int n=num.length();\\n    \\n    if(k>n*n){\\n        sort(num.begin(),num.end());\\n        \\n        return num;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2610988,
                "title": "segment-tree-bit-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int Do(int a,int b,string &s){\\n        if(a==s.size())return b;\\n        if(b==s.size())return a;\\n        if(s[a]<=s[b])return a;\\n        return b;\\n    }\\n    \\n    void build(vector<int> &seg,int si,int sl,int sr,string &s){\\n        if(sl==sr){\\n            seg[si]=sl;\\n            return;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        build(seg,2*si,sl,mid,s);\\n        build(seg,2*si+1,mid+1,sr,s);\\n        seg[si]=Do(\\n            seg[si*2],\\n            seg[si*2+1],\\n            s\\n        );\\n        \\n    }\\n    \\n    \\n    int Q(vector<int> &seg,int si,int sl,int sr,int l,int r,string &s){\\n        if(l>r)return s.size();\\n        if(sl==l and sr==r)return seg[si];\\n        int mid=(sl+sr)/2;\\n        return Do(\\n            Q(seg,si*2,sl,mid,l,min(mid,r),s),\\n            Q(seg,si*2+1,mid+1,sr,max(l,mid+1),r,s),\\n            s\\n        );\\n    }\\n    \\n    void update(vector<int> &seg,int si,int sl,int sr,int ind,char val,string &s){\\n        if(sl==sr){\\n            s[ind]=val;\\n            seg[si]=sl;\\n            return ;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        if(ind<=mid)update(seg,si*2,sl,mid,ind,val,s);\\n        else update(seg,si*2+1,mid+1,sr,ind,val,s);\\n        seg[si]=Do(seg[si*2],seg[si*2+1],s);\\n    }\\n    \\n    int sum(int ind,vector<int> &BIT){\\n        if(ind<0)return 0;\\n        return BIT[ind]+sum((ind&(ind+1))-1,BIT);\\n    }\\n    \\n    void updateBIT(int ind,vector<int> &BIT,int val){\\n        if(ind>=BIT.size())return;\\n        BIT[ind]+=val;\\n        updateBIT(ind|(ind+1),BIT,val);\\n    }\\n    \\n    int DO(int k,vector<int> &BIT){\\n        int l=0,r=BIT.size()-1;\\n        int ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(sum(mid,BIT)<=k)ans=mid,l=mid+1;\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string minInteger(string num, int k) {\\n        int n=num.size();\\n        vector<int> seg(4*n);\\n        build(seg,1,0,n-1,num);\\n        vector<int> BIT(n);\\n        for(int i=0;i<n;i++)updateBIT(i,BIT,1);\\n        \\n        string ans;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            int ind=DO(k+1,BIT);\\n            int aind=Q(seg,1,0,n-1,0,ind,num);\\n            ans+=num[aind];\\n            update(seg,1,0,n-1,aind,(\\'9\\'+1),num);\\n            int sumi=sum(aind,BIT);\\n            k-=sumi;\\n            k++;\\n            updateBIT(aind,BIT,-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Do(int a,int b,string &s){\\n        if(a==s.size())return b;\\n        if(b==s.size())return a;\\n        if(s[a]<=s[b])return a;\\n        return b;\\n    }\\n    \\n    void build(vector<int> &seg,int si,int sl,int sr,string &s){\\n        if(sl==sr){\\n            seg[si]=sl;\\n            return;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        build(seg,2*si,sl,mid,s);\\n        build(seg,2*si+1,mid+1,sr,s);\\n        seg[si]=Do(\\n            seg[si*2],\\n            seg[si*2+1],\\n            s\\n        );\\n        \\n    }\\n    \\n    \\n    int Q(vector<int> &seg,int si,int sl,int sr,int l,int r,string &s){\\n        if(l>r)return s.size();\\n        if(sl==l and sr==r)return seg[si];\\n        int mid=(sl+sr)/2;\\n        return Do(\\n            Q(seg,si*2,sl,mid,l,min(mid,r),s),\\n            Q(seg,si*2+1,mid+1,sr,max(l,mid+1),r,s),\\n            s\\n        );\\n    }\\n    \\n    void update(vector<int> &seg,int si,int sl,int sr,int ind,char val,string &s){\\n        if(sl==sr){\\n            s[ind]=val;\\n            seg[si]=sl;\\n            return ;\\n        }\\n        \\n        int mid=(sl+sr)/2;\\n        if(ind<=mid)update(seg,si*2,sl,mid,ind,val,s);\\n        else update(seg,si*2+1,mid+1,sr,ind,val,s);\\n        seg[si]=Do(seg[si*2],seg[si*2+1],s);\\n    }\\n    \\n    int sum(int ind,vector<int> &BIT){\\n        if(ind<0)return 0;\\n        return BIT[ind]+sum((ind&(ind+1))-1,BIT);\\n    }\\n    \\n    void updateBIT(int ind,vector<int> &BIT,int val){\\n        if(ind>=BIT.size())return;\\n        BIT[ind]+=val;\\n        updateBIT(ind|(ind+1),BIT,val);\\n    }\\n    \\n    int DO(int k,vector<int> &BIT){\\n        int l=0,r=BIT.size()-1;\\n        int ans;\\n        while(l<=r){\\n            int mid=(l+r)/2;\\n            if(sum(mid,BIT)<=k)ans=mid,l=mid+1;\\n            else r=mid-1;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    string minInteger(string num, int k) {\\n        int n=num.size();\\n        vector<int> seg(4*n);\\n        build(seg,1,0,n-1,num);\\n        vector<int> BIT(n);\\n        for(int i=0;i<n;i++)updateBIT(i,BIT,1);\\n        \\n        string ans;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            int ind=DO(k+1,BIT);\\n            int aind=Q(seg,1,0,n-1,0,ind,num);\\n            ans+=num[aind];\\n            update(seg,1,0,n-1,aind,(\\'9\\'+1),num);\\n            int sumi=sum(aind,BIT);\\n            k-=sumi;\\n            k++;\\n            updateBIT(aind,BIT,-1);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570852,
                "title": "c-segment-tree-o-nlogn-cleanest-code",
                "content": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;\\n    int n;\\n\\n    //constructor\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);\\n    }\\n\\n    void update(int ss, int se, int ql, int idx, int val) {\\n        //update[ql,ql]\\n        if (ql<ss or ql>se) {\\n            return;\\n        }\\n        if (ss == se) {\\n            nodes[idx] += val;\\n            return;\\n        }\\n        int mid = (ss + se) >> 1;\\n        update(ss, mid, ql, 2 * idx + 1, val);\\n        update(mid + 1, se, ql, 2 * idx + 2, val);\\n        nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];\\n    }\\n\\n    int query(int ss, int se, int ql, int qr, int idx) {\\n        //ql aur qr ke beech me answer nikal\\n        if (ql > se or qr < ss) {\\n            return 0;\\n        }\\n        if (ql <= ss and se <= qr) {\\n            return nodes[idx];\\n        }\\n        int mid = (ss + se) >> 1;\\n        int lt = query(ss, mid, ql, qr, 2 * idx + 1);\\n        int rt = query(mid + 1, se, ql, qr, 2 * idx + 2);\\n        return lt + rt;\\n    }\\n    int querylessthan(int pos) {\\n        return query(0, n - 1, 0, pos - 1, 0); //query left is 0 and query right is pos-1\\n    }\\n    void increase(int pos) {\\n        update(0, n - 1, pos, 0, 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        string ans = \"\";\\n        int n = num.size();\\n        SegTree* tree = new SegTree(n);\\n        vector<queue<int>> qs(10);\\n        for (int i = 0; i < n; i++) {\\n            qs[num[i] - \\'0\\'].push(i); //pushing back the positions for each digit from 0 to 9\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (qs[d].empty() == false) {\\n                    int pos = qs[d].front();\\n                    \\n\\n                    /*Explanation\\n                     Since few numbers already shifted to left, this `pos` might be outdated,so we try to find how many numbers already got shifted that were to the left of pos.\\n                    int shifted = seg.getCountLessThan(pos);\\n                    (pos - shift) is number of steps to make digit d move from pos to i.\\n\\n                    */\\n\\t\\t\\t\\t\\t/*how many digits infront of this position \"pos\" has been moved to the right position*/\\n                    if (pos - shifted <= k) {\\n                        k -= (pos - shifted);\\n                        tree->increase(pos);\\n                        qs[d].pop();\\n                        ans += d + \\'0\\';\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegTree {\\npublic:\\n    vector<int> nodes;\\n    int n;\\n\\n    //constructor\\n    SegTree(int n) {\\n        this->n = n;\\n        nodes = vector<int>(this->n << 2);\\n    }\\n\\n    void update(int ss, int se, int ql, int idx, int val) {\\n        //update[ql,ql]\\n        if (ql<ss or ql>se) {\\n            return;\\n        }\\n        if (ss == se) {\\n            nodes[idx] += val;\\n            return;\\n        }\\n        int mid = (ss + se) >> 1;\\n        update(ss, mid, ql, 2 * idx + 1, val);\\n        update(mid + 1, se, ql, 2 * idx + 2, val);\\n        nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];\\n    }\\n\\n    int query(int ss, int se, int ql, int qr, int idx) {\\n        //ql aur qr ke beech me answer nikal\\n        if (ql > se or qr < ss) {\\n            return 0;\\n        }\\n        if (ql <= ss and se <= qr) {\\n            return nodes[idx];\\n        }\\n        int mid = (ss + se) >> 1;\\n        int lt = query(ss, mid, ql, qr, 2 * idx + 1);\\n        int rt = query(mid + 1, se, ql, qr, 2 * idx + 2);\\n        return lt + rt;\\n    }\\n    int querylessthan(int pos) {\\n        return query(0, n - 1, 0, pos - 1, 0); //query left is 0 and query right is pos-1\\n    }\\n    void increase(int pos) {\\n        update(0, n - 1, pos, 0, 1);\\n    }\\n};\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        string ans = \"\";\\n        int n = num.size();\\n        SegTree* tree = new SegTree(n);\\n        vector<queue<int>> qs(10);\\n        for (int i = 0; i < n; i++) {\\n            qs[num[i] - \\'0\\'].push(i); //pushing back the positions for each digit from 0 to 9\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int d = 0; d <= 9; d++) {\\n                if (qs[d].empty() == false) {\\n                    int pos = qs[d].front();\\n                    \\n\\n                    /*Explanation\\n                     Since few numbers already shifted to left, this `pos` might be outdated,so we try to find how many numbers already got shifted that were to the left of pos.\\n                    int shifted = seg.getCountLessThan(pos);\\n                    (pos - shift) is number of steps to make digit d move from pos to i.\\n\\n                    */\\n\\t\\t\\t\\t\\t/*how many digits infront of this position \"pos\" has been moved to the right position*/\\n                    if (pos - shifted <= k) {\\n                        k -= (pos - shifted);\\n                        tree->increase(pos);\\n                        qs[d].pop();\\n                        ans += d + \\'0\\';\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539404,
                "title": "c-o-nlogn-segment-tree",
                "content": "```\\nclass Solution {\\n    class SegTree {\\n        vector<int> st;\\n        int siz;\\n\\n        void upd(int i, int k) {\\n            i += siz;\\n            st[i]+= k;\\n            i /= 2;\\n            while (i > 0) {\\n                st[i] = st[i * 2] + st[i * 2 + 1];\\n                i /= 2;\\n            }\\n        }\\n        int qry(int l, int r) {\\n            l += siz;\\n            r += siz;\\n            int ans = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) ans += st[l++];\\n                if (r % 2 == 0) ans += st[r--];\\n                l /= 2;\\n                r /= 2;\\n            }\\n            return ans;\\n        }\\n\\n       public:\\n        SegTree(int n) {\\n            n++;\\n            siz = 1 << int(ceil(log2(n)));\\n            st.resize(siz * 2, 0);\\n        }\\n        int query(int i) {  // elements shifted from 0 to i -> prefix sum from 0 to i\\n            return qry(0, i);\\n        }\\n        void update(int i) {  // shift ith element to first position -> add 1 to 0 to i\\n            upd(0, 1);\\n            upd(i + 1, -1);\\n        }\\n    };\\n\\n   public:\\n    string minInteger(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> pos(10);\\n        for (int i = 0; i < n; i++)\\n            pos[s[i] - \\'0\\'].push_back(i);\\n        for (int dig = 0; dig < 10; dig++)\\n            reverse(pos[dig].begin(), pos[dig].end());\\n        SegTree st(n);\\n        string ans;\\n        int i = 0;\\n        while (k > 0 && i < n) {\\n            for (int dig = 0; dig < 10; dig++) {\\n                if (pos[dig].empty()) continue;\\n                int p = pos[dig].back();\\n                int actual = p + st.query(p);\\n                if (actual <= i + k) {\\n                    pos[dig].pop_back();\\n                    ans += to_string(dig);\\n                    st.update(p);\\n                    k -= actual - i;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        vector<pair<int, int>> v;\\n        for (int dig = 0; dig < 10; dig++) {\\n            while (pos[dig].size()) {\\n                v.push_back({pos[dig].back(), dig});\\n                pos[dig].pop_back();\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for (auto &[p, d] : v)\\n            ans += to_string(d);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class SegTree {\\n        vector<int> st;\\n        int siz;\\n\\n        void upd(int i, int k) {\\n            i += siz;\\n            st[i]+= k;\\n            i /= 2;\\n            while (i > 0) {\\n                st[i] = st[i * 2] + st[i * 2 + 1];\\n                i /= 2;\\n            }\\n        }\\n        int qry(int l, int r) {\\n            l += siz;\\n            r += siz;\\n            int ans = 0;\\n            while (l <= r) {\\n                if (l % 2 == 1) ans += st[l++];\\n                if (r % 2 == 0) ans += st[r--];\\n                l /= 2;\\n                r /= 2;\\n            }\\n            return ans;\\n        }\\n\\n       public:\\n        SegTree(int n) {\\n            n++;\\n            siz = 1 << int(ceil(log2(n)));\\n            st.resize(siz * 2, 0);\\n        }\\n        int query(int i) {  // elements shifted from 0 to i -> prefix sum from 0 to i\\n            return qry(0, i);\\n        }\\n        void update(int i) {  // shift ith element to first position -> add 1 to 0 to i\\n            upd(0, 1);\\n            upd(i + 1, -1);\\n        }\\n    };\\n\\n   public:\\n    string minInteger(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> pos(10);\\n        for (int i = 0; i < n; i++)\\n            pos[s[i] - \\'0\\'].push_back(i);\\n        for (int dig = 0; dig < 10; dig++)\\n            reverse(pos[dig].begin(), pos[dig].end());\\n        SegTree st(n);\\n        string ans;\\n        int i = 0;\\n        while (k > 0 && i < n) {\\n            for (int dig = 0; dig < 10; dig++) {\\n                if (pos[dig].empty()) continue;\\n                int p = pos[dig].back();\\n                int actual = p + st.query(p);\\n                if (actual <= i + k) {\\n                    pos[dig].pop_back();\\n                    ans += to_string(dig);\\n                    st.update(p);\\n                    k -= actual - i;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        vector<pair<int, int>> v;\\n        for (int dig = 0; dig < 10; dig++) {\\n            while (pos[dig].size()) {\\n                v.push_back({pos[dig].back(), dig});\\n                pos[dig].pop_back();\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        for (auto &[p, d] : v)\\n            ans += to_string(d);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460086,
                "title": "python-code",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        num = list(num)\\n        BIT = [0] *(n+1)\\n        counter = defaultdict(deque)\\n        for idx, val in enumerate(num):\\n            counter[val].append(idx)\\n        def update(i,x):\\n            while i< len(BIT):\\n                BIT[i] +=x\\n                i += i & -i\\n        def query(i):\\n            res = 0\\n            while i>0:\\n                res +=BIT[i]\\n                i -= i&-i\\n            return res\\n        ans = []\\n        used = [False]*n\\n        while k>0 and len(ans)<n:\\n            for d in list(\\'0123456789\\'):\\n                if not counter[d]:\\n                    continue\\n                index = counter[d][0]\\n                offset = query(index)\\n                if index - offset >k:\\n                    continue\\n                if index - offset <=k:\\n                    k -= index-offset\\n                    ans.append(d)\\n                    counter[d].popleft()\\n                    update (index+1, 1)\\n                    used[index] = True\\n                    break\\n        for i in range(n):\\n            if not used[i]:\\n                ans +=num[i]\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        num = list(num)\\n        BIT = [0] *(n+1)\\n        counter = defaultdict(deque)\\n        for idx, val in enumerate(num):\\n            counter[val].append(idx)\\n        def update(i,x):\\n            while i< len(BIT):\\n                BIT[i] +=x\\n                i += i & -i\\n        def query(i):\\n            res = 0\\n            while i>0:\\n                res +=BIT[i]\\n                i -= i&-i\\n            return res\\n        ans = []\\n        used = [False]*n\\n        while k>0 and len(ans)<n:\\n            for d in list(\\'0123456789\\'):\\n                if not counter[d]:\\n                    continue\\n                index = counter[d][0]\\n                offset = query(index)\\n                if index - offset >k:\\n                    continue\\n                if index - offset <=k:\\n                    k -= index-offset\\n                    ans.append(d)\\n                    counter[d].popleft()\\n                    update (index+1, 1)\\n                    used[index] = True\\n                    break\\n        for i in range(n):\\n            if not used[i]:\\n                ans +=num[i]\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399591,
                "title": "java-o-nlogn-30ms-check-pos-by-pos-not-digit-by-digit",
                "content": "#### Wrong Strategy\\nInitially I tried to arrange all the 0s first, then 1s, 2s ..., but that strategy is flawed when there are multiple identical numbers together like \"235288888...1\" It is because when we are looking at number 1, we conclude that the last 1 can\\'t be moved to the head of whatever current is, so we skipped it, but then when we get to 8, due to it being .. 88888 .. , we incur 0 cost to add them, then 1 becomes doable to switch to the current head when previously we\\'ve concluded that it can\\'t be done - **ERROR (44/50 testcase passed)**. This only works if there is no adjcent identical characters and run in `O(10N)`\\n\\n#### Correct Strategy\\nSo then, I decided to check position by position, for each position, I need the best digit, but for this approach, we\\'ve got a problem to deal with. How do we know how many elements to the **right** of the current digit has been swapped? We care only care about those to the **right** because it pushes the current digit to the right when they pass it. In the **Wrong Strategy** section, I dealt with this by just simple suffix sum update, one update takes `O(N)` and for 10 times, in total, `O(10N)`. That approach is not possible here because the outer loop is now position, so we need a Binary Index Tree, making the whole problem solvable in `O(NlogN)`.\\n\\nI am using a queue to keep track of the index of the first number that hasn\\'t been used. It can be shown that the first index is always the better choice.\\n\\n```Java\\n// Time O(NlogN) [30ms submitted once]\\n// Space O(N)\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] A = num.toCharArray();\\n        int[] bit = new int[A.length+2];\\n        Queue<Integer>[] queue = new ArrayDeque[10];\\n        Arrays.setAll(queue, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){ // track indexes for each digit\\n            queue[A[i]-\\'0\\'].offer(i);\\n        }\\n        for (int i = 0; i < A.length; i++){ // solve for each position\\n            for (int j = 0; j < 10; j++){ // from the best to worst\\n                if (!queue[j].isEmpty()){\\n                    int cost = queue[j].peek() - i + (i - sum(bit, queue[j].peek())); // cost needed to move to the head.\\n                    if (cost <= k){\\n                        k -= cost;\\n                        sb.append(j);\\n                        add(bit, queue[j].poll(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(NlogN) [30ms submitted once]\\n// Space O(N)\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] A = num.toCharArray();\\n        int[] bit = new int[A.length+2];\\n        Queue<Integer>[] queue = new ArrayDeque[10];\\n        Arrays.setAll(queue, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){ // track indexes for each digit\\n            queue[A[i]-\\'0\\'].offer(i);\\n        }\\n        for (int i = 0; i < A.length; i++){ // solve for each position\\n            for (int j = 0; j < 10; j++){ // from the best to worst\\n                if (!queue[j].isEmpty()){\\n                    int cost = queue[j].peek() - i + (i - sum(bit, queue[j].peek())); // cost needed to move to the head.\\n                    if (cost <= k){\\n                        k -= cost;\\n                        sb.append(j);\\n                        add(bit, queue[j].poll(), 1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397016,
                "title": "my-intuitive-java-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int length = s.length();\\n        int[] num = new int[length];\\n        int i = 0;\\n        for(char ch : s.toCharArray()) \\n            num[i++] = Integer.parseInt(String.valueOf(ch));\\n        \\n\\t\\tfor (i = 0; i < length && k > 0; i++){\\n\\t\\t\\tint minIndex = 0, min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint limit = (k + i) > length - 1 ? length - 1 : k + i;\\n\\n\\t\\t\\tfor(int j = i; j <= limit; j++){\\n\\t\\t\\t\\tif (num[j] < min){\\n\\t\\t\\t\\t\\tmin = num[j];\\n\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= (minIndex - i);\\n\\t\\t\\tfor(int idx = minIndex; idx > i; idx--) {\\n\\t\\t\\t\\tint temp = num[idx - 1];\\n\\t\\t\\t\\tnum[idx - 1] = num[idx];\\n\\t\\t\\t\\tnum[idx] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int n : num) ans.append(n);\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int length = s.length();\\n        int[] num = new int[length];\\n        int i = 0;\\n        for(char ch : s.toCharArray()) \\n            num[i++] = Integer.parseInt(String.valueOf(ch));\\n        \\n\\t\\tfor (i = 0; i < length && k > 0; i++){\\n\\t\\t\\tint minIndex = 0, min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint limit = (k + i) > length - 1 ? length - 1 : k + i;\\n\\n\\t\\t\\tfor(int j = i; j <= limit; j++){\\n\\t\\t\\t\\tif (num[j] < min){\\n\\t\\t\\t\\t\\tmin = num[j];\\n\\t\\t\\t\\t\\tminIndex = j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tk -= (minIndex - i);\\n\\t\\t\\tfor(int idx = minIndex; idx > i; idx--) {\\n\\t\\t\\t\\tint temp = num[idx - 1];\\n\\t\\t\\t\\tnum[idx - 1] = num[idx];\\n\\t\\t\\t\\tnum[idx] = temp;\\n\\t\\t\\t}\\n\\t\\t}\\n        StringBuilder ans = new StringBuilder(\"\");\\n        for(int n : num) ans.append(n);\\n\\t\\treturn ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178682,
                "title": "o-nlogn-segment-tree-binary-search",
                "content": "For a given swap count `k`, if we are currently at index `i` of our array `nums`, we wish to find the minimum element in `nums` that is `<= k` swaps away from index `i`, and bubble it up to `i`\\'s position, eating up some number of swaps along the way. We repeatedly do this until we have either:\\n- exhausted all swaps\\n- exhausted all digits in `nums`\\n\\nThe fact that we are trying to find a minimum value within some prescribed interval range should immediately suggest we leverage a segment tree (`min` is binary, associative operation), where the minimum value stored for an internal/parent node is the minimum of the minimum values stored by it\\'s two children:\\n```\\nparent min = min(left child min, right child min)\\n```\\n\\nThere are a couple of subtleties to be mindful of, which we discuss below.\\n\\n**ACCEPTABLE INDEX INTERVAL**\\nSuppose we have performed a bunch of swaps so far. How do we determine which range of original indexes in `nums` we should be searching our segment tree for the next round of swaps, if we have `k` swaps left? \\n\\nLet\\'s maintain a sorted list `free` of the original indexes of unused values in `nums`, throughout the swapping rounds (by unused, we simply mean the value at this original index has not been bubbled up towards the front yet). Then, the index interval `[free[0], free[k]]` is certainly what we care about (note, if `k > len(free)`, then right-hand endpoint will be `free[n-1]`). This is because we are guaranteed everything we removed from `free` during prior rounds, will precede `free[0]` in our final semi-sorted result, and so the corresponding digits for `free[0], free[1], ..., free[k]` should currently be contiguous after those earlier swaps were performed. By restricting to the first `k+1` such, we are ensured we don\\'t go beyond `k` swaps for this upcoming round.\\n\\nHowever, we want to make sure, when searching our segment tree for the minimum value in this interval `[free[0], free[k]]`, we don\\'t take into account any indexes in this interval that were previously used. We treat this next.\\n\\n**\"DELETION\" OF NODES**\\nWhenever we have used an original index `i`, we want to make sure it won\\'t be eligible in future swapping rounds. How can we easily achieve this? Since our segment tree is keeping track of minimums over index subintervals of `nums`, we should:\\n- search for the segment tree node corresponding to the index `i` we just used\\n- set the min value for this tree node to infinity\\n- parent back up, using the same update rule we did during building of the tree (i.e. `parent min = min(left child min, right child min)`)\\n\\nBy doing this, whenever we later search for a minimum value in some prescribed index range `[a, b]` which contains previously used index `i`, we know `nums[i]` will no longer contribute to this answer since we artificially made it too large in our tree, effectively deleting it from the segment tree (for the purpose of lookups).\\n\\nWe now know:\\n- which subinterval to restrict our segment tree search for a min value; it will depending on the number of remaining swaps `k` and our maintained sorted list of currently free/unused indexes\\n- how to avoid re-using previously used indexes that fall into such a search interval;  \"delete\" the corresponding leaf node from the segment tree by updating the value to something large, and propagate this update to ancestor nodes\\n\\nSo we can easily get the minimum we care about. But once we have it and swapped it forward, how do we know how many swaps are remaining after?\\n\\n\\n**UPDATING REMAINING SWAPS: BINARY SEARCH**\\nAs we\\'ve vaguely discussed so far, our segment tree is returning the minimum free value within a restricted index interval of interest (the restriction being the number of swaps we have remaining). Although this gives us the next value to bubble up, it yields no information about how many swaps actually got used, hence gives us no way to update the remaining swaps after this round.\\n\\nRather than returning the minimum free value within some interval `[free[0], free[k]]`, our segment tree should return the _index of_ the minimum free value within that interval. Suppose we get free index `j`, then we know at most  `j - free[0]` swaps were performed, and we simply need to deduct the number of indexes in `[free[0], j]` that were already used/swapped in prior rounds. \\n\\nFor this, let\\'s just maintain a complementary sorted list to `free`, call it `used`. We can easily binary search for the number of elements in range `[free[0], j]` that are in `used`, denote this value `u`. Then this means the number of swaps we used to bubble up `nums[j]` was precisely:\\n```\\nj - free[0] - u\\n```\\nand that\\'s what we update our remaining swap count `k` to for the next round.\\n\\n**CODE**\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        \\n        # CORNER CASE: able to handle the worst case scenario of sorting a reverse sorted list\\n        if k >= n * (n - 1) // 2:\\n            return \"\".join(sorted(num))\\n        \\n        nums = [int(x) for x in num]\\n        \\n        # segment tree data structures and methods\\n        min_val = [float(\"inf\")] * 4 * n\\n        min_index = [float(\"inf\")] * 4 * n\\n        \\n        def build(node: int, l: int, r: int):\\n            # CASE 1: arrived at a leaf node\\n            if l == r:\\n                min_val[node] = nums[l]\\n                min_index[node] = l\\n                return\\n            # CASE 2: still at an internal node, recurse down\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            build(left_child, l, mid)\\n            build(right_child, mid + 1, r)\\n            update(node)\\n        \\n        def update(node: int):\\n            \"\"\"\\n            update rule for internal/parent node in segment tree. In case, minima for children\\n            is a tie, left child wins, since this results in fewer swaps to move corresponding digit in nums forward.\\n            \"\"\"\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            if min_val[left_child] <= min_val[right_child]:\\n                winner = left_child\\n            else:\\n                winner = right_child\\n            min_val[node] = min_val[winner]\\n            min_index[node] = min_index[winner]\\n        \\n        def lookup(node: int, l: int, r: int, desired_l: int, desired_r: int):\\n            \"\"\"\\n            Return\\'s the index in nums of the currently smallest value in range [desired_l, desired_r]\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > desired_r or r < desired_l:\\n                return None\\n            # CASE 2: containment of node\\'s interval [l,r] inside of [desired_l, desired_r]\\n            if desired_l <= l and r <= desired_r:\\n                return min_index[node]\\n\\t\\t    # CASE 3: intersection of node\\'s interval [l, r] with [desired_l, desired_r]\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            left_res = lookup(left_child, l,  mid, desired_l, desired_r)\\n            right_res = lookup(right_child, mid + 1, r, desired_l, desired_r)\\n            if left_res is None:\\n                return right_res\\n            if right_res is None:\\n                return left_res\\n            if nums[left_res] <= nums[right_res]:\\n                return left_res\\n            else:\\n                return right_res\\n        \\n        def delete(node: int, l: int, r: int, target: int):\\n            \"\"\"\\n            Update\\'s segment tree leaf corresponding to index target in nums to be infinity, \\n            and updates parent node values on the way back up recursive call stack\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > target or r < target:\\n                return\\n            # CASE 2: at the target leaf\\n            if l == r:\\n                min_val[node] = float(\"inf\")\\n                nums[target] = float(\"inf\")\\n                return\\n            # CASE 3: internal node whose interval [l, r] contains target\\n            mid = (l + r) // 2\\n            if target <= mid:\\n                left_child = 2 * node + 1\\n                delete(left_child, l, mid, target)\\n            else:\\n                right_child = 2 * node + 2\\n                delete(right_child, mid + 1, r, target)\\n            update(node)\\n        \\n        # STEP 1: build the segment tree\\n        build(0, 0, n-1)\\n        \\n        \\n        # STEP 2: While we have swaps available, greedily pick the smallest allowed value possible\\n        # to swap into current position in our result\\n        res = []\\n        free = SortedList([i for i in range(n)])\\n        used = SortedList()\\n        while k > 0 and len(res) < n:\\n            # Find allowed range of indexes in the original array to search for a free minimum\\n            left_index = free[0]\\n            r = min(k, len(free) - 1)\\n            right_index = free[r]\\n            # Get the index of the swapped in element in nums, update our final result, and \"delete\" from segment tree\\n            next_index = lookup(0, 0, n - 1, left_index, right_index) \\n            res.append(str(nums[next_index]))\\n            delete(0, 0, n - 1, next_index)\\n            # Determine precisely how many swaps occurred to bubble up nums[next_index]\\n            intervening_that_were_used = used.bisect_right(next_index) - used.bisect_right(left_index)\\n            swaps = next_index - left_index - intervening_that_were_used\\n            k -= swaps\\n            # Update our sorted lists of used and unused elements\\n            free.remove(next_index)\\n            used.add(next_index)\\n        \\n        # STEP 3: any indices i which were not used, tack on nums[i] IN ORDER, since no more swaps allowed\\n        for i in range(n):\\n            if nums[i] == float(\"inf\"):\\n                continue\\n            res.append(str(nums[i]))\\n        return \"\".join(res)\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nparent min = min(left child min, right child min)\\n```\n```\\nj - free[0] - u\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        \\n        # CORNER CASE: able to handle the worst case scenario of sorting a reverse sorted list\\n        if k >= n * (n - 1) // 2:\\n            return \"\".join(sorted(num))\\n        \\n        nums = [int(x) for x in num]\\n        \\n        # segment tree data structures and methods\\n        min_val = [float(\"inf\")] * 4 * n\\n        min_index = [float(\"inf\")] * 4 * n\\n        \\n        def build(node: int, l: int, r: int):\\n            # CASE 1: arrived at a leaf node\\n            if l == r:\\n                min_val[node] = nums[l]\\n                min_index[node] = l\\n                return\\n            # CASE 2: still at an internal node, recurse down\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            build(left_child, l, mid)\\n            build(right_child, mid + 1, r)\\n            update(node)\\n        \\n        def update(node: int):\\n            \"\"\"\\n            update rule for internal/parent node in segment tree. In case, minima for children\\n            is a tie, left child wins, since this results in fewer swaps to move corresponding digit in nums forward.\\n            \"\"\"\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            if min_val[left_child] <= min_val[right_child]:\\n                winner = left_child\\n            else:\\n                winner = right_child\\n            min_val[node] = min_val[winner]\\n            min_index[node] = min_index[winner]\\n        \\n        def lookup(node: int, l: int, r: int, desired_l: int, desired_r: int):\\n            \"\"\"\\n            Return\\'s the index in nums of the currently smallest value in range [desired_l, desired_r]\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > desired_r or r < desired_l:\\n                return None\\n            # CASE 2: containment of node\\'s interval [l,r] inside of [desired_l, desired_r]\\n            if desired_l <= l and r <= desired_r:\\n                return min_index[node]\\n\\t\\t    # CASE 3: intersection of node\\'s interval [l, r] with [desired_l, desired_r]\\n            mid = (l + r) // 2\\n            left_child = 2 * node + 1\\n            right_child = left_child + 1\\n            left_res = lookup(left_child, l,  mid, desired_l, desired_r)\\n            right_res = lookup(right_child, mid + 1, r, desired_l, desired_r)\\n            if left_res is None:\\n                return right_res\\n            if right_res is None:\\n                return left_res\\n            if nums[left_res] <= nums[right_res]:\\n                return left_res\\n            else:\\n                return right_res\\n        \\n        def delete(node: int, l: int, r: int, target: int):\\n            \"\"\"\\n            Update\\'s segment tree leaf corresponding to index target in nums to be infinity, \\n            and updates parent node values on the way back up recursive call stack\\n            \"\"\"\\n            # CASE 1: out of bounds\\n            if l > target or r < target:\\n                return\\n            # CASE 2: at the target leaf\\n            if l == r:\\n                min_val[node] = float(\"inf\")\\n                nums[target] = float(\"inf\")\\n                return\\n            # CASE 3: internal node whose interval [l, r] contains target\\n            mid = (l + r) // 2\\n            if target <= mid:\\n                left_child = 2 * node + 1\\n                delete(left_child, l, mid, target)\\n            else:\\n                right_child = 2 * node + 2\\n                delete(right_child, mid + 1, r, target)\\n            update(node)\\n        \\n        # STEP 1: build the segment tree\\n        build(0, 0, n-1)\\n        \\n        \\n        # STEP 2: While we have swaps available, greedily pick the smallest allowed value possible\\n        # to swap into current position in our result\\n        res = []\\n        free = SortedList([i for i in range(n)])\\n        used = SortedList()\\n        while k > 0 and len(res) < n:\\n            # Find allowed range of indexes in the original array to search for a free minimum\\n            left_index = free[0]\\n            r = min(k, len(free) - 1)\\n            right_index = free[r]\\n            # Get the index of the swapped in element in nums, update our final result, and \"delete\" from segment tree\\n            next_index = lookup(0, 0, n - 1, left_index, right_index) \\n            res.append(str(nums[next_index]))\\n            delete(0, 0, n - 1, next_index)\\n            # Determine precisely how many swaps occurred to bubble up nums[next_index]\\n            intervening_that_were_used = used.bisect_right(next_index) - used.bisect_right(left_index)\\n            swaps = next_index - left_index - intervening_that_were_used\\n            k -= swaps\\n            # Update our sorted lists of used and unused elements\\n            free.remove(next_index)\\n            used.add(next_index)\\n        \\n        # STEP 3: any indices i which were not used, tack on nums[i] IN ORDER, since no more swaps allowed\\n        for i in range(n):\\n            if nums[i] == float(\"inf\"):\\n                continue\\n            res.append(str(nums[i]))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100827,
                "title": "python-fenwick-tree-solution",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        tr = [0 for i in range(n+1)]\\n        def add(ind,d):\\n            while ind<=n:\\n                tr[ind] += d\\n                ind += -ind&ind\\n        def query(ind):\\n            res = 0\\n            while ind:\\n                res += tr[ind]\\n                ind -= -ind&ind\\n            return res\\n        \\n        pm = [[]for i in range(10)]\\n        for i in range(n-1,-1,-1):\\n            pm[ord(num[i]) - ord(\\'0\\')].append(i)\\n        ans = \"\"\\n        for i in range(n):\\n            for j in range(10):\\n                if pm[j]:\\n                    cnt = query(n) - query(pm[j][-1]+1)\\n                    if pm[j][-1] - i + cnt <= k:\\n                        k -= pm[j][-1] - i + cnt\\n                        ans += str(j)\\n                        add(pm[j][-1]+1,1)\\n                        pm[j].pop()\\n                        break\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        tr = [0 for i in range(n+1)]\\n        def add(ind,d):\\n            while ind<=n:\\n                tr[ind] += d\\n                ind += -ind&ind\\n        def query(ind):\\n            res = 0\\n            while ind:\\n                res += tr[ind]\\n                ind -= -ind&ind\\n            return res\\n        \\n        pm = [[]for i in range(10)]\\n        for i in range(n-1,-1,-1):\\n            pm[ord(num[i]) - ord(\\'0\\')].append(i)\\n        ans = \"\"\\n        for i in range(n):\\n            for j in range(10):\\n                if pm[j]:\\n                    cnt = query(n) - query(pm[j][-1]+1)\\n                    if pm[j][-1] - i + cnt <= k:\\n                        k -= pm[j][-1] - i + cnt\\n                        ans += str(j)\\n                        add(pm[j][-1]+1,1)\\n                        pm[j].pop()\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092084,
                "title": "c-segment-tree-greedy-o-nlogn-time",
                "content": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Segment Tree, Greedy (put the possible feasible smallest index in place of cur index), Queue\\n    Difficulty: H (Both Logic and Implementation)\\n*/\\n\\nclass SegmentTree {\\n    vector<int> tree;\\n\\npublic:\\n    SegmentTree(int size) {\\n        tree.resize(4 * size + 1, 0);\\n    }\\n\\n    void printTree() {\\n        for (int num : tree) cout << num << \"\";\\n        cout << endl;\\n    }\\n\\n    void updateTree(int lo, int hi, int index, int upd) {\\n        if (upd < lo || upd > hi) return;\\n        if (lo == hi) {\\n            tree[index]++;\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        updateTree(lo, mid, 2 * index, upd);\\n        updateTree(mid + 1, hi, 2 * index + 1, upd);\\n        tree[index] = tree[2 * index] + tree[2 * index + 1];\\n    }\\n\\n    int queryTree(int lo, int hi, int index, int qs, int qe) {\\n        if (qe < lo || qs > hi) return 0;\\n        if (qe >= hi && qs <= lo) return tree[index];\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        int left = queryTree(lo, mid, 2 * index, qs, qe);\\n        int right = queryTree(mid + 1, hi, 2 * index + 1, qs, qe);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        queue<int> pos[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            pos[num[i] - \\'0\\'].push(i);\\n        }\\n        string res = \"\";\\n        SegmentTree *seg = new SegmentTree((int)num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            if (num[i] == \\'-\\') continue;\\n            int digit = num[i] - \\'0\\';\\n\\n            bool swapped = false;\\n            for (int j = 0; j < digit; j++) {\\n                if (pos[j].size() > 0) {\\n                    int curNumIndex = pos[j].front();\\n                    int shifts = seg->queryTree(0, num.length() - 1, 1, i, pos[j].front());\\n\\n                    if (curNumIndex - i - shifts <= k) {\\n                        seg->updateTree(0, num.length() - 1, 1, curNumIndex);\\n                        k -= curNumIndex - i - shifts;\\n                        pos[j].pop();\\n                        res += num[curNumIndex];\\n                        num[curNumIndex] = \\'-\\';\\n                        swapped = true;\\n                        i--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!swapped) {\\n                res += num[i];\\n                pos[digit].pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Segment Tree, Greedy (put the possible feasible smallest index in place of cur index), Queue\\n    Difficulty: H (Both Logic and Implementation)\\n*/\\n\\nclass SegmentTree {\\n    vector<int> tree;\\n\\npublic:\\n    SegmentTree(int size) {\\n        tree.resize(4 * size + 1, 0);\\n    }\\n\\n    void printTree() {\\n        for (int num : tree) cout << num << \"\";\\n        cout << endl;\\n    }\\n\\n    void updateTree(int lo, int hi, int index, int upd) {\\n        if (upd < lo || upd > hi) return;\\n        if (lo == hi) {\\n            tree[index]++;\\n            return;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        updateTree(lo, mid, 2 * index, upd);\\n        updateTree(mid + 1, hi, 2 * index + 1, upd);\\n        tree[index] = tree[2 * index] + tree[2 * index + 1];\\n    }\\n\\n    int queryTree(int lo, int hi, int index, int qs, int qe) {\\n        if (qe < lo || qs > hi) return 0;\\n        if (qe >= hi && qs <= lo) return tree[index];\\n\\n        int mid = lo + (hi - lo) / 2;\\n\\n        int left = queryTree(lo, mid, 2 * index, qs, qe);\\n        int right = queryTree(mid + 1, hi, 2 * index + 1, qs, qe);\\n        return left + right;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        queue<int> pos[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            pos[num[i] - \\'0\\'].push(i);\\n        }\\n        string res = \"\";\\n        SegmentTree *seg = new SegmentTree((int)num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            if (num[i] == \\'-\\') continue;\\n            int digit = num[i] - \\'0\\';\\n\\n            bool swapped = false;\\n            for (int j = 0; j < digit; j++) {\\n                if (pos[j].size() > 0) {\\n                    int curNumIndex = pos[j].front();\\n                    int shifts = seg->queryTree(0, num.length() - 1, 1, i, pos[j].front());\\n\\n                    if (curNumIndex - i - shifts <= k) {\\n                        seg->updateTree(0, num.length() - 1, 1, curNumIndex);\\n                        k -= curNumIndex - i - shifts;\\n                        pos[j].pop();\\n                        res += num[curNumIndex];\\n                        num[curNumIndex] = \\'-\\';\\n                        swapped = true;\\n                        i--;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!swapped) {\\n                res += num[i];\\n                pos[digit].pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1993616,
                "title": "python-bit-solution-with-explanation",
                "content": "```\\n# For each index, find the smallest digit at the right within distance k, and left shift it to current index\\n# After shift, update k \\n# Ex : num = 4321567, k = 4, \\n# [4]321567 -> [1]432567 , since there are 3 left shift, k = k -3 = 1\\n# In the above example, all index before 3 (432) increase by one, and all index after 3 (567) remain its index, \\n# We can use BIT to minus all index after 3 by 1, and then add 1 to all index, this equals to add 1 to all index before 3\\n# Note that index of BIT start from 1, so when query at index use query[j+1], and update at j use update(j+1)\\n# Apply this to all the digits to get the answer\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:   \\n        N = len(num)\\n        BIT = [0] * (N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x] -= 1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        dq = collections.defaultdict(collections.deque)\\n        for i,n in enumerate(num):\\n            dq[n].append(i) \\n        res = \\'\\'\\n        for i,c in enumerate(num):\\n            for d in string.digits:\\n                if dq[d]:\\n                    j = dq[d][0]\\n                    j_adj = j + query(j+1) + i\\n                    dis = j_adj - i\\n                    if dis <= k:\\n                        update(j+1)\\n                        k-=dis\\n                        res+=d\\n                        dq[d].popleft()\\n                        break\\n        return res\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\n# For each index, find the smallest digit at the right within distance k, and left shift it to current index\\n# After shift, update k \\n# Ex : num = 4321567, k = 4, \\n# [4]321567 -> [1]432567 , since there are 3 left shift, k = k -3 = 1\\n# In the above example, all index before 3 (432) increase by one, and all index after 3 (567) remain its index, \\n# We can use BIT to minus all index after 3 by 1, and then add 1 to all index, this equals to add 1 to all index before 3\\n# Note that index of BIT start from 1, so when query at index use query[j+1], and update at j use update(j+1)\\n# Apply this to all the digits to get the answer\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:   \\n        N = len(num)\\n        BIT = [0] * (N+1)\\n        def update(x):\\n            while x <= N:\\n                BIT[x] -= 1\\n                x += x&(-x)\\n        def query(x):\\n            res = 0\\n            while x > 0:\\n                res += BIT[x]\\n                x -= x&(-x)\\n            return res\\n        dq = collections.defaultdict(collections.deque)\\n        for i,n in enumerate(num):\\n            dq[n].append(i) \\n        res = \\'\\'\\n        for i,c in enumerate(num):\\n            for d in string.digits:\\n                if dq[d]:\\n                    j = dq[d][0]\\n                    j_adj = j + query(j+1) + i\\n                    dis = j_adj - i\\n                    if dis <= k:\\n                        update(j+1)\\n                        k-=dis\\n                        res+=d\\n                        dq[d].popleft()\\n                        break\\n        return res\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987427,
                "title": "python-clean-and-easy-to-understand",
                "content": "class Solution:\\n    \\'\\'\\'\\n    Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n    Observation 2: Choose first smallest d that is in reach of k.\\n\\t*Learned from khaufnak\\n    \\'\\'\\'\\n\\n    def minInteger(self, num: str, k: int) -> str:\\n        preInd = 0\\n        to_find = 0\\n        while k > 0 and to_find < 10 and preInd < len(num):\\n            ind = num.find(str(to_find), preInd)\\n            if ind != -1 and ind - preInd <= k:\\n                # swap and reroder numbers\\n                num = num[:preInd] + num[ind] + num[preInd:ind] + num[ind+1:]\\n                to_find = 0\\n                k = k - ind + preInd\\n                preInd += 1\\n            else:\\n                to_find += 1\\n        return num\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    \\'\\'\\'\\n    Observation 1: when we move a digit to left, other digit are shifted to right. i.e 432 got shifted to right by 1.\\n    Observation 2: Choose first smallest d that is in reach of k.\\n\\t*Learned from khaufnak\\n    \\'\\'\\'\\n\\n    def minInteger(self, num: str, k: int) -> str:\\n        preInd = 0\\n        to_find = 0\\n        while k > 0 and to_find < 10 and preInd < len(num):\\n            ind = num.find(str(to_find), preInd)\\n            if ind != -1 and ind - preInd <= k:\\n                # swap and reroder numbers\\n                num = num[:preInd] + num[ind] + num[preInd:ind] + num[ind+1:]\\n                to_find = 0\\n                k = k - ind + preInd\\n                preInd += 1\\n            else:\\n                to_find += 1\\n        return num\\n",
                "codeTag": "Java"
            },
            {
                "id": 1978663,
                "title": "java-binary-indexed-tree",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder ans=new StringBuilder();\\n        int n=num.length();\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        BIT bit=new BIT(n);\\n        for(int i=0; i<n; i++){\\n            // System.out.println(i);\\n            for (int d = 0; d <= 9; ++d) {\\n                // System.out.println(\"  \"+d);\\n                if(pqs.get(d).size()>0){\\n                    int pos=pqs.get(d).peek();\\n                    int shift=bit.query(pos+1);\\n                    // System.out.println(\"   \"+pos+\" \"+shift);\\n                    if(pos-shift<=k){\\n                        k-=pos-shift;\\n                        bit.update(pos+1);\\n                        ans.append(d);\\n                        // System.out.println(\"    \"+k+\" \"+ans);\\n                        pqs.get(d).remove();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\nclass BIT{\\n    int[] cnt;\\n    int n;\\n    public BIT(int n){\\n        cnt=new int[n+1];\\n        this.n=n+1;\\n    }\\n    int query(int x){\\n        int ans=0;\\n        while(x>0){\\n            ans+=cnt[x];\\n            x-=x&-x;\\n        }\\n        return ans;\\n    }\\n    void update(int x){\\n        while(x<n){\\n            cnt[x]++;\\n            x+=x&-x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        StringBuilder ans=new StringBuilder();\\n        int n=num.length();\\n        List<Queue<Integer>> pqs = new ArrayList<>();\\n        for (int i = 0; i <= 9; ++i) {\\n            pqs.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); ++i) {\\n            pqs.get(num.charAt(i) - \\'0\\').add(i);\\n        }\\n        BIT bit=new BIT(n);\\n        for(int i=0; i<n; i++){\\n            // System.out.println(i);\\n            for (int d = 0; d <= 9; ++d) {\\n                // System.out.println(\"  \"+d);\\n                if(pqs.get(d).size()>0){\\n                    int pos=pqs.get(d).peek();\\n                    int shift=bit.query(pos+1);\\n                    // System.out.println(\"   \"+pos+\" \"+shift);\\n                    if(pos-shift<=k){\\n                        k-=pos-shift;\\n                        bit.update(pos+1);\\n                        ans.append(d);\\n                        // System.out.println(\"    \"+k+\" \"+ans);\\n                        pqs.get(d).remove();\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\nclass BIT{\\n    int[] cnt;\\n    int n;\\n    public BIT(int n){\\n        cnt=new int[n+1];\\n        this.n=n+1;\\n    }\\n    int query(int x){\\n        int ans=0;\\n        while(x>0){\\n            ans+=cnt[x];\\n            x-=x&-x;\\n        }\\n        return ans;\\n    }\\n    void update(int x){\\n        while(x<n){\\n            cnt[x]++;\\n            x+=x&-x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966653,
                "title": "java-iterative-simple",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n=num.length();\\n        if(num.charAt(0)==\\'0\\'){\\n            return num;\\n        }\\n        System.out.println(n);\\n        char[] cA=num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            for(int d=0; d<cA[i]-\\'0\\'; d++){\\n                int pos=i+1;\\n                while(pos<n && pos-i<=k && cA[pos]-\\'0\\'!=d){\\n                    pos++;\\n                }\\n                if(pos<n && pos-i<=k){\\n                    swap(cA, i, pos);\\n                    k-=pos-i;\\n                }\\n            }\\n        }\\n        return new String(cA);\\n    }\\n    void swap(char[] cA, int i, int j){\\n        char t=cA[j];\\n        while(j>i){\\n            cA[j]=cA[j-1];\\n            j--;\\n        }\\n        cA[i]=t;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n=num.length();\\n        if(num.charAt(0)==\\'0\\'){\\n            return num;\\n        }\\n        System.out.println(n);\\n        char[] cA=num.toCharArray();\\n        for(int i=0; i<n; i++){\\n            for(int d=0; d<cA[i]-\\'0\\'; d++){\\n                int pos=i+1;\\n                while(pos<n && pos-i<=k && cA[pos]-\\'0\\'!=d){\\n                    pos++;\\n                }\\n                if(pos<n && pos-i<=k){\\n                    swap(cA, i, pos);\\n                    k-=pos-i;\\n                }\\n            }\\n        }\\n        return new String(cA);\\n    }\\n    void swap(char[] cA, int i, int j){\\n        char t=cA[j];\\n        while(j>i){\\n            cA[j]=cA[j-1];\\n            j--;\\n        }\\n        cA[i]=t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964479,
                "title": "python-fenwick-tree-bit",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n=len(num)\\n        ft=[0]*(n+1)\\n        D=defaultdict(lambda : deque())\\n        for idx,val in enumerate(num):\\n            D[int(val)].append(idx+1)\\n            \\n        def update(i,no):\\n            while i<=n:\\n                ft[i]+=no\\n                i += i & -i\\n                \\n        def query(i):\\n            res=0\\n            while i>0:\\n                res+=ft[i]\\n                i -= i & -i\\n            return res\\n        \\n        ans=\"\"\\n        t=0\\n        while k>0:\\n            flag=False\\n            for i in range(10):\\n                if len(D[i])>0:\\n                    x=D[i][0]-query(D[i][0])-1\\n                    if k>=x:\\n                        k-=x\\n                        flag=True\\n                        ans+=str(i)\\n                        update(D[i][0],1)\\n                        D[i].popleft()\\n                        break\\n            if not flag:\\n                break\\n        temp=[]\\n        for key in D:\\n            for val in D[key]:\\n                temp.append((val,key))\\n        temp.sort()\\n        for idx,no in temp:\\n            ans+=str(no)\\n        return ans\\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n=len(num)\\n        ft=[0]*(n+1)\\n        D=defaultdict(lambda : deque())\\n        for idx,val in enumerate(num):\\n            D[int(val)].append(idx+1)\\n            \\n        def update(i,no):\\n            while i<=n:\\n                ft[i]+=no\\n                i += i & -i\\n                \\n        def query(i):\\n            res=0\\n            while i>0:\\n                res+=ft[i]\\n                i -= i & -i\\n            return res\\n        \\n        ans=\"\"\\n        t=0\\n        while k>0:\\n            flag=False\\n            for i in range(10):\\n                if len(D[i])>0:\\n                    x=D[i][0]-query(D[i][0])-1\\n                    if k>=x:\\n                        k-=x\\n                        flag=True\\n                        ans+=str(i)\\n                        update(D[i][0],1)\\n                        D[i].popleft()\\n                        break\\n            if not flag:\\n                break\\n        temp=[]\\n        for key in D:\\n            for val in D[key]:\\n                temp.append((val,key))\\n        temp.sort()\\n        for idx,no in temp:\\n            ans+=str(no)\\n        return ans\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705504,
                "title": "python-segment-tree-o-nlogn",
                "content": "For num[i], if it hasn\\'t been shifted, then just find the minimum digit num[j] that j > i, and num[j] is also not been shifted, and the number of swaps for num[j] to be shifted to i-th index = j - i - digits_shift(i, j) <= k.\\n\\nIf such num[j] exists, num[j] will be shifted to i-th index, otherwise num[i] will be kept.\\n\\nTo count digits_shift between [i, j], since we modify the description that if num[t] has been shifted, Segment Tree is a good data structure to qurry the statistic information of [i, j].\\n\\nTime: O(NlogN)\\nSpace: O(N)\\n```\\nclass Solution(object):\\n    def minInteger(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def segmentAdd(idx):\\n            return _add(1, 0, n - 1, idx)\\n\\n        def _add(node, left, right, idx):\\n            if left <= idx <= right:\\n                segment[node] += 1\\n                if left != right:\\n                    mid = (left + right) // 2\\n                    _add(2 * node, left, mid, idx)\\n                    _add(2 * node + 1, mid + 1, right, idx)\\n\\n        def segmentCount(begin, end):\\n            return _count(1, 0, n - 1, begin, end)\\n\\n        def _count(node, left, right, begin, end):\\n            if right < begin or left > end:\\n                return 0\\n            if begin <= left and end >= right:\\n                return segment[node]\\n            mid = (left + right) // 2\\n            return _count(2 * node, left, mid, begin, end) + _count(2 * node + 1, mid + 1, right, begin, end)\\n\\n        n = len(num)\\n        segment = [0] * (4 * n)\\n        digits_idx = collections.defaultdict(lambda :collections.deque())\\n        for i, d in enumerate(num):\\n            digits_idx[int(d)].append(i)\\n        ans = []\\n        shifted = set()\\n        i = 0\\n        n = len(num)\\n        while i < n:\\n            if i in shifted:\\n                i += 1\\n                continue\\n            if k == 0:\\n                ans.append(num[i])\\n                i += 1\\n            else:\\n                for d in range(int(num[i])):\\n                    while digits_idx[d] and digits_idx[d][0] < i:\\n                        digits_idx[d].popleft()\\n                    if digits_idx[d]:\\n                        j = digits_idx[d][0]\\n                        digitsMoved = segmentCount(i, j)\\n                        if j - i - digitsMoved <= k:\\n                            segmentAdd(j)\\n                            ans.append(num[j])\\n                            shifted.add(j)\\n                            k -= digits_idx[d].popleft() - i - digitsMoved\\n                            break\\n                else:\\n                    ans.append(num[i])\\n                    i += 1\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minInteger(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        def segmentAdd(idx):\\n            return _add(1, 0, n - 1, idx)\\n\\n        def _add(node, left, right, idx):\\n            if left <= idx <= right:\\n                segment[node] += 1\\n                if left != right:\\n                    mid = (left + right) // 2\\n                    _add(2 * node, left, mid, idx)\\n                    _add(2 * node + 1, mid + 1, right, idx)\\n\\n        def segmentCount(begin, end):\\n            return _count(1, 0, n - 1, begin, end)\\n\\n        def _count(node, left, right, begin, end):\\n            if right < begin or left > end:\\n                return 0\\n            if begin <= left and end >= right:\\n                return segment[node]\\n            mid = (left + right) // 2\\n            return _count(2 * node, left, mid, begin, end) + _count(2 * node + 1, mid + 1, right, begin, end)\\n\\n        n = len(num)\\n        segment = [0] * (4 * n)\\n        digits_idx = collections.defaultdict(lambda :collections.deque())\\n        for i, d in enumerate(num):\\n            digits_idx[int(d)].append(i)\\n        ans = []\\n        shifted = set()\\n        i = 0\\n        n = len(num)\\n        while i < n:\\n            if i in shifted:\\n                i += 1\\n                continue\\n            if k == 0:\\n                ans.append(num[i])\\n                i += 1\\n            else:\\n                for d in range(int(num[i])):\\n                    while digits_idx[d] and digits_idx[d][0] < i:\\n                        digits_idx[d].popleft()\\n                    if digits_idx[d]:\\n                        j = digits_idx[d][0]\\n                        digitsMoved = segmentCount(i, j)\\n                        if j - i - digitsMoved <= k:\\n                            segmentAdd(j)\\n                            ans.append(num[j])\\n                            shifted.add(j)\\n                            k -= digits_idx[d].popleft() - i - digitsMoved\\n                            break\\n                else:\\n                    ans.append(num[i])\\n                    i += 1\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638964,
                "title": "c-with-gnu-order-stat-tree-o-nlogn",
                "content": "We basically do insertion sort at each step but we need to keep track of the positions used up so far to calculate the distance. \\nFor that purpose, we can make use of the order stat tree provided by GNU ( not in STL).\\n\\nThe order statistic tree allows O(logN) insertion/deletion and also O(logN) find_rank/find_order.\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<int> d2p[10];\\n        for (int ii = 0; ii < num.size(); ii++) {\\n            d2p[num[ii] - \\'0\\'].push_back(ii);\\n        }\\n        \\n        tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> nums_used_order_stat_tree;\\n            \\n        string ans = \"\";\\n        \\n        for (int ii = 0; ii < 10; ii++) {\\n            reverse(d2p[ii].begin(), d2p[ii].end());\\n        }\\n        \\n        for (int ii = 0; ii < num.size(); ii++) {\\n            int minimum_index = -1;\\n            for (int jj = 0; jj <= 9; jj++) {\\n                if (d2p[jj].size() != 0 && (minimum_index == -1 || d2p[jj].back() < d2p[minimum_index].back()))\\n                    minimum_index = jj;\\n            }\\n            \\n            int jj = 0;\\n            if (k == 0) {\\n                jj = minimum_index;\\n            } else {\\n                for (; jj < minimum_index; jj++) {\\n                    if (d2p[jj].size() != 0) {\\n                        int num_used = nums_used_order_stat_tree.order_of_key(d2p[jj].back()) - \\n                                         nums_used_order_stat_tree.order_of_key(d2p[minimum_index].back());\\n                        if (d2p[jj].back() - d2p[minimum_index].back() - num_used <= k) {\\n                            k -= (d2p[jj].back() - d2p[minimum_index].back() - num_used);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(jj + \\'0\\');\\n            nums_used_order_stat_tree.insert(d2p[jj].back());\\n            d2p[jj].pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<int> d2p[10];\\n        for (int ii = 0; ii < num.size(); ii++) {\\n            d2p[num[ii] - \\'0\\'].push_back(ii);\\n        }\\n        \\n        tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> nums_used_order_stat_tree;\\n            \\n        string ans = \"\";\\n        \\n        for (int ii = 0; ii < 10; ii++) {\\n            reverse(d2p[ii].begin(), d2p[ii].end());\\n        }\\n        \\n        for (int ii = 0; ii < num.size(); ii++) {\\n            int minimum_index = -1;\\n            for (int jj = 0; jj <= 9; jj++) {\\n                if (d2p[jj].size() != 0 && (minimum_index == -1 || d2p[jj].back() < d2p[minimum_index].back()))\\n                    minimum_index = jj;\\n            }\\n            \\n            int jj = 0;\\n            if (k == 0) {\\n                jj = minimum_index;\\n            } else {\\n                for (; jj < minimum_index; jj++) {\\n                    if (d2p[jj].size() != 0) {\\n                        int num_used = nums_used_order_stat_tree.order_of_key(d2p[jj].back()) - \\n                                         nums_used_order_stat_tree.order_of_key(d2p[minimum_index].back());\\n                        if (d2p[jj].back() - d2p[minimum_index].back() - num_used <= k) {\\n                            k -= (d2p[jj].back() - d2p[minimum_index].back() - num_used);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(jj + \\'0\\');\\n            nums_used_order_stat_tree.insert(d2p[jj].back());\\n            d2p[jj].pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1631902,
                "title": "c-o-n-2-simple-bruteforce-91-77-95-88",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        int i = 0;\\n        int first = \\'0\\';\\n        int start = 0;\\n        int end   = n-1;\\n        bool found = true;\\n        while (found == true)\\n        {\\n            found = false;\\n            for (char d = first; d<=\\'9\\' && k>0 && !found; d++)\\n            {\\n                int j, l;\\n                for (j = start, l=0; j<=end && k>=l; j++)\\n                {\\n                    if (num[j] == d)\\n                    {\\n                        found = true;\\n                        // cout << d << endl;\\n                        ans[i++] = d;\\n                        num[j] = \\'-\\';\\n                        k -= l;\\n                        if (d != first)\\n                            break;\\n                    }\\n                    else if (num[j] != \\'-\\') l++;\\n                }\\n                if (j>end && d== first) first++;\\n                while (end  >= start && num[end] == \\'-\\') end--;\\n                while (start <= end && num[start] == \\'-\\') start++;\\n            }\\n        }\\n        int j=start;\\n        while (i<n)\\n        {\\n            if (num[j] == \\'-\\')\\n            {\\n                j++;\\n                continue;\\n            }\\n            ans[i++] = num[j++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.length();\\n        string ans(n,\\'-\\');\\n        int i = 0;\\n        int first = \\'0\\';\\n        int start = 0;\\n        int end   = n-1;\\n        bool found = true;\\n        while (found == true)\\n        {\\n            found = false;\\n            for (char d = first; d<=\\'9\\' && k>0 && !found; d++)\\n            {\\n                int j, l;\\n                for (j = start, l=0; j<=end && k>=l; j++)\\n                {\\n                    if (num[j] == d)\\n                    {\\n                        found = true;\\n                        // cout << d << endl;\\n                        ans[i++] = d;\\n                        num[j] = \\'-\\';\\n                        k -= l;\\n                        if (d != first)\\n                            break;\\n                    }\\n                    else if (num[j] != \\'-\\') l++;\\n                }\\n                if (j>end && d== first) first++;\\n                while (end  >= start && num[end] == \\'-\\') end--;\\n                while (start <= end && num[start] == \\'-\\') start++;\\n            }\\n        }\\n        int j=start;\\n        while (i<n)\\n        {\\n            if (num[j] == \\'-\\')\\n            {\\n                j++;\\n                continue;\\n            }\\n            ans[i++] = num[j++];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1577995,
                "title": "python-help-please-don-t-understand-bisect-perfm",
                "content": "Duhh I got a crazy difference perf between using bisect.bisect(list,index) and list.bisect(index) (got from stochastic TLE, as i was near 10 000 ms, to AC with 600 ms). \\nIt\\'s crazy. \\nIf someone can explain the difference, would be welcomed (or can point me out my mistake..)\\n\\n```\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    #swap_to_right = len(seen) - bisect(seen,index)\\n                    swap_to_right = len(seen) - seen.bisect(index)\\n                    index_after_swap = index + swap_to_right\\n                    if index_after_swap-i <= k:\\n                        ans.append(digit)\\n                        k -= (index_after_swap - i)\\n                        d[digit].pop()\\n                        seen.add(index)\\n                        break\\n                    \\n        return \"\".join(ans)\\n```\\n\\nEDIT :\\nAlright it seems, I\\'m not crazy finally, after testing locally, bisect.bisect is indeed highly inneficient when used with a SortedList.\\nActually with 10^7 iterations of bisect over a list of 10^5 element I got (to give you a rough estimate): \\n\\n1.5 sec for using bisect.bisect with a normal python list (but sorted of course)\\n13 sec using sortedList.bisect with a sorted list \\n260 sec using bisect.bisect with a sorted list :O",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom string import digits\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        \\n        d = defaultdict(list)\\n        ans, seen = [], SortedList()\\n        \\n        for i, n in enumerate(num):\\n            d[n].append(i)\\n        \\n        for digit in digits:\\n            d[digit] = d[digit][::-1]\\n            \\n        for i in range(len(num)):\\n            for digit in digits:\\n                if d[digit]:\\n                    index = d[digit][-1]\\n                    #swap_to_right = len(seen) - bisect(seen,index)\\n                    swap_to_right = len(seen) - seen.bisect(index)\\n                    index_after_swap = index + swap_to_right\\n                    if index_after_swap-i <= k:\\n                        ans.append(digit)\\n                        k -= (index_after_swap - i)\\n                        d[digit].pop()\\n                        seen.add(index)\\n                        break\\n                    \\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533307,
                "title": "my-notes-on-bit",
                "content": "Solve LC1409 and read [my notes](https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/1532316/My-notes-on-BIT-solution) first and come back. \\n\\nNow you should have a feel how BIT is used to move char to the front.\\n\\nWe want to move smallest char say 0, to the front, but can we move any 0? No. We can only move 0 within steps. If 0 cannot be moved to front, it is pointless to move it as we could have better choice. Note, if 0 cannot be move to the front this turn, it means this 0 will never have it\\'s chance again. (is this true?)\\n\\nBIT will tell you how many chars are in front.\\n\\nSo while we have steps, find the smallest char we can move to front, move to front, decrease steps, and repeat.\\n\\nNow I got stuck on 1) how to find the smallest char in the range of remaining steps, and 2) how to find the range as some char has been removed(we can use binary search). BIT cannot maintain min value.\\n\\nIt turns out we can just loop through 0 - 9 and try each to see if it is reachable, we keep a size 10 vector of queue and put each number\\'s position in the queue. This try and verify method solved both 1) and 2).\\n\\t\\n\\n\\n",
                "solutionTags": [],
                "code": "Solve LC1409 and read [my notes](https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/1532316/My-notes-on-BIT-solution) first and come back. \\n\\nNow you should have a feel how BIT is used to move char to the front.\\n\\nWe want to move smallest char say 0, to the front, but can we move any 0? No. We can only move 0 within steps. If 0 cannot be moved to front, it is pointless to move it as we could have better choice. Note, if 0 cannot be move to the front this turn, it means this 0 will never have it\\'s chance again. (is this true?)\\n\\nBIT will tell you how many chars are in front.\\n\\nSo while we have steps, find the smallest char we can move to front, move to front, decrease steps, and repeat.\\n\\nNow I got stuck on 1) how to find the smallest char in the range of remaining steps, and 2) how to find the range as some char has been removed(we can use binary search). BIT cannot maintain min value.\\n\\nIt turns out we can just loop through 0 - 9 and try each to see if it is reachable, we keep a size 10 vector of queue and put each number\\'s position in the queue. This try and verify method solved both 1) and 2).\\n\\t\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1529554,
                "title": "java-short-fenwicktree-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        Queue<Integer>[] q = new LinkedList[10];\\n        for(int i = 0; i <= 9; i++) q[i] = new LinkedList<Integer>();\\n        for(int i = 0; i < n; i++) q[num.charAt(i)-\\'0\\'].add(i);\\n        \\n        fenWickTree ft = new fenWickTree(n);\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            for(int d = 0; d <= 9; d++) {\\n                if(q[d].isEmpty()) continue;\\n                int pos = q[d].peek();\\n                int alreadyMoved = ft.getSum(pos+1);\\n                int reqSwaps = pos - alreadyMoved;\\n                if(reqSwaps <= k) {\\n                    k -= reqSwaps;\\n                    char c = (char)(d+\\'0\\');\\n                    ans.append(c);\\n                    q[d].poll();\\n                    ft.update(pos+1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    static class fenWickTree {\\n        int[] tree;\\n        int n;\\n        fenWickTree(int n) {\\n            tree = new int[n+1];\\n            this.n = n;\\n        }\\n        \\n        public void update(int idx) {\\n            while(idx <= n) {\\n                tree[idx]++;\\n                idx += idx&-idx;\\n            }\\n        }\\n        \\n        public int getSum(int idx) {\\n            int sum = 0;\\n            while(idx > 0) {\\n                sum += tree[idx];\\n                idx -= idx&-idx;\\n            }\\n            \\n            return sum;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        Queue<Integer>[] q = new LinkedList[10];\\n        for(int i = 0; i <= 9; i++) q[i] = new LinkedList<Integer>();\\n        for(int i = 0; i < n; i++) q[num.charAt(i)-\\'0\\'].add(i);\\n        \\n        fenWickTree ft = new fenWickTree(n);\\n        StringBuilder ans = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            for(int d = 0; d <= 9; d++) {\\n                if(q[d].isEmpty()) continue;\\n                int pos = q[d].peek();\\n                int alreadyMoved = ft.getSum(pos+1);\\n                int reqSwaps = pos - alreadyMoved;\\n                if(reqSwaps <= k) {\\n                    k -= reqSwaps;\\n                    char c = (char)(d+\\'0\\');\\n                    ans.append(c);\\n                    q[d].poll();\\n                    ft.update(pos+1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans.toString();\\n    }\\n    \\n    static class fenWickTree {\\n        int[] tree;\\n        int n;\\n        fenWickTree(int n) {\\n            tree = new int[n+1];\\n            this.n = n;\\n        }\\n        \\n        public void update(int idx) {\\n            while(idx <= n) {\\n                tree[idx]++;\\n                idx += idx&-idx;\\n            }\\n        }\\n        \\n        public int getSum(int idx) {\\n            int sum = 0;\\n            while(idx > 0) {\\n                sum += tree[idx];\\n                idx -= idx&-idx;\\n            }\\n            \\n            return sum;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467714,
                "title": "minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits",
                "content": "class Solution {\\n    public String minInteger(String num, int k) {\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        for(int i=0;i<num.length();i++){\\n            arr.add(num.charAt(i));\\n        }\\n        minimizer(0,arr , k);\\n        String ans = \"\";\\n        for(char i:arr){\\n            ans = ans + i;\\n        }\\n        return ans;\\n    }\\n    public void minimizer(int pos , ArrayList<Character> arr , int k){\\n        if(k==0 || pos >= arr.size()){\\n            return;\\n        }\\n        int n = arr.size();\\n        int swaps = Math.min( k , n - 1 - pos);\\n        char min = \\'9\\';\\n        int min_pos = pos;\\n        for(int i=pos;i<pos + swaps + 1;i++){\\n            if(arr.get(i) < min ){\\n                min = arr.get(i);\\n                min_pos = i;\\n            }\\n        }\\n        arr.remove(min_pos);\\n        arr.add(pos , min);\\n        minimizer(pos+1 , arr  , k - (min_pos - pos));\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String minInteger(String num, int k) {\\n        ArrayList<Character> arr = new ArrayList<Character>();\\n        for(int i=0;i<num.length();i++){\\n            arr.add(num.charAt(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1423291,
                "title": "help-with-my-solution",
                "content": "I hereby enclose my O(N^2) solution .\\nI have no idea why it has been accepted.\\nCan someone please explain me the reason\\n\\n```\\nstring minInteger(string num, int k) {\\n        int n=num.size();\\n        string te=\"\";\\n        for(int i=0;i<n;i++){\\n            if(k==0)\\n                break;\\n            int id=i;\\n            char ch=num[i];\\n            for(int j=i+1;j<n;j++){\\n                if(num[j]<ch&&k>=(j-i)){\\n                    ch=num[j];\\n                    id=j;\\n                }}\\n            int le=id-i+1;\\n            if(k<(le-1))\\n                continue;\\n            ch=num[id];\\n            num.erase(num.begin()+id);\\n            num.insert(num.begin()+i,ch);\\n            //cout<<num<<endl;\\n            k-=(le-1);\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n        int n=num.size();\\n        string te=\"\";\\n        for(int i=0;i<n;i++){\\n            if(k==0)\\n                break;\\n            int id=i;\\n            char ch=num[i];\\n            for(int j=i+1;j<n;j++){\\n                if(num[j]<ch&&k>=(j-i)){\\n                    ch=num[j];\\n                    id=j;\\n                }}\\n            int le=id-i+1;\\n            if(k<(le-1))\\n                continue;\\n            ch=num[id];\\n            num.erase(num.begin()+id);\\n            num.insert(num.begin()+i,ch);\\n            //cout<<num<<endl;\\n            k-=(le-1);\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1329987,
                "title": "jave-93-fenwick-tree",
                "content": "```\\nclass Solution {\\n    // Using Fewick Tree data structure to compute the nmber of elements removed before eacg element in num\\n    // cost of each element = its index - numer of elements that have been removed before itself\\n    // the number of elements removed before index i can be obtained from the Fenwick Tree\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Queue<Integer>> indices = new ArrayList<>();\\n        for (int d = 0; d < 10; d++) {\\n            indices.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int temp = num.charAt(i) - \\'0\\';\\n            indices.get(temp).add(i);\\n        }\\n        Fenwick tree = new Fenwick(n + 1);\\n        StringBuilder res = new StringBuilder();\\n        boolean[] removed = new boolean[n];\\n        while (k > 0 && res.length() < n) {\\n            for (int d = 0; d < 10; d++) {\\n                if (indices.get(d).isEmpty()) continue;\\n                int pos = indices.get(d).peek();\\n                int cost = pos - tree.preSum(pos - 1);\\n                if (cost > k) continue;\\n                removed[pos] = true;\\n                k -= cost;\\n                res.append(d);\\n                indices.get(d).remove();\\n                tree.update(pos, 1);\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!removed[i]) res.append(num.charAt(i));\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    class Fenwick {\\n        int[] tree;\\n        public Fenwick(int n) {\\n            tree = new int[n];\\n        }\\n        public void update(int index, int delta) {\\n            index++;\\n            while (index < tree.length) {\\n                tree[index] += delta;\\n                index += lowbit(index);\\n            }\\n        }\\n        public int preSum(int index) {\\n            int res = 0;\\n            index++;\\n            while (index > 0) {\\n                res += tree[index];\\n                index -= lowbit(index);\\n            }\\n            return res;\\n        }\\n        private int lowbit(int index) {\\n            return index & (-index);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Using Fewick Tree data structure to compute the nmber of elements removed before eacg element in num\\n    // cost of each element = its index - numer of elements that have been removed before itself\\n    // the number of elements removed before index i can be obtained from the Fenwick Tree\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        List<Queue<Integer>> indices = new ArrayList<>();\\n        for (int d = 0; d < 10; d++) {\\n            indices.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int temp = num.charAt(i) - \\'0\\';\\n            indices.get(temp).add(i);\\n        }\\n        Fenwick tree = new Fenwick(n + 1);\\n        StringBuilder res = new StringBuilder();\\n        boolean[] removed = new boolean[n];\\n        while (k > 0 && res.length() < n) {\\n            for (int d = 0; d < 10; d++) {\\n                if (indices.get(d).isEmpty()) continue;\\n                int pos = indices.get(d).peek();\\n                int cost = pos - tree.preSum(pos - 1);\\n                if (cost > k) continue;\\n                removed[pos] = true;\\n                k -= cost;\\n                res.append(d);\\n                indices.get(d).remove();\\n                tree.update(pos, 1);\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (!removed[i]) res.append(num.charAt(i));\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    class Fenwick {\\n        int[] tree;\\n        public Fenwick(int n) {\\n            tree = new int[n];\\n        }\\n        public void update(int index, int delta) {\\n            index++;\\n            while (index < tree.length) {\\n                tree[index] += delta;\\n                index += lowbit(index);\\n            }\\n        }\\n        public int preSum(int index) {\\n            int res = 0;\\n            index++;\\n            while (index > 0) {\\n                res += tree[index];\\n                index -= lowbit(index);\\n            }\\n            return res;\\n        }\\n        private int lowbit(int index) {\\n            return index & (-index);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247041,
                "title": "java-10ms-o-n-radix-sort",
                "content": "```\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        //\\u6700\\u8FD1\\u7684[0,9]\\u4F4D\\u4E8Epos\\u4E2D\\u7684\\u4F4D\\u7F6E\\n        int[] digitPos = new int[10];\\n        int[] reduceMove = new int[10];\\n        int matchAmount = 0;\\n        char[] chars = num.toCharArray();\\n        Arrays.fill(digitPos, chars.length);\\n        for (int i = 0; i < chars.length; i++) {\\n            int cur = chars[i] - \\'0\\';\\n            if (digitPos[cur] == chars.length) {\\n                digitPos[cur] = i;\\n                matchAmount++;\\n                if (matchAmount == 10) {\\n                    break;\\n                }\\n            }\\n        }\\n        int curIndex=0;\\n        while (k > 0 && curIndex < chars.length) {\\n            for (int digit = 0; digit <= 9; digit++) {\\n                if (digitPos[digit]<chars.length&&digitPos[digit] - reduceMove[digit] <= k) {\\n                    sb.append(chars[digitPos[digit]]);\\n                    k-=(digitPos[digit] - reduceMove[digit]);\\n                    curIndex++;\\n                    reduceMove[digit]++;\\n                    for(int j=0;j<=9;j++){\\n                        if(j!=digit){\\n                            if(digitPos[j]>digitPos[digit]){\\n                                reduceMove[j]++;\\n                            }\\n                        }\\n                    }\\n                    boolean find=false;\\n                    for(int next=digitPos[digit]+1;next<chars.length;next++){\\n                        int cur=chars[next]-\\'0\\';\\n                        if (cur==digit){\\n                            find=true;\\n                            digitPos[digit]=next;\\n                            break;\\n                        }\\n                        if(next<digitPos[cur]){\\n                            reduceMove[digit]++;\\n                        }\\n                    }\\n                    if(!find){\\n                        digitPos[digit]=chars.length;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        int start=Arrays.stream(digitPos).min().getAsInt();\\n        for(int i=start;i<chars.length;i++){\\n            if(digitPos[chars[i]-\\'0\\']<=i){\\n                sb.append(chars[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String minInteger(String num, int k) {\\n        StringBuilder sb = new StringBuilder();\\n        //\\u6700\\u8FD1\\u7684[0,9]\\u4F4D\\u4E8Epos\\u4E2D\\u7684\\u4F4D\\u7F6E\\n        int[] digitPos = new int[10];\\n        int[] reduceMove = new int[10];\\n        int matchAmount = 0;\\n        char[] chars = num.toCharArray();\\n        Arrays.fill(digitPos, chars.length);\\n        for (int i = 0; i < chars.length; i++) {\\n            int cur = chars[i] - \\'0\\';\\n            if (digitPos[cur] == chars.length) {\\n                digitPos[cur] = i;\\n                matchAmount++;\\n                if (matchAmount == 10) {\\n                    break;\\n                }\\n            }\\n        }\\n        int curIndex=0;\\n        while (k > 0 && curIndex < chars.length) {\\n            for (int digit = 0; digit <= 9; digit++) {\\n                if (digitPos[digit]<chars.length&&digitPos[digit] - reduceMove[digit] <= k) {\\n                    sb.append(chars[digitPos[digit]]);\\n                    k-=(digitPos[digit] - reduceMove[digit]);\\n                    curIndex++;\\n                    reduceMove[digit]++;\\n                    for(int j=0;j<=9;j++){\\n                        if(j!=digit){\\n                            if(digitPos[j]>digitPos[digit]){\\n                                reduceMove[j]++;\\n                            }\\n                        }\\n                    }\\n                    boolean find=false;\\n                    for(int next=digitPos[digit]+1;next<chars.length;next++){\\n                        int cur=chars[next]-\\'0\\';\\n                        if (cur==digit){\\n                            find=true;\\n                            digitPos[digit]=next;\\n                            break;\\n                        }\\n                        if(next<digitPos[cur]){\\n                            reduceMove[digit]++;\\n                        }\\n                    }\\n                    if(!find){\\n                        digitPos[digit]=chars.length;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        int start=Arrays.stream(digitPos).min().getAsInt();\\n        for(int i=start;i<chars.length;i++){\\n            if(digitPos[chars[i]-\\'0\\']<=i){\\n                sb.append(chars[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174885,
                "title": "scala-linear-solution-o-n-time-o-n-memory",
                "content": "```\\n// Inspired by tztanjunjie\\'s approach\\ndef minInteger(numStr: String, k: Int): String = {\\n    var ans = new StringBuilder(numStr.length)\\n    var swapsLeft = k\\n    var offset = 0\\n    var num: mutable.Map[Int, Char] = mutable.Map() ++ (numStr.indices zip numStr).toMap\\n    var nextOccurrence = mutable.ListBuffer.fill[(Int, Int)](10)((-1, -1)) // True-Index (in numStr), \"fake\" index (i.e. where it belongs after swaps have moved it left)\\n\\n    nextOccurrence = (0 to 9).map(n => numStr.indexWhere(_ == n + \\'0\\')).map(x => (x, x)).toList.to(mutable.ListBuffer)\\n    println(nextOccurrence)\\n\\n   var idx = 0\\n    while (idx < numStr.length) {\\n      //the main process involves keeping num \"array\" constant (except for X-ing out used numbers)\\n      // when a number must be \"moved front\" it is X\\'d-out, and num now represents the remaining string shifted 1\\n      if (num(idx) != \\'X\\') {\\n        val toSwap = num(idx).toString.toInt\\n        var numPicked = nextOccurrence.slice(0, toSwap).indexWhere(tup => tup._1 >= 0 && tup._2 <= idx + swapsLeft)\\n\\n        var pos: Option[(Int, Int)] = nextOccurrence.lift(numPicked)\\n        if (pos.nonEmpty) { // we found a number to be swapped\\n          swapsLeft -= pos.get._2 - idx\\n          ans ++= numPicked.toString\\n          idx -= 1\\n          nextOccurrence.indices.filter(v => nextOccurrence(v)._1 >= 0 && nextOccurrence(v)._1 > pos.get._1).foreach(i => nextOccurrence(i) = (nextOccurrence(i)._1, nextOccurrence(i)._2 - 1))\\n          num(pos.get._1) = \\'X\\'\\n        } else {\\n          num(idx) = \\'X\\'\\n          numPicked = toSwap // nextOccurrence of this same number is out-of-date, must be updated\\n          ans ++= toSwap.toString\\n        }\\n\\n        var i = pos.map(_._1).getOrElse(idx + 1) // starting at last occurrence, search to right for next occurrence\\n        var adj = pos.map(tup => tup._1 - tup._2).getOrElse(0) // start with number of X\\'s to the left so far\\n        \\n        var nextPos = Stream.range(i, numStr.length).indexWhere(n => num(n) == \\'0\\' + numPicked)\\n        if (nextPos != -1)\\n          nextPos += i\\n        adj += Stream.range(i, nextPos).count(num(_) == \\'X\\') // keep track of any new ones along the way\\n        nextOccurrence(numPicked) = (nextPos, nextPos - adj)\\n      } else { // we ingest a left-x, so un-discount all the nextOccurrences by 1\\n        nextOccurrence = nextOccurrence.map(tup => (tup._1, tup._2 + 1))\\n      }\\n      idx += 1\\n    }\\n    ans.toString\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n// Inspired by tztanjunjie\\'s approach\\ndef minInteger(numStr: String, k: Int): String = {\\n    var ans = new StringBuilder(numStr.length)\\n    var swapsLeft = k\\n    var offset = 0\\n    var num: mutable.Map[Int, Char] = mutable.Map() ++ (numStr.indices zip numStr).toMap\\n    var nextOccurrence = mutable.ListBuffer.fill[(Int, Int)](10)((-1, -1)) // True-Index (in numStr), \"fake\" index (i.e. where it belongs after swaps have moved it left)\\n\\n    nextOccurrence = (0 to 9).map(n => numStr.indexWhere(_ == n + \\'0\\')).map(x => (x, x)).toList.to(mutable.ListBuffer)\\n    println(nextOccurrence)\\n\\n   var idx = 0\\n    while (idx < numStr.length) {\\n      //the main process involves keeping num \"array\" constant (except for X-ing out used numbers)\\n      // when a number must be \"moved front\" it is X\\'d-out, and num now represents the remaining string shifted 1\\n      if (num(idx) != \\'X\\') {\\n        val toSwap = num(idx).toString.toInt\\n        var numPicked = nextOccurrence.slice(0, toSwap).indexWhere(tup => tup._1 >= 0 && tup._2 <= idx + swapsLeft)\\n\\n        var pos: Option[(Int, Int)] = nextOccurrence.lift(numPicked)\\n        if (pos.nonEmpty) { // we found a number to be swapped\\n          swapsLeft -= pos.get._2 - idx\\n          ans ++= numPicked.toString\\n          idx -= 1\\n          nextOccurrence.indices.filter(v => nextOccurrence(v)._1 >= 0 && nextOccurrence(v)._1 > pos.get._1).foreach(i => nextOccurrence(i) = (nextOccurrence(i)._1, nextOccurrence(i)._2 - 1))\\n          num(pos.get._1) = \\'X\\'\\n        } else {\\n          num(idx) = \\'X\\'\\n          numPicked = toSwap // nextOccurrence of this same number is out-of-date, must be updated\\n          ans ++= toSwap.toString\\n        }\\n\\n        var i = pos.map(_._1).getOrElse(idx + 1) // starting at last occurrence, search to right for next occurrence\\n        var adj = pos.map(tup => tup._1 - tup._2).getOrElse(0) // start with number of X\\'s to the left so far\\n        \\n        var nextPos = Stream.range(i, numStr.length).indexWhere(n => num(n) == \\'0\\' + numPicked)\\n        if (nextPos != -1)\\n          nextPos += i\\n        adj += Stream.range(i, nextPos).count(num(_) == \\'X\\') // keep track of any new ones along the way\\n        nextOccurrence(numPicked) = (nextPos, nextPos - adj)\\n      } else { // we ingest a left-x, so un-discount all the nextOccurrences by 1\\n        nextOccurrence = nextOccurrence.map(tup => (tup._1, tup._2 + 1))\\n      }\\n      idx += 1\\n    }\\n    ans.toString\\n  }\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 997365,
                "title": "note-nlogn-algorithm-takes-more-time-after-leetcode-added-more-test-cases",
                "content": "In case you only beat 20% percent when using nlogn algorithm such as segment tree like me :D\\n\\n```\\nstruct Node {\\npublic:\\n    Node* left, *right;\\n    int l, r;\\n    int sum;\\n    \\n    Node(int _l, int _r): l(_l), r(_r), left(nullptr), right(nullptr), sum(0) {}\\n};\\n\\nvoid add(Node* root, int val) {\\n    if (val < root->l || val > root->r) return;\\n    if (root->l == root->r) root->sum ++;    \\n    else {\\n        int mid = (root->l + root->r) / 2;\\n        if (val <= mid) {\\n            if (!root->left) root->left = new Node(root->l, mid);\\n            add(root->left, val);\\n        }\\n        \\n        else {\\n            if (!root->right) root->right = new Node(mid+1, root->r);\\n            add(root->right, val);\\n        }\\n        root->sum ++;\\n    }\\n} \\n\\nint find(Node* root, int val) {\\n    if (!root) return 0;\\n    if (val < root->l || val > root->r) return 0;\\n    if (val == root->r) return root->sum;\\n    \\n    int mid = (root->l + root->r) / 2;\\n    if (val <= mid) {\\n        return find(root->left, val);\\n    }\\n    \\n    return find(root->left, mid) + find(root->right, val);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> record(10);\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for (int i = 0; i < n; ++i) record[num[i]-\\'0\\'].push(i);\\n        \\n        string res;\\n        Node* root = new Node(0, n-1);\\n        while (n) {\\n            for (int i = 0; i <= 9; ++i) {\\n                if (record[i].size() > 0) {\\n                    int id = record[i].front();\\n                    int pre = find(root, id);\\n                    if (id - pre <= k) {\\n                        k = k - (id - pre);\\n                        res += (char)(\\'0\\' + i);\\n                        add(root, id);\\n                        record[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            n --;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node {\\npublic:\\n    Node* left, *right;\\n    int l, r;\\n    int sum;\\n    \\n    Node(int _l, int _r): l(_l), r(_r), left(nullptr), right(nullptr), sum(0) {}\\n};\\n\\nvoid add(Node* root, int val) {\\n    if (val < root->l || val > root->r) return;\\n    if (root->l == root->r) root->sum ++;    \\n    else {\\n        int mid = (root->l + root->r) / 2;\\n        if (val <= mid) {\\n            if (!root->left) root->left = new Node(root->l, mid);\\n            add(root->left, val);\\n        }\\n        \\n        else {\\n            if (!root->right) root->right = new Node(mid+1, root->r);\\n            add(root->right, val);\\n        }\\n        root->sum ++;\\n    }\\n} \\n\\nint find(Node* root, int val) {\\n    if (!root) return 0;\\n    if (val < root->l || val > root->r) return 0;\\n    if (val == root->r) return root->sum;\\n    \\n    int mid = (root->l + root->r) / 2;\\n    if (val <= mid) {\\n        return find(root->left, val);\\n    }\\n    \\n    return find(root->left, mid) + find(root->right, val);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> record(10);\\n        int n = num.size();\\n        if(k > n*(n-1)/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for (int i = 0; i < n; ++i) record[num[i]-\\'0\\'].push(i);\\n        \\n        string res;\\n        Node* root = new Node(0, n-1);\\n        while (n) {\\n            for (int i = 0; i <= 9; ++i) {\\n                if (record[i].size() > 0) {\\n                    int id = record[i].front();\\n                    int pre = find(root, id);\\n                    if (id - pre <= k) {\\n                        k = k - (id - pre);\\n                        res += (char)(\\'0\\' + i);\\n                        add(root, id);\\n                        record[i].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n            n --;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985260,
                "title": "python-binary-index-tree-solution",
                "content": "\\tclass binaryIndexTree:\\n\\n\\t\\tdef __init__(self, length: int):\\n\\t\\t\\tself.arr = [0] * (length + 1)\\n\\n\\t\\tdef add(self, idx: int, val: int):\\n\\t\\t\\twhile idx < len(self.arr):\\n\\t\\t\\t\\tself.arr[idx] += val\\n\\t\\t\\t\\tidx += idx & -idx\\n\\n\\t\\tdef query(self, idx: int):\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile idx > 0:\\n\\t\\t\\t\\tres += self.arr[idx]\\n\\t\\t\\t\\tidx -= idx & -idx\\n\\t\\t\\treturn res\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tidmap = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tidmap[int(num[i])].append(i)\\n\\n\\t\\t\\ttree = binaryIndexTree(len(num))\\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\tfor _ in range(len(num)):\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i in idmap:\\n\\t\\t\\t\\t\\t\\trelevant = tree.query(idmap[i][0] + 1)\\n\\t\\t\\t\\t\\t\\tval = idmap[i][0] - relevant\\n\\t\\t\\t\\t\\t\\tif val <= k:\\n\\t\\t\\t\\t\\t\\t\\tk -= val\\n\\t\\t\\t\\t\\t\\t\\ttree.add(idmap[i].pop(0) + 1, 1)\\n\\t\\t\\t\\t\\t\\t\\tif not idmap[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\tdel idmap[i]\\n\\t\\t\\t\\t\\t\\t\\tres += str(i)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass binaryIndexTree:\\n\\n\\t\\tdef __init__(self, length: int):\\n\\t\\t\\tself.arr = [0] * (length + 1)\\n\\n\\t\\tdef add(self, idx: int, val: int):\\n\\t\\t\\twhile idx < len(self.arr):\\n\\t\\t\\t\\tself.arr[idx] += val\\n\\t\\t\\t\\tidx += idx & -idx\\n\\n\\t\\tdef query(self, idx: int):\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile idx > 0:\\n\\t\\t\\t\\tres += self.arr[idx]\\n\\t\\t\\t\\tidx -= idx & -idx\\n\\t\\t\\treturn res\\n\\n\\tclass Solution:\\n\\t\\tdef minInteger(self, num: str, k: int) -> str:\\n\\t\\t\\tidmap = defaultdict(list)\\n\\t\\t\\tfor i in range(len(num)):\\n\\t\\t\\t\\tidmap[int(num[i])].append(i)\\n\\n\\t\\t\\ttree = binaryIndexTree(len(num))\\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\tfor _ in range(len(num)):\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tif i in idmap:\\n\\t\\t\\t\\t\\t\\trelevant = tree.query(idmap[i][0] + 1)\\n\\t\\t\\t\\t\\t\\tval = idmap[i][0] - relevant\\n\\t\\t\\t\\t\\t\\tif val <= k:\\n\\t\\t\\t\\t\\t\\t\\tk -= val\\n\\t\\t\\t\\t\\t\\t\\ttree.add(idmap[i].pop(0) + 1, 1)\\n\\t\\t\\t\\t\\t\\t\\tif not idmap[i]:\\n\\t\\t\\t\\t\\t\\t\\t\\tdel idmap[i]\\n\\t\\t\\t\\t\\t\\t\\tres += str(i)\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 877010,
                "title": "python-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def minInteger(self, num, k):\\n        ln=len(num)\\n        optimizedNums=0\\n        YJSP=1145141919810\\n        a={\\'0\\':YJSP,\\'1\\':YJSP,\\'2\\':YJSP,\\'3\\':YJSP,\\'4\\':YJSP,\\'5\\':YJSP,\\'6\\':YJSP,\\'7\\':YJSP,\\'8\\':YJSP,\\'9\\':YJSP}\\n        for i in range(ln):\\n            if i<a[num[i]]:a[num[i]]=i   \\n        while k>0 and optimizedNums<ln:\\n            for i in a:\\n                if a[i]-optimizedNums<=k:\\n                    num=num[:optimizedNums]+i+num[optimizedNums:a[i]]+num[a[i]+1:]\\n                    k-=a[i]-optimizedNums\\n                    for j in a:\\n                        if a[j]<a[i]:a[j]+=1               \\n                    for j in range(a[i]+1,ln):\\n                        if num[j]==i:\\n                            a[i]=j\\n                            break\\n                    else:\\n                        a[i]=YJSP\\n                    break\\n            optimizedNums+=1\\n        return num\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num, k):\\n        ln=len(num)\\n        optimizedNums=0\\n        YJSP=1145141919810\\n        a={\\'0\\':YJSP,\\'1\\':YJSP,\\'2\\':YJSP,\\'3\\':YJSP,\\'4\\':YJSP,\\'5\\':YJSP,\\'6\\':YJSP,\\'7\\':YJSP,\\'8\\':YJSP,\\'9\\':YJSP}\\n        for i in range(ln):\\n            if i<a[num[i]]:a[num[i]]=i   \\n        while k>0 and optimizedNums<ln:\\n            for i in a:\\n                if a[i]-optimizedNums<=k:\\n                    num=num[:optimizedNums]+i+num[optimizedNums:a[i]]+num[a[i]+1:]\\n                    k-=a[i]-optimizedNums\\n                    for j in a:\\n                        if a[j]<a[i]:a[j]+=1               \\n                    for j in range(a[i]+1,ln):\\n                        if num[j]==i:\\n                            a[i]=j\\n                            break\\n                    else:\\n                        a[i]=YJSP\\n                    break\\n            optimizedNums+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847387,
                "title": "my-java-solution-hashmap-and-segmenttree-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) \\n    {\\n        \\n\\t\\tHashMap<Integer,List<Integer>> digitVsPositionMap = new HashMap< Integer,List<Integer>> ();\\n\\n\\t\\tfor (int i = 0; i <= 9; ++i) \\n\\t\\t{\\n\\t\\t\\tdigitVsPositionMap.put(i, new LinkedList<>());\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\tint numberAtDigit =  Character.getNumericValue(num.charAt(i)) ;\\n\\n\\t\\t\\tList<Integer> list = digitVsPositionMap.get(numberAtDigit);\\n\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\t\\tdigitVsPositionMap.put(numberAtDigit, list);\\n\\t\\t}\\n\\n\\t\\tString ans = \"\";\\n\\t\\t\\n\\t\\t\\n\\t\\tint posArr[] = new int[num.length()];\\n\\t\\t\\n\\t\\tArrays.fill(posArr, 0);\\n\\t\\t\\n\\t\\tSegmentTree tree = new SegmentTree(posArr);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tfor (int digit = 0; digit <= 9; ++digit) \\n\\t\\t\\t{\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (digitVsPositionMap.get(digit).size() != 0) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tInteger pos = digitVsPositionMap.get(digit).get(0);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint shift = tree.sumRange( 0 , pos);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (pos - shift <= k) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk -= pos - shift;\\n\\n\\t\\t\\t\\t\\t\\ttree.update(pos, 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tdigitVsPositionMap.get(digit).remove(0);\\n\\n\\t\\t\\t\\t\\t\\tans += digit;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t\\n    }\\n}\\n\\nclass SegmentTree \\n{\\n\\t\\n\\tSegmentTreeNode root = null;\\n\\t\\n\\tpublic SegmentTree( int[] nums )\\n\\t{\\n\\t\\troot = buildTree(nums, 0, nums.length-1);\\n\\t}\\n\\n\\n\\tprivate SegmentTreeNode buildTree(int[] nums, int start, int end) \\n\\t{\\n\\t\\tif (start > end)  // base case\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t} \\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tSegmentTreeNode ret = new SegmentTreeNode(start, end);\\n\\t\\t\\t\\n\\t\\t\\tif (start == end)   // if start and end index are same , then we reached leaf nodes , here after no childs \\n\\t\\t\\t{\\n\\t\\t\\t\\tret.sum = nums[start];\\n\\t\\t\\t} \\n\\t\\t\\telse  // else there is child that we need to explore\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start  + (end - start) / 2;             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.left = buildTree(nums, start, mid);  // constructing left sub tree \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.right = buildTree(nums, mid + 1, end); // constructing right sub tree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.sum = ret.left.sum + ret.right.sum;  // updating the root sum \\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void update(int i, int val) \\n\\t{\\n        update(root, i, val);\\n    }\\n   \\n    private void update(SegmentTreeNode root, int pos, int val) \\n    {\\n        if (root.start == root.end) \\n        {\\n           root.sum = val;\\n        }\\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;  // find the mid index of the root node\\n            \\n            if (pos <= mid)   // if the index of the element ( for which we have to update value ) is less than mid , \\n            {\\t\\t\\t\\t  //then node lies in left subtree \\n                 update(root.left, pos, val);\\n            } \\n            else  //  or else it lies in right sub tree \\n            {\\n                 update(root.right, pos, val);\\n            }\\n            \\n            root.sum = root.left.sum + root.right.sum; // after exploring  we are updating the root element sum , since it child values changed\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) \\n    {\\n        return sumRange(root, i, j);\\n    }\\n    \\n    private int sumRange(SegmentTreeNode root, int start, int end) \\n    {\\n        if (root.end == end && root.start == start) \\n        {\\n            return root.sum;\\n        } \\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;\\n            \\n            if (end <= mid)    \\n            {\\n                return sumRange(root.left, start, end);\\n            } \\n            else if (start >= mid+1) \\n            {\\n                return sumRange(root.right, start, end);\\n            }  \\n            else \\n            {    \\n                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);\\n            }\\n        }\\n    }\\n\\t\\n\\tclass SegmentTreeNode \\n\\t{\\n        int start, end;\\n        SegmentTreeNode left, right;\\n        int sum;\\n\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.left = null;\\n            this.right = null;\\n            this.sum = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) \\n    {\\n        \\n\\t\\tHashMap<Integer,List<Integer>> digitVsPositionMap = new HashMap< Integer,List<Integer>> ();\\n\\n\\t\\tfor (int i = 0; i <= 9; ++i) \\n\\t\\t{\\n\\t\\t\\tdigitVsPositionMap.put(i, new LinkedList<>());\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\tint numberAtDigit =  Character.getNumericValue(num.charAt(i)) ;\\n\\n\\t\\t\\tList<Integer> list = digitVsPositionMap.get(numberAtDigit);\\n\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\t\\tdigitVsPositionMap.put(numberAtDigit, list);\\n\\t\\t}\\n\\n\\t\\tString ans = \"\";\\n\\t\\t\\n\\t\\t\\n\\t\\tint posArr[] = new int[num.length()];\\n\\t\\t\\n\\t\\tArrays.fill(posArr, 0);\\n\\t\\t\\n\\t\\tSegmentTree tree = new SegmentTree(posArr);\\n\\t\\t\\n\\t\\tfor (int i = 0; i < num.length(); ++i) \\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tfor (int digit = 0; digit <= 9; ++digit) \\n\\t\\t\\t{\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (digitVsPositionMap.get(digit).size() != 0) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tInteger pos = digitVsPositionMap.get(digit).get(0);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint shift = tree.sumRange( 0 , pos);\\n\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (pos - shift <= k) \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tk -= pos - shift;\\n\\n\\t\\t\\t\\t\\t\\ttree.update(pos, 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tdigitVsPositionMap.get(digit).remove(0);\\n\\n\\t\\t\\t\\t\\t\\tans += digit;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t\\n    }\\n}\\n\\nclass SegmentTree \\n{\\n\\t\\n\\tSegmentTreeNode root = null;\\n\\t\\n\\tpublic SegmentTree( int[] nums )\\n\\t{\\n\\t\\troot = buildTree(nums, 0, nums.length-1);\\n\\t}\\n\\n\\n\\tprivate SegmentTreeNode buildTree(int[] nums, int start, int end) \\n\\t{\\n\\t\\tif (start > end)  // base case\\n\\t\\t{\\n\\t\\t\\treturn null;\\n\\t\\t} \\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tSegmentTreeNode ret = new SegmentTreeNode(start, end);\\n\\t\\t\\t\\n\\t\\t\\tif (start == end)   // if start and end index are same , then we reached leaf nodes , here after no childs \\n\\t\\t\\t{\\n\\t\\t\\t\\tret.sum = nums[start];\\n\\t\\t\\t} \\n\\t\\t\\telse  // else there is child that we need to explore\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid = start  + (end - start) / 2;             \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.left = buildTree(nums, start, mid);  // constructing left sub tree \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.right = buildTree(nums, mid + 1, end); // constructing right sub tree\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tret.sum = ret.left.sum + ret.right.sum;  // updating the root sum \\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic void update(int i, int val) \\n\\t{\\n        update(root, i, val);\\n    }\\n   \\n    private void update(SegmentTreeNode root, int pos, int val) \\n    {\\n        if (root.start == root.end) \\n        {\\n           root.sum = val;\\n        }\\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;  // find the mid index of the root node\\n            \\n            if (pos <= mid)   // if the index of the element ( for which we have to update value ) is less than mid , \\n            {\\t\\t\\t\\t  //then node lies in left subtree \\n                 update(root.left, pos, val);\\n            } \\n            else  //  or else it lies in right sub tree \\n            {\\n                 update(root.right, pos, val);\\n            }\\n            \\n            root.sum = root.left.sum + root.right.sum; // after exploring  we are updating the root element sum , since it child values changed\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) \\n    {\\n        return sumRange(root, i, j);\\n    }\\n    \\n    private int sumRange(SegmentTreeNode root, int start, int end) \\n    {\\n        if (root.end == end && root.start == start) \\n        {\\n            return root.sum;\\n        } \\n        else \\n        {\\n            int mid = root.start + (root.end - root.start) / 2;\\n            \\n            if (end <= mid)    \\n            {\\n                return sumRange(root.left, start, end);\\n            } \\n            else if (start >= mid+1) \\n            {\\n                return sumRange(root.right, start, end);\\n            }  \\n            else \\n            {    \\n                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);\\n            }\\n        }\\n    }\\n\\t\\n\\tclass SegmentTreeNode \\n\\t{\\n        int start, end;\\n        SegmentTreeNode left, right;\\n        int sum;\\n\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            this.left = null;\\n            this.right = null;\\n            this.sum = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791475,
                "title": "javascript-greedy-solution",
                "content": "```\\n\\tvar minInteger = function (num, k) {\\n        if (!num || num.length === 0 || k <= 0) return num;\\n        num = num.split(\"\").map(Number);\\n        let len = num.length;\\n        let l = 0,\\n          index = 0,\\n          smallest = Infinity;\\n        while (k > 0 && l < len - 1) {\\n          smallest = Infinity;\\n          for (let i = l; i < len && i <= l + k; i++) {\\n            if (num[i] < smallest) {\\n              smallest = num[i];\\n              index = i;\\n            }\\n          }\\n          for (let j = index; j > l; j--) {\\n            [num[j], num[j - 1]] = [num[j - 1], num[j]];\\n            k--;\\n            if (k <= 0) {\\n              break;\\n            }\\n          }\\n          l++;\\n        }\\n        return num.join(\"\");\\n      };",
                "solutionTags": [],
                "code": "```\\n\\tvar minInteger = function (num, k) {\\n        if (!num || num.length === 0 || k <= 0) return num;\\n        num = num.split(\"\").map(Number);\\n        let len = num.length;\\n        let l = 0,\\n          index = 0,\\n          smallest = Infinity;\\n        while (k > 0 && l < len - 1) {\\n          smallest = Infinity;\\n          for (let i = l; i < len && i <= l + k; i++) {\\n            if (num[i] < smallest) {\\n              smallest = num[i];\\n              index = i;\\n            }\\n          }\\n          for (let j = index; j > l; j--) {\\n            [num[j], num[j - 1]] = [num[j - 1], num[j]];\\n            k--;\\n            if (k <= 0) {\\n              break;\\n            }\\n          }\\n          l++;\\n        }\\n        return num.join(\"\");\\n      };",
                "codeTag": "Unknown"
            },
            {
                "id": 788851,
                "title": "accepted-java-unique-solution-using-doubly-linked-list",
                "content": "Key idea is seeing that using `ArrayList` would TLE because of the `list.add()` and `list.remove()` taking O(n) when used in shifting the digits.\\nDoubly linked list makes these O(1) operations.\\n\\n```\\nimport org.junit.Test;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        Node prevNode;\\n        Node nextNode;\\n        final int val;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n        Node addNext(final int i) {\\n            final Node next = new Node(i);\\n            this.nextNode = next;\\n            next.prevNode = this;\\n            return next;\\n        }\\n\\n        void addPrev(final Node node) {\\n            final Node prev = this.prevNode;\\n            node.prevNode = prev;\\n\\n            if (prev != null) {\\n                prev.nextNode = node;\\n            }\\n\\n            node.nextNode = this;\\n            this.prevNode = node;\\n        }\\n\\n        void unlink() {\\n            final Node prev = this.prevNode;\\n            final Node next = this.nextNode;\\n            this.prevNode = null;\\n            this.nextNode = null;\\n            prev.nextNode = next;\\n\\n            if (next != null) {\\n                next.prevNode = prev;\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            Node current = this;\\n            final StringBuilder sb = new StringBuilder();\\n\\n            while (current != null) {\\n                sb.append(current.val);\\n                current = current.nextNode;\\n            }\\n\\n            return sb.toString();\\n        }\\n\\n    }\\n\\n    private boolean increasing(final String num) {\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (num.charAt(i) > num.charAt(i + 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public String minInteger(final String num, final int k) {\\n        if (increasing(num)) {\\n            return num;\\n        }\\n\\n        final Node head = new Node(num.charAt(0) - \\'0\\');\\n        Node tail = head;\\n\\n        for (int i = 1; i < num.length(); i++) {\\n            tail = tail.addNext(num.charAt(i) - \\'0\\');\\n        }\\n\\n        final Node newHead = swap(head, k);\\n        return newHead.toString();\\n    }\\n\\n    private Node swap(final Node head, final int remaining) {\\n        if (remaining == 0 || head == null) {\\n            return null;\\n        }\\n\\n        if (head.val == 0) {\\n            swap(head.nextNode, remaining);\\n            return head;\\n        }\\n\\n        Node nextSmallest = null;\\n        int nextSmallestDistance = 0;\\n\\n        Node current = head.nextNode;\\n        int distance = 1;\\n\\n        while (current != null && distance <= remaining) {\\n            if (nextSmallest == null || current.val < nextSmallest.val) {\\n                nextSmallest = current;\\n                nextSmallestDistance = distance;\\n            }\\n\\n            current = current.nextNode;\\n            distance++;\\n        }\\n\\n        if (nextSmallest != null && nextSmallest.val < head.val) {\\n            nextSmallest.unlink(); // O(1)\\n            head.addPrev(nextSmallest); // O(1)\\n            swap(head, remaining - nextSmallestDistance);\\n            return nextSmallest;\\n        }\\n\\n        swap(head.nextNode, remaining);\\n        return head;\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(\"012345\", new Solution().minInteger(\"012345\", 23));\\n        assertEquals(\"0345989723478563548\", new Solution().minInteger(\"9438957234785635408\", 23));\\n        assertEquals(\"1342\",new Solution().minInteger(\"4321\", 4));\\n        assertEquals(\"010\",new Solution().minInteger(\"100\", 1));\\n        assertEquals(\"36789\",new Solution().minInteger(\"36789\", 1000));\\n        assertEquals(\"22\",new Solution().minInteger(\"22\", 22));\\n        assertEquals(\"124498948179\",new Solution().minInteger(\"294984148179\", 11));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport org.junit.Test;\\n\\nimport static org.junit.Assert.assertEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        Node prevNode;\\n        Node nextNode;\\n        final int val;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n        Node addNext(final int i) {\\n            final Node next = new Node(i);\\n            this.nextNode = next;\\n            next.prevNode = this;\\n            return next;\\n        }\\n\\n        void addPrev(final Node node) {\\n            final Node prev = this.prevNode;\\n            node.prevNode = prev;\\n\\n            if (prev != null) {\\n                prev.nextNode = node;\\n            }\\n\\n            node.nextNode = this;\\n            this.prevNode = node;\\n        }\\n\\n        void unlink() {\\n            final Node prev = this.prevNode;\\n            final Node next = this.nextNode;\\n            this.prevNode = null;\\n            this.nextNode = null;\\n            prev.nextNode = next;\\n\\n            if (next != null) {\\n                next.prevNode = prev;\\n            }\\n        }\\n\\n        @Override\\n        public String toString() {\\n            Node current = this;\\n            final StringBuilder sb = new StringBuilder();\\n\\n            while (current != null) {\\n                sb.append(current.val);\\n                current = current.nextNode;\\n            }\\n\\n            return sb.toString();\\n        }\\n\\n    }\\n\\n    private boolean increasing(final String num) {\\n        for (int i = 0; i < num.length() - 1; i++) {\\n            if (num.charAt(i) > num.charAt(i + 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public String minInteger(final String num, final int k) {\\n        if (increasing(num)) {\\n            return num;\\n        }\\n\\n        final Node head = new Node(num.charAt(0) - \\'0\\');\\n        Node tail = head;\\n\\n        for (int i = 1; i < num.length(); i++) {\\n            tail = tail.addNext(num.charAt(i) - \\'0\\');\\n        }\\n\\n        final Node newHead = swap(head, k);\\n        return newHead.toString();\\n    }\\n\\n    private Node swap(final Node head, final int remaining) {\\n        if (remaining == 0 || head == null) {\\n            return null;\\n        }\\n\\n        if (head.val == 0) {\\n            swap(head.nextNode, remaining);\\n            return head;\\n        }\\n\\n        Node nextSmallest = null;\\n        int nextSmallestDistance = 0;\\n\\n        Node current = head.nextNode;\\n        int distance = 1;\\n\\n        while (current != null && distance <= remaining) {\\n            if (nextSmallest == null || current.val < nextSmallest.val) {\\n                nextSmallest = current;\\n                nextSmallestDistance = distance;\\n            }\\n\\n            current = current.nextNode;\\n            distance++;\\n        }\\n\\n        if (nextSmallest != null && nextSmallest.val < head.val) {\\n            nextSmallest.unlink(); // O(1)\\n            head.addPrev(nextSmallest); // O(1)\\n            swap(head, remaining - nextSmallestDistance);\\n            return nextSmallest;\\n        }\\n\\n        swap(head.nextNode, remaining);\\n        return head;\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertEquals(\"012345\", new Solution().minInteger(\"012345\", 23));\\n        assertEquals(\"0345989723478563548\", new Solution().minInteger(\"9438957234785635408\", 23));\\n        assertEquals(\"1342\",new Solution().minInteger(\"4321\", 4));\\n        assertEquals(\"010\",new Solution().minInteger(\"100\", 1));\\n        assertEquals(\"36789\",new Solution().minInteger(\"36789\", 1000));\\n        assertEquals(\"22\",new Solution().minInteger(\"22\", 22));\\n        assertEquals(\"124498948179\",new Solution().minInteger(\"294984148179\", 11));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779446,
                "title": "c-76ms-o-nlgn-time-o-n-space",
                "content": "```\\nclass Solution {\\n    \\n    vector<int> presum;\\n    \\n    void update(int i) {\\n        i++;\\n        while(i < presum.size()) {\\n            presum[i]++;\\n            i += i & -i;\\n        }\\n    }\\n    \\n    int getpresum(int i) {  // get number of digits before index i having already been put into string.\\n        int res = 0;\\n        while(i) {\\n            res += presum[i];\\n            i -= i & -i;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        if(k >= n * (n - 1) / 2) {  // trivial case\\n            std::sort(num.begin(), num.end());\\n            return num;\\n        }\\n\\n        presum.assign(n + 1, 0);\\n        \\n        vector<vector<int>> v(10);\\n        for(int i = 0; i < num.size(); i++) v[num[i] - \\'0\\'].push_back(i);  // v[i] contains indices of digit i in num\\n        \\n        string res;\\n        vector<int> c(10, 0); // c[i]: beginning index of unprocessed v[i]\\n        \\n        for(int i = 0; i < num.size(); i++) { \\n            for(int j = 0; j < 10; j++) { \\n                if(c[j] < v[j].size() && v[j][c[j]] - getpresum(v[j][c[j]]) <= k) { // choose smallest feasible char to fill res\\n                    res.push_back(\\'0\\' + j);\\n                    update(v[j][c[j]]);\\n                    k -= v[j][c[j]] - getpresum(v[j][c[j]]);\\n                    c[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    vector<int> presum;\\n    \\n    void update(int i) {\\n        i++;\\n        while(i < presum.size()) {\\n            presum[i]++;\\n            i += i & -i;\\n        }\\n    }\\n    \\n    int getpresum(int i) {  // get number of digits before index i having already been put into string.\\n        int res = 0;\\n        while(i) {\\n            res += presum[i];\\n            i -= i & -i;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n\\n    string minInteger(string num, int k) {\\n        \\n        int n = num.size();\\n        if(k >= n * (n - 1) / 2) {  // trivial case\\n            std::sort(num.begin(), num.end());\\n            return num;\\n        }\\n\\n        presum.assign(n + 1, 0);\\n        \\n        vector<vector<int>> v(10);\\n        for(int i = 0; i < num.size(); i++) v[num[i] - \\'0\\'].push_back(i);  // v[i] contains indices of digit i in num\\n        \\n        string res;\\n        vector<int> c(10, 0); // c[i]: beginning index of unprocessed v[i]\\n        \\n        for(int i = 0; i < num.size(); i++) { \\n            for(int j = 0; j < 10; j++) { \\n                if(c[j] < v[j].size() && v[j][c[j]] - getpresum(v[j][c[j]]) <= k) { // choose smallest feasible char to fill res\\n                    res.push_back(\\'0\\' + j);\\n                    update(v[j][c[j]]);\\n                    k -= v[j][c[j]] - getpresum(v[j][c[j]]);\\n                    c[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747180,
                "title": "javascript-fenwick-tree",
                "content": "\\t/**\\n\\t * @param {string} num\\n\\t * @param {number} k\\n\\t * @return {string}\\n\\t */\\n\\tfunction FenwickTree(n) {\\n\\t\\tthis.sum = Array(n+1).fill(0);\\n\\t}\\n\\n\\tFenwickTree.prototype.update = function(i, delta) {\\n\\t\\twhile (i < this.sum.length) {\\n\\t\\t\\tthis.sum[i] += delta;\\n\\t\\t\\ti += i & (-i);\\n\\t\\t}\\n\\t}\\n\\n\\tFenwickTree.prototype.query = function(i) {\\n\\t\\tlet sum = 0;\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsum += this.sum[i];\\n\\t\\t\\ti -= i & (-i);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvar minInteger = function(num, k) {\\n\\t\\tconst n = num.length;\\n\\t\\tconst pos = {}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tpos[num[i]] = pos[num[i]] || []\\n\\t\\t\\tpos[num[i]].push(i);\\n\\t\\t}\\n\\n\\t\\tconst fenwickTree = new FenwickTree(n);\\n\\t\\tconst used = new Set();\\n\\t\\tlet ans = \\'\\';\\n\\n\\t\\twhile (k > 0 && ans.length < n) {\\n\\t\\t\\tfor (let d = 0; d < 10; d++) {\\n\\t\\t\\t\\tif (!pos[d+\\'\\'] || !pos[d+\\'\\'].length) continue;\\n\\t\\t\\t\\tconst i = pos[d+\\'\\'][0];\\n\\t\\t\\t\\tconst cost = i - fenwickTree.query(i);\\n\\t\\t\\t\\tif (cost > k) continue;\\n\\t\\t\\t\\tk -= cost;\\n\\t\\t\\t\\tans += d;\\n\\t\\t\\t\\tfenwickTree.update(i+1, 1);\\n\\t\\t\\t\\tused.add(i);\\n\\t\\t\\t\\tpos[d+\\'\\'].shift();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!used.has(i)) ans += num[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t};",
                "solutionTags": [],
                "code": "\\t/**\\n\\t * @param {string} num\\n\\t * @param {number} k\\n\\t * @return {string}\\n\\t */\\n\\tfunction FenwickTree(n) {\\n\\t\\tthis.sum = Array(n+1).fill(0);\\n\\t}\\n\\n\\tFenwickTree.prototype.update = function(i, delta) {\\n\\t\\twhile (i < this.sum.length) {\\n\\t\\t\\tthis.sum[i] += delta;\\n\\t\\t\\ti += i & (-i);\\n\\t\\t}\\n\\t}\\n\\n\\tFenwickTree.prototype.query = function(i) {\\n\\t\\tlet sum = 0;\\n\\t\\twhile (i > 0) {\\n\\t\\t\\tsum += this.sum[i];\\n\\t\\t\\ti -= i & (-i);\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tvar minInteger = function(num, k) {\\n\\t\\tconst n = num.length;\\n\\t\\tconst pos = {}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tpos[num[i]] = pos[num[i]] || []\\n\\t\\t\\tpos[num[i]].push(i);\\n\\t\\t}\\n\\n\\t\\tconst fenwickTree = new FenwickTree(n);\\n\\t\\tconst used = new Set();\\n\\t\\tlet ans = \\'\\';\\n\\n\\t\\twhile (k > 0 && ans.length < n) {\\n\\t\\t\\tfor (let d = 0; d < 10; d++) {\\n\\t\\t\\t\\tif (!pos[d+\\'\\'] || !pos[d+\\'\\'].length) continue;\\n\\t\\t\\t\\tconst i = pos[d+\\'\\'][0];\\n\\t\\t\\t\\tconst cost = i - fenwickTree.query(i);\\n\\t\\t\\t\\tif (cost > k) continue;\\n\\t\\t\\t\\tk -= cost;\\n\\t\\t\\t\\tans += d;\\n\\t\\t\\t\\tfenwickTree.update(i+1, 1);\\n\\t\\t\\t\\tused.add(i);\\n\\t\\t\\t\\tpos[d+\\'\\'].shift();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (let i = 0; i < n; i++) {\\n\\t\\t\\tif (!used.has(i)) ans += num[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 746719,
                "title": "rust-translated-binary-indexed-tree",
                "content": "Runtime: 20 ms, faster than 100.00% of Rust online submissions for Minimum Possible Integer After at Most K Adjacent Swaps On Digits.\\nMemory Usage: 2.4 MB, less than 100.00% of Rust online submissions for Minimum Possible Integer After at Most K Adjacent Swaps On Digits.\\n```rust\\n#[derive(Debug, Default)]\\nstruct BinaryIndexedTree {\\n    n: usize,\\n    nodes: Vec<i32>,\\n}\\n\\nimpl BinaryIndexedTree {\\n    fn new(n: usize) -> BinaryIndexedTree {\\n        BinaryIndexedTree {\\n            n,\\n            nodes: vec![0; n + 1],\\n        }\\n    }\\n\\n    pub fn update(&mut self, idx: usize, delta: i32) {\\n        let mut i = (idx + 1) as i32;\\n        while i <= self.n as i32 {\\n            self.nodes[i as usize] += delta;\\n            i += i & (-i);\\n        }\\n    }\\n\\n    pub fn query(&mut self, idx: usize) -> i32 {\\n        let mut i = (idx + 1) as i32;\\n        let mut sum = 0;\\n        while i > 0 {\\n            sum += self.nodes[i as usize];\\n            i -= i & (-i);\\n        }\\n        sum\\n    }\\n}\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let n = num.len();\\n        let mut qs = vec![Vec::<i32>::new(); 10];\\n        for (pos, d) in num.as_bytes().iter().enumerate() {\\n            qs[(d - b\\'0\\') as usize].push(pos as i32);\\n        }\\n        let mut removed = vec![false; n];\\n        let mut tree = BinaryIndexedTree::new(n);\\n        let mut k = k;\\n        let mut ans = String::new();\\n        while k > 0 {\\n            let mut found = false;\\n            for d in 0..10 {\\n                if !qs[d as usize].is_empty() {\\n                    let pos = qs[d as usize][0];\\n                    let shifted = tree.query(pos as usize);\\n                    if pos - shifted <= k {\\n                        k -= pos - shifted;\\n                        tree.update(pos as usize, 1);\\n                        qs[d].remove(0);\\n                        ans.push((b\\'0\\' + d as u8) as char);\\n                        removed[pos as usize] = true;\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if !found {\\n                break;\\n            }\\n        }\\n        for i in 0..n {\\n            if !removed[i] {\\n                ans.push(num.as_bytes()[i] as char);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_integer() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"4321\"), 4),\\n            String::from(\"1342\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_02() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"100\"), 1),\\n            String::from(\"010\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_03() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"36789\"), 1000),\\n            String::from(\"36789\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_04() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"22\"), 22),\\n            String::from(\"22\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_05() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"9438957234785635408\"), 23),\\n            String::from(\"0345989723478563548\")\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n#[derive(Debug, Default)]\\nstruct BinaryIndexedTree {\\n    n: usize,\\n    nodes: Vec<i32>,\\n}\\n\\nimpl BinaryIndexedTree {\\n    fn new(n: usize) -> BinaryIndexedTree {\\n        BinaryIndexedTree {\\n            n,\\n            nodes: vec![0; n + 1],\\n        }\\n    }\\n\\n    pub fn update(&mut self, idx: usize, delta: i32) {\\n        let mut i = (idx + 1) as i32;\\n        while i <= self.n as i32 {\\n            self.nodes[i as usize] += delta;\\n            i += i & (-i);\\n        }\\n    }\\n\\n    pub fn query(&mut self, idx: usize) -> i32 {\\n        let mut i = (idx + 1) as i32;\\n        let mut sum = 0;\\n        while i > 0 {\\n            sum += self.nodes[i as usize];\\n            i -= i & (-i);\\n        }\\n        sum\\n    }\\n}\\nimpl Solution {\\n    pub fn min_integer(num: String, k: i32) -> String {\\n        let n = num.len();\\n        let mut qs = vec![Vec::<i32>::new(); 10];\\n        for (pos, d) in num.as_bytes().iter().enumerate() {\\n            qs[(d - b\\'0\\') as usize].push(pos as i32);\\n        }\\n        let mut removed = vec![false; n];\\n        let mut tree = BinaryIndexedTree::new(n);\\n        let mut k = k;\\n        let mut ans = String::new();\\n        while k > 0 {\\n            let mut found = false;\\n            for d in 0..10 {\\n                if !qs[d as usize].is_empty() {\\n                    let pos = qs[d as usize][0];\\n                    let shifted = tree.query(pos as usize);\\n                    if pos - shifted <= k {\\n                        k -= pos - shifted;\\n                        tree.update(pos as usize, 1);\\n                        qs[d].remove(0);\\n                        ans.push((b\\'0\\' + d as u8) as char);\\n                        removed[pos as usize] = true;\\n                        found = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if !found {\\n                break;\\n            }\\n        }\\n        for i in 0..n {\\n            if !removed[i] {\\n                ans.push(num.as_bytes()[i] as char);\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_integer() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"4321\"), 4),\\n            String::from(\"1342\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_02() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"100\"), 1),\\n            String::from(\"010\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_03() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"36789\"), 1000),\\n            String::from(\"36789\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_04() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"22\"), 22),\\n            String::from(\"22\")\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_integer_05() {\\n        assert_eq!(\\n            Solution::min_integer(String::from(\"9438957234785635408\"), 23),\\n            String::from(\"0345989723478563548\")\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733274,
                "title": "java-segmenttree",
                "content": "Ref: https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720548/O(n-logn)-or-Java-or-Heavily-Commented-or-Segment-Tree-or-Detailed-Explanation\\n```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        List<Queue<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i <= 9; i++) {\\n            list.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); i++) {\\n            list.get(num.charAt(i) - \\'0\\').offer(i);\\n        }\\n        \\n        Tree tr = new Tree(num.length());\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length(); i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                if (list.get(j).size() != 0) {\\n                    Integer pos = list.get(j).peek();\\n                    int shift = tr.getLowerSum(pos);\\n                    if (pos - shift <= k) {\\n                        list.get(j).poll();\\n                        k -= pos -shift;\\n                        tr.add(pos);\\n                        sb.append(j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public class Tree{\\n        int[] nodes;\\n        int n;\\n        \\n        public Tree(int max) {\\n            nodes = new int[4 * max];\\n            n = max;\\n        }\\n        \\n        public void add(int num) {\\n            add(num, 0, n, 0);\\n        }\\n        \\n        private void add(int num, int l, int r, int node) {\\n            if (num < l || num > r) return;\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (r + l) / 2;\\n            add(num, l, mid, node * 2 + 1);\\n            add(num, mid + 1, r, node * 2 + 2);\\n            nodes[node] = nodes[node * 2 + 1] + nodes[node * 2 + 2];\\n        }\\n        \\n        public int getLowerSum(int pos) {\\n            return getSum(0, pos, 0, n, 0);\\n        }\\n        \\n        private int getSum(int ql, int qr, int l, int r, int node) {\\n            if (ql > r || qr < l) return 0;\\n            if (ql <= l && qr >= r) return nodes[node];\\n            int mid = (r + l) / 2;\\n            return getSum(ql, qr, l, mid, node * 2 + 1) + getSum(ql, qr, mid + 1, r, node * 2 + 2);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        List<Queue<Integer>> list = new ArrayList<>();\\n        for (int i = 0; i <= 9; i++) {\\n            list.add(new LinkedList<>());\\n        }\\n        for (int i = 0; i < num.length(); i++) {\\n            list.get(num.charAt(i) - \\'0\\').offer(i);\\n        }\\n        \\n        Tree tr = new Tree(num.length());\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < num.length(); i++) {\\n            for (int j = 0; j <= 9; j++) {\\n                if (list.get(j).size() != 0) {\\n                    Integer pos = list.get(j).peek();\\n                    int shift = tr.getLowerSum(pos);\\n                    if (pos - shift <= k) {\\n                        list.get(j).poll();\\n                        k -= pos -shift;\\n                        tr.add(pos);\\n                        sb.append(j);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public class Tree{\\n        int[] nodes;\\n        int n;\\n        \\n        public Tree(int max) {\\n            nodes = new int[4 * max];\\n            n = max;\\n        }\\n        \\n        public void add(int num) {\\n            add(num, 0, n, 0);\\n        }\\n        \\n        private void add(int num, int l, int r, int node) {\\n            if (num < l || num > r) return;\\n            if (l == r) {\\n                nodes[node]++;\\n                return;\\n            }\\n            int mid = (r + l) / 2;\\n            add(num, l, mid, node * 2 + 1);\\n            add(num, mid + 1, r, node * 2 + 2);\\n            nodes[node] = nodes[node * 2 + 1] + nodes[node * 2 + 2];\\n        }\\n        \\n        public int getLowerSum(int pos) {\\n            return getSum(0, pos, 0, n, 0);\\n        }\\n        \\n        private int getSum(int ql, int qr, int l, int r, int node) {\\n            if (ql > r || qr < l) return 0;\\n            if (ql <= l && qr >= r) return nodes[node];\\n            int mid = (r + l) / 2;\\n            return getSum(ql, qr, l, mid, node * 2 + 1) + getSum(ql, qr, mid + 1, r, node * 2 + 2);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731420,
                "title": "o-nlogn-binary-indexed-tree-recommend-one-video-otherwise-it-s-too-subtle-to-explain",
                "content": "Learned the whole process from this solution video https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/727273/Java-Fenwick-Tree-O(nlogn)-Solution, I personally feel that it\\'s very hard to understand what is going on by reading solutions by texts.\\n\\n```\\nclass FenwickArray {\\nprivate:\\n    vector<int> array;\\n\\npublic:\\n    FenwickArray(int n): array(vector<int>(n + 1, 0)) {}\\n\\n    int query(int idx) {\\n        int ans = 0;\\n        while (idx > 0) {\\n            ans += array[idx];\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n\\n    void add(int idx, int delta) {\\n        while (idx < array.size()) {\\n            array[idx] += delta;\\n            idx += idx & -idx;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> indices(10, queue<int>());\\n        for (int i = 0; i < num.size(); ++i) {\\n            indices[num[i] - \\'0\\'].emplace(i);\\n        }\\n        FenwickArray fenwick(num.size());\\n        for (int i = 0; i < num.size(); ++i) {\\n            fenwick.add(i + 1, 1);\\n        }\\n        ostringstream ans;\\n        for (int i = 0; i < num.size(); ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!indices[j].empty()) {\\n                    int idx = indices[j].front();\\n                    int cost = fenwick.query(idx + 1) - 1;\\n                    if (cost <= k) {\\n                        ans << char(\\'0\\' + j);\\n                        indices[j].pop();\\n                        if (idx < num.size() - 1) {\\n                            fenwick.add(idx + 2, -1);\\n                        }\\n                        k -= cost;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FenwickArray {\\nprivate:\\n    vector<int> array;\\n\\npublic:\\n    FenwickArray(int n): array(vector<int>(n + 1, 0)) {}\\n\\n    int query(int idx) {\\n        int ans = 0;\\n        while (idx > 0) {\\n            ans += array[idx];\\n            idx -= idx & -idx;\\n        }\\n        return ans;\\n    }\\n\\n    void add(int idx, int delta) {\\n        while (idx < array.size()) {\\n            array[idx] += delta;\\n            idx += idx & -idx;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        vector<queue<int>> indices(10, queue<int>());\\n        for (int i = 0; i < num.size(); ++i) {\\n            indices[num[i] - \\'0\\'].emplace(i);\\n        }\\n        FenwickArray fenwick(num.size());\\n        for (int i = 0; i < num.size(); ++i) {\\n            fenwick.add(i + 1, 1);\\n        }\\n        ostringstream ans;\\n        for (int i = 0; i < num.size(); ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!indices[j].empty()) {\\n                    int idx = indices[j].front();\\n                    int cost = fenwick.query(idx + 1) - 1;\\n                    if (cost <= k) {\\n                        ans << char(\\'0\\' + j);\\n                        indices[j].pop();\\n                        if (idx < num.size() - 1) {\\n                            fenwick.add(idx + 2, -1);\\n                        }\\n                        k -= cost;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729134,
                "title": "o-n-log-n-solution-no-complex-ds",
                "content": "Let\\'s build queue for each digit and store the positions of this digit in the given string. For each item in the queue store number of items in original string which were moved to the front before this item. Do a loop while k > 0 and try to figure out, what is the smallest digit can be moved to the front. Let me illustrate this:\\n\\nFor instance, consider you have a string **4131231**.\\nThen we will store the following information:\\n\\nPositions for 1: 1, 3, 6, amount of moved items in front = 0, 0, 0\\nPositions for 2: 4, amount of moved items = 0\\nPositions for 3: 2, 5, amount of moved items = 0, 0\\nPositions for 4: 0, amount = 0\\n\\nSuppose we can move the first 1 to the front. Then we should update our amounts of moved items for other queues. So it becomes:\\nPositions for 1: 3, 6, amount = **1**, 0\\nPositions for 2: 4, amount = **1**\\nPositions for 3: 2, 5, amount of moved items = **1**, 0\\nPositions for 4: 0, amount = 0\\n\\nSuppose we move 1 to the front again. Then our information becomes as follows:\\nPositions for 1: 6, amount = **2**\\nPositions for 2: 4, amount = **2**\\nPositions for 3: 2, 5, amount of moved items = **1**, **1**\\nPositions for 4: 0, amount = 0\\nNotice the way we updated amount of moved items for 3, we simply found smallest item (5) > position (3) of moved digit (and incremented it).\\nThis is the place we can use binary search.\\n\\nAt each step, for each digit we compare k with value in the front queue - amount of moved items before. If a digit can be moved, we pop the item from the queue and update amount of items for each queue.\\n```\\nstring minInteger(string num, int k) {\\n\\tconst int n = num.size();\\n\\tconst int digits = 10;\\n\\n\\tvector<vector<int>> queues(digits);\\n\\tvector<int> curr(digits); // stores the head of each queue\\n\\n\\tvector<vector<int>> deltas(digits);\\n\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tqueues[num[i]-\\'0\\'].push_back(i);\\n\\t\\tdeltas[num[i]-\\'0\\'].push_back(0);\\n\\t}\\n\\n\\tstring prefix;\\n\\tvector<int> used(n);\\n\\n\\t// Put some sentinels to ease bunary search\\n\\tfor(int d = 0; d < digits; ++d)\\n\\t{\\n\\t\\tqueues[d].push_back(INT_MAX);\\n\\t\\tdeltas[d].push_back(0);            \\n\\t}\\n\\n\\twhile (k > 0)\\n\\t{\\n\\t\\tbool found = false;\\n\\n\\t\\tfor(int d = 0; d < digits; ++d)\\n\\t\\t{\\n\\t\\t\\tint& p = curr[d];\\n\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = queues[d][p] + deltas[d][p];\\n\\t\\t\\t\\tif (delta <= k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint pos = queues[d][p];\\n\\t\\t\\t\\t\\tused[pos] = true;\\n\\n\\t\\t\\t\\t\\tprefix.push_back(\\'0\\' + d);\\n\\n\\t\\t\\t\\t\\t++p;\\n\\t\\t\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] += deltas[d][p-1];\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] -= 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tk -= delta;\\n\\n\\t\\t\\t\\t\\tfor(int t = 0; t < digits; ++t)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (t == d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tint low = curr[t]-1, high = queues[t].size()-1;\\n\\t\\t\\t\\t\\t\\twhile (low + 1 < high)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint m = (low + high) / 2;    \\n\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][m] > pos)\\n\\t\\t\\t\\t\\t\\t\\t\\thigh = m;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tlow = m;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tdeltas[t][high]--;\\n\\n\\t\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t\\t// Equivalent of the binary search above\\n\\t\\t\\t\\t\\t\\tfor(int u = curr[t]; u < queues[t].size(); ++u)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][u] > pos)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tdeltas[t][u]--;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t*/\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!found)\\n\\t\\t\\tbreak;            \\n\\t}\\n\\n\\tstring suffix = \"\";\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!used[i])\\n\\t\\t\\tsuffix.push_back(num[i]);\\n\\t}        \\n\\n\\treturn prefix + suffix;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n\\tconst int n = num.size();\\n\\tconst int digits = 10;\\n\\n\\tvector<vector<int>> queues(digits);\\n\\tvector<int> curr(digits); // stores the head of each queue\\n\\n\\tvector<vector<int>> deltas(digits);\\n\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tqueues[num[i]-\\'0\\'].push_back(i);\\n\\t\\tdeltas[num[i]-\\'0\\'].push_back(0);\\n\\t}\\n\\n\\tstring prefix;\\n\\tvector<int> used(n);\\n\\n\\t// Put some sentinels to ease bunary search\\n\\tfor(int d = 0; d < digits; ++d)\\n\\t{\\n\\t\\tqueues[d].push_back(INT_MAX);\\n\\t\\tdeltas[d].push_back(0);            \\n\\t}\\n\\n\\twhile (k > 0)\\n\\t{\\n\\t\\tbool found = false;\\n\\n\\t\\tfor(int d = 0; d < digits; ++d)\\n\\t\\t{\\n\\t\\t\\tint& p = curr[d];\\n\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint delta = queues[d][p] + deltas[d][p];\\n\\t\\t\\t\\tif (delta <= k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint pos = queues[d][p];\\n\\t\\t\\t\\t\\tused[pos] = true;\\n\\n\\t\\t\\t\\t\\tprefix.push_back(\\'0\\' + d);\\n\\n\\t\\t\\t\\t\\t++p;\\n\\t\\t\\t\\t\\tif (p < queues[d].size())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] += deltas[d][p-1];\\n\\t\\t\\t\\t\\t\\tdeltas[d][p] -= 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfound = true;\\n\\t\\t\\t\\t\\tk -= delta;\\n\\n\\t\\t\\t\\t\\tfor(int t = 0; t < digits; ++t)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (t == d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tint low = curr[t]-1, high = queues[t].size()-1;\\n\\t\\t\\t\\t\\t\\twhile (low + 1 < high)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint m = (low + high) / 2;    \\n\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][m] > pos)\\n\\t\\t\\t\\t\\t\\t\\t\\thigh = m;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tlow = m;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tdeltas[t][high]--;\\n\\n\\t\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t\\t// Equivalent of the binary search above\\n\\t\\t\\t\\t\\t\\tfor(int u = curr[t]; u < queues[t].size(); ++u)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (queues[t][u] > pos)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tdeltas[t][u]--;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t*/\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!found)\\n\\t\\t\\tbreak;            \\n\\t}\\n\\n\\tstring suffix = \"\";\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!used[i])\\n\\t\\t\\tsuffix.push_back(num[i]);\\n\\t}        \\n\\n\\treturn prefix + suffix;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 728883,
                "title": "java-bit-fenwick-tree",
                "content": "```\\nclass Solution {\\n    int n;\\n    int[] sum;\\n    \\n    private int lowbit(int i) {return i & (-i);}\\n    private void add(int x, int v) {\\n        for (int i = x; i <= n; i += lowbit(i)) {\\n            sum[i] += v;\\n        }\\n    }\\n    private int query(int x) {\\n        int res = 0;\\n        for (int i = x; i > 0; i -= lowbit(i)) {\\n            res += sum[i];\\n        }\\n        return res;\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if (num == null || num.length() == 0) return num;\\n        Deque<Integer>[] pos = new Deque[10];  // save all pos of current digit\\n        for (int i = 0; i < 10; i++) {\\n            pos[i] = new ArrayDeque<>();\\n        }\\n        n = num.length();\\n        sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pos[num.charAt(i) - \\'0\\'].addLast(i + 1);   // BIT starts with 1\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 10; j++) {              // try all digits\\n                if (pos[j].isEmpty()) continue;         // all used\\n                int t = pos[j].peekFirst();             // get next closest digit\\n                int p = t + query(t);                   // query(p) \\u662F\\u5750\\u6807\\u504F\\u79FB\\u91CF\\n                if (p - i <= k) {\\n                    k -= p - i;\\n                    pos[j].pollFirst();\\n                    res.append(j);\\n                    add(1, 1);              // add all 1 in [1, t-1]    \\n                    add(t, -1);                \\n                    break;\\n                }   \\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    int[] sum;\\n    \\n    private int lowbit(int i) {return i & (-i);}\\n    private void add(int x, int v) {\\n        for (int i = x; i <= n; i += lowbit(i)) {\\n            sum[i] += v;\\n        }\\n    }\\n    private int query(int x) {\\n        int res = 0;\\n        for (int i = x; i > 0; i -= lowbit(i)) {\\n            res += sum[i];\\n        }\\n        return res;\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if (num == null || num.length() == 0) return num;\\n        Deque<Integer>[] pos = new Deque[10];  // save all pos of current digit\\n        for (int i = 0; i < 10; i++) {\\n            pos[i] = new ArrayDeque<>();\\n        }\\n        n = num.length();\\n        sum = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            pos[num.charAt(i) - \\'0\\'].addLast(i + 1);   // BIT starts with 1\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 10; j++) {              // try all digits\\n                if (pos[j].isEmpty()) continue;         // all used\\n                int t = pos[j].peekFirst();             // get next closest digit\\n                int p = t + query(t);                   // query(p) \\u662F\\u5750\\u6807\\u504F\\u79FB\\u91CF\\n                if (p - i <= k) {\\n                    k -= p - i;\\n                    pos[j].pollFirst();\\n                    res.append(j);\\n                    add(1, 1);              // add all 1 in [1, t-1]    \\n                    add(t, -1);                \\n                    break;\\n                }   \\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728201,
                "title": "java-o-n-2-108-ms-easy-understand-and-with-detailed-explaination",
                "content": "fisrt, follow the question description, we can got:\\n\\nif we want to got the min number,  we must  serach from `0` to `9` for each move , and make the count of move to head is **less than or equal** `k`.\\n\\nfor example:  `num = 4321`, `k = 4`.\\n\\nthe min number we can find is `1`, and move it to head need move 3 times.\\n\\nafter move,  we got `num = 1432`, `k = 4 - 3 = 1`\\n\\nand the min number for `432` is `2`, and move it to head need move  2 times,  but k is `1`, so we can not move it,\\n\\nand the next min number is `3`, and move it to head need move 1 times, and k is `1`, so we do it.\\n\\nand than `num = 1342`,  `k = 1 - 1 = 0`.\\n\\nbecause k is 0, so we return `1342.`\\n\\n---\\n\\n**Recursion(Time Limit Exceeded)**\\ni got the following code from the comments.  it can passed 47 testcase, but **Time Limit Exceeded** on the 48th testcase.\\n`indexOf()` and `substring` is  `O(N)`, and it run N times, so the time complexity is O(N<sup>2</sup>).\\n```\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\\n\\n---\\n\\n**Optimization Recusion**\\nwe can optimize `indexOf` and `substring`, but how?\\n\\nbecause we will search the position from 0 to 9 for each move, so we can traverse the num string, and record the position for each char. so we can make the time complexity for search index from `O(N)` to `O(1)`.\\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\\nthe pos in the `list[i]` is the index in the num string.\\n\\nlet\\'s see a example again.  ` num = 4132`, `k = 4`.\\n\\nif we want move `4` to the head, we need move 0 times, and `1` is 1 times, `3` is 2 times, `2` is 3 times.\\n\\nbut after we moved `1`,  `num = 1432`, `k = 3`.\\n\\nand move `4` to the head, we also need move 0 times, but `3` is  `2 - 1 = 1` times, `2` is ` 3 - 1  = 2` times.\\n\\nso we can see, the number after the each moved number,  the move count will be **minus one**.  so we record it.\\n\\n\\nand for `substring`, we can record the index we had used, than we not need to use `substring`.\\n\\n**Runtime: 846 ms, faster than 51.21%**\\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //recrod the index for 0 - 9\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n\\t\\n    //append the moved char\\n    StringBuilder res = new StringBuilder();\\n    //offset[i] is record the number had move befor i.\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 mean we can move continue\\uFF0C res.length() < len  mean we have number not move.\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                continue;\\n            }\\n            //get the need move times\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //if move > k, we can not move it\\n                continue ;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove the used index in list\\n            int index = list[i].removeFirst();\\n            //append the moved number\\n            res.append(arr[index]);\\n            //update arr[index] = 0,  record we had used it\\n            arr[index] = 0;\\n            //update offset\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            continue outer;\\n        }\\n    }\\n    //if we have not moved num, we append it one by one.\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\\n\\n---\\n\\n**Optimize to O(N LogN)**\\n\\nin the upper code, we use offset[i] to record the count of moved number before i.\\n\\nwe can alse record the moved index, and then use **Binary Search** to find the count of less the i.\\n\\nand for the num, we can total move ` 1 + 2 + 3 + ... + (n - 1) = (n - 1) * n / 2`,  so  if ` k >=  (n - 1) * n / 2`, we can use `Arrays.sort(arr)` to sort the `char[] arr = num.toCharArray()`. and `return new String(arr);`\\n\\n\\n**Runtime: 108 ms, faster than 77.38%\\uFF0C Memory Usage: 53.8 MB, less than 100.00% of Java online submissions**\\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //record moved index\\n    List<Integer> record = new ArrayList<>();\\n    //record res\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //find the moved count before pos\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove used form list\\n            int pos = list[i].removeFirst();\\n\\t\\t\\t//add to the moved index list\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    *Binary Search find the count less than value\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\\n\\n---\\n\\nif i had made any mistake, please let me know, thanks a lot.\\n\\nthe following description is in Chinese.\\n\\n\\n---\\n\\n## \\u7406\\u89E3\\u9898\\u610F\\n\\n\\u9996\\u5148\\u6839\\u636E\\u9898\\u76EE\\u63CF\\u8FF0\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u5F97\\u5230\\uFF1A\\n\\u8981\\u60F3\\u5728\\u79FB\\u52A8 k \\u6B21\\u4E4B\\u540E\\u5F97\\u5230\\u6700\\u5C0F\\u7684\\u6570\\uFF0C \\u5FC5\\u987B\\u6BCF\\u6B21\\u79FB\\u52A8\\u5C3D\\u53EF\\u80FD\\u7684\\u5728K\\u6B21\\u5185\\uFF0C\\u628A\\u4ECE 0 \\u5F00\\u59CB\\u5230 9 \\u7684\\u6570\\u79FB\\u52A8\\u5230\\u4F7F\\u524D\\u9762\\u6CA1\\u6709\\u6BD4\\u5B83\\u5927\\u7684\\u6570\\u5B57\\u3002\\n\\n\\u6BD4\\u5982\\uFF1A `num = 4321`, `k = 4`.\\n\\u6211\\u4EEC\\u80FD\\u627E\\u5230\\u7684\\u6700\\u5C0F\\u7684\\u6570\\u662F `1`, \\u628A `1` \\u79FB\\u52A8\\u5230\\u5F00\\u5934\\u9700\\u8981\\u79FB\\u52A8 `3` \\u6B21\\u3002\\n\\u6240\\u4EE5\\u79FB\\u52A8\\u4E4B\\u540E\\u5F97\\u5230\\uFF1A `num = 1432`, `k = 4 - 3 = 1`;\\n\\u7136\\u540E\\u4ECE 1 \\u540E\\u9762\\u5F00\\u59CB\\uFF0C\\u6211\\u4EEC\\u80FD\\u627E\\u5230\\u7684 `2`\\uFF0C \\u628A `2` \\u79FB\\u52A8\\u5230 `1` \\u540E\\u9762\\u9700\\u8981\\u79FB\\u52A8 2 \\u6B21\\uFF0C \\u4F46\\u662F k = 1, \\u6240\\u4EE5\\u6211\\u4EEC\\u5F97\\u627E\\u4E0B\\u4E00\\u4E2A\\u5C0F\\u7684\\u6570\\u3002 \\u6211\\u4EEC\\u627E\\u5230\\u4E86 `3`\\uFF0C\\u7136\\u540E\\u628A `3` \\u79FB\\u52A8\\u5230 1 \\u540E\\u9762\\u9700\\u8981 \\u79FB\\u52A8 1 \\u6B21\\uFF0C k = 1, \\u521A\\u597D\\u53EF\\u4EE5\\u3002\\n\\u6240\\u4EE5\\u79FB\\u52A8\\u4E4B\\u540E\\u5F97\\u5230\\uFF1A `num = 1342`,  `k = 1 - 1 = 0`;\\n\\u56E0\\u4E3A `k = 0` \\u4E0D\\u80FD\\u79FB\\u52A8\\u4E86\\uFF0C \\u6240\\u4EE5\\u6211\\u4EEC\\u76F4\\u63A5\\u8FD4\\u56DE  `1342`\\u3002\\n\\n---\\n\\n### \\u9012\\u5F52\\u89E3\\u6CD5\\uFF08\\u8D85\\u51FA\\u65F6\\u95F4\\u9650\\u5236\\uFF09\\n\\u6240\\u4EE5\\u4EE3\\u7801\\u6211\\u4EEC\\u53EF\\u4EE5\\u7528 \\u9012\\u5F52 \\u76F4\\u63A5\\u8FD9\\u6837\\u5199, **\\u4F46\\u662F\\u5728\\u7B2C48\\u4E2A\\u6D4B\\u8BD5\\u7528\\u4F8B\\u7684\\u65F6\\u5019\\u4F1A\\u63D0\\u793A \\u8D85\\u51FA\\u65F6\\u95F4\\u9650\\u5236**\\u3002\\n\\u6211\\u4EEC\\u6765\\u5206\\u6790\\u4E0B\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF0C\\n`num.indexOf(c)` \\u662F `O(N)`, \\n`subString` \\u4E5F\\u662F `O(N)`, \\n\\u4E00\\u5171\\u6267\\u884C\\u4E86 N \\u6B21\\uFF0C \\u6240\\u4EE5\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u662F `O(N^2)`.\\n```\\n//\\u4EE3\\u7801\\u6765\\u81EA\\u8BC4\\u8BBA\\u533A\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\\n\\n---\\n\\n### \\u4F18\\u5316\\u9012\\u5F52\\n\\u5BF9\\u4E8E\\u9012\\u5F52\\u65B9\\u6CD5\\u7684 `indexOf` \\u548C `substring` \\u6211\\u4EEC\\u53EF\\u4EE5\\u600E\\u4E48\\u4F18\\u5316\\u5462\\uFF1F\\n\\n\\u56E0\\u4E3A\\u6211\\u4EEC\\u6BCF\\u6B21\\u90FD\\u8981\\u4ECE 0 \\u5230 9 \\u53BB\\u83B7\\u53D6\\u5176\\u5728 `num` \\u5BF9\\u5E94\\u7684\\u4F4D\\u7F6E, \\u6240\\u4EE5\\u6211\\u4EEC\\u53EF\\u4EE5\\u5148\\u8BB0\\u5F55\\u4ED6\\u4EEC\\u7684\\u4F4D\\u7F6E\\uFF0C \\u53EF\\u4EE5\\u901A\\u8FC7\\u4E0B\\u9762\\u7684\\u4EE3\\u7801\\u4E00\\u6B21\\u904D\\u5386\\u5C31\\u80FD\\u83B7\\u53D6\\u5230 0 - 9 \\u5728 num\\u4E2D\\u7684\\u6240\\u6709\\u4F4D\\u7F6E\\u3002\\u53EF\\u4EE5\\u628A\\u6BCF\\u6B21\\u67E5\\u627E\\u4F4D\\u7F6E\\u7684\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4ECE `O(N)` \\u964D\\u5230 `O(1)`.\\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\\n\\u8FD9\\u6837\\u6211\\u4EEC\\u4FDD\\u5B58\\u7684\\u662F 0 - 9 \\u5728 num\\u4E2D\\u7684\\u539F\\u59CB\\u4F4D\\u7F6E\\u3002\\n\\u6211\\u4EEC\\u518D\\u6765\\u770B\\u4E2A\\u793A\\u4F8B `num = 4132`, `k = 4`.\\n\\u628A `4` \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u662F 0 \\u6B21\\uFF0C `1` \\u662F1\\u6B21\\uFF0C`3` \\u662F 2\\u6B21\\uFF0C`2` \\u662F 3\\u6B21\\n\\u5F53\\u6211\\u4EEC\\u79FB\\u52A8 `1` \\u4E4B\\u540E \\u5F97\\u5230 `num = 1432`, `k = 3`.\\n\\u6B64\\u65F6 `1` \\u662F\\u5DF2\\u7ECF\\u786E\\u5B9A\\u7684\\u76F8\\u5F53\\u4E8E\\u53EA\\u662F\\u5904\\u7406 `432`\\uFF0C \\u6B64\\u65F6\\u6211\\u4EEC\\u548C\\u5F00\\u59CB\\u7684 `4132` \\u76F8\\u6BD4\\u628A\\u6BCF\\u4E2A\\u6570 \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u7684\\u6B21\\u6570\\u53D8\\u6210\\u4E86:\\n\\u628A `4` \\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u662F 0 \\u6B21\\uFF0C `3` \\u662F 1\\u6B21\\uFF0C`2` \\u662F 2\\u6B21.\\n\\u6211\\u4EEC\\u53D1\\u73B0\\uFF0C \\u6BCF\\u4E00\\u79FB\\u52A8\\u5B8C\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4ED6\\u540E\\u9762\\u7684\\u5B57\\u7B26\\u6700\\u524D\\u9762\\u7684\\u6B21\\u6570\\u5C31\\u4F1A **\\u51CF1**\\u3002\\n\\n**\\u8FD9\\u6837\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u8BB0\\u5F55\\u6BCF\\u6B21\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u540E\\u9762\\u5B57\\u7B26\\u8BA9\\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u79FB\\u52A8\\u6B21\\u6570\\u51CF\\u4E00\\u3002**\\n\\n\\u5BF9\\u4E8E`substring` \\u6211\\u4EEC\\u53EF\\u4EE5\\u8BB0\\u5F55\\u90A3\\u4E9B\\u5B57\\u7B26\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86, \\u8FD9\\u6837\\u5C31\\u53EF\\u4EE5\\u76F4\\u63A5\\u5728\\u539F\\u5B57\\u7B26\\u4E0A\\u64CD\\u4F5C\\u4E86\\uFF0C\\u4E0D\\u9700\\u8981\\u5229\\u7528`substring`\\u4E86\\u3002\\n\\n\\n\\u4EE3\\u7801\\u5982\\u4E0B\\uFF0C \\u8FD9\\u6837\\u80FD\\u901A\\u8FC7\\u6240\\u6709\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\u4E86\\uFF0C**\\u4F46\\u662F \\u6267\\u884C\\u7528\\u65F6\\uFF1A1131 ms\\uFF0C \\u8FD8\\u662F\\u6BD4\\u8F83\\u6162\\u7684\\uFF0C \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u7EE7\\u7EED\\u4F18\\u5316**\\u3002\\n\\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E \\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    //\\u8BB0\\u5F55 \\u5F53\\u524D\\u4F4D\\u7F6E \\u524D\\u9762\\u7531\\u591A\\u5C11\\u4E2A\\u5B57\\u7B26\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 \\u8BF4\\u660E\\u6211\\u4EEC \\u53EF\\u4EE5\\u79FB\\u52A8\\uFF0C res.length() < len \\u8BF4\\u660E\\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8  \\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                //num\\u4E2D\\u6CA1\\u6709\\u8FD9\\u4E2A\\u5B57\\u7B26\\n                continue;\\n            }\\n            //\\u83B7\\u53D6\\u5B57\\u7B26\\u7684\\u4E0B\\u6807 \\u51CF\\u53BB \\u524D\\u9762\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26 \\u5F97\\u5230 \\u5B83\\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u9700\\u8981\\u7684\\u6B21\\u6570\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //\\u6BD4 K \\u5927\\uFF0C\\u5219\\u627E\\u4E0B\\u4E00\\u4E2A\\u6570\\u5B57\\n                continue ;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int index = list[i].removeFirst();\\n            //\\u6DFB\\u52A0\\u5230\\u7ED3\\u679C\\u4E2D\\n            res.append(arr[index]);\\n            //\\u4FEE\\u6539num\\u4E2D\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E3A \\u5B57\\u7B26 0\\uFF0C \\u8868\\u793A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\u3002\\n            arr[index] = 0;\\n            //\\u5C06 index \\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u9700\\u8981\\u51CF\\u53BB\\u7684\\u79FB\\u52A8\\u6B21\\u6570 + 1\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            //\\u7EE7\\u7EED\\u4ECE 0 \\u5F00\\u59CB\\u627E \\u79FB\\u52A8\\u6B21\\u6570\\u5C0F\\u4E8E k \\u7684\\u5B57\\u7B26\\n            continue outer;\\n        }\\n    }\\n    //\\u5982\\u679C k \\u6BD4\\u8F83\\u5C0F\\uFF0C \\u5C31\\u4F1A\\u5B58\\u5728 \\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8\\uFF0C \\u6211\\u4EEC\\u6309\\u539F\\u987A\\u5E8F\\u4F9D\\u6B21\\u6DFB\\u52A0\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\\n\\n---\\n\\n### \\u4F18\\u5316\\u5230 O(N*logN)\\n\\n\\u4E0A\\u9762\\u7684\\u4EE3\\u7801\\uFF0C \\u6BCF\\u6B21\\u79FB\\u52A8\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E4B\\u540E\\uFF0C\\u9700\\u8981\\u5BF9\\u540E\\u9762\\u7684\\u6240\\u6709\\u5B57\\u7B26\\u8BB0\\u5F55\\u524D\\u9762\\u79FB\\u52A8\\u7684\\u5B57\\u7B26 \\u52A0 1\\u3002\\n\\n**\\u90A3\\u6211\\u4EEC\\u4E5F\\u53EF\\u4EE5\\u76F4\\u63A5\\u4FDD\\u5B58 \\u79FB\\u52A8\\u8FC7\\u5B57\\u7B26\\u7684\\u4F4D\\u7F6E\\uFF0C\\u627E\\u5B57\\u7B26\\u65F6\\uFF0C\\u901A\\u8FC7\\u4E8C\\u5206\\u67E5\\u627E \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u8BB0\\u5F55\\u4E2D \\u6709\\u591A\\u5C11\\u4E2A \\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\u3002**\\n\\n**\\u800C\\u4E14\\u6211\\u4EEC\\u5B57\\u7B26\\u6700\\u591A\\u79FB\\u52A8 1 + 2 + ... + n-1 = (n - 1) * n / 2 \\u6B21\\uFF0C \\u6240\\u4EE5\\u5F53 k >= (n -1) * n / 2 \\u65F6\\uFF0C \\u6211\\u4EEC\\u53EF\\u4EE5\\u76F4\\u63A5\\u5BF9\\u5B57\\u7B26\\u6309\\u5347\\u5E8F\\u6392\\u5E8F\\u3002**\\n\\n\\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //\\u8BB0\\u5F55\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\n    List<Integer> record = new ArrayList<>();\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //\\u627E\\u5230\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\u4E2D\\u6709 \\u591A\\u5C11\\u4E2A\\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int pos = list[i].removeFirst();\\n            //\\u628A\\u5F53\\u524D \\u4F4D\\u7F6E \\u6DFB\\u52A0\\u5230 \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u5217\\u8868\\u4E2D\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    * \\u4E8C\\u5206\\u67E5\\u627E\\u6BD4 value\\u5C0F\\u7684\\u4E2A\\u6570\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\\n\\n\\u5982\\u679C\\u4E0A\\u9762\\u6709\\u4EC0\\u4E48\\u63CF\\u8FF0\\u9519\\u8BEF\\u7684\\uFF0C\\u8BF7\\u6307\\u51FA\\u6765\\uFF0C \\u611F\\u8C22\\u3002",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //recrod the index for 0 - 9\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n\\t\\n    //append the moved char\\n    StringBuilder res = new StringBuilder();\\n    //offset[i] is record the number had move befor i.\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 mean we can move continue\\uFF0C res.length() < len  mean we have number not move.\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                continue;\\n            }\\n            //get the need move times\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //if move > k, we can not move it\\n                continue ;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove the used index in list\\n            int index = list[i].removeFirst();\\n            //append the moved number\\n            res.append(arr[index]);\\n            //update arr[index] = 0,  record we had used it\\n            arr[index] = 0;\\n            //update offset\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            continue outer;\\n        }\\n    }\\n    //if we have not moved num, we append it one by one.\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //record moved index\\n    List<Integer> record = new ArrayList<>();\\n    //record res\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //find the moved count before pos\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //update k\\n            k -= move;\\n\\t\\t\\t// remove used form list\\n            int pos = list[i].removeFirst();\\n\\t\\t\\t//add to the moved index list\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    *Binary Search find the count less than value\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```\n```\\n//\\u4EE3\\u7801\\u6765\\u81EA\\u8BC4\\u8BBA\\u533A\\npublic String minInteger(String num, int k) {\\n    if (k == 0) return num;\\n    for (char c = \\'0\\'; c <= \\'9\\'; c++) {\\n        int i = num.indexOf(c);\\n        if (i >= 0) {\\n            if (i <= k) {\\n                return c + minInteger(num.substring(0, i) + num.substring(i + 1), k - i);\\n            }\\n        }\\n    }\\n    return num;\\n}\\n```\n```\\nLinkedList<Integer>[] list = new LinkedList[10];\\nfor (int i = 0; i < 10; i++) {\\n    list[i] = new LinkedList<>();\\n}\\nint len = num.length();\\nchar[] arr = num.toCharArray();\\nfor (int i = 0; i < len; i++) {\\n    list[arr[i] - \\'0\\'].add(i);\\n}\\n```\n```\\n// O(N^2)time\\n// O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E \\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    //\\u8BB0\\u5F55 \\u5F53\\u524D\\u4F4D\\u7F6E \\u524D\\u9762\\u7531\\u591A\\u5C11\\u4E2A\\u5B57\\u7B26\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\n    int[] offset = new int[len];\\n    outer:\\n    // k > 0 \\u8BF4\\u660E\\u6211\\u4EEC \\u53EF\\u4EE5\\u79FB\\u52A8\\uFF0C res.length() < len \\u8BF4\\u660E\\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8  \\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()){\\n                //num\\u4E2D\\u6CA1\\u6709\\u8FD9\\u4E2A\\u5B57\\u7B26\\n                continue;\\n            }\\n            //\\u83B7\\u53D6\\u5B57\\u7B26\\u7684\\u4E0B\\u6807 \\u51CF\\u53BB \\u524D\\u9762\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26 \\u5F97\\u5230 \\u5B83\\u79FB\\u52A8\\u5230\\u6700\\u524D\\u9762\\u9700\\u8981\\u7684\\u6B21\\u6570\\n            int move = list[i].getFirst() - offset[list[i].getFirst()];\\n            if (move > k) {\\n                //\\u6BD4 K \\u5927\\uFF0C\\u5219\\u627E\\u4E0B\\u4E00\\u4E2A\\u6570\\u5B57\\n                continue ;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int index = list[i].removeFirst();\\n            //\\u6DFB\\u52A0\\u5230\\u7ED3\\u679C\\u4E2D\\n            res.append(arr[index]);\\n            //\\u4FEE\\u6539num\\u4E2D\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u4E3A \\u5B57\\u7B26 0\\uFF0C \\u8868\\u793A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\u3002\\n            arr[index] = 0;\\n            //\\u5C06 index \\u540E\\u9762\\u7684\\u5B57\\u7B26\\u7684\\u9700\\u8981\\u51CF\\u53BB\\u7684\\u79FB\\u52A8\\u6B21\\u6570 + 1\\n            for (int j = index + 1; j < len; j++) {\\n                offset[j]++;\\n            }\\n            //\\u7EE7\\u7EED\\u4ECE 0 \\u5F00\\u59CB\\u627E \\u79FB\\u52A8\\u6B21\\u6570\\u5C0F\\u4E8E k \\u7684\\u5B57\\u7B26\\n            continue outer;\\n        }\\n    }\\n    //\\u5982\\u679C k \\u6BD4\\u8F83\\u5C0F\\uFF0C \\u5C31\\u4F1A\\u5B58\\u5728 \\u8FD8\\u6709\\u5B57\\u7B26\\u672A\\u88AB\\u79FB\\u52A8\\uFF0C \\u6211\\u4EEC\\u6309\\u539F\\u987A\\u5E8F\\u4F9D\\u6B21\\u6DFB\\u52A0\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n```\n```\\n//O(N * logN)time\\n//O(N)space\\npublic String minInteger(String num, int k) {\\n    //\\u8BB0\\u5F550 - 9 \\u5728 num\\u4E2D\\u7684\\u4F4D\\u7F6E\\n    LinkedList<Integer>[] list = new LinkedList[10];\\n    for (int i = 0; i < 10; i++) {\\n        list[i] = new LinkedList<>();\\n    }\\n    int len = num.length();\\n    char[] arr = num.toCharArray();\\n    for (int i = 0; i < len; i++) {\\n        list[arr[i] - \\'0\\'].add(i);\\n    }\\n    if (k >= (len - 1) * len / 2) {\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    //\\u8BB0\\u5F55\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\n    List<Integer> record = new ArrayList<>();\\n    //\\u8BB0\\u5F55\\u7ED3\\u679C\\uFF0C \\u6DFB\\u52A0\\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u5B57\\u7B26\\n    StringBuilder res = new StringBuilder();\\n    outer:\\n    while (k > 0 && res.length() < len) {\\n        for (int i = 0; i < 10; i++) {\\n            if (list[i].isEmpty()) {\\n                continue;\\n            }\\n            //\\u627E\\u5230\\u79FB\\u52A8\\u7684\\u5B57\\u7B26\\u4F4D\\u7F6E\\u4E2D\\u6709 \\u591A\\u5C11\\u4E2A\\u6BD4\\u5F53\\u524D\\u4F4D\\u7F6E\\u5C0F\\n            int index = findIndex(record, list[i].getFirst());\\n            int move = list[i].getFirst() - index;\\n            if (move > k) {\\n                continue;\\n            }\\n            //\\u66F4\\u65B0 k\\u7684\\u503C \\n            k -= move;\\n            //\\u83B7\\u53D6\\u8FD9\\u4E2A\\u5B57\\u7B26\\u7684\\u9996\\u4E2A\\u4F4D\\u7F6E\\uFF0C \\u5E76\\u628A\\u5B83\\u4ECE\\u4FDD\\u5B58\\u4F4D\\u7F6E\\u7684\\u94FE\\u8868\\u4E2D\\u79FB\\u9664\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u5DF2\\u7ECF\\u7528\\u8FC7\\u4E86\\uFF0C\\u4E0D\\u80FD\\u518D\\u7528\\n            int pos = list[i].removeFirst();\\n            //\\u628A\\u5F53\\u524D \\u4F4D\\u7F6E \\u6DFB\\u52A0\\u5230 \\u5DF2\\u7ECF\\u79FB\\u52A8\\u8FC7\\u7684\\u4F4D\\u7F6E\\u5217\\u8868\\u4E2D\\n            record.add(index, pos);\\n            res.append(i);\\n            arr[pos] = 0;\\n            continue outer;\\n        }\\n    }\\n    for (int i = 0; i < len; i++) {\\n        if (arr[i] != 0) {\\n            res.append(arr[i]);\\n        }\\n    }\\n    return res.toString();\\n}\\n\\n/**\\n    * \\u4E8C\\u5206\\u67E5\\u627E\\u6BD4 value\\u5C0F\\u7684\\u4E2A\\u6570\\n    */\\nint findIndex(List<Integer> list, int value) {\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n        int mid = (l + r) >> 1;\\n        if (list.get(mid) < value) {\\n            l = mid + 1;\\n        } else {\\n            r = mid;\\n        }\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 725256,
                "title": "java-o-n-sqrt-n-sqrt-decomposition-and-index-queues",
                "content": "A solution with **O(n*sqrt(n))** time and  **O(n)** space complexity. \\nIt is asymptotically slower than the Segment Tree solution,\\nbut it has not been offered so far, so I will add it here for completeness.\\n\\nWe create queues of index occurences for every digit, and we pick the left most index of the smallest digit we could move to first position.\\nOnce we have exhausted all k swaps, we append remaining unused digits.\\n\\nWhen we do swaps to move an element to the front, all elements to the left of it shift one position to the right.\\nTo keep track of how far every element has shifted we use a Sqrt Decomposition structure (we could use instead a Segment Tree for this purpose, see other solutions). \\nSqrt Decomposition is a simpler structure, but less efficient too: **calculateShift()** has a **sqrt(n)** instead of **log(n)** execution time. For more information see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\n\\n\\n\\n```\\n// O(n*sqrt(n)) time, O(n) space\\t\\nclass Solution {\\t\\n   \\t\\n    public String minInteger(String num, int k) {\\t\\n        int n = num.length();\\t\\n        char[] arr = num.toCharArray();\\t\\n        \\n        Queue[] indexQueues = createIndexQueues(arr);\\t\\n        SqrtDecomposition sqrt = new SqrtDecomposition(n);\\t\\n            \\t\\n        StringBuilder sb = new StringBuilder();\\t\\n        for (int i = 0; i < n; i++) {\\t\\n            if (k == 0) break;\\t\\n            for (int digit = 0; digit < 10; digit++) {\\t\\n                Queue<Integer> q = indexQueues[digit];\\t\\n                if (!q.isEmpty()) {\\t\\n                    int originalIndex = q.peek();\\t\\n                    int shiftedIndex = originalIndex + sqrt.calculateShift(originalIndex) - i;\\t\\n                    if (shiftedIndex <= k) {\\t\\n                        sb.append(arr[originalIndex]);\\t\\n                        sqrt.add(q.poll());\\t\\n                        k -= shiftedIndex;\\t\\n                        break;\\t\\n                    }    \\t\\n                }\\t\\n            }            \\t\\n        }\\t\\n        \\t\\n        //add digits which we haven\\'t used yet    \\t\\n        for (int i = 0; i < n; i++) if (sqrt.a[i] == 0) sb.append(arr[i]);\\t\\n        return sb.toString();\\t\\n    }\\t\\n    \\t\\n    private Queue[] createIndexQueues(char[] arr) {\\t\\n        Queue[] queues = new LinkedList[10];\\t\\n        for (int i = 0; i < 10; i++) queues[i] = new LinkedList<Integer>();\\t\\n        for (int i = 0; i < arr.length; i++) queues[arr[i]-\\'0\\'].offer(i);\\t\\n        return queues;\\t\\n    }\\t\\n}\\t\\n\\n//For explanation on how Sqrt Decomposition works, see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\nclass SqrtDecomposition {\\t\\n    int[] a;\\t\\n    int[] b;\\t\\n    int n;\\t\\n    int sqrtN;\\t\\n    \\t\\n    SqrtDecomposition(int n) {\\t\\n        this.n = n;\\n        sqrtN = ((int) Math.sqrt(n)) + 1;\\t\\n        a = new int[n];\\t\\n        b = new int[sqrtN];\\t\\n    }\\t\\n    \\t\\n    void add(int i) {\\t\\n        a[i]++;\\t\\n        b[i/sqrtN]++;\\t\\n    }\\t\\n    \\t\\n    int calculateShift(int i) {\\t\\n        int answer = 0;\\t\\n        while ( i < n && i % sqrtN != 0) {\\t\\n            answer += a[i++];\\t\\n        }\\t\\n        int j = i/sqrtN;\\t\\n        while (j < sqrtN) {\\t\\n            answer += b[j++];\\t\\n        }\\t\\n        return answer;\\t\\n    }\\t\\n}\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// O(n*sqrt(n)) time, O(n) space\\t\\nclass Solution {\\t\\n   \\t\\n    public String minInteger(String num, int k) {\\t\\n        int n = num.length();\\t\\n        char[] arr = num.toCharArray();\\t\\n        \\n        Queue[] indexQueues = createIndexQueues(arr);\\t\\n        SqrtDecomposition sqrt = new SqrtDecomposition(n);\\t\\n            \\t\\n        StringBuilder sb = new StringBuilder();\\t\\n        for (int i = 0; i < n; i++) {\\t\\n            if (k == 0) break;\\t\\n            for (int digit = 0; digit < 10; digit++) {\\t\\n                Queue<Integer> q = indexQueues[digit];\\t\\n                if (!q.isEmpty()) {\\t\\n                    int originalIndex = q.peek();\\t\\n                    int shiftedIndex = originalIndex + sqrt.calculateShift(originalIndex) - i;\\t\\n                    if (shiftedIndex <= k) {\\t\\n                        sb.append(arr[originalIndex]);\\t\\n                        sqrt.add(q.poll());\\t\\n                        k -= shiftedIndex;\\t\\n                        break;\\t\\n                    }    \\t\\n                }\\t\\n            }            \\t\\n        }\\t\\n        \\t\\n        //add digits which we haven\\'t used yet    \\t\\n        for (int i = 0; i < n; i++) if (sqrt.a[i] == 0) sb.append(arr[i]);\\t\\n        return sb.toString();\\t\\n    }\\t\\n    \\t\\n    private Queue[] createIndexQueues(char[] arr) {\\t\\n        Queue[] queues = new LinkedList[10];\\t\\n        for (int i = 0; i < 10; i++) queues[i] = new LinkedList<Integer>();\\t\\n        for (int i = 0; i < arr.length; i++) queues[arr[i]-\\'0\\'].offer(i);\\t\\n        return queues;\\t\\n    }\\t\\n}\\t\\n\\n//For explanation on how Sqrt Decomposition works, see https://cp-algorithms.com/data_structures/sqrt_decomposition.html\\nclass SqrtDecomposition {\\t\\n    int[] a;\\t\\n    int[] b;\\t\\n    int n;\\t\\n    int sqrtN;\\t\\n    \\t\\n    SqrtDecomposition(int n) {\\t\\n        this.n = n;\\n        sqrtN = ((int) Math.sqrt(n)) + 1;\\t\\n        a = new int[n];\\t\\n        b = new int[sqrtN];\\t\\n    }\\t\\n    \\t\\n    void add(int i) {\\t\\n        a[i]++;\\t\\n        b[i/sqrtN]++;\\t\\n    }\\t\\n    \\t\\n    int calculateShift(int i) {\\t\\n        int answer = 0;\\t\\n        while ( i < n && i % sqrtN != 0) {\\t\\n            answer += a[i++];\\t\\n        }\\t\\n        int j = i/sqrtN;\\t\\n        while (j < sqrtN) {\\t\\n            answer += b[j++];\\t\\n        }\\t\\n        return answer;\\t\\n    }\\t\\n}\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724464,
                "title": "java-solution-complexity-o-k-n",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int swaps) {\\n        char[] arr = num.toCharArray();\\n        arr = minArray(arr, arr.length, swaps); \\n        return new String(arr);\\n    }\\n    char[] minArray(char[] arr, int length, int swaps) { \\n        if (swaps == 0) \\n            return arr; \\n        for (int i = 0; i < length; i++) { \\n            int min_index = 0, min = Integer.MAX_VALUE;\\n            int limit = (swaps+i) > length-1 ?  length-1 : swaps + i; \\n            for (int j = i; j <= limit; j++) {\\n                if (arr[j] < min) { \\n                    min = arr[j]; \\n                    min_index = j; \\n                }\\n            }\\n            swaps -= (min_index - i);     \\n            arr = swapMin(arr, i, min_index); \\n            if (swaps == 0) \\n                break; \\n        }\\n        return arr;\\n    } \\n    char[] swapMin(char[] arr, int target, int current) { \\n        char temp = \\'0\\'; \\n        for (int i = current; i > target; i--) { \\n            temp = arr[i - 1]; \\n            arr[i - 1] = arr[i]; \\n            arr[i] = temp; \\n        }\\n        return arr;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String num, int swaps) {\\n        char[] arr = num.toCharArray();\\n        arr = minArray(arr, arr.length, swaps); \\n        return new String(arr);\\n    }\\n    char[] minArray(char[] arr, int length, int swaps) { \\n        if (swaps == 0) \\n            return arr; \\n        for (int i = 0; i < length; i++) { \\n            int min_index = 0, min = Integer.MAX_VALUE;\\n            int limit = (swaps+i) > length-1 ?  length-1 : swaps + i; \\n            for (int j = i; j <= limit; j++) {\\n                if (arr[j] < min) { \\n                    min = arr[j]; \\n                    min_index = j; \\n                }\\n            }\\n            swaps -= (min_index - i);     \\n            arr = swapMin(arr, i, min_index); \\n            if (swaps == 0) \\n                break; \\n        }\\n        return arr;\\n    } \\n    char[] swapMin(char[] arr, int target, int current) { \\n        char temp = \\'0\\'; \\n        for (int i = current; i > target; i--) { \\n            temp = arr[i - 1]; \\n            arr[i - 1] = arr[i]; \\n            arr[i] = temp; \\n        }\\n        return arr;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724013,
                "title": "c-bit-easy-understand-with-explanation",
                "content": "Data Structures used: Binary Indexed tree, Priority Queue, Vector.\\nBIT Tree: To store the count as well as the position of the swapped numbers.\\nPriority Queue: Used for storing the positions of all the numbers\\nVector: For storing the remaining numbers which were not swapped and will be added to the resutling string in the end.\\n\\nTo get the minimum number possible we have to find the smallest number possible in the beginning of the string. So, we will greedily choose numbers from 0-9 for each position, check how many previous numbers have been swapped before this number, (It is important because for each swapped number at position ```cur```, all the numbers left to it are shifted by 1 position to the right and the numbers to the right are at their original position).  We will subtract the ```cur``` with ```prevCnt``` because since the numbers are shifted by 1 position to the right, the position of the the current number to be swapped is also moving forward with each swap, so net effect reamins the same and we only have to take care of the number of swaps upto that position ```cur``` After checking if swap is possible or not, we update the current position of the number for all the future swaps. Like this we do for all the numbers and at the end we store all the numbers in the tmp vector, sort it and add it to the resulting string.\\n\\nHope this clears your doubt. Feel free to ask any questions! \\nCredits: [jt3698](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720235/C%2B%2B-O(N-log-N)-FenwickBIT-solution-196ms-(with-explanation))\\n\\n```\\nclass Solution {\\npublic:\\n    int BIT[30002];\\n    priority_queue<int,vector<int>,greater<int>> pq[10];\\n    vector<pair<int,int>> tmp;\\n    int n;\\n    \\n    string minInteger(string num, int k) {\\n        string res=\"\";\\n        int counter=0;\\n        n=num.size();\\n        memset(BIT,0,sizeof BIT);\\n        tmp.clear();\\n        for(int i=0;i<n;i++)\\n            pq[num[i]-\\'0\\'].push(i);\\n        \\n        \\n        while(counter < n && k>0) {\\n            for(int i=0;i<=9;i++){\\n                if(!pq[i].empty()){\\n                    int cur=pq[i].top();\\n                    int prevCnt=getPrevCnt(cur);\\n                    int swaps=cur-prevCnt;\\n                    if(swaps<=k){\\n                        k-=swaps;\\n                        res+=(i+\\'0\\');\\n                        pq[i].pop();\\n                        updateBIT(cur+1);\\n                        break;\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        for(int i=0;i<=9;i++){\\n            while(!pq[i].empty()){\\n                int num=pq[i].top();\\n                pq[i].pop();\\n                tmp.push_back({num,i});\\n            }\\n        }\\n        \\n        sort(tmp.begin(),tmp.end());\\n        \\n        for(int i=0;i<tmp.size();i++)\\n            res+=(tmp[i].second+\\'0\\');\\n        \\n        return res;\\n    }\\n    \\n    int getPrevCnt(int x){\\n        int cnt=0;\\n        while(x>0){\\n            cnt+=BIT[x];\\n            x-=(x&-x);\\n        }\\n        return cnt;\\n    }\\n    \\n    void updateBIT(int x){\\n        while(x<=n){\\n            BIT[x]++;\\n            x+=(x&-x);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cur```\n```cur```\n```prevCnt```\n```cur```\n```\\nclass Solution {\\npublic:\\n    int BIT[30002];\\n    priority_queue<int,vector<int>,greater<int>> pq[10];\\n    vector<pair<int,int>> tmp;\\n    int n;\\n    \\n    string minInteger(string num, int k) {\\n        string res=\"\";\\n        int counter=0;\\n        n=num.size();\\n        memset(BIT,0,sizeof BIT);\\n        tmp.clear();\\n        for(int i=0;i<n;i++)\\n            pq[num[i]-\\'0\\'].push(i);\\n        \\n        \\n        while(counter < n && k>0) {\\n            for(int i=0;i<=9;i++){\\n                if(!pq[i].empty()){\\n                    int cur=pq[i].top();\\n                    int prevCnt=getPrevCnt(cur);\\n                    int swaps=cur-prevCnt;\\n                    if(swaps<=k){\\n                        k-=swaps;\\n                        res+=(i+\\'0\\');\\n                        pq[i].pop();\\n                        updateBIT(cur+1);\\n                        break;\\n                    }\\n                }\\n            }\\n            counter++;\\n        }\\n        for(int i=0;i<=9;i++){\\n            while(!pq[i].empty()){\\n                int num=pq[i].top();\\n                pq[i].pop();\\n                tmp.push_back({num,i});\\n            }\\n        }\\n        \\n        sort(tmp.begin(),tmp.end());\\n        \\n        for(int i=0;i<tmp.size();i++)\\n            res+=(tmp[i].second+\\'0\\');\\n        \\n        return res;\\n    }\\n    \\n    int getPrevCnt(int x){\\n        int cnt=0;\\n        while(x>0){\\n            cnt+=BIT[x];\\n            x-=(x&-x);\\n        }\\n        return cnt;\\n    }\\n    \\n    void updateBIT(int x){\\n        while(x<=n){\\n            BIT[x]++;\\n            x+=(x&-x);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722393,
                "title": "java-solution-no-collections-super-slow-ac",
                "content": "```\\nclass Solution {\\n    \\n    public String minInteger(String num, int k) {\\n        \\n\\t\\t// the k enough to make the string ordered\\n        if(k>=num.length()*(num.length()-1)/2){\\n            char[] cs = num.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(num);\\n        StringBuilder rst = new StringBuilder();\\n        \\n        while(k>0){\\n            for(int i=0; i<9; i++){\\n                int idx = sb.indexOf(String.valueOf(i));\\n\\t\\t\\t\\t// swap the char to the head\\n                if(idx>=0 && idx<=k){\\n                    k-=idx;\\n                    rst.append(i);\\n                    sb.deleteCharAt(idx);\\n                    i=-1;\\n                }\\n            }\\n            break;\\n        }\\n        \\n\\t\\t// if the k still>0, move the first non ordered char k forward\\n        if(k>0){\\n            for(int i=1; i<sb.length(); i++){\\n                if(sb.charAt(i)<sb.charAt(i-1)){\\n                    char ch = sb.charAt(i);\\n                    sb.deleteCharAt(i);\\n                    sb.insert(i-k, ch);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        rst.append(sb);\\n        return rst.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public String minInteger(String num, int k) {\\n        \\n\\t\\t// the k enough to make the string ordered\\n        if(k>=num.length()*(num.length()-1)/2){\\n            char[] cs = num.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(num);\\n        StringBuilder rst = new StringBuilder();\\n        \\n        while(k>0){\\n            for(int i=0; i<9; i++){\\n                int idx = sb.indexOf(String.valueOf(i));\\n\\t\\t\\t\\t// swap the char to the head\\n                if(idx>=0 && idx<=k){\\n                    k-=idx;\\n                    rst.append(i);\\n                    sb.deleteCharAt(idx);\\n                    i=-1;\\n                }\\n            }\\n            break;\\n        }\\n        \\n\\t\\t// if the k still>0, move the first non ordered char k forward\\n        if(k>0){\\n            for(int i=1; i<sb.length(); i++){\\n                if(sb.charAt(i)<sb.charAt(i-1)){\\n                    char ch = sb.charAt(i);\\n                    sb.deleteCharAt(i);\\n                    sb.insert(i-k, ch);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        rst.append(sb);\\n        return rst.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721962,
                "title": "268ms-python-solution-beat-100",
                "content": "store the position of all previously moved-to-front element and keep in order, then use binary search to find out how many elements before the current one have been forwarded.\\n```python\\nfrom bisect import bisect\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        len_num = len(num)\\n        if k >= len_num * (len_num - 1) / 2:\\n            return \\'\\'.join(sorted(num))\\n        pos = [[] for _ in range(10)]\\n        for i in range(len_num - 1, -1, -1):\\n            pos[int(num[i])].append(i)\\n        prev = []\\n        ans = \\'\\'\\n        candi = list(range(10))\\n        while k and len(ans) < len_num:\\n            for di in candi[:]:\\n                if pos[di]:\\n                    index = pos[di][-1]\\n                    place = bisect(prev, index)\\n                    if index - place <= k:\\n                        prev.insert(place, index)\\n                        k -= index - place\\n                        pos[di].pop()\\n                        ans += str(di)\\n                        break\\n                else:\\n                    candi.remove(di)\\n        if k == 0 and len(ans) < len_num:\\n            prev = set(prev)\\n            return ans + \\'\\'.join(ch for i, ch in enumerate(num) if i not in prev)\\n        else:\\n            return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom bisect import bisect\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        len_num = len(num)\\n        if k >= len_num * (len_num - 1) / 2:\\n            return \\'\\'.join(sorted(num))\\n        pos = [[] for _ in range(10)]\\n        for i in range(len_num - 1, -1, -1):\\n            pos[int(num[i])].append(i)\\n        prev = []\\n        ans = \\'\\'\\n        candi = list(range(10))\\n        while k and len(ans) < len_num:\\n            for di in candi[:]:\\n                if pos[di]:\\n                    index = pos[di][-1]\\n                    place = bisect(prev, index)\\n                    if index - place <= k:\\n                        prev.insert(place, index)\\n                        k -= index - place\\n                        pos[di].pop()\\n                        ans += str(di)\\n                        break\\n                else:\\n                    candi.remove(di)\\n        if k == 0 and len(ans) < len_num:\\n            prev = set(prev)\\n            return ans + \\'\\'.join(ch for i, ch in enumerate(num) if i not in prev)\\n        else:\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721935,
                "title": "an-interesting-observation-linear-time-edge-cases",
                "content": "Just a small observation: let k = #swaps and n=(len string - 1) If k > (n^2 + n) / 2 just return sorted string.\\n\\nWhy?\\n\\nRecall, Gauss\\' sum, g(n) = 1+2+3+...+n = (n^2 + n) / 2\\n\\nand imagine some worst-case string. This worst-case string will be reverse order, like:\\n\\n\"54321\". Imagine this string, and k = 1000\\n\\nBest string is clearly \"12345\". # of swaps to create this number is\\n\\n4+3+2+1. So, g(N-1) where N is length of string. We can immediately return sorted string if this condition is true.\\n\\nWe can sort this string with Radix sort, since alphabet is only 0-9. And Radix sort is O(n) for this problem.\\n\\n",
                "solutionTags": [],
                "code": "Just a small observation: let k = #swaps and n=(len string - 1) If k > (n^2 + n) / 2 just return sorted string.\\n\\nWhy?\\n\\nRecall, Gauss\\' sum, g(n) = 1+2+3+...+n = (n^2 + n) / 2\\n\\nand imagine some worst-case string. This worst-case string will be reverse order, like:\\n\\n\"54321\". Imagine this string, and k = 1000\\n\\nBest string is clearly \"12345\". # of swaps to create this number is\\n\\n4+3+2+1. So, g(N-1) where N is length of string. We can immediately return sorted string if this condition is true.\\n\\nWe can sort this string with Radix sort, since alphabet is only 0-9. And Radix sort is O(n) for this problem.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 721774,
                "title": "c-o-n-2-172ms-greedy-solution-28-lines-with-explanation",
                "content": "* To make num string sorted, the maximal numer of swaps is n*(n-1)/2. If k is >= this number,  the sorted one could just be returned. (This helps to pass some test cases with TLE).\\n* getNext() tries to find the smallest character within range k to replace the current character. If it was not found (or the smaller ones are all out of k range), it means the current one is the best one (we don\\'t need to do any swap), we just go to the next position.\\n* If the smallest one was found, we shift the substring (idx, replacement-idx) one element back, and replace the current one with the smallest one. \\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k> n*n/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0; i<n; i++){\\n            getNext(num, i, k);\\n        }\\n        return num;\\n    }\\n    void getNext(string& num, int idx, int& k) {\\n        int replacement = idx;\\n        for(char c=\\'0\\'; c<num[idx]; c++) {\\n            size_t pos = num.find(c, idx+1);\\n            if(pos-idx<=k) {\\n                replacement = pos;\\n                break;\\n            }\\n        }\\n        if(replacement==idx) return;\\n        char c = num[replacement];\\n        for(int i=replacement; i>idx; i--) num[i] = num[i-1];\\n        num[idx] = c;\\n        k-=(replacement-idx);  \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k> n*n/2) {\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0; i<n; i++){\\n            getNext(num, i, k);\\n        }\\n        return num;\\n    }\\n    void getNext(string& num, int idx, int& k) {\\n        int replacement = idx;\\n        for(char c=\\'0\\'; c<num[idx]; c++) {\\n            size_t pos = num.find(c, idx+1);\\n            if(pos-idx<=k) {\\n                replacement = pos;\\n                break;\\n            }\\n        }\\n        if(replacement==idx) return;\\n        char c = num[replacement];\\n        for(int i=replacement; i>idx; i--) num[i] = num[i-1];\\n        num[idx] = c;\\n        k-=(replacement-idx);  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721697,
                "title": "python3-solution-in-o-nlogn-time",
                "content": "Use a subscript *idx* to represent the character that can be replaced by a smaller digit. *idx* traverses from num[0] to num[-1]. In O(N^2) solution, it takes linear time to find the minimum digit on the right to *num[idx]*. In order to reduce it to O(logN) time:\\n\\n1. Use a dict to find a minimum digit in O(1) time. The key of this dict is a digit, the value(a sorted list) of the dict is the indices of its occurrences. This digit is just a candidate, use step 2 to check if it is appropriate.\\n2. Compute the real distance between [idx] and the candidate, which is the tricky part.\\n\\nThe dict only contains the original indices of the digits, but during the algorithm, we rebuild the string *num* each loop. However we don\\'t want to update the dict, because it will take linear time. Therefore, we use the value in the dict to compute the real-time distance.\\n\\nThe key is to maintain a list *pick_idx*, which records the digits that we have swapped to the front, and we use bisect to keep it sorted. Every time we compute a distance, we use bisect_right to find the index of it in *pick_idx*, and count how many swapped digits are on its right. We have to add this number to *index of candidate - idx* because the candidate actually moves right for 1 slot if another candidate right to it was swapped in the past.\\n\\nMaintain *pick_idx*, add the appropriate candidate to this list, and use this list to compute the real distance.\\n\\n\\n``` python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        map = collections.defaultdict(list)\\n        for i,c in enumerate(num):\\n            map[c].append(i)\\n        \\n        idx, pick_idx= 0, []\\n        for idx in range(len(num)):\\n            for target in range(10):\\n                if target<=int(num[idx]) and map[str(target)]:\\n                    insert_pos = bisect.bisect_right(pick_idx, map[str(target)][0])\\n                    num_on_the_right = len(pick_idx)-insert_pos\\n                    move_length = map[str(target)][0]+num_on_the_right-idx\\n\\t\\t\\t\\t\\t# compute the actual move length\\n                    if move_length>=0 and move_length<=k:\\n                        k-=move_length\\n                        target_pos = map[str(target)][0]\\n                        pick_idx.insert(insert_pos, target_pos)\\n                        target_pos+=num_on_the_right                        \\n                        num = num[0:idx]+num[target_pos]+num[idx:target_pos]+num[target_pos+1:]\\n                        map[str(target)].pop(0)\\n                        if len(map[str(target)])==0: del map[str(target)]          \\n                        break    \\n                                        \\n            if k==0: break  # no jumps left\\n        return num\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        map = collections.defaultdict(list)\\n        for i,c in enumerate(num):\\n            map[c].append(i)\\n        \\n        idx, pick_idx= 0, []\\n        for idx in range(len(num)):\\n            for target in range(10):\\n                if target<=int(num[idx]) and map[str(target)]:\\n                    insert_pos = bisect.bisect_right(pick_idx, map[str(target)][0])\\n                    num_on_the_right = len(pick_idx)-insert_pos\\n                    move_length = map[str(target)][0]+num_on_the_right-idx\\n\\t\\t\\t\\t\\t# compute the actual move length\\n                    if move_length>=0 and move_length<=k:\\n                        k-=move_length\\n                        target_pos = map[str(target)][0]\\n                        pick_idx.insert(insert_pos, target_pos)\\n                        target_pos+=num_on_the_right                        \\n                        num = num[0:idx]+num[target_pos]+num[idx:target_pos]+num[target_pos+1:]\\n                        map[str(target)].pop(0)\\n                        if len(map[str(target)])==0: del map[str(target)]          \\n                        break    \\n                                        \\n            if k==0: break  # no jumps left\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721647,
                "title": "c-bit-solution-with-comments-and-explanations",
                "content": "Credits to https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720235/C%2B%2B-O(N-log-N)-FenwickBIT-solution-196ms-(with-explanation) for the original idea. This is my implementation and understanding of the idea.\\n\\nTo summarize here:\\n1. Preprocess the string to get all indexes of each digit in the original string.\\n2. At each point, greedily see whether we can put the smallest digit to the current position, here we use BIT to store total number of digits already selected before index i, to calculate and update the cost in O(logn) time.\\n3. We stop when we no longer have any additional moves, or when we have already reconstructed the whole string. If we ran out of moves before the whole string is reconstructed, we need to put back the rest of the characters in their original order, which can be done in a merge-sort fashion.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int GetSum(const vector<int>& bit, int index) {\\n        int x = index;\\n        int sum = 0;\\n        while (x > 0) {\\n            sum += bit[x];\\n            x -= x&(-x);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(vector<int>& bit, int index, int val) {\\n        int x = index;\\n        while (x < bit.size()) {\\n            bit[x] += val;\\n            x += x & (-x);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        // Stores indexes of each number incrementally.\\n        vector<deque<int>> indexes(10, deque<int>());\\n        \\n        for (int i = 0; i < num.length(); ++i) {\\n            int n = num[i] - \\'0\\';\\n            indexes[n].push_back(i);\\n        }\\n        \\n        // BIT for storing how many numbers have we already taken so far.\\n        vector<int> bit(num.length() + 1, 0);\\n\\n        // Prefix for storing already swapped elements.\\n        string prefix;\\n        \\n        // Iterate when we are not already finished (prefix length == num length), and when we still have moves.\\n        while (k > 0 && prefix.length() < num.length()) {\\n            // Iterate each number from small to large, greedily.\\n            for (int i = 0; i <= 9; ++i) {\\n                if (indexes[i].empty()) {\\n                    continue;\\n                }\\n                int next = indexes[i].front();\\n                \\n                // The cost to move this number from its current position to front.\\n                // The cost is equal to \"original index - number of digits already taken before this\".\\n                int taken = GetSum(bit, next + 1);\\n                int cost = next - taken;\\n                \\n                // If we can move this digit, we move it and adjust the cost in the BIT accordingly.\\n                if (cost <= k) {\\n                    prefix.append(1, \\'0\\' + i);\\n                    update(bit, next + 1, 1);\\n                    k -= cost;\\n                    indexes[i].pop_front();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // For cases where we have used all moves, but the entire string hasn\\'t been constructed yet,\\n\\t\\t// we just need to reconstruct the rest of the original string based on its initial order.\\n        // Since the relative positions of them are not moved, we can simply do a \"merge sort from k lists\" here.\\n        while (prefix.length() != num.length()) {\\n            int smallest = INT_MAX;\\n            int smallest_num = -1; \\n            for (int i = 0; i <= 9; ++i) {\\n                if (!indexes[i].empty()) {\\n                    if (smallest > indexes[i].front()) {\\n                        smallest = indexes[i].front();\\n                        smallest_num = i;\\n                    }\\n                }\\n            }\\n            \\n            if (smallest_num != -1) {\\n                indexes[smallest_num].pop_front();\\n                prefix.append(1, \\'0\\' + smallest_num);\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int GetSum(const vector<int>& bit, int index) {\\n        int x = index;\\n        int sum = 0;\\n        while (x > 0) {\\n            sum += bit[x];\\n            x -= x&(-x);\\n        }\\n        return sum;\\n    }\\n    \\n    void update(vector<int>& bit, int index, int val) {\\n        int x = index;\\n        while (x < bit.size()) {\\n            bit[x] += val;\\n            x += x & (-x);\\n        }\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        // Stores indexes of each number incrementally.\\n        vector<deque<int>> indexes(10, deque<int>());\\n        \\n        for (int i = 0; i < num.length(); ++i) {\\n            int n = num[i] - \\'0\\';\\n            indexes[n].push_back(i);\\n        }\\n        \\n        // BIT for storing how many numbers have we already taken so far.\\n        vector<int> bit(num.length() + 1, 0);\\n\\n        // Prefix for storing already swapped elements.\\n        string prefix;\\n        \\n        // Iterate when we are not already finished (prefix length == num length), and when we still have moves.\\n        while (k > 0 && prefix.length() < num.length()) {\\n            // Iterate each number from small to large, greedily.\\n            for (int i = 0; i <= 9; ++i) {\\n                if (indexes[i].empty()) {\\n                    continue;\\n                }\\n                int next = indexes[i].front();\\n                \\n                // The cost to move this number from its current position to front.\\n                // The cost is equal to \"original index - number of digits already taken before this\".\\n                int taken = GetSum(bit, next + 1);\\n                int cost = next - taken;\\n                \\n                // If we can move this digit, we move it and adjust the cost in the BIT accordingly.\\n                if (cost <= k) {\\n                    prefix.append(1, \\'0\\' + i);\\n                    update(bit, next + 1, 1);\\n                    k -= cost;\\n                    indexes[i].pop_front();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // For cases where we have used all moves, but the entire string hasn\\'t been constructed yet,\\n\\t\\t// we just need to reconstruct the rest of the original string based on its initial order.\\n        // Since the relative positions of them are not moved, we can simply do a \"merge sort from k lists\" here.\\n        while (prefix.length() != num.length()) {\\n            int smallest = INT_MAX;\\n            int smallest_num = -1; \\n            for (int i = 0; i <= 9; ++i) {\\n                if (!indexes[i].empty()) {\\n                    if (smallest > indexes[i].front()) {\\n                        smallest = indexes[i].front();\\n                        smallest_num = i;\\n                    }\\n                }\\n            }\\n            \\n            if (smallest_num != -1) {\\n                indexes[smallest_num].pop_front();\\n                prefix.append(1, \\'0\\' + smallest_num);\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721506,
                "title": "java-nlogn-solution-20-ms-using-fenwick-tree",
                "content": "1) Use fenwick tree to determine how many digits before a particular index have already been swapped. This will help us determine the number of swaps needed.\\n2) Use greedy approach to move the smallest possible digit at every step, to the most significant possible position.\\n\\n```\\nclass Solution {\\n    int[] bt;\\n    \\n    public String minInteger(String num, int k) {\\n        bt = new int[num.length()+1];\\n        char[] nums = num.toCharArray();\\n        List<List<Integer>> a = new ArrayList();\\n        for(int i=0;i<=9;i++) a.add(new ArrayList());\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int ind = nums[i]-\\'0\\';\\n            a.get(ind).add(i);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n   \\n        while(sb.length()<nums.length && k>0){\\n            int i=0; \\n        while(i<=9){\\n                if(a.get(i).size() == 0) i++;\\n                else{\\n                  int index = a.get(i).get(0);\\n                  int swap = index-get(index+1);  // find elements to be swapped\\n                    if(k<swap){\\n                        i++;\\n                    }\\n                    else{\\n                        update(index+1); // update the fenwick tree to give this information to future indexes\\n                        a.get(i).remove(0);\\n                        k-=swap;\\n                        sb.append(nums[index]);\\n                        nums[index] = \\'a\\';\\n                        break;\\n                    }\\n                }\\n           }\\n       }\\n        if(sb.length() == nums.length) return sb.toString();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != \\'a\\') sb.append(nums[i]);\\n        } \\n        \\n        return sb.toString();\\n    }\\n    \\n    public int get(int val){\\n        int count = 0;\\n        \\n        while(val>0){\\n            count+=bt[val];\\n            val-= -val&val;\\n        }\\n        return count;\\n    }\\n    \\n    public void update(int val){ \\n        while(val < bt.length){\\n            bt[val]+=1;\\n            val += -val&val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] bt;\\n    \\n    public String minInteger(String num, int k) {\\n        bt = new int[num.length()+1];\\n        char[] nums = num.toCharArray();\\n        List<List<Integer>> a = new ArrayList();\\n        for(int i=0;i<=9;i++) a.add(new ArrayList());\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int ind = nums[i]-\\'0\\';\\n            a.get(ind).add(i);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n   \\n        while(sb.length()<nums.length && k>0){\\n            int i=0; \\n        while(i<=9){\\n                if(a.get(i).size() == 0) i++;\\n                else{\\n                  int index = a.get(i).get(0);\\n                  int swap = index-get(index+1);  // find elements to be swapped\\n                    if(k<swap){\\n                        i++;\\n                    }\\n                    else{\\n                        update(index+1); // update the fenwick tree to give this information to future indexes\\n                        a.get(i).remove(0);\\n                        k-=swap;\\n                        sb.append(nums[index]);\\n                        nums[index] = \\'a\\';\\n                        break;\\n                    }\\n                }\\n           }\\n       }\\n        if(sb.length() == nums.length) return sb.toString();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] != \\'a\\') sb.append(nums[i]);\\n        } \\n        \\n        return sb.toString();\\n    }\\n    \\n    public int get(int val){\\n        int count = 0;\\n        \\n        while(val>0){\\n            count+=bt[val];\\n            val-= -val&val;\\n        }\\n        return count;\\n    }\\n    \\n    public void update(int val){ \\n        while(val < bt.length){\\n            bt[val]+=1;\\n            val += -val&val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721181,
                "title": "greedy-algorithm-binary-indexed-tree-ten-pointers",
                "content": "```\\nfrom queue import deque\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        nums = [int(c) for c in num]\\n        N = n+1\\n        cnts = [0]*N\\n        \\n        def update(pos, v):\\n            i = pos+1\\n            while i < N:\\n                cnts[i] += v\\n                i += i & (-i)\\n        \\n        def getSum(pos):\\n            i = pos+1\\n            ans = 0\\n            while i > 0:\\n                ans += cnts[i]\\n                i -= i & (-i)\\n            return ans\\n        \\n        left = [-1]*10\\n        for i, v in enumerate(nums):\\n            if left[v] != -1:\\n                continue\\n            left[v] = i\\n        ans = []\\n        res = k\\n        i = 0\\n        while res > 0 and i < n:\\n            cur = nums[i]\\n            flg = False\\n            for v in range(cur):\\n                if left[v] == -1:\\n                    continue\\n                pos = left[v]\\n                cost = pos-getSum(pos)\\n                if cost > res:\\n                    continue\\n                flg = True\\n                res -= cost\\n                ans.append(v)\\n                nums[pos] = -1\\n                update(pos, 1)\\n                left[v] = -1\\n                for ni in range(pos+1, n):\\n                    if nums[ni] == v:\\n                        left[v] = ni\\n                        break\\n                break\\n            if not flg:\\n                ans.append(cur)\\n                nums[i] = -1\\n                update(i, 1)\\n                while i < n and nums[i] == -1:\\n                    i += 1\\n                if left[cur] != -1:\\n                    left[cur] = -1\\n                    for ni in range(i, n):\\n                        if nums[ni] == cur:\\n                            left[cur] = ni\\n                            break\\n        while i < n:\\n            if nums[i] != -1:\\n                ans.append(nums[i])\\n            i += 1\\n        return \"\".join([str(v) for v in ans])\\n \\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import deque\\n\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        n = len(num)\\n        nums = [int(c) for c in num]\\n        N = n+1\\n        cnts = [0]*N\\n        \\n        def update(pos, v):\\n            i = pos+1\\n            while i < N:\\n                cnts[i] += v\\n                i += i & (-i)\\n        \\n        def getSum(pos):\\n            i = pos+1\\n            ans = 0\\n            while i > 0:\\n                ans += cnts[i]\\n                i -= i & (-i)\\n            return ans\\n        \\n        left = [-1]*10\\n        for i, v in enumerate(nums):\\n            if left[v] != -1:\\n                continue\\n            left[v] = i\\n        ans = []\\n        res = k\\n        i = 0\\n        while res > 0 and i < n:\\n            cur = nums[i]\\n            flg = False\\n            for v in range(cur):\\n                if left[v] == -1:\\n                    continue\\n                pos = left[v]\\n                cost = pos-getSum(pos)\\n                if cost > res:\\n                    continue\\n                flg = True\\n                res -= cost\\n                ans.append(v)\\n                nums[pos] = -1\\n                update(pos, 1)\\n                left[v] = -1\\n                for ni in range(pos+1, n):\\n                    if nums[ni] == v:\\n                        left[v] = ni\\n                        break\\n                break\\n            if not flg:\\n                ans.append(cur)\\n                nums[i] = -1\\n                update(i, 1)\\n                while i < n and nums[i] == -1:\\n                    i += 1\\n                if left[cur] != -1:\\n                    left[cur] = -1\\n                    for ni in range(i, n):\\n                        if nums[ni] == cur:\\n                            left[cur] = ni\\n                            break\\n        while i < n:\\n            if nums[i] != -1:\\n                ans.append(nums[i])\\n            i += 1\\n        return \"\".join([str(v) for v in ans])\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 721119,
                "title": "java-nlogn-recursion",
                "content": "```\\nclass Solution {\\n    class Item {\\n        int val;\\n        int dist;\\n        public Item(int val, int dist) {\\n            this.val = val;\\n            this.dist = dist;\\n        }\\n        \\n        public String toString() {\\n            return \"(\"+val+\",\"+dist+\")\";\\n        }\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if(k == 0) return num;\\n        if(num.length() == 0) return num;\\n        PriorityQueue<Item> queue = new PriorityQueue<>((a, b) -> a.val == b.val ? a.dist - b.dist : a.val - b.val);\\n        for(int i = 0; i < num.length(); i++) {\\n            queue.offer(new Item(num.charAt(i) - \\'0\\', i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<Integer> exclude = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() && queue.peek().dist <= k) {\\n            Item item = queue.poll();\\n            sb.append(item.val);\\n            int insertPos = bisearch(exclude, item.dist);\\n            exclude.add(insertPos, item.dist);\\n            k -= Math.max(0, (item.dist - insertPos));\\n        }\\n        if(!exclude.isEmpty()) {\\n            String next = throwaway(num, exclude);\\n            return sb.toString() + minInteger(next, k);\\n        }\\n        \\n        while(!queue.isEmpty() && queue.peek().dist > k) queue.poll();\\n        Item item = queue.peek();\\n        return \"\" + item.val + minInteger(num.substring(0, item.dist) + num.substring(item.dist+1), k-item.dist);\\n    }\\n    \\n    private int bisearch(List<Integer> list, int i) {\\n        int index = Collections.binarySearch(list, i);\\n        if(index < 0) index = -index-1;\\n        return index;\\n    }\\n    \\n    private String throwaway(String s, List<Integer> exclude) {\\n        Set<Integer> set = new HashSet<>(exclude);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(set.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Item {\\n        int val;\\n        int dist;\\n        public Item(int val, int dist) {\\n            this.val = val;\\n            this.dist = dist;\\n        }\\n        \\n        public String toString() {\\n            return \"(\"+val+\",\"+dist+\")\";\\n        }\\n    }\\n    \\n    public String minInteger(String num, int k) {\\n        if(k == 0) return num;\\n        if(num.length() == 0) return num;\\n        PriorityQueue<Item> queue = new PriorityQueue<>((a, b) -> a.val == b.val ? a.dist - b.dist : a.val - b.val);\\n        for(int i = 0; i < num.length(); i++) {\\n            queue.offer(new Item(num.charAt(i) - \\'0\\', i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        List<Integer> exclude = new ArrayList<>();\\n        \\n        while(!queue.isEmpty() && queue.peek().dist <= k) {\\n            Item item = queue.poll();\\n            sb.append(item.val);\\n            int insertPos = bisearch(exclude, item.dist);\\n            exclude.add(insertPos, item.dist);\\n            k -= Math.max(0, (item.dist - insertPos));\\n        }\\n        if(!exclude.isEmpty()) {\\n            String next = throwaway(num, exclude);\\n            return sb.toString() + minInteger(next, k);\\n        }\\n        \\n        while(!queue.isEmpty() && queue.peek().dist > k) queue.poll();\\n        Item item = queue.peek();\\n        return \"\" + item.val + minInteger(num.substring(0, item.dist) + num.substring(item.dist+1), k-item.dist);\\n    }\\n    \\n    private int bisearch(List<Integer> list, int i) {\\n        int index = Collections.binarySearch(list, i);\\n        if(index < 0) index = -index-1;\\n        return index;\\n    }\\n    \\n    private String throwaway(String s, List<Integer> exclude) {\\n        Set<Integer> set = new HashSet<>(exclude);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++) {\\n            if(set.contains(i)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721117,
                "title": "c-intuitive-solution",
                "content": "In the given problem max string length is 30000 and max number of swaps is 10^9.\\nTherefore it is understood that any k more than n*(n+1)/2 will give the sorted array.\\nThe next step is to find the minimum element and place it in the front under the limit of permissible swaps. Next we count the number of swaps remaining and find the next smallest element and bring it to the second place and so on. If at any point we have a sorted array, we break.\\n```\\nstring minInteger(string num, int k) {\\n        int n = num.length();\\n        string num2 = num;\\n        sort(num2.begin(),num2.end());\\n        if(k>(n*(n+1))/2)\\n        {\\n            return num2;\\n        }\\n        int posi = -1;\\n        int mini = 10;\\n        int done = 0;\\n        while(k>0)\\n        {\\n            mini = 10;\\n            for(int i=done;i<n && i<=done+k;i++)\\n            {\\n                if(mini>(num[i]-\\'0\\'))\\n                {\\n                    posi = i;\\n                    mini = num[i]-\\'0\\';\\n                }\\n            }\\n            for(int i=posi;i>done;i--)\\n            {\\n                swap(num[i],num[i-1]);\\n                k--;\\n            }\\n            done++;\\n            if(num==num2)\\n                return num2;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring minInteger(string num, int k) {\\n        int n = num.length();\\n        string num2 = num;\\n        sort(num2.begin(),num2.end());\\n        if(k>(n*(n+1))/2)\\n        {\\n            return num2;\\n        }\\n        int posi = -1;\\n        int mini = 10;\\n        int done = 0;\\n        while(k>0)\\n        {\\n            mini = 10;\\n            for(int i=done;i<n && i<=done+k;i++)\\n            {\\n                if(mini>(num[i]-\\'0\\'))\\n                {\\n                    posi = i;\\n                    mini = num[i]-\\'0\\';\\n                }\\n            }\\n            for(int i=posi;i>done;i--)\\n            {\\n                swap(num[i],num[i-1]);\\n                k--;\\n            }\\n            done++;\\n            if(num==num2)\\n                return num2;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720751,
                "title": "c-o-nlogn-solution-faster-than-100-soln",
                "content": "Well Idea is to reduce the simple n^2 solution using Binary Indexed Tree. In O(n^2) solution we check for all non selected indices but only ten digits are possible from \\'0\\' to \\'9\\' well we can maintain a queue for each digit from \\'0\\' to \\'9\\' that consists first occurance of the the digit at the front. We can use BIT to find how many indices before the current indices have been moved in front of our answer by that amount we have to shift to find the cost of swapping current index to the ith position. Rest can be done same as the n^2 soln.\\n\\n\\n\\n\\n\\n```\\ntypedef int ll;\\nclass Solution {\\n    vector<ll>bit;\\npublic:\\n    \\n    void update(ll x,ll n)\\n    {\\n        while(x<=n)\\n        {\\n            bit[x]+=1;\\n            x+=(x&(-x));\\n        }\\n    }\\n    ll query(ll x)\\n    {\\n        ll ans=0;\\n        while(x>0)\\n        {\\n            ans+=bit[x];\\n            x-=(x&(-x));\\n        }\\n        return ans;\\n    }\\n    string minInteger(string num, int k) {\\n        ll n=num.size();\\n        for(ll i=0;i<=n+1;i++)\\n        {\\n            bit.push_back(0);\\n        }\\n        \\n        \\n        string ans=\"\";\\n        vector< queue<ll> > v(10);\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll x=num[i]-\\'0\\';\\n            v[x].push(i);\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll pos=-1;\\n            ll dig=\\'a\\';\\n            ll cnt=i;\\n            ll hh=0;\\n            for(ll j=9;j>=0;j--)\\n            {\\n              \\n                ll ch=j+\\'0\\';\\n                if((!v[j].empty())&&ch<dig)\\n                {\\n                    ll pp=v[j].front();\\n                    ll ind=query(pp+1);\\n                    ll val=pp-i+cnt-ind;\\n                  \\n                    if(val<=k)\\n                    {\\n                        pos=pp;\\n                        dig=ch;\\n                        hh=val;\\n                    }\\n                }\\n            }\\n            if(pos!=-1)\\n            {\\n                update(pos+1,n);\\n                v[dig-\\'0\\'].pop();\\n                ans+=dig;\\n                k=k-hh;\\n                //cout<<(char)dig<<\" \"<<k<< \" \"<<pos<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef int ll;\\nclass Solution {\\n    vector<ll>bit;\\npublic:\\n    \\n    void update(ll x,ll n)\\n    {\\n        while(x<=n)\\n        {\\n            bit[x]+=1;\\n            x+=(x&(-x));\\n        }\\n    }\\n    ll query(ll x)\\n    {\\n        ll ans=0;\\n        while(x>0)\\n        {\\n            ans+=bit[x];\\n            x-=(x&(-x));\\n        }\\n        return ans;\\n    }\\n    string minInteger(string num, int k) {\\n        ll n=num.size();\\n        for(ll i=0;i<=n+1;i++)\\n        {\\n            bit.push_back(0);\\n        }\\n        \\n        \\n        string ans=\"\";\\n        vector< queue<ll> > v(10);\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll x=num[i]-\\'0\\';\\n            v[x].push(i);\\n        }\\n        for(ll i=0;i<n;i++)\\n        {\\n            ll pos=-1;\\n            ll dig=\\'a\\';\\n            ll cnt=i;\\n            ll hh=0;\\n            for(ll j=9;j>=0;j--)\\n            {\\n              \\n                ll ch=j+\\'0\\';\\n                if((!v[j].empty())&&ch<dig)\\n                {\\n                    ll pp=v[j].front();\\n                    ll ind=query(pp+1);\\n                    ll val=pp-i+cnt-ind;\\n                  \\n                    if(val<=k)\\n                    {\\n                        pos=pp;\\n                        dig=ch;\\n                        hh=val;\\n                    }\\n                }\\n            }\\n            if(pos!=-1)\\n            {\\n                update(pos+1,n);\\n                v[dig-\\'0\\'].pop();\\n                ans+=dig;\\n                k=k-hh;\\n                //cout<<(char)dig<<\" \"<<k<< \" \"<<pos<<endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 720721,
                "title": "simple-c-position-memorization",
                "content": "I feel that the contest is unfair. C++ without a postion remember helper will fail due to time limit error while java can pass.\\n\\nThose code are not optimized. (contest code..) Sorry about this..\\n\\n\\nlike this:\\n```\\n    string minInteger_(string& num, int k, int idx) {\\n        if (idx >= num.length()) return num;\\n        if (k <= 0) return num;\\n        \\n        char maxVal = num[idx];\\n        int nextIdx = -1;\\n        \\n        for (int i = idx + 1; i < num.size() && i - idx <= k; ++i) {\\n            if (num[i] < maxVal) {\\n                maxVal = num[i];\\n                nextIdx = i;\\n            }\\n        }\\n        \\n        if (nextIdx < 0) return minInteger_(num, k, idx + 1);\\n        \\n        char t = num[nextIdx];\\n        num.erase(nextIdx, 1);\\n        num.insert(idx, string(1, t));\\n        \\n        return minInteger_(num, k - (nextIdx - idx), idx + 1);\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        return minInteger_(num, k, 0);\\n    }\\n```\\n\\nTherefore, I have to introduce a position remember helper:\\n\\n```\\nstring minInteger_(string& num, int k, int idx, vector<int>& pos) {\\n\\tif (idx >= num.length()) return num;\\n\\tif (k <= 0) return num;\\n\\n\\tint nextIdx = -1;\\n\\n\\tfor (int j = 0; j < num[idx] - \\'0\\'; ++j) {\\n\\t\\tint i = max(idx + 1, pos[j]);\\n\\t\\tfor (; i < num.size() && i - idx <= k; ++i) {\\n\\t\\t\\tif (num[i] - \\'0\\' == j) {\\n\\t\\t\\t\\tnextIdx = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos[j] = i;\\n\\t\\tif (nextIdx != -1) break;\\n\\t}\\n\\n\\tif (nextIdx < 0) return minInteger_(num, k, idx + 1, pos);\\n\\n\\tchar t = num[nextIdx];\\n\\tnum.erase(nextIdx, 1);\\n\\tnum.insert(idx, string(1, t));\\n\\n\\treturn minInteger_(num, k - (nextIdx - idx), idx + 1, pos);\\n}\\n\\nstring minInteger(string num, int k) {\\n\\tvector<int> pos(10, 0);\\n\\treturn minInteger_(num, k, 0, pos);\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    string minInteger_(string& num, int k, int idx) {\\n        if (idx >= num.length()) return num;\\n        if (k <= 0) return num;\\n        \\n        char maxVal = num[idx];\\n        int nextIdx = -1;\\n        \\n        for (int i = idx + 1; i < num.size() && i - idx <= k; ++i) {\\n            if (num[i] < maxVal) {\\n                maxVal = num[i];\\n                nextIdx = i;\\n            }\\n        }\\n        \\n        if (nextIdx < 0) return minInteger_(num, k, idx + 1);\\n        \\n        char t = num[nextIdx];\\n        num.erase(nextIdx, 1);\\n        num.insert(idx, string(1, t));\\n        \\n        return minInteger_(num, k - (nextIdx - idx), idx + 1);\\n    }\\n    \\n    string minInteger(string num, int k) {\\n        return minInteger_(num, k, 0);\\n    }\\n```\n```\\nstring minInteger_(string& num, int k, int idx, vector<int>& pos) {\\n\\tif (idx >= num.length()) return num;\\n\\tif (k <= 0) return num;\\n\\n\\tint nextIdx = -1;\\n\\n\\tfor (int j = 0; j < num[idx] - \\'0\\'; ++j) {\\n\\t\\tint i = max(idx + 1, pos[j]);\\n\\t\\tfor (; i < num.size() && i - idx <= k; ++i) {\\n\\t\\t\\tif (num[i] - \\'0\\' == j) {\\n\\t\\t\\t\\tnextIdx = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos[j] = i;\\n\\t\\tif (nextIdx != -1) break;\\n\\t}\\n\\n\\tif (nextIdx < 0) return minInteger_(num, k, idx + 1, pos);\\n\\n\\tchar t = num[nextIdx];\\n\\tnum.erase(nextIdx, 1);\\n\\tnum.insert(idx, string(1, t));\\n\\n\\treturn minInteger_(num, k - (nextIdx - idx), idx + 1, pos);\\n}\\n\\nstring minInteger(string num, int k) {\\n\\tvector<int> pos(10, 0);\\n\\treturn minInteger_(num, k, 0, pos);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720677,
                "title": "java-n-2-solution-nlogn-segment-tree-solution-nlogn-bit-solution",
                "content": "BIT\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int arr[]=new int[s.length()];\\n        Arrays.fill(arr,1);\\n        Fenwick fe=new Fenwick(arr);\\n        StringBuilder res=new StringBuilder();\\n        Queue<Integer>q[]=new LinkedList[10];\\n        for(int i=0;i<q.length;i++){\\n            q[i]=new LinkedList<>();\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            q[c-\\'0\\'].add(i);\\n        }\\n        \\n        \\n        \\n        while(k>0){\\n            boolean good=false;\\n            for(int i=0;i<10;i++){\\n                if(q[i].size()==0)continue;\\n                \\n                int index=q[i].peek();\\n                int less=fe.sumRange(0,index-1);//how many elements remain less than it \\n                if(k>=less){\\n                    good=true;\\n                    q[i].poll();\\n                    k-=less;\\n                    res.append(i+\"\");\\n                    fe.update(index,-1);\\n                    break;\\n                }\\n            }\\n            \\n            if(!good)break;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        List<int[]>A=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n           while(q[i].size()>0){\\n               A.add(new int[]{i,q[i].poll()});\\n           }\\n        }\\n        \\n        Collections.sort(A,(a,b)->{\\n            return a[1]-b[1];\\n        });\\n        \\n        for(int i=0;i<A.size();i++){\\n            res.append(A.get(i)[0]+\"\");\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    class Fenwick {\\n        int tree[];//1-index based\\n        int A[];\\n        int arr[];\\n        public Fenwick(int[] A) {\\n            this.A=A;\\n            arr=new int[A.length];\\n            tree=new int[A.length+1];\\n            int sum=0;\\n            for(int i=0;i<A.length;i++){\\n                update(i,A[i]);\\n            }\\n        }\\n\\n        public void update(int i, int val) {\\n            arr[i]+=val;\\n            i++;\\n            while(i<tree.length){\\n                tree[i]+=val;\\n                i+=(i&-i);\\n            }\\n            \\n        }\\n\\n        public int sumRange(int i, int j) {\\n            \\n            return pre(j+1)-pre(i);\\n        }\\n\\n        public int pre(int i){\\n            int sum=0;\\n            while(i>0){\\n                sum+=tree[i];\\n                i-=(i&-i);\\n            }\\n            return sum;\\n        }\\n    }\\n}\\n```\\n\\nn^2 solution\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        char A[]=s.toCharArray();\\n        for(int i=0;i<A.length;i++){\\n            char min=A[i];\\n            int j=i+1;\\n            int copyk=k;\\n            int index=-1;\\n            while(copyk>0&&j<A.length){\\n                if(A[j]<min){\\n                    min=A[j];\\n                    index=j;\\n                }\\n                copyk--;j++;\\n            }\\n            if(index==-1||min==A[i])continue;\\n            for(j=index;j>i;j--){\\n                swap(A,j,j-1);\\n            }\\n            k-=(index-i);\\n            if(k==0)break;\\n        }\\n        StringBuilder str=new StringBuilder();\\n        for(char c:A)str.append(c+\"\");\\n        return str.toString();\\n    }\\n    \\n    public void swap(char A[],int i,int j){\\n        char temp=A[i];\\n        A[i]=A[j];\\n        A[j]=temp;\\n    }\\n}\\n```\\n\\n\\nsegment tree nlogn\\n\\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        Seg seg=new Seg(0,s.length()-1);\\n        StringBuilder str=new StringBuilder();\\n        Queue<Integer>A[]=new LinkedList[10];\\n        for(int i=0;i<10;i++)A[i]=new LinkedList<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            A[c-\\'0\\'].add(i);\\n        }\\n        \\n        while(k>0){\\n            int i=Integer.MAX_VALUE;\\n            for(int j=0;j<10;j++){\\n                if(A[j].size()==0)continue;\\n                i=Math.min(i,A[j].peek());\\n            }\\n            if(i==Integer.MAX_VALUE)break;\\n            char cur=s.charAt(i);\\n            boolean found=false;\\n            for(int j=0;j<10;j++){\\n                char next=(char)(j+\\'0\\');\\n                if(next>=cur)break;\\n                if(A[j].size()==0)continue;//nothing can take out\\n                int index=A[j].peek();\\n                int cnt=seg.query(i+1,index);\\n                if(cnt<=k){//smallest\\n                    found=true;\\n                    A[j].poll();\\n                    k-=cnt;\\n                    str.append(next);\\n                    seg.update(index);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                A[cur-\\'0\\'].poll();\\n                str.append(\"\"+cur);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(A[c-\\'0\\'].size()==0)continue;\\n            if(A[c-\\'0\\'].peek()!=i)continue;\\n            str.append(\"\"+c);A[c-\\'0\\'].poll();\\n        }\\n        return str.toString();\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        Seg left,right;\\n        int cnt;\\n        public Seg(int l,int r){\\n            this.l=l;this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                left=new Seg(l,mid);\\n                right=new Seg(mid+1,r);\\n                cnt=(r-l)+1;\\n            }else{\\n                cnt=1;\\n            }\\n            \\n        }\\n        \\n        public int query(int s,int e){\\n            if(l==s&&e==r){\\n                return cnt;\\n            }\\n            int mid=l+(r-l)/2;\\n            int res=0;\\n            if(e<=mid){\\n                res+=left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                res+=right.query(s,e);\\n            }else{\\n                res+=left.query(s,mid)+right.query(mid+1,e);\\n            }\\n            return res;\\n            \\n        }\\n        \\n        public void update(int index){\\n            this.cnt--;\\n            if(l==r&&l==index){\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index);\\n            }else{\\n                right.update(index);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        int arr[]=new int[s.length()];\\n        Arrays.fill(arr,1);\\n        Fenwick fe=new Fenwick(arr);\\n        StringBuilder res=new StringBuilder();\\n        Queue<Integer>q[]=new LinkedList[10];\\n        for(int i=0;i<q.length;i++){\\n            q[i]=new LinkedList<>();\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            q[c-\\'0\\'].add(i);\\n        }\\n        \\n        \\n        \\n        while(k>0){\\n            boolean good=false;\\n            for(int i=0;i<10;i++){\\n                if(q[i].size()==0)continue;\\n                \\n                int index=q[i].peek();\\n                int less=fe.sumRange(0,index-1);//how many elements remain less than it \\n                if(k>=less){\\n                    good=true;\\n                    q[i].poll();\\n                    k-=less;\\n                    res.append(i+\"\");\\n                    fe.update(index,-1);\\n                    break;\\n                }\\n            }\\n            \\n            if(!good)break;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        List<int[]>A=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n           while(q[i].size()>0){\\n               A.add(new int[]{i,q[i].poll()});\\n           }\\n        }\\n        \\n        Collections.sort(A,(a,b)->{\\n            return a[1]-b[1];\\n        });\\n        \\n        for(int i=0;i<A.size();i++){\\n            res.append(A.get(i)[0]+\"\");\\n        }\\n        \\n        return res.toString();\\n    }\\n    \\n    \\n    class Fenwick {\\n        int tree[];//1-index based\\n        int A[];\\n        int arr[];\\n        public Fenwick(int[] A) {\\n            this.A=A;\\n            arr=new int[A.length];\\n            tree=new int[A.length+1];\\n            int sum=0;\\n            for(int i=0;i<A.length;i++){\\n                update(i,A[i]);\\n            }\\n        }\\n\\n        public void update(int i, int val) {\\n            arr[i]+=val;\\n            i++;\\n            while(i<tree.length){\\n                tree[i]+=val;\\n                i+=(i&-i);\\n            }\\n            \\n        }\\n\\n        public int sumRange(int i, int j) {\\n            \\n            return pre(j+1)-pre(i);\\n        }\\n\\n        public int pre(int i){\\n            int sum=0;\\n            while(i>0){\\n                sum+=tree[i];\\n                i-=(i&-i);\\n            }\\n            return sum;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        char A[]=s.toCharArray();\\n        for(int i=0;i<A.length;i++){\\n            char min=A[i];\\n            int j=i+1;\\n            int copyk=k;\\n            int index=-1;\\n            while(copyk>0&&j<A.length){\\n                if(A[j]<min){\\n                    min=A[j];\\n                    index=j;\\n                }\\n                copyk--;j++;\\n            }\\n            if(index==-1||min==A[i])continue;\\n            for(j=index;j>i;j--){\\n                swap(A,j,j-1);\\n            }\\n            k-=(index-i);\\n            if(k==0)break;\\n        }\\n        StringBuilder str=new StringBuilder();\\n        for(char c:A)str.append(c+\"\");\\n        return str.toString();\\n    }\\n    \\n    public void swap(char A[],int i,int j){\\n        char temp=A[i];\\n        A[i]=A[j];\\n        A[j]=temp;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String minInteger(String s, int k) {\\n        Seg seg=new Seg(0,s.length()-1);\\n        StringBuilder str=new StringBuilder();\\n        Queue<Integer>A[]=new LinkedList[10];\\n        for(int i=0;i<10;i++)A[i]=new LinkedList<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            A[c-\\'0\\'].add(i);\\n        }\\n        \\n        while(k>0){\\n            int i=Integer.MAX_VALUE;\\n            for(int j=0;j<10;j++){\\n                if(A[j].size()==0)continue;\\n                i=Math.min(i,A[j].peek());\\n            }\\n            if(i==Integer.MAX_VALUE)break;\\n            char cur=s.charAt(i);\\n            boolean found=false;\\n            for(int j=0;j<10;j++){\\n                char next=(char)(j+\\'0\\');\\n                if(next>=cur)break;\\n                if(A[j].size()==0)continue;//nothing can take out\\n                int index=A[j].peek();\\n                int cnt=seg.query(i+1,index);\\n                if(cnt<=k){//smallest\\n                    found=true;\\n                    A[j].poll();\\n                    k-=cnt;\\n                    str.append(next);\\n                    seg.update(index);\\n                    break;\\n                }\\n            }\\n            if(!found){\\n                A[cur-\\'0\\'].poll();\\n                str.append(\"\"+cur);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(A[c-\\'0\\'].size()==0)continue;\\n            if(A[c-\\'0\\'].peek()!=i)continue;\\n            str.append(\"\"+c);A[c-\\'0\\'].poll();\\n        }\\n        return str.toString();\\n    }\\n    \\n    class Seg{\\n        int l,r;\\n        Seg left,right;\\n        int cnt;\\n        public Seg(int l,int r){\\n            this.l=l;this.r=r;\\n            if(l!=r){\\n                int mid=l+(r-l)/2;\\n                left=new Seg(l,mid);\\n                right=new Seg(mid+1,r);\\n                cnt=(r-l)+1;\\n            }else{\\n                cnt=1;\\n            }\\n            \\n        }\\n        \\n        public int query(int s,int e){\\n            if(l==s&&e==r){\\n                return cnt;\\n            }\\n            int mid=l+(r-l)/2;\\n            int res=0;\\n            if(e<=mid){\\n                res+=left.query(s,e);\\n            }\\n            else if(s>=mid+1){\\n                res+=right.query(s,e);\\n            }else{\\n                res+=left.query(s,mid)+right.query(mid+1,e);\\n            }\\n            return res;\\n            \\n        }\\n        \\n        public void update(int index){\\n            this.cnt--;\\n            if(l==r&&l==index){\\n                return;\\n            }\\n            int mid=l+(r-l)/2;\\n            if(index<=mid){\\n                left.update(index);\\n            }else{\\n                right.update(index);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720656,
                "title": "python-segmenttree-o-nlogn",
                "content": "```python\\n\\n\\nclass Node:\\n    def __init__(self, left, right, l, r, val, cnt, idx):\\n        self.left = left\\n        self.right = right\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.cnt = cnt\\n        self.idx = idx\\nNONE_NODE = Node(None, None, -1, -1, float(\\'inf\\'), 0, -1)\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.head = self.build(nums, 0, len(nums)-1) \\n    \\n    def build(self, nums, l, r):\\n        if l == r:\\n            return Node(None, None, l, r, nums[l], 1, l)\\n        mid = (l+r)//2\\n        left = self.build(nums, l, mid)\\n        right = self.build(nums, mid+1, r)\\n        return Node(left, right, l, r, min(left.val, right.val), left.cnt+right.cnt, left.idx if left.val <= right.val else right.idx)\\n    def remove(self, u, node):\\n        if node == None or u == node.l == node.r:\\n            return None\\n        if node.r < u or u < node.l:\\n            return node\\n        \\n        node.left = left = self.remove(u, node.left)\\n        node.right = right = self.remove(u, node.right)\\n        if left == None:\\n            left = NONE_NODE\\n        if right == None:\\n            right = NONE_NODE\\n        node.val = min(left.val, right.val)\\n        node.cnt = left.cnt + right.cnt\\n        node.idx = left.idx if left.val <= right.val else right.idx\\n        return node\\n    def query(self, k, node):\\n        \\n        if k <= 0 or node == None:\\n            return (float(\\'inf\\'), -1)\\n        if node.cnt <= k:\\n            return (node.val, node.idx)\\n        if node.left != None:\\n            return min(self.query(k, node.left), self.query(k-node.left.cnt, node.right))\\n        return self.query(k, node.right)\\n    def get_nth(self, u, node):\\n        if node == None or node.l == node.r == u:\\n            return 0\\n        if node.left == None:\\n            return self.get_nth(u, node.right)\\n        if node.left.l <= u <= node.left.r:\\n            return self.get_nth(u, node.left)\\n        return node.left.cnt + self.get_nth(u, node.right)\\n        \\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        nums = [int(c) for c in num]\\n        used = set()\\n        ans = []\\n        segmentTree = SegmentTree(nums)\\n        while len(ans) < len(num) and k > 0:\\n            val, idx = segmentTree.query(k+1, segmentTree.head)\\n            \\n            used.add(idx)\\n            ans.append(str(val))\\n            k -= segmentTree.get_nth(idx, segmentTree.head)\\n            \\n            segmentTree.remove(idx, segmentTree.head)\\n        for idx, val in enumerate(nums):\\n            if idx not in used:\\n                ans.append(str(val))\\n        return \"\".join(ans)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n\\n\\nclass Node:\\n    def __init__(self, left, right, l, r, val, cnt, idx):\\n        self.left = left\\n        self.right = right\\n        self.l = l\\n        self.r = r\\n        self.val = val\\n        self.cnt = cnt\\n        self.idx = idx\\nNONE_NODE = Node(None, None, -1, -1, float(\\'inf\\'), 0, -1)\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.head = self.build(nums, 0, len(nums)-1) \\n    \\n    def build(self, nums, l, r):\\n        if l == r:\\n            return Node(None, None, l, r, nums[l], 1, l)\\n        mid = (l+r)//2\\n        left = self.build(nums, l, mid)\\n        right = self.build(nums, mid+1, r)\\n        return Node(left, right, l, r, min(left.val, right.val), left.cnt+right.cnt, left.idx if left.val <= right.val else right.idx)\\n    def remove(self, u, node):\\n        if node == None or u == node.l == node.r:\\n            return None\\n        if node.r < u or u < node.l:\\n            return node\\n        \\n        node.left = left = self.remove(u, node.left)\\n        node.right = right = self.remove(u, node.right)\\n        if left == None:\\n            left = NONE_NODE\\n        if right == None:\\n            right = NONE_NODE\\n        node.val = min(left.val, right.val)\\n        node.cnt = left.cnt + right.cnt\\n        node.idx = left.idx if left.val <= right.val else right.idx\\n        return node\\n    def query(self, k, node):\\n        \\n        if k <= 0 or node == None:\\n            return (float(\\'inf\\'), -1)\\n        if node.cnt <= k:\\n            return (node.val, node.idx)\\n        if node.left != None:\\n            return min(self.query(k, node.left), self.query(k-node.left.cnt, node.right))\\n        return self.query(k, node.right)\\n    def get_nth(self, u, node):\\n        if node == None or node.l == node.r == u:\\n            return 0\\n        if node.left == None:\\n            return self.get_nth(u, node.right)\\n        if node.left.l <= u <= node.left.r:\\n            return self.get_nth(u, node.left)\\n        return node.left.cnt + self.get_nth(u, node.right)\\n        \\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        nums = [int(c) for c in num]\\n        used = set()\\n        ans = []\\n        segmentTree = SegmentTree(nums)\\n        while len(ans) < len(num) and k > 0:\\n            val, idx = segmentTree.query(k+1, segmentTree.head)\\n            \\n            used.add(idx)\\n            ans.append(str(val))\\n            k -= segmentTree.get_nth(idx, segmentTree.head)\\n            \\n            segmentTree.remove(idx, segmentTree.head)\\n        for idx, val in enumerate(nums):\\n            if idx not in used:\\n                ans.append(str(val))\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720646,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    vector<int> v;\\n    \\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(int x, int y) {\\n        for (int i = x; i < v.size(); i += lowbit(i)) {\\n            v[i] += y;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        int r = 0;\\n        for (int i = x; i; i ^= lowbit(i)) {\\n            r += v[i];\\n        }\\n        return r;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.length();\\n        v.resize(n + 1);\\n        vector<list<int>> d(10);\\n        for (int i = 0; i < n; ++i) {\\n            update(i + 1, 1);\\n            d[num[i] - \\'0\\'].push_back(i);\\n        }\\n        string r(n, \\' \\');\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!d[j].empty()) {\\n                    const int x = get(*d[j].begin());\\n                    if (x <= k) {\\n                        k -= x;\\n                        r[i] = j + \\'0\\';\\n                        update(1 + *d[j].begin(), -1); \\n                        d[j].pop_front();\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> v;\\n    \\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    \\n    void update(int x, int y) {\\n        for (int i = x; i < v.size(); i += lowbit(i)) {\\n            v[i] += y;\\n        }\\n    }\\n    \\n    int get(int x) {\\n        int r = 0;\\n        for (int i = x; i; i ^= lowbit(i)) {\\n            r += v[i];\\n        }\\n        return r;\\n    }\\n    \\npublic:\\n    string minInteger(string num, int k) {\\n        const int n = num.length();\\n        v.resize(n + 1);\\n        vector<list<int>> d(10);\\n        for (int i = 0; i < n; ++i) {\\n            update(i + 1, 1);\\n            d[num[i] - \\'0\\'].push_back(i);\\n        }\\n        string r(n, \\' \\');\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                if (!d[j].empty()) {\\n                    const int x = get(*d[j].begin());\\n                    if (x <= k) {\\n                        k -= x;\\n                        r[i] = j + \\'0\\';\\n                        update(1 + *d[j].begin(), -1); \\n                        d[j].pop_front();\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720501,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k == 0)\\n            return num;\\n        int t;\\n        string ans = \"\";\\n        int cur[30010] = {0};\\n        for(t = 0; t < 10; t++){\\n            cur[0] = 0;\\n            int ind = 0;\\n            for(int i = 0; i < num.size(); i++){\\n                if(i > 0)\\n                    cur[i] = cur[i-1];\\n                if(num[i] == t+\\'0\\'){\\n                    if(i - cur[i] <= k){\\n                        ans += t+\\'0\\';\\n                        k -= i - cur[i];\\n                        cur[i]++;\\n                        ind = i+1;\\n                    }\\n                    else{\\n                        ind = i;\\n                        break;\\n                    }\\n                }\\n                if(k == 0)\\n                    break;\\n            }\\n            string tmp = \"\";\\n            for(int i = 0; i < ind; i++)\\n                if(num[i] != t + \\'0\\')\\n                    tmp += num[i];\\n            int l = tmp.size();\\n            for(int i = ind; i < num.size(); i++)\\n                tmp += num[i];\\n            num = tmp;\\n            if(k == 0)\\n                return ans + num;\\n            ind = -1;\\n            for(int i = l; i < num.size(); i++)\\n                if(num[i] == t + \\'0\\'){\\n                    ind = i;\\n                    break;\\n                }\\n            if(ind > 1){\\n                bool rise = true;\\n                for(int i = 1; i < ind - k; i++)\\n                    if(num[i] < num[i-1]){\\n                        rise = false;\\n                        break;\\n                    }\\n                for(int i = 0; i < k; i++){\\n                    if(num[ind-k-1] > num[ind-k+i]){\\n                        rise = false;\\n                        break;\\n                    }\\n                }\\n                if(rise){\\n                    for(int i = 0; i < k; i++){\\n                        char cc = num[ind-i];\\n                        num[ind-i] = num[ind-i-1];\\n                        num[ind-i-1] = cc;\\n                    }\\n                    return ans + num;\\n                }\\n            }\\n            if(k == 0){\\n                ans += num;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n        if(k == 0)\\n            return num;\\n        int t;\\n        string ans = \"\";\\n        int cur[30010] = {0};\\n        for(t = 0; t < 10; t++){\\n            cur[0] = 0;\\n            int ind = 0;\\n            for(int i = 0; i < num.size(); i++){\\n                if(i > 0)\\n                    cur[i] = cur[i-1];\\n                if(num[i] == t+\\'0\\'){\\n                    if(i - cur[i] <= k){\\n                        ans += t+\\'0\\';\\n                        k -= i - cur[i];\\n                        cur[i]++;\\n                        ind = i+1;\\n                    }\\n                    else{\\n                        ind = i;\\n                        break;\\n                    }\\n                }\\n                if(k == 0)\\n                    break;\\n            }\\n            string tmp = \"\";\\n            for(int i = 0; i < ind; i++)\\n                if(num[i] != t + \\'0\\')\\n                    tmp += num[i];\\n            int l = tmp.size();\\n            for(int i = ind; i < num.size(); i++)\\n                tmp += num[i];\\n            num = tmp;\\n            if(k == 0)\\n                return ans + num;\\n            ind = -1;\\n            for(int i = l; i < num.size(); i++)\\n                if(num[i] == t + \\'0\\'){\\n                    ind = i;\\n                    break;\\n                }\\n            if(ind > 1){\\n                bool rise = true;\\n                for(int i = 1; i < ind - k; i++)\\n                    if(num[i] < num[i-1]){\\n                        rise = false;\\n                        break;\\n                    }\\n                for(int i = 0; i < k; i++){\\n                    if(num[ind-k-1] > num[ind-k+i]){\\n                        rise = false;\\n                        break;\\n                    }\\n                }\\n                if(rise){\\n                    for(int i = 0; i < k; i++){\\n                        char cc = num[ind-i];\\n                        num[ind-i] = num[ind-i-1];\\n                        num[ind-i-1] = cc;\\n                    }\\n                    return ans + num;\\n                }\\n            }\\n            if(k == 0){\\n                ans += num;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720463,
                "title": "find-min-in-next-k-items-and-swap-o-n2",
                "content": "```\\n fun minInteger(num: String, k: Int): String {\\n        val arr = num.toCharArray()\\n        helper(arr, 0, k)\\n        return arr.joinToString(\"\")\\n    }\\n    \\n    fun helper(arr: CharArray, index: Int, k: Int) {\\n        var count = k        \\n        for(index in 0 until arr.size) {\\n\\t\\t    // Get the min value out of an arr from index + 1 to min(remaining k, arr.size)\\n            var minIndex = index\\n            for(i in index + 1 until Math.min(arr.size, index + count + 1)) {\\n                if(arr[i] < arr[minIndex]) {\\n                    minIndex = i\\n                }\\n            }\\n\\t\\t\\t// After finiding minimum value adjust items\\n            val temp = arr[minIndex]\\n            for(j in minIndex downTo index + 1) {\\n                arr[j] = arr[j - 1]\\n            }\\n            arr[index] = temp\\n\\t\\t\\t// reduce count by number of used for above operation.\\n            count -= (minIndex - index)\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n fun minInteger(num: String, k: Int): String {\\n        val arr = num.toCharArray()\\n        helper(arr, 0, k)\\n        return arr.joinToString(\"\")\\n    }\\n    \\n    fun helper(arr: CharArray, index: Int, k: Int) {\\n        var count = k        \\n        for(index in 0 until arr.size) {\\n\\t\\t    // Get the min value out of an arr from index + 1 to min(remaining k, arr.size)\\n            var minIndex = index\\n            for(i in index + 1 until Math.min(arr.size, index + count + 1)) {\\n                if(arr[i] < arr[minIndex]) {\\n                    minIndex = i\\n                }\\n            }\\n\\t\\t\\t// After finiding minimum value adjust items\\n            val temp = arr[minIndex]\\n            for(j in minIndex downTo index + 1) {\\n                arr[j] = arr[j - 1]\\n            }\\n            arr[index] = temp\\n\\t\\t\\t// reduce count by number of used for above operation.\\n            count -= (minIndex - index)\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 720462,
                "title": "c-greedy-solution-fenwick-tree-for-keep-shifts-sorted-set-for-min-char-linkedlist",
                "content": "```\\n   public class Solution\\n    {\\n        private struct Data : IComparable<Data>, IEquatable<Data>\\n        {\\n            public readonly char C;\\n            public readonly int Pos;\\n\\n            public Data(char c, int pos)\\n            {\\n                C = c;\\n                Pos = pos;\\n            }\\n\\n            public int CompareTo(Data other)\\n            {\\n                var cmp = C.CompareTo(other.C);\\n                if (cmp != 0)\\n                {\\n                    return cmp;\\n                }\\n\\n                return Pos.CompareTo(other.Pos);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"C: {C}; Pos: {Pos}\";\\n            }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return Equals((Data)obj);\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                unchecked\\n                {\\n                    return C * 117 + Pos;\\n                }\\n            }\\n\\n            int IComparable<Data>.CompareTo(Data other)\\n            {\\n                return CompareTo(other);\\n            }\\n\\n            public bool Equals(Data other)\\n            {\\n                return C == other.C && Pos == other.Pos;\\n            }\\n        }\\n\\n        private class Fenwick\\n        {\\n            private const int CHUNK_SIZE = 256;\\n\\n            private class Node\\n            {\\n                public readonly int Min;\\n                public readonly int Max;\\n\\n                public Node(int min, int max)\\n                {\\n                    Min = min;\\n                    Max = max;\\n                }\\n\\n                public Node Left;\\n                public Node Right;\\n                public bool IsLeaf => Left == null && Right == null;\\n                public long Sum;\\n            }\\n\\n            private readonly Node _root;\\n\\n            public Fenwick(int min, int max, int[] input)\\n            {\\n                _root = new Node(min, max);\\n                Build(_root, input);\\n            }\\n\\n            private void Build(Node node, int[] input)\\n            {\\n                int chunk = node.Max - node.Min + 1;\\n                int chunksCount = Convert.ToInt32(Math.Ceiling((double)chunk / CHUNK_SIZE));\\n\\n                if (chunksCount <= 1)\\n                {\\n                    checked\\n                    {\\n                        long sum = 0;\\n\\n                        for (int i = node.Min; i <= node.Max; i++)\\n                        {\\n                            sum += input[i];\\n                        }\\n\\n                        node.Sum = sum;\\n                    }\\n\\n                    return;\\n                }\\n\\n                int leftChunksCount = chunksCount / 2;\\n\\n                node.Left = new Node(node.Min, node.Min + leftChunksCount * CHUNK_SIZE - 1);\\n                node.Right = new Node(node.Min + leftChunksCount * CHUNK_SIZE, node.Max);\\n\\n                Build(node.Left, input);\\n                Build(node.Right, input);\\n\\n                node.Sum = node.Left.Sum + node.Right.Sum;\\n            }\\n\\n            private void Update(Node node, int i, int val, int[] data)\\n            {\\n                if (node == null || i < node.Min || i > node.Max)\\n                {\\n                    return;\\n                }\\n\\n                var diff = val - data[i];\\n                node.Sum += diff;\\n\\n                if (!node.IsLeaf)\\n                {\\n                    Update(node.Left, i, diff, data);\\n                    Update(node.Right, i, diff, data);\\n                }\\n                else\\n                {\\n                    data[i] = val;\\n                }\\n            }\\n\\n            public void Update(int i, int val, int[] data)\\n            {\\n                Update(_root, i, val, data);\\n            }\\n\\n            private long SumRange(Node node, int from, int to, int[] data)\\n            {\\n                if (node == null || from > node.Max || to < node.Min)\\n                {\\n                    return 0;\\n                }\\n\\n                if (node.Min == from && node.Max == to)\\n                {\\n                    return node.Sum;\\n                }\\n\\n                if (node.IsLeaf)\\n                {\\n                    int start = Math.Max(node.Min, from);\\n                    int end = Math.Min(node.Max, to);\\n                    long res = 0;\\n                    for (int i = start; i <= end; i++)\\n                    {\\n                        res += data[i];\\n                    }\\n\\n                    return res;\\n                }\\n\\n                return SumRange(node.Left, Math.Max(node.Left.Min, from), Math.Min(node.Left.Max, to), data)\\n                       + SumRange(node.Right, Math.Max(node.Right.Min, from), Math.Min(node.Right.Max, to), data);\\n            }\\n\\n            public long SumRange(int from, int to, int[] data)\\n            {\\n                return SumRange(_root, from, to, data);\\n            }\\n        }\\n\\n\\n        public string MinInteger(string num, int k)\\n        {\\n            int[] shifts = new int[num.Length];\\n            Fenwick f = new Fenwick(0, num.Length - 1, shifts);\\n            StringBuilder res = new StringBuilder(num.Length);\\n            SortedSet<Data> set = new SortedSet<Data>();\\n            LinkedList<Data> ll = new LinkedList<Data>();\\n            IDictionary<Data, LinkedListNode<Data>> map = new Dictionary<Data, LinkedListNode<Data>>();\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                var d = new Data(num[i], i);\\n                ll.AddLast(d);\\n                map[d] = ll.Last;\\n            }\\n\\n            LinkedListNode<Data> last = ll.First;\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                //try attach all possible chars for next step\\n                while (true)\\n                {\\n                    if (set.Count == k + 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    set.Add(last.Value);\\n                    if (last.Next == null)\\n                    {\\n                        break;\\n                    }\\n\\n                    last = last.Next;\\n                }\\n\\n                var top = set.First();\\n\\n\\n                //here we should need to know the index of selected item\\n\\t\\t\\t\\t//shifted = count of removed precedessors of selected items in LinkedList\\n                var shifted = (int) f.SumRange(0, top.Pos, shifts);\\n                k -= top.Pos + shifted;\\n                f.Update(top.Pos, -1, shifts);\\n\\n                res.Append(top.C);\\n\\n                if (last == map[top])\\n                {\\n                    last = map[top].Previous;\\n                    if (last == null)\\n                    {\\n                        last = map[top].Next;\\n                    }\\n                }\\n\\n                ll.Remove(map[top]);\\n                set.Remove(top);\\n                map.Remove(top);\\n\\n\\n                //remove items that can not to be used as next char\\n                while (set.Count > k + 1 && last != null)\\n                {\\n                    set.Remove(last.Value);\\n                    last = last.Previous;\\n                }\\n            }\\n\\n            return res.ToString();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public class Solution\\n    {\\n        private struct Data : IComparable<Data>, IEquatable<Data>\\n        {\\n            public readonly char C;\\n            public readonly int Pos;\\n\\n            public Data(char c, int pos)\\n            {\\n                C = c;\\n                Pos = pos;\\n            }\\n\\n            public int CompareTo(Data other)\\n            {\\n                var cmp = C.CompareTo(other.C);\\n                if (cmp != 0)\\n                {\\n                    return cmp;\\n                }\\n\\n                return Pos.CompareTo(other.Pos);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"C: {C}; Pos: {Pos}\";\\n            }\\n\\n            public override bool Equals(object obj)\\n            {\\n                return Equals((Data)obj);\\n            }\\n\\n            public override int GetHashCode()\\n            {\\n                unchecked\\n                {\\n                    return C * 117 + Pos;\\n                }\\n            }\\n\\n            int IComparable<Data>.CompareTo(Data other)\\n            {\\n                return CompareTo(other);\\n            }\\n\\n            public bool Equals(Data other)\\n            {\\n                return C == other.C && Pos == other.Pos;\\n            }\\n        }\\n\\n        private class Fenwick\\n        {\\n            private const int CHUNK_SIZE = 256;\\n\\n            private class Node\\n            {\\n                public readonly int Min;\\n                public readonly int Max;\\n\\n                public Node(int min, int max)\\n                {\\n                    Min = min;\\n                    Max = max;\\n                }\\n\\n                public Node Left;\\n                public Node Right;\\n                public bool IsLeaf => Left == null && Right == null;\\n                public long Sum;\\n            }\\n\\n            private readonly Node _root;\\n\\n            public Fenwick(int min, int max, int[] input)\\n            {\\n                _root = new Node(min, max);\\n                Build(_root, input);\\n            }\\n\\n            private void Build(Node node, int[] input)\\n            {\\n                int chunk = node.Max - node.Min + 1;\\n                int chunksCount = Convert.ToInt32(Math.Ceiling((double)chunk / CHUNK_SIZE));\\n\\n                if (chunksCount <= 1)\\n                {\\n                    checked\\n                    {\\n                        long sum = 0;\\n\\n                        for (int i = node.Min; i <= node.Max; i++)\\n                        {\\n                            sum += input[i];\\n                        }\\n\\n                        node.Sum = sum;\\n                    }\\n\\n                    return;\\n                }\\n\\n                int leftChunksCount = chunksCount / 2;\\n\\n                node.Left = new Node(node.Min, node.Min + leftChunksCount * CHUNK_SIZE - 1);\\n                node.Right = new Node(node.Min + leftChunksCount * CHUNK_SIZE, node.Max);\\n\\n                Build(node.Left, input);\\n                Build(node.Right, input);\\n\\n                node.Sum = node.Left.Sum + node.Right.Sum;\\n            }\\n\\n            private void Update(Node node, int i, int val, int[] data)\\n            {\\n                if (node == null || i < node.Min || i > node.Max)\\n                {\\n                    return;\\n                }\\n\\n                var diff = val - data[i];\\n                node.Sum += diff;\\n\\n                if (!node.IsLeaf)\\n                {\\n                    Update(node.Left, i, diff, data);\\n                    Update(node.Right, i, diff, data);\\n                }\\n                else\\n                {\\n                    data[i] = val;\\n                }\\n            }\\n\\n            public void Update(int i, int val, int[] data)\\n            {\\n                Update(_root, i, val, data);\\n            }\\n\\n            private long SumRange(Node node, int from, int to, int[] data)\\n            {\\n                if (node == null || from > node.Max || to < node.Min)\\n                {\\n                    return 0;\\n                }\\n\\n                if (node.Min == from && node.Max == to)\\n                {\\n                    return node.Sum;\\n                }\\n\\n                if (node.IsLeaf)\\n                {\\n                    int start = Math.Max(node.Min, from);\\n                    int end = Math.Min(node.Max, to);\\n                    long res = 0;\\n                    for (int i = start; i <= end; i++)\\n                    {\\n                        res += data[i];\\n                    }\\n\\n                    return res;\\n                }\\n\\n                return SumRange(node.Left, Math.Max(node.Left.Min, from), Math.Min(node.Left.Max, to), data)\\n                       + SumRange(node.Right, Math.Max(node.Right.Min, from), Math.Min(node.Right.Max, to), data);\\n            }\\n\\n            public long SumRange(int from, int to, int[] data)\\n            {\\n                return SumRange(_root, from, to, data);\\n            }\\n        }\\n\\n\\n        public string MinInteger(string num, int k)\\n        {\\n            int[] shifts = new int[num.Length];\\n            Fenwick f = new Fenwick(0, num.Length - 1, shifts);\\n            StringBuilder res = new StringBuilder(num.Length);\\n            SortedSet<Data> set = new SortedSet<Data>();\\n            LinkedList<Data> ll = new LinkedList<Data>();\\n            IDictionary<Data, LinkedListNode<Data>> map = new Dictionary<Data, LinkedListNode<Data>>();\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                var d = new Data(num[i], i);\\n                ll.AddLast(d);\\n                map[d] = ll.Last;\\n            }\\n\\n            LinkedListNode<Data> last = ll.First;\\n\\n            for (int i = 0; i < num.Length; i++)\\n            {\\n                //try attach all possible chars for next step\\n                while (true)\\n                {\\n                    if (set.Count == k + 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    set.Add(last.Value);\\n                    if (last.Next == null)\\n                    {\\n                        break;\\n                    }\\n\\n                    last = last.Next;\\n                }\\n\\n                var top = set.First();\\n\\n\\n                //here we should need to know the index of selected item\\n\\t\\t\\t\\t//shifted = count of removed precedessors of selected items in LinkedList\\n                var shifted = (int) f.SumRange(0, top.Pos, shifts);\\n                k -= top.Pos + shifted;\\n                f.Update(top.Pos, -1, shifts);\\n\\n                res.Append(top.C);\\n\\n                if (last == map[top])\\n                {\\n                    last = map[top].Previous;\\n                    if (last == null)\\n                    {\\n                        last = map[top].Next;\\n                    }\\n                }\\n\\n                ll.Remove(map[top]);\\n                set.Remove(top);\\n                map.Remove(top);\\n\\n\\n                //remove items that can not to be used as next char\\n                while (set.Count > k + 1 && last != null)\\n                {\\n                    set.Remove(last.Value);\\n                    last = last.Previous;\\n                }\\n            }\\n\\n            return res.ToString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720449,
                "title": "c-solution-with-no-extra-space-easy-understanding",
                "content": "From num[0], every time try to make num[i] the smallest, or move to next char;\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        for (int i = 0; i < num.size() - 1; i++) {\\n            char min = \\'0\\';\\n            int position;\\n            while (min <= \\'9\\') {\\n                position = num.find(min, i);\\n                if (position != num.npos) {\\n                    if (min == \\'9\\') break;\\n                    if (num[i] == min) break;\\n                    if (position - i <= k) {\\n                        num.erase(position, 1);\\n                        num.insert(i, 1, min);\\n                        k -= position - i;\\n                        break;\\n                    }\\n                }\\n                min += 1;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        for (int i = 0; i < num.size() - 1; i++) {\\n            char min = \\'0\\';\\n            int position;\\n            while (min <= \\'9\\') {\\n                position = num.find(min, i);\\n                if (position != num.npos) {\\n                    if (min == \\'9\\') break;\\n                    if (num[i] == min) break;\\n                    if (position - i <= k) {\\n                        num.erase(position, 1);\\n                        num.insert(i, 1, min);\\n                        k -= position - i;\\n                        break;\\n                    }\\n                }\\n                min += 1;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720448,
                "title": "java-binary-indexed-tree-o-nlogn-17ms",
                "content": "idea : Every turn we find the smallest number that we can move to the head of the left string, it will make the answer  minimum. We can calculate how many characters  in the left string before the most left index of current number, if it is less than or equal to k, then we can move a current number of most left index to the head of the left string.Using data struct like BIT or segment Tree will solve this problem.\\n```\\nclass Solution {\\n    int[] C;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n    void add(int x, int k) {\\n        while(k < C.length) {\\n            C[k] += x;\\n            k += lowbit(k);\\n        }\\n    }\\n    int getSum(int r) {\\n        int res = 0;\\n        while(r > 0) {\\n            res += C[r];\\n            r ^= lowbit(r);\\n        }\\n        return res;\\n    }\\n    public String minInteger(String num, int k) {\\n        int n = num.length();\\n        C = new int [n + 1];\\n        for(int i = 1; i < C.length; ++i) add(1,i);\\n        StringBuilder ans = new StringBuilder();\\n        ArrayList<Integer>[] arr = new ArrayList[10];\\n        for(int i = 0; i < num.length(); i++) {\\n            int x = num.charAt(i) - \\'0\\';\\n            if(arr[x] == null) arr[x] = new ArrayList<>();\\n            arr[x].add(i + 1);\\n        }\\n        int[] pos = new int[10];\\n        for(int i = 0; i < n; i++ ){\\n            for(int j = 0; j <= 9; j++) {\\n                if(arr[j] == null || pos[j] >= arr[j].size()) continue;\\n                int top = arr[j].get(pos[j]);\\n                int p = getSum(top - 1);\\n                if(p <= k) {\\n                    ans.append((char)(\\'0\\' + j));\\n                    k -= p;\\n                    add(-1,top);\\n                    pos[j]++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] C;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 720395,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string MinInteger(string num, int k) \\n    {\\n        int start = 0, n = num.Length;\\n        var charArray = num.ToCharArray();\\n        if(k >=(n * (n - 1))/ 2)\\n        {\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        while(start < charArray.Length)\\n        {\\n            int minIndex = start;\\n            int length = Math.Min(k, charArray.Length - start - 1);\\n            for(int len = length; len > 0; len--)\\n            {\\n                if(charArray[start + len] <= charArray[minIndex])\\n                    minIndex = start + len;\\n            }\\n                \\n            char val = charArray[minIndex];\\n            if(charArray[minIndex] != charArray[start])\\n            {\\n                for(int i = minIndex; i > start; i--)\\n                {\\n                    charArray[i] = charArray[i - 1];\\n                    k--;\\n                }\\n            }\\n            \\n            charArray[start] = val;\\n            start++;\\n        }\\n        \\n        return new string(charArray);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string MinInteger(string num, int k) \\n    {\\n        int start = 0, n = num.Length;\\n        var charArray = num.ToCharArray();\\n        if(k >=(n * (n - 1))/ 2)\\n        {\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        while(start < charArray.Length)\\n        {\\n            int minIndex = start;\\n            int length = Math.Min(k, charArray.Length - start - 1);\\n            for(int len = length; len > 0; len--)\\n            {\\n                if(charArray[start + len] <= charArray[minIndex])\\n                    minIndex = start + len;\\n            }\\n                \\n            char val = charArray[minIndex];\\n            if(charArray[minIndex] != charArray[start])\\n            {\\n                for(int i = minIndex; i > start; i--)\\n                {\\n                    charArray[i] = charArray[i - 1];\\n                    k--;\\n                }\\n            }\\n            \\n            charArray[start] = val;\\n            start++;\\n        }\\n        \\n        return new string(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720389,
                "title": "python-runtime-100-ms-beat-100-better-than-o-n-2-analyse-the-complexity-if-you-can-help",
                "content": "try digit ==0 firstly.\\n\\n1. Try to move all digit to left. Say positions= all of indice of digit in num and it\\'s length is N\\nThen it needs (sum(positions)-(1+N-1) * (N-1)/2) swaps to move all digit to the left.\\nif K is large enough, remove all the digit from num, problem turns out to be [digit]* N + solve(num,k-temp,digit+1)\\n\\n2 if k is not large enough, try to move as many digit to left as possible, so move the leftmost digit firstly  every move cost position[i]-i swaps.\\n3. At last if k is not big enough to finish a single move, then use bubble sort to bruteforce the result.\\n\\nAs part 1 is O(10* n) \\npart2 is O(n)\\npart3 is hard to analyse, please comment if you have an idea.\\n\\n```\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def sum1ton(n):\\n            return (1+n)*n//2\\n\\n        def brutforce(num,k: int):\\n            N = len(num)\\n            i = 0\\n            while i < N - 1 and k > 0:\\n                min_ind = i\\n                j = i + 1\\n                while j - i <= k and j < N:\\n                    if num[j] < num[min_ind]:\\n                        min_ind = j\\n                    j += 1\\n                num[i:min_ind + 1] = [num[min_ind]] + num[i:min_ind]\\n                k -= min_ind - i\\n                i += 1\\n            return num\\n\\n        def solve(num,k,digit):\\n            if digit==10:\\n                return num\\n            if k==0:\\n                return num\\n\\n            positons = []\\n            summ = 0\\n            for i, x in enumerate(num):\\n                if x ==digit:\\n                    positons.append(i)\\n                    summ += i\\n\\n            if len(positons)==0:\\n                return solve(num,k,digit+1)\\n            temp=summ-sum1ton(len(positons)-1)\\n            if k>=temp:# if can move all digit to left\\n                new_num=[x for x in num if x!=digit]\\n                res=[digit]*len(positons)+solve(new_num,k-temp,digit+1)\\n                return res\\n            else:#otherwise try to move as many digit to left as possible\\n                ind=0\\n                while k>=positons[ind]-ind:\\n                    k-=positons[ind]-ind\\n                    ind+=1\\n                pre=[digit]*ind\\n                temp=[x for x in num[:positons[ind]] if x!=digit]+num[positons[ind]:]\\n\\t\\t\\t\\t#cannot move any digit to left use bubble sort\\n                return pre+brutforce(temp,k)\\n\\n        num=[int(ch) for ch in num]\\n        ans=solve(num,k,0)\\n        return \"\".join([str(x) for x in ans])\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def sum1ton(n):\\n            return (1+n)*n//2\\n\\n        def brutforce(num,k: int):\\n            N = len(num)\\n            i = 0\\n            while i < N - 1 and k > 0:\\n                min_ind = i\\n                j = i + 1\\n                while j - i <= k and j < N:\\n                    if num[j] < num[min_ind]:\\n                        min_ind = j\\n                    j += 1\\n                num[i:min_ind + 1] = [num[min_ind]] + num[i:min_ind]\\n                k -= min_ind - i\\n                i += 1\\n            return num\\n\\n        def solve(num,k,digit):\\n            if digit==10:\\n                return num\\n            if k==0:\\n                return num\\n\\n            positons = []\\n            summ = 0\\n            for i, x in enumerate(num):\\n                if x ==digit:\\n                    positons.append(i)\\n                    summ += i\\n\\n            if len(positons)==0:\\n                return solve(num,k,digit+1)\\n            temp=summ-sum1ton(len(positons)-1)\\n            if k>=temp:# if can move all digit to left\\n                new_num=[x for x in num if x!=digit]\\n                res=[digit]*len(positons)+solve(new_num,k-temp,digit+1)\\n                return res\\n            else:#otherwise try to move as many digit to left as possible\\n                ind=0\\n                while k>=positons[ind]-ind:\\n                    k-=positons[ind]-ind\\n                    ind+=1\\n                pre=[digit]*ind\\n                temp=[x for x in num[:positons[ind]] if x!=digit]+num[positons[ind]:]\\n\\t\\t\\t\\t#cannot move any digit to left use bubble sort\\n                return pre+brutforce(temp,k)\\n\\n        num=[int(ch) for ch in num]\\n        ans=solve(num,k,0)\\n        return \"\".join([str(x) for x in ans])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720369,
                "title": "c-nlogn-using-std-set-to-record-position",
                "content": "132 ms.\\nwe search from  0 - 9 to find the next number with range k greedly.\\nSort previus number in a set.  keep a dis[10] array to record each number\\'s distance.  keep pos[10] array to track each number\\'s next position.\\nTrick is we need to update dis[10] each time we find a number v in front postion curpos.\\nfor other 9 number v1 that is not v, just compare position pos[v1]  with curpos, add 1 if cupos is bigger than pos[v1].\\nfor number v,  we need to caulate distance \\n\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\nNote this is (much) faster than std::distance(iter2, m.end());\\n\\ntime O(nlogn)\\n \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int next(int cur, string& num)\\n    {\\n        int v = num[cur] - \\'0\\';\\n        for (int i = cur + 1; i < num.size(); i++)\\n        {\\n            int nv = num[i] - \\'0\\';\\n            if (nv == v)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    string minInteger(string num, int k) {\\n        vector<int> pos(10, -1);\\n        vector<int> dis(10, 0);\\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            int v = num[i] - \\'0\\';\\n            if (pos[v] == -1)\\n            {\\n                pos[v] = i;\\n            }\\n        }\\n        int i = 0;\\n        vector<int> res;\\n        set<int> m;\\n        while (k > 0)\\n        {\\n            bool find = false;\\n            int v = 0;\\n            int cur;\\n            for (v = 0; v < 10; v++)\\n            {\\n                cur = pos[v];\\n                if (cur != -1 )\\n                {\\n                    if ((cur + dis[v] - i) <= k)\\n                    {\\n                        int pre = pos[v];\\n                        find = true;\\n                        res.push_back(v);\\n                        k = k - (cur + dis[v] - i);\\n                        pos[v] = next(cur, num);\\n                        if (pos[v] != -1)\\n                        {\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\n                        }\\n                        m.insert(cur);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n            if (!find) break;\\n            for (int t = 0; t < 10; t++)\\n            {\\n                if (t != v)\\n                {\\n                    if (pos[t] < cur)\\n                    {\\n                        dis[t]++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        bool allend = false;\\n        while (true)\\n        {\\n            int minpos = INT_MAX;\\n            int minv = -1;\\n            int v = -1;\\n            for (v = 0; v < 10; v++)\\n            {\\n                if (pos[v] != -1 && minpos > (pos[v]))\\n                {\\n                    minpos = pos[v];\\n                    minv = v;\\n                }\\n            }\\n\\n            if (minpos == INT_MAX)\\n            {\\n                break;\\n            }\\n            pos[minv] = next(minpos, num);\\n            res.push_back(minv);\\n        }\\n        string re;\\n        re.resize(res.size());\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n            re[i] = res[i] + \\'0\\';\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int next(int cur, string& num)\\n    {\\n        int v = num[cur] - \\'0\\';\\n        for (int i = cur + 1; i < num.size(); i++)\\n        {\\n            int nv = num[i] - \\'0\\';\\n            if (nv == v)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    string minInteger(string num, int k) {\\n        vector<int> pos(10, -1);\\n        vector<int> dis(10, 0);\\n        for (int i = 0; i < num.size(); i++)\\n        {\\n            int v = num[i] - \\'0\\';\\n            if (pos[v] == -1)\\n            {\\n                pos[v] = i;\\n            }\\n        }\\n        int i = 0;\\n        vector<int> res;\\n        set<int> m;\\n        while (k > 0)\\n        {\\n            bool find = false;\\n            int v = 0;\\n            int cur;\\n            for (v = 0; v < 10; v++)\\n            {\\n                cur = pos[v];\\n                if (cur != -1 )\\n                {\\n                    if ((cur + dis[v] - i) <= k)\\n                    {\\n                        int pre = pos[v];\\n                        find = true;\\n                        res.push_back(v);\\n                        k = k - (cur + dis[v] - i);\\n                        pos[v] = next(cur, num);\\n                        if (pos[v] != -1)\\n                        {\\n                            auto iter1 = m.lower_bound(pre);\\n                            auto iter2 = m.lower_bound(pos[v]);\\n                            int offset = std::distance(iter1, iter2);\\n                            dis[v] = dis[v] - offset;\\n                        }\\n                        m.insert(cur);\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            i++;\\n            if (!find) break;\\n            for (int t = 0; t < 10; t++)\\n            {\\n                if (t != v)\\n                {\\n                    if (pos[t] < cur)\\n                    {\\n                        dis[t]++;\\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        bool allend = false;\\n        while (true)\\n        {\\n            int minpos = INT_MAX;\\n            int minv = -1;\\n            int v = -1;\\n            for (v = 0; v < 10; v++)\\n            {\\n                if (pos[v] != -1 && minpos > (pos[v]))\\n                {\\n                    minpos = pos[v];\\n                    minv = v;\\n                }\\n            }\\n\\n            if (minpos == INT_MAX)\\n            {\\n                break;\\n            }\\n            pos[minv] = next(minpos, num);\\n            res.push_back(minv);\\n        }\\n        string re;\\n        re.resize(res.size());\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n            re[i] = res[i] + \\'0\\';\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720293,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ca = num.toCharArray();\\n        helper(ca, k, 0);\\n        return new String(ca);\\n        \\n    }\\n    \\n    \\n    \\n    public char[] helper(char[] num,int k,int i){\\n        if(k==0  || i==num.length-1){\\n            return num;\\n        }\\n        char min=num[i];\\n        int index=i;\\n        for(int j=i+1;j<Math.min(num.length,i+k+1);j++){\\n            char n=num[j];\\n            if(n<min){\\n                    \\n                    min=n;\\n                    index=j;\\n                }    \\n            }\\n        \\n        for (int j = index; j>i; j--) {num[j]=num[j-1];}\\n        num[i] = min;\\n        \\n        return helper(num,k-(index-i),i+1);  \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ca = num.toCharArray();\\n        helper(ca, k, 0);\\n        return new String(ca);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 720277,
                "title": "python-580ms-using-heap-336ms-sorting-by-digit",
                "content": "Finish this 20 minutes after deadline, unfortunately. \\uD83D\\uDE22\\n\\nI tried the O(n^2) method but got a TLE. Then I tried to use heap... Finished too late.\\n\\n**UPDATE**: Just saw this post [[Python] O(N log N) 316ms Greedy Solution](http://https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720191/Python-O(N-log-N)-316ms-Greedy-Solution), sorting digits by 0 ~ 9. This is a great insight. I post my update at the bottom, with a runtime of 336ms. \\n\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) <= 1: return num\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        hp = [(c, i) for i, c in enumerate(num)]\\n        heapq.heapify(hp)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while hp and k:\\n            bak = []  # digits too far for this round might be valid later\\n            while hp and f(hp[0][1]) > k: bak.append(heapq.heappop(hp))\\n            if not hp: break\\n            k -= f(hp[0][1])\\n            ans.append(hp[0][0])\\n            bisect.insort(pops, hp[0][1])\\n            heapq.heappop(hp)\\n            for pair in bak: heapq.heappush(hp, pair)  # abandoned digits might be usefull later\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```\\n\\nUpdate:\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        idx = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            idx[int(num[i])].append(i)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while k:\\n            d = 0\\n            while d < 10 and (not idx[d] or f(idx[d][-1]) > k): d += 1\\n            if d == 10: break\\n            k -= f(idx[d][-1])\\n            ans.append(str(d))\\n            bisect.insort(pops, idx[d].pop())\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        if len(num) <= 1: return num\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        hp = [(c, i) for i, c in enumerate(num)]\\n        heapq.heapify(hp)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while hp and k:\\n            bak = []  # digits too far for this round might be valid later\\n            while hp and f(hp[0][1]) > k: bak.append(heapq.heappop(hp))\\n            if not hp: break\\n            k -= f(hp[0][1])\\n            ans.append(hp[0][0])\\n            bisect.insort(pops, hp[0][1])\\n            heapq.heappop(hp)\\n            for pair in bak: heapq.heappush(hp, pair)  # abandoned digits might be usefull later\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        def f(i):  # calculate the cost to k after some digits picked\\n            return i - bisect.bisect(pops, i)\\n        idx = [[] for _ in range(10)]\\n        for i in range(len(num)-1, -1, -1):\\n            idx[int(num[i])].append(i)\\n        ans = []\\n        pops = []  # picked nums\\' index. Keep increasing ordered for f()\\n        while k:\\n            d = 0\\n            while d < 10 and (not idx[d] or f(idx[d][-1]) > k): d += 1\\n            if d == 10: break\\n            k -= f(idx[d][-1])\\n            ans.append(str(d))\\n            bisect.insort(pops, idx[d].pop())\\n        pops.insert(0, -1)\\n        pops.append(len(num))\\n        for i in range(len(pops)-1):\\n            ans.append(num[pops[i]+1:pops[i+1]])\\n        t = \"\".join(ans)\\n        if k > 0:  # if some k left, find the first not increasing digit and move it k step forward\\n            for i in range(1, len(t)):\\n                if t[i] < t[i-1]: break\\n            if t[i] >= t[i-1]: return t\\n            return t[:i-k-1] + t[i] + t[i-k-1:i] + t[i+1:]\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720252,
                "title": "o-n-log-n-solution-using-segmenttree-124-ms-c",
                "content": "Store the indices of all digits 0 - 9. For each index from the start, greedily shift the smallest possible digit to this index provided that the number of swaps remaining is larger than the number of swaps required to move the smallest index in which this digit occurs. As swaps happen, the actual index of said digit may be different as there may be indices behind this actual index being pushed to the front, making the actual index of this digit larger than its original index.\\n      Let\\'s call this index `i`. Upon observation, the actual index is equal to `i + the number of elements with index > i which have been shifted to the front`. Once the actual index is found, the number of swaps required is just equal to the `actual index - target index location`. We could use a segment tree to maintain the count of pushed indices after each index.\\n\\t  After exhausting all swaps possible, just concatenate the remaining unsorted digits to the back of the sorted ones. `SegmentTree` takes `O(log N)` time per query therefore this algorithm runs in `O(N log N)`.\\n```\\nconst int MAXN = 30000 + 5;\\nclass SegmentTree {\\nprivate:\\n    int tree[4 * MAXN];\\n    int n;\\n    int merge(int, int);\\n    void build(vector<int>&, int, int, int);\\n    void modify(int, int, int, int, int);\\n    int get(int, int, int, int, int);\\npublic:\\n    SegmentTree(vector<int>&);\\n    void build(vector<int>&);\\n    void modify(int, int);\\n    int get(int, int);\\n};\\n\\n// initialize segment tree\\nSegmentTree::SegmentTree(vector<int>& arr) {\\n    n = arr.size();\\n    build(arr);\\n}\\n\\n// merging method of nodes in the segmment tree\\nint SegmentTree::merge(int left, int right) {\\n    return left + right;\\n}\\n\\n// recursively build the segment tree\\nvoid SegmentTree::build(vector<int>& arr, int treeIndex, int lo, int hi) {  \\n    if (lo == hi) {\\n        tree[treeIndex] = arr[lo];\\n        return;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    build(arr, 2 * treeIndex + 1, lo, mid);\\n    build(arr, 2 * treeIndex + 2, mid + 1, hi);\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// function to get value on interval [left, right]\\nint SegmentTree::get(int treeIndex, int left, int right, int lo, int hi) {\\n    // segment completely out of range\\n    if (lo > right || hi < left) {\\n        return 0;\\n    }\\n    // segment completely inside range\\n    if (left <= lo && right >= hi) {          \\n        return tree[treeIndex];\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    // segment completely to the left of mid\\n    if (right <= mid) {\\n        return get(2 * treeIndex + 1, left, right, lo, mid);\\n    }\\n    // segment completely to the right of mid\\n    else if (left > mid) {\\n        return get(2 * treeIndex + 2, left, right, mid + 1, hi);\\n    }\\n    // segment overlapping both left and right\\n    int leftRes = get(2 * treeIndex + 1, left, mid, lo, mid);\\n    int rightRes = get(2 * treeIndex + 2, mid + 1, right, mid + 1, hi);\\n    // merge query results\\n    return merge(leftRes, rightRes);\\n}\\n\\n// function to modify a tree node \\nvoid SegmentTree::modify(int treeIndex, int arrIndex, int val, int lo, int hi) {  \\n    // leaf node. update element.\\n     if (lo == hi) {\\n        tree[treeIndex] = val;\\n        return;\\n     }\\n    int mid = lo + (hi - lo) / 2;\\n    // update descendants\\n    if (arrIndex <= mid) {\\n        modify(2 * treeIndex + 1, arrIndex, val, lo, mid);\\n    } else {\\n        modify(2 * treeIndex + 2, arrIndex, val, mid + 1, hi);\\n    }\\n    // merge updates\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// public wrapper for build\\nvoid SegmentTree::build(vector<int>& arr) {\\n    return build(arr, 0, 0, n - 1);\\n}\\n\\n// public wrapper for get\\nint SegmentTree::get(int left, int right) {\\n    return get(0, left, right, 0, n - 1);\\n}\\n\\n// public wrapper for modify\\nvoid SegmentTree::modify(int arrIndex, int val) {\\n    return modify(0, arrIndex, val, 0, n - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int N = num.size();\\n        queue<int> digs[10];\\n        for(int i = 0; i < N; i++) {\\n            int d = num[i]-\\'0\\';\\n            digs[d].push(i);\\n        }\\n        vector<int> pushed(N);\\n        SegmentTree segT(pushed);\\n        string sorted;\\n        for(int i = 0; i < N && k; i++) {\\n            bool canImprove = false;\\n            for(int d = 0; d <= 9; d++) {\\n                if(digs[d].empty()) {\\n                    continue;\\n                }\\n                int ind = digs[d].front();\\n                int actualInd = ind + (ind < N - 1 ? segT.get(ind + 1, N - 1) : 0);\\n                int swapsNeeded = actualInd - i;\\n                if(k >= swapsNeeded) {\\n                    k -= swapsNeeded;\\n                    sorted.push_back(d + \\'0\\');\\n                    segT.modify(ind, 1);\\n                    canImprove = true;\\n                    digs[d].pop();\\n                    break;\\n                }\\n            }\\n            if(!canImprove) {\\n                break;\\n            }\\n        }\\n        vector<int> leftover;\\n        for(int d = 0; d <= 9; d++) {\\n            while(!digs[d].empty()) {\\n                leftover.push_back(digs[d].front());\\n                digs[d].pop();\\n            }\\n        }\\n        sort(leftover.begin(), leftover.end());\\n        string unsorted;\\n        for(int i : leftover) {\\n            unsorted.push_back(num[i]);\\n        }\\n        return sorted + unsorted;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int MAXN = 30000 + 5;\\nclass SegmentTree {\\nprivate:\\n    int tree[4 * MAXN];\\n    int n;\\n    int merge(int, int);\\n    void build(vector<int>&, int, int, int);\\n    void modify(int, int, int, int, int);\\n    int get(int, int, int, int, int);\\npublic:\\n    SegmentTree(vector<int>&);\\n    void build(vector<int>&);\\n    void modify(int, int);\\n    int get(int, int);\\n};\\n\\n// initialize segment tree\\nSegmentTree::SegmentTree(vector<int>& arr) {\\n    n = arr.size();\\n    build(arr);\\n}\\n\\n// merging method of nodes in the segmment tree\\nint SegmentTree::merge(int left, int right) {\\n    return left + right;\\n}\\n\\n// recursively build the segment tree\\nvoid SegmentTree::build(vector<int>& arr, int treeIndex, int lo, int hi) {  \\n    if (lo == hi) {\\n        tree[treeIndex] = arr[lo];\\n        return;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    build(arr, 2 * treeIndex + 1, lo, mid);\\n    build(arr, 2 * treeIndex + 2, mid + 1, hi);\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// function to get value on interval [left, right]\\nint SegmentTree::get(int treeIndex, int left, int right, int lo, int hi) {\\n    // segment completely out of range\\n    if (lo > right || hi < left) {\\n        return 0;\\n    }\\n    // segment completely inside range\\n    if (left <= lo && right >= hi) {          \\n        return tree[treeIndex];\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    // segment completely to the left of mid\\n    if (right <= mid) {\\n        return get(2 * treeIndex + 1, left, right, lo, mid);\\n    }\\n    // segment completely to the right of mid\\n    else if (left > mid) {\\n        return get(2 * treeIndex + 2, left, right, mid + 1, hi);\\n    }\\n    // segment overlapping both left and right\\n    int leftRes = get(2 * treeIndex + 1, left, mid, lo, mid);\\n    int rightRes = get(2 * treeIndex + 2, mid + 1, right, mid + 1, hi);\\n    // merge query results\\n    return merge(leftRes, rightRes);\\n}\\n\\n// function to modify a tree node \\nvoid SegmentTree::modify(int treeIndex, int arrIndex, int val, int lo, int hi) {  \\n    // leaf node. update element.\\n     if (lo == hi) {\\n        tree[treeIndex] = val;\\n        return;\\n     }\\n    int mid = lo + (hi - lo) / 2;\\n    // update descendants\\n    if (arrIndex <= mid) {\\n        modify(2 * treeIndex + 1, arrIndex, val, lo, mid);\\n    } else {\\n        modify(2 * treeIndex + 2, arrIndex, val, mid + 1, hi);\\n    }\\n    // merge updates\\n    tree[treeIndex] = merge(tree[2 * treeIndex + 1], tree[2 * treeIndex + 2]);\\n}\\n\\n// public wrapper for build\\nvoid SegmentTree::build(vector<int>& arr) {\\n    return build(arr, 0, 0, n - 1);\\n}\\n\\n// public wrapper for get\\nint SegmentTree::get(int left, int right) {\\n    return get(0, left, right, 0, n - 1);\\n}\\n\\n// public wrapper for modify\\nvoid SegmentTree::modify(int arrIndex, int val) {\\n    return modify(0, arrIndex, val, 0, n - 1);\\n}\\n\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int N = num.size();\\n        queue<int> digs[10];\\n        for(int i = 0; i < N; i++) {\\n            int d = num[i]-\\'0\\';\\n            digs[d].push(i);\\n        }\\n        vector<int> pushed(N);\\n        SegmentTree segT(pushed);\\n        string sorted;\\n        for(int i = 0; i < N && k; i++) {\\n            bool canImprove = false;\\n            for(int d = 0; d <= 9; d++) {\\n                if(digs[d].empty()) {\\n                    continue;\\n                }\\n                int ind = digs[d].front();\\n                int actualInd = ind + (ind < N - 1 ? segT.get(ind + 1, N - 1) : 0);\\n                int swapsNeeded = actualInd - i;\\n                if(k >= swapsNeeded) {\\n                    k -= swapsNeeded;\\n                    sorted.push_back(d + \\'0\\');\\n                    segT.modify(ind, 1);\\n                    canImprove = true;\\n                    digs[d].pop();\\n                    break;\\n                }\\n            }\\n            if(!canImprove) {\\n                break;\\n            }\\n        }\\n        vector<int> leftover;\\n        for(int d = 0; d <= 9; d++) {\\n            while(!digs[d].empty()) {\\n                leftover.push_back(digs[d].front());\\n                digs[d].pop();\\n            }\\n        }\\n        sort(leftover.begin(), leftover.end());\\n        string unsorted;\\n        for(int i : leftover) {\\n            unsorted.push_back(num[i]);\\n        }\\n        return sorted + unsorted;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720247,
                "title": "can-someone-help-in-optimizing-this-backtracking-solution",
                "content": "I am getting a TLE through this backtracking solution for string \"9438957234785635408\".\\nCan someone help me with some pruning step?\\n\\n```\\n void findMin(string S, long long int n, int k, string &min_so_far){\\n    // compare current number with minimum number so far\\n    if (min_so_far.compare(S) > 0)\\n        min_so_far = S;\\n\\n    // base case: no swaps left\\n    if (k < 1)\\n        return;\\n        \\n\\n    // do for each digit in the input string\\n    for (int i = 0; i < n - 1; i++){\\n        // compare the current digit with remaining digits\\n            // if digit at i\\'th index is more than the digit at j\\'th index\\n            int j=i+1;\\n            if (S[i] > S[j])\\n            {\\n                // swap S[i] and S[j]\\n                swap(S[i], S[j]);\\n\\n                // recur for remaining k - 1 swaps\\n                findMin(S, n, k - 1, min_so_far);\\n\\n                // backtrack - restore the string back\\n                swap(S[i], S[j]);\\n            }\\n    }\\n }\\n    \\n    string minInteger(string num, int k) {\\n        string minimum= num;\\n        \\n        findMin(num, num.length(), k, minimum);\\n        \\n        return minimum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void findMin(string S, long long int n, int k, string &min_so_far){\\n    // compare current number with minimum number so far\\n    if (min_so_far.compare(S) > 0)\\n        min_so_far = S;\\n\\n    // base case: no swaps left\\n    if (k < 1)\\n        return;\\n        \\n\\n    // do for each digit in the input string\\n    for (int i = 0; i < n - 1; i++){\\n        // compare the current digit with remaining digits\\n            // if digit at i\\'th index is more than the digit at j\\'th index\\n            int j=i+1;\\n            if (S[i] > S[j])\\n            {\\n                // swap S[i] and S[j]\\n                swap(S[i], S[j]);\\n\\n                // recur for remaining k - 1 swaps\\n                findMin(S, n, k - 1, min_so_far);\\n\\n                // backtrack - restore the string back\\n                swap(S[i], S[j]);\\n            }\\n    }\\n }\\n    \\n    string minInteger(string num, int k) {\\n        string minimum= num;\\n        \\n        findMin(num, num.length(), k, minimum);\\n        \\n        return minimum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 720217,
                "title": "greedy-solution-using-heap",
                "content": "Imagine k as the moving budget, intuitively, \\n1. we always want to move the smallest possible item (as long as the moving distance is maller than remaining budget k) to the begining of the final array first. \\n2. Then decrease the budget k by moving distance (the position of the candidate item in current string, a little tricky here, I try to find how many items after the current item in the initial array have been moved to begining as the position shift)\\n3. Keep iterating until k equals 0, then the order all remaining items will not change.\\n4. To always pick the smallest item, use a heap to store all values and initial position.\\n\\n```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        queue = []\\n        res = []\\n\\t\\t# Initialize the heap, always pop the smallest value\\n        for i in range(len(num)):\\n            heapq.heappush(queue, (num[i], i))\\n        \\n\\t\\t# The next position we need to decide for the output\\n        cur = 0\\n\\t\\t# The indices that have been moved to begining\\n        vis = []\\n        while queue and k > 0:\\n            temp = []\\n            while queue and k > 0:\\n                x, idx = heapq.heappop(queue)\\n                # binary search, find how many items after x have been moved to array begining, use the shift to decide the new position of x in current array\\n                shift = bisect.bisect_left(vis, -idx)\\n                if idx + shift - cur <= k:\\n                    res.append(x)\\n                    bisect.insort_left(vis, -idx)\\n                    k -= (idx + shift - cur)\\n                    cur += 1\\n                    break\\n                else:\\n                    temp.append((x, idx))\\n\\t\\t\\t# Put the candidates that are too far for moving back to heap ... I think this step could be improved\\n            for item in temp:\\n                heapq.heappush(queue, item)\\n        # If k equals 0, but there still items remaining in the queue, just output all remaining items in original order\\n        if queue:\\n            queue = sorted(queue, key = lambda x: x[1])\\n            for x, idx in queue:\\n                res.append(x)\\n        \\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInteger(self, num: str, k: int) -> str:\\n        queue = []\\n        res = []\\n\\t\\t# Initialize the heap, always pop the smallest value\\n        for i in range(len(num)):\\n            heapq.heappush(queue, (num[i], i))\\n        \\n\\t\\t# The next position we need to decide for the output\\n        cur = 0\\n\\t\\t# The indices that have been moved to begining\\n        vis = []\\n        while queue and k > 0:\\n            temp = []\\n            while queue and k > 0:\\n                x, idx = heapq.heappop(queue)\\n                # binary search, find how many items after x have been moved to array begining, use the shift to decide the new position of x in current array\\n                shift = bisect.bisect_left(vis, -idx)\\n                if idx + shift - cur <= k:\\n                    res.append(x)\\n                    bisect.insort_left(vis, -idx)\\n                    k -= (idx + shift - cur)\\n                    cur += 1\\n                    break\\n                else:\\n                    temp.append((x, idx))\\n\\t\\t\\t# Put the candidates that are too far for moving back to heap ... I think this step could be improved\\n            for item in temp:\\n                heapq.heappush(queue, item)\\n        # If k equals 0, but there still items remaining in the queue, just output all remaining items in original order\\n        if queue:\\n            queue = sorted(queue, key = lambda x: x[1])\\n            for x, idx in queue:\\n                res.append(x)\\n        \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861118,
                "title": "another-bubble-sort-solution-may-be-easier-to-understand-java",
                "content": "```java\\n public int getMinNumberIdx(char[] a, int i, int k){\\n        int minIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int j=i; j <=k+i && j < a.length; j++){\\n            if((int)(a[j]-\\'0\\') < min){\\n                min = (int)(a[j]-\\'0\\');\\n                minIdx = j;\\n            }\\n        }\\n        return minIdx;\\n    }\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ar = num.toCharArray();\\n        int i =0;\\n        while(k > 0){\\n            int idx = getMinNumberIdx(ar, i, k);\\n            if(idx==-1)break; //whole array is sorted.\\n\\t\\t\\t\\n            char min = ar[idx];\\n            for(int j=idx; j >i; j--){\\n                ar[j] = ar[j-1]; \\n            }\\n            ar[i] = min;\\n             \\n            k -= (idx-i); \\n\\t\\t\\t\\n            i++;\\n            \\n        }\\n        return new String(ar);\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int getMinNumberIdx(char[] a, int i, int k){\\n        int minIdx = -1;\\n        int min = Integer.MAX_VALUE;\\n        for(int j=i; j <=k+i && j < a.length; j++){\\n            if((int)(a[j]-\\'0\\') < min){\\n                min = (int)(a[j]-\\'0\\');\\n                minIdx = j;\\n            }\\n        }\\n        return minIdx;\\n    }\\n    public String minInteger(String num, int k) {\\n        \\n        char[] ar = num.toCharArray();\\n        int i =0;\\n        while(k > 0){\\n            int idx = getMinNumberIdx(ar, i, k);\\n            if(idx==-1)break; //whole array is sorted.\\n\\t\\t\\t\\n            char min = ar[idx];\\n            for(int j=idx; j >i; j--){\\n                ar[j] = ar[j-1]; \\n            }\\n            ar[i] = min;\\n             \\n            k -= (idx-i); \\n\\t\\t\\t\\n            i++;\\n            \\n        }\\n        return new String(ar);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826662,
                "title": "easy-to-understand-c-priority-queue-ordered-set-o-nlogn-time",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\nusing namespace __gnu_pbds; \\nclass Solution {\\n\\npublic:\\n    #define pr pair<int,int>\\n    #define pb push_back\\n    #define fi first\\n    #define se second\\n\\n    \\n    #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n    \\n    struct compare_queue\\n    {\\n        bool operator()(const int& a, const int& b)\\n        {\\n            return a>b;\\n        }\\n    };\\n    \\n    string minInteger(string num, int k) {\\n            vector<priority_queue<int,vector<int>,compare_queue>  > q(10);              int n=num.size();\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            q[num[i]-\\'0\\'].push(i);\\n        }\\n        i=0;\\n        string ans=\"\";\\n        ordered_set po;\\n        while(i<n){\\n            if(num[i]==\\'X\\'){i++; continue;}\\n            if(k==0){\\n                ans+=num[i];\\n                i++;\\n                continue;\\n            }\\n            int curr=num[i]-\\'0\\';\\n            int flag=0;\\n            for(j=0;j<curr;j++){\\n                \\n                while(!q[j].empty()  &&  q[j].top()<i){q[j].pop();}\\n                if(q[j].empty()){continue;}\\n                int val1=po.order_of_key(q[j].top());\\n               int val2=po.order_of_key(i);\\n                val1=val1-val2;\\n                val1=q[j].top()-i-val1;\\n               \\n                if(k>=val1){\\n                    flag=1;\\n                    k-=val1;\\n                    ans+=num[q[j].top()];\\n                    po.insert(q[j].top());\\n                    num[q[j].top()]=\\'X\\';\\n                    q[j].pop();\\n                    break;\\n                }\\n            }\\n            if(flag==0){\\n                ans+=num[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\nusing namespace __gnu_pbds; \\nclass Solution {\\n\\npublic:\\n    #define pr pair<int,int>\\n    #define pb push_back\\n    #define fi first\\n    #define se second\\n\\n    \\n    #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\n    \\n    struct compare_queue\\n    {\\n        bool operator()(const int& a, const int& b)\\n        {\\n            return a>b;\\n        }\\n    };\\n    \\n    string minInteger(string num, int k) {\\n            vector<priority_queue<int,vector<int>,compare_queue>  > q(10);              int n=num.size();\\n        int i,j;\\n        for(i=0;i<n;i++){\\n            q[num[i]-\\'0\\'].push(i);\\n        }\\n        i=0;\\n        string ans=\"\";\\n        ordered_set po;\\n        while(i<n){\\n            if(num[i]==\\'X\\'){i++; continue;}\\n            if(k==0){\\n                ans+=num[i];\\n                i++;\\n                continue;\\n            }\\n            int curr=num[i]-\\'0\\';\\n            int flag=0;\\n            for(j=0;j<curr;j++){\\n                \\n                while(!q[j].empty()  &&  q[j].top()<i){q[j].pop();}\\n                if(q[j].empty()){continue;}\\n                int val1=po.order_of_key(q[j].top());\\n               int val2=po.order_of_key(i);\\n                val1=val1-val2;\\n                val1=q[j].top()-i-val1;\\n               \\n                if(k>=val1){\\n                    flag=1;\\n                    k-=val1;\\n                    ans+=num[q[j].top()];\\n                    po.insert(q[j].top());\\n                    num[q[j].top()]=\\'X\\';\\n                    q[j].pop();\\n                    break;\\n                }\\n            }\\n            if(flag==0){\\n                ans+=num[i];\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 722656,
                "title": "simple-solution-with-explanation-o-n-2-greedy-solution-passed-c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) {\\n//         greedy approach\\n//         time O(n^2) || space O(n)\\n        \\n//         iterative algorithm:\\n//         On each iteration:\\n//         find the smallest digit say num[i], such that num[i] < num[0]  \\n//         where i > 0 and (i - 0) <= k\\n//         add num[i] to min, as\\n//         min += num[i];\\n//         and new subproblem would be \\n//         minInteger(num\\' = (num[0:i] + num[i + 1:]), k\\' = (k - i))\\n        \\n//         Little optimization is when \\n//         num swaps left k > n * (n - 1) / 2, where n = num.length()\\n//         then we can directly form min number by sorting and returns\\n        \\n//         without the above optimization code only passing 55/57 test cases.\\n        \\n        string min = \"\";\\n        while(k && num.length()) {\\n            \\n            int n = num.length();     \\n            if(k >= (n * (n - 1)) / 2) {\\n                sort(num.begin(), num.end());\\n                return min + num;\\n            }\\n            \\n            int mi_idx = 0;\\n            for(int i = 1; i < num.length() && i <= k; i++) {\\n                if(num[i] < num[mi_idx]) \\n                    mi_idx = i;\\n            }\\n            min += num[mi_idx];\\n            k -= (mi_idx);\\n            num = num.substr(0, mi_idx) + num.substr(mi_idx + 1);\\n        }\\n        min += num;\\n        return min;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string minInteger(string num, int k) {\\n//         greedy approach\\n//         time O(n^2) || space O(n)\\n        \\n//         iterative algorithm:\\n//         On each iteration:\\n//         find the smallest digit say num[i], such that num[i] < num[0]  \\n//         where i > 0 and (i - 0) <= k\\n//         add num[i] to min, as\\n//         min += num[i];\\n//         and new subproblem would be \\n//         minInteger(num\\' = (num[0:i] + num[i + 1:]), k\\' = (k - i))\\n        \\n//         Little optimization is when \\n//         num swaps left k > n * (n - 1) / 2, where n = num.length()\\n//         then we can directly form min number by sorting and returns\\n        \\n//         without the above optimization code only passing 55/57 test cases.\\n        \\n        string min = \"\";\\n        while(k && num.length()) {\\n            \\n            int n = num.length();     \\n            if(k >= (n * (n - 1)) / 2) {\\n                sort(num.begin(), num.end());\\n                return min + num;\\n            }\\n            \\n            int mi_idx = 0;\\n            for(int i = 1; i < num.length() && i <= k; i++) {\\n                if(num[i] < num[mi_idx]) \\n                    mi_idx = i;\\n            }\\n            min += num[mi_idx];\\n            k -= (mi_idx);\\n            num = num.substr(0, mi_idx) + num.substr(mi_idx + 1);\\n        }\\n        min += num;\\n        return min;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720983,
                "title": "cpp-similar-to-sorting-a-string-in-lexicographic-order-with-at-most-k-changes",
                "content": "Below are the observation.\\n- If K is too large we can directly return the sorted string.\\n- Otherwise at each position find the smallest character on right side within K reach and replace current character with it and also move all right side neighbours to right by one position. Reduce K by the distance we got the small character.\\n\\n```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\t\\t\\n\\t\\t/*If K is too large, sort and return*/\\n        if(k>=n*(n-1)/2){\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0;i<n && k>0;i++){\\n            char mn = num[i];\\n            int index=i;\\n            int tk=k;\\n\\t\\t\\t\\n\\t\\t\\t//for the character at index i , find the smallest character with at most K distance\\n            for(int j= i+1;j<n && tk>0;j++){\\n                if(mn>num[j]){\\n\\t\\t\\t\\t    // save character and index for the swap\\n                    mn=num[j];\\n                    index=j;\\n                }\\n                tk--;\\n            }\\n\\t\\t\\t// Move all characters from i to min_char_index to the right to make space for the smallest character\\n            for(int j=index;j>i;j--){\\n                num[j]=num[j-1];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//replace current character with minimum char\\n            num[i]=mn;\\n\\t\\t\\t\\n\\t\\t\\t//reduce K\\n            k-=(index-i);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string minInteger(string num, int k) {\\n        int n = num.size();\\n\\t\\t\\n\\t\\t/*If K is too large, sort and return*/\\n        if(k>=n*(n-1)/2){\\n            sort(num.begin(), num.end());\\n            return num;\\n        }\\n        for(int i=0;i<n && k>0;i++){\\n            char mn = num[i];\\n            int index=i;\\n            int tk=k;\\n\\t\\t\\t\\n\\t\\t\\t//for the character at index i , find the smallest character with at most K distance\\n            for(int j= i+1;j<n && tk>0;j++){\\n                if(mn>num[j]){\\n\\t\\t\\t\\t    // save character and index for the swap\\n                    mn=num[j];\\n                    index=j;\\n                }\\n                tk--;\\n            }\\n\\t\\t\\t// Move all characters from i to min_char_index to the right to make space for the smallest character\\n            for(int j=index;j>i;j--){\\n                num[j]=num[j-1];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//replace current character with minimum char\\n            num[i]=mn;\\n\\t\\t\\t\\n\\t\\t\\t//reduce K\\n            k-=(index-i);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720241,
                "title": "javascript-bubble-sort",
                "content": "Learned my lesson: `localeCompare` is slower than `>` or `<` operators\\n```javascript\\n// pseudo code:\\n// put number into a data structure that reduces the need for unnecessary copying\\n// iterate through the datastructure and find the minimum value we can put into the digit\\n// with the greatest weight with the minimum number of moves\\n// move that value to the current digit while shifting all digits from the digit to the minimum digit to the right\\n// decrement k by the amount of digits we moved\\n\\nvar minInteger = function(num, k) {\\n    const numArr = num.split(\\'\\');\\n    for (let i = 0; i < num.length && k; i++) {\\n        let swapIdx = i;\\n        const end = Math.min(num.length, k + i + 1);\\n        for (let j = i + 1; j < end; j++) {\\n            if (numArr[swapIdx] > numArr[j]) swapIdx = j;\\n        }\\n        const temp = numArr[swapIdx];\\n        for (let k = swapIdx; k > i; k--) {\\n            numArr[k] = numArr[k - 1];\\n        }\\n        numArr[i] = temp;\\n        k -= swapIdx - i;\\n    }\\n    return numArr.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n// pseudo code:\\n// put number into a data structure that reduces the need for unnecessary copying\\n// iterate through the datastructure and find the minimum value we can put into the digit\\n// with the greatest weight with the minimum number of moves\\n// move that value to the current digit while shifting all digits from the digit to the minimum digit to the right\\n// decrement k by the amount of digits we moved\\n\\nvar minInteger = function(num, k) {\\n    const numArr = num.split(\\'\\');\\n    for (let i = 0; i < num.length && k; i++) {\\n        let swapIdx = i;\\n        const end = Math.min(num.length, k + i + 1);\\n        for (let j = i + 1; j < end; j++) {\\n            if (numArr[swapIdx] > numArr[j]) swapIdx = j;\\n        }\\n        const temp = numArr[swapIdx];\\n        for (let k = swapIdx; k > i; k--) {\\n            numArr[k] = numArr[k - 1];\\n        }\\n        numArr[i] = temp;\\n        k -= swapIdx - i;\\n    }\\n    return numArr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565628,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            },
            {
                "id": 1576513,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            },
            {
                "id": 2033594,
                "content": [
                    {
                        "username": "theOtherWC",
                        "content": "It would not be acceptable to accept solutions that needs 8s to run with the large test case in python but not in C#. Right now this is what I see. This is ridiculous: a 8s Python is accepted but not C#. Please, be consistent when it comes to timing. Accept either none or all, especially during a contest! \\n\\n![image](https://assets.leetcode.com/users/images/164782dd-15cc-4cac-a7ad-57736b4384e4_1593923029.0101244.png)\\n"
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "Does this make sense? Make the description should be modified?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "For every index i, search for the minimum number in range i to i + k (inclusive). Keep track of the minimum numbers distance from i and the minimum numbers index. \\n\\nIf  num[i] is the minimum, we can just continue in our loop because that number is already where it should be.\\n\\nOtherwise, remove the minimum at its index, append it to index i, and subtract the distance from k.\\n\\nDo this until either k == 0 or you\\'ve gone through every index. It makes this process a lot easier to use something like a List in python or c#, because when you append the number to its new index it will automatically push all the indexes in front of it forward.\\n\\nFinally, construct the new string from your list and return the answer!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Speed to Arrive on Time",
        "question_content": "<p>You are given a floating-point number <code>hour</code>, representing the amount of time you have to reach the office. To commute to the office, you must take <code>n</code> trains in sequential order. You are also given an integer array <code>dist</code> of length <code>n</code>, where <code>dist[i]</code> describes the distance (in kilometers) of the <code>i<sup>th</sup></code> train ride.</p>\n\n<p>Each train can only depart at an integer hour, so you may need to wait in between each train ride.</p>\n\n<ul>\n\t<li>For example, if the <code>1<sup>st</sup></code> train ride takes <code>1.5</code> hours, you must wait for an additional <code>0.5</code> hours before you can depart on the <code>2<sup>nd</sup></code> train ride at the 2 hour mark.</li>\n</ul>\n\n<p>Return <em>the <strong>minimum positive integer</strong> speed <strong>(in kilometers per hour)</strong> that all the trains must travel at for you to reach the office on time, or </em><code>-1</code><em> if it is impossible to be on time</em>.</p>\n\n<p>Tests are generated such that the answer will not exceed <code>10<sup>7</sup></code> and <code>hour</code> will have <strong>at most two digits after the decimal point</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [1,3,2], hour = 6\n<strong>Output:</strong> 1\n<strong>Explanation: </strong>At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [1,3,2], hour = 2.7\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> dist = [1,3,2], hour = 1.9\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It is impossible because the earliest the third train can depart is at the 2 hour mark.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == dist.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= dist[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= hour &lt;= 10<sup>9</sup></code></li>\n\t<li>There will be at most two digits after the decimal point in <code>hour</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1224643,
                "title": "java-binary-search-explained",
                "content": "* Here we know that minimum answer can be `1` and maximum can be `10 ^ 7`(mentioned in problem statement).\\n\\n* We will perform binary search to find the best integer `i` such that:\\n    - Initially `sum = 0`.\\n    - for each index `j` in range `0` to `n-1`, `sum = sum + ceil(dist[j] / i)`\\n    - for `n-1` index, `sum = sum + dist[n-1]/i`. Because the time taken by last train need not be converted into Integer.\\n\\n```java\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int min = 1, max = 10000000;\\n        int ans = -1;\\n        while(min <= max){\\n            int mid = (max + min)/2;\\n            double sum = 0;\\n            for(int i = 0; i<n-1; ++i){\\n                sum += Math.ceil( ( (double) dist[i]) /mid);\\n            }\\n            sum = sum + ( ( (double) dist[n-1]) /mid);\\n            if(sum > hour){\\n                min = mid+1;\\n            }else{\\n                ans = mid;\\n                max = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Note - please upvote if you like the explanation. If you have any doubts, please ask in the comment section, I\\'ll be happy to answer : )**",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int min = 1, max = 10000000;\\n        int ans = -1;\\n        while(min <= max){\\n            int mid = (max + min)/2;\\n            double sum = 0;\\n            for(int i = 0; i<n-1; ++i){\\n                sum += Math.ceil( ( (double) dist[i]) /mid);\\n            }\\n            sum = sum + ( ( (double) dist[n-1]) /mid);\\n            if(sum > hour){\\n                min = mid+1;\\n            }else{\\n                ans = mid;\\n                max = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226468,
                "title": "binary-answer-cheat-sheet",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n# Binary Answer\\n## What\\'s Binary Answer\\nWhen the search range is small, the binary answer problems are solvable by linear scaning the answer range. For example, assume the answer range is `[0, 100]`, we can check `0`, then `1`, ..., then `100`, and we return the maximum number that is valid.\\n\\nHowever, when the answer range is large, say `[0, 10^5]`, linear scanning the entire answer range will get TLE. \\n\\nSo, instead of doing `O(N)` linear scanning, we binary search in the answer range which reduces the time complexity to `O(logN)`.\\n\\n## When can we use Binary Answer?\\n\\nWe can use \"Binary Answer\" solution if we can write a predicate function `valid(i)` that has **monotocity**:\\n\\n* If `valid(i) == true`, then `valid(j) == true` for all `j <= i`.\\n* If `valid(i) == false`, then `valid(j) == false` for all `j >= i`.\\n\\n![image](https://assets.leetcode.com/users/images/570c77bb-fdb6-491c-9012-b3124edb2ef5_1621797433.0307293.png)\\n\\n## Algorithm\\n\\nOur goal is the find the maximum `i` that `valid(i) == true`.\\n\\nWe can use two pointers `L = minVal, R = maxVal`, and keep using binary search to move the pointers towards each other until they swap order. In the end, `R` will point to the largest value that is valid, `L` will point to the smallest value that is invalid.\\n\\n![image](https://assets.leetcode.com/users/images/e3e2d79f-5016-4e9a-8fbc-5fe972ab7c93_1621797444.6634147.png)\\n\\n## Pseudo Code\\n\\nAssume the answer range is monotonically going from valid to invalid, and we are looking for the maximum valid value.\\n\\n```cpp\\nint L = minVal, R = maxVal\\nwhile (L <= R) {\\n    int M = (L + R) / 2;\\n    if (valid(M)) L = M + 1; \\n    else R = M - 1;\\n}\\nreturn R >= minVal ? R : NOT_FOUND;\\n```\\n\\nIf we are looking for the minimal invalid value, simply return `L <= maxVal ? L : NOT_FOUND`.\\n\\n## Apply Binary Answer to this problem\\n\\nWe can define the `valid` function to be `valid(speed)` returns `true` if the speed is high enough for being on time. This `valid` function has monotonicity because:\\n* If the current speed `x` is valid, all speed values `>= x` are valid.\\n* If the current speed `x` is invalid, all speed values `<= x` are invalid.\\n\\nNote that for this problem, the `valid` range is in the right/greater part of the answer range.\\n\\nSo we can apply binary answer to this problem. We can implement the `valid` function such that it just scans the input array one pass.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-speed-to-arrive-on-time/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogT) where T is the maximum possible speed\\n// Space: O(1)\\nclass Solution {\\n    bool valid(vector<int>& A, int speed, double hour) {\\n        double time = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            time = ceil(time);\\n            time +=  (double)A[i] / speed;\\n            if (time > hour) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& A, double hour) {\\n        if (hour < A.size() - 1) return -1;\\n        long L = 1, R = 1e7;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(A, M, hour)) R = M - 1;\\n            else L = M + 1;\\n        }\\n        return L > 1e7 ? -1 : L;\\n    }\\n};\\n```\\n\\n## Apply Binary Answer to other problems\\n\\n* See [C++  Binary Answer or Sort+Greedy](https://leetcode.com/problems/sell-diminishing-valued-colored-balls/discuss/927560/c-binary-answer-or-sortgreedy) for [1648. Sell Diminishing-Valued Colored Balls (Medium)](https://leetcode.com/problems/sell-diminishing-valued-colored-balls/)\\n* See [C++ Binary Search with explanation (with other binary answer problems)](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/794103/C%2B%2B-Binary-Search-with-explanation-(with-other-binary-answer-problems)) for [1862. Sum of Floored Pairs (Hard)](https://leetcode.com/problems/sum-of-floored-pairs/)\\n\\n## Other Binary Answer Problems\\n\\n* [410. Split Array Largest Sum \\\\(Hard\\\\)](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1482. Minimum Number of Days to Make m Bouquets \\\\(Medium\\\\)](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [1300. Sum of Mutated Array Closest to Target \\\\(Medium\\\\)](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/)\\n* [1044. Longest Duplicate Substring \\\\(Hard\\\\)](https://leetcode.com/problems/longest-duplicate-substring/)\\n* [668. Kth Smallest Number in Multiplication Table (Hard)](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [719. Find K-th Smallest Pair Distance (Hard)](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [1283. Find the Smallest Divisor Given a Threshold (Medium)](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n* [1802. Maximum Value at a Given Index in a Bounded Array (Medium)](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/)\\n* [1648. Sell Diminishing-Valued Colored Balls (Medium)](https://leetcode.com/problems/sell-diminishing-valued-colored-balls/)\\n",
                "solutionTags": [],
                "code": "```cpp\\nint L = minVal, R = maxVal\\nwhile (L <= R) {\\n    int M = (L + R) / 2;\\n    if (valid(M)) L = M + 1; \\n    else R = M - 1;\\n}\\nreturn R >= minVal ? R : NOT_FOUND;\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-speed-to-arrive-on-time/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogT) where T is the maximum possible speed\\n// Space: O(1)\\nclass Solution {\\n    bool valid(vector<int>& A, int speed, double hour) {\\n        double time = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            time = ceil(time);\\n            time +=  (double)A[i] / speed;\\n            if (time > hour) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& A, double hour) {\\n        if (hour < A.size() - 1) return -1;\\n        long L = 1, R = 1e7;\\n        while (L <= R) {\\n            long M = (L + R) / 2;\\n            if (valid(A, M, hour)) R = M - 1;\\n            else L = M + 1;\\n        }\\n        return L > 1e7 ? -1 : L;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224657,
                "title": "java-python-3-binary-search-w-comment-brief-analysis-and-similar-problems",
                "content": "Binary search code similar to:\\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446313/JavaPython-3-Binary-search-9-and-8-liners-w-brief-explanation-and-analysis.)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/1802443/)\\n\\nMore similar binary search problems:\\n\\n[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011. Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[1150. Check If a Number Is Majority Element in a Sorted Array: Premium](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array)\\n[1231. Divide Chocolate: Premium](https://leetcode.com/problems/divide-chocolate/)\\n[1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/discuss/451290/JavaPython-3-O(n)-and-O(logn)-codes-w-brief-explanation-and-analysis.)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets)\\n[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n\\n----\\n\\n\"There will be at most two digits after the decimal point in `hour`.\" - This means `hour`>= `dist.length - 1 + 0.01`, if there is a valid speed. Therefore, the max speed is no more than  `10 ^ 5 / 0.01 = 10 ^ 7`, and the search space for speed is `[1, 10 ^ 7]`.\\n\\n**Note:** use`(dist + speed - 1) / speed` to compute the ceil of the time of taking a train.\\n```java\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int lo = 1, hi = 10_000_001, n = dist.length;\\n        while (lo < hi) {\\n            int speed = lo + hi >> 1;\\n            double time = 0;\\n            for (int i = 0; i < n - 1; ++i) { // time need for all but last train.\\n                time += (dist[i] + speed - 1) / speed;\\n            }\\n            time += (double)dist[n - 1] / speed; // The last train will not need to wait.\\n            if (time > hour) { // slow speed cost more time, search in higher speed space.\\n                lo = speed + 1;\\n            }else { // fast speed cost less time, search in lower speed space.\\n                hi = speed;\\n            }\\n        }\\n        return lo == 10_000_001 ? -1 : lo;\\n    }\\n```\\n\\n----\\n\\n```python\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        lo, hi, n = 1, 10 ** 7 + 1, len(dist)\\n        while lo < hi:\\n            speed = lo + (hi - lo) // 2\\n            need = dist[-1] / speed + sum((dist[i] + speed - 1) // speed for i in range(n - 1))\\n            if need > hour:\\n                lo = speed + 1\\n            else:\\n                hi = speed\\n        return -1 if lo == 10 ** 7 + 1 else lo  \\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlog(K))`, space: `O(1)`, where `n = dist.length` and `K` is the search space of speed.",
                "solutionTags": [],
                "code": "```java\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int lo = 1, hi = 10_000_001, n = dist.length;\\n        while (lo < hi) {\\n            int speed = lo + hi >> 1;\\n            double time = 0;\\n            for (int i = 0; i < n - 1; ++i) { // time need for all but last train.\\n                time += (dist[i] + speed - 1) / speed;\\n            }\\n            time += (double)dist[n - 1] / speed; // The last train will not need to wait.\\n            if (time > hour) { // slow speed cost more time, search in higher speed space.\\n                lo = speed + 1;\\n            }else { // fast speed cost less time, search in lower speed space.\\n                hi = speed;\\n            }\\n        }\\n        return lo == 10_000_001 ? -1 : lo;\\n    }\\n```\n```python\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        lo, hi, n = 1, 10 ** 7 + 1, len(dist)\\n        while lo < hi:\\n            speed = lo + (hi - lo) // 2\\n            need = dist[-1] / speed + sum((dist[i] + speed - 1) // speed for i in range(n - 1))\\n            if need > hour:\\n                lo = speed + 1\\n            else:\\n                hi = speed\\n        return -1 if lo == 10 ** 7 + 1 else lo  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1224661,
                "title": "c-binary-search",
                "content": "Simple binary search problem with some details to be careful about.\\nWe only need to wait between two trains, so do a ceiling division of (distance/speed) for all trains but the last one, and do exact division for the last one.\\n\\nPerform binary search on solution space.\\n\\nTime Complexity: `O(N lg K)` where N = number of trains, K = range of solution space\\nSpace Complexity: `O(1)` since no extra space.\\n```\\nclass Solution\\n{\\n    bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818862,
                "title": "beats-100-users-proved-detailed-easy-to-understand-with-comments-in-each-line",
                "content": "![Screenshot 2023-07-26 165541.png](https://assets.leetcode.com/users/images/f6725356-527a-45dd-920d-680088c6c5fd_1690371353.667832.png)\\n# Intuition & Approach\\n```Described in code segments each line by line with comments details```\\n- If it helped please do **upvote**.\\n# Complexity\\n- Time complexity : O(n * log(1e7))\\n\\n- Space complexity : O(1)\\n\\n\\n# Code \\n```CPP []\\n\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(); // Get the size of the input vector \\'dist\\' (number of distances to travel)\\n        int minSpeed = 1, maxSpeed = 1e7 + 1; // Initialize the minimum and maximum possible speeds\\n        int answer = -1; // Initialize the variable to store the final answer\\n\\n        while (minSpeed < maxSpeed) { // Binary search loop to find the minimum required speed\\n            int midSpeed = minSpeed + (maxSpeed - minSpeed) / 2; // Calculate the middle speed\\n\\n            double totalHours = 0.0; // Initialize total travel time to 0\\n\\n            // Calculate the total hours required to travel each distance at the current middle speed\\n            for (int i = 0; i < n - 1; ++i) {\\n                // Add the time taken to travel distance at index i using current midSpeed to totalHours\\n                totalHours += std::ceil(static_cast<double>(dist[i]) / midSpeed);\\n            }\\n            // Add the time taken to travel the last distance using current midSpeed to totalHours\\n            totalHours += static_cast<double>(dist[n - 1]) / midSpeed;\\n\\n            if (totalHours > hour) {\\n                // If the total hours exceed the given hour, update minSpeed to consider higher speeds\\n                minSpeed = midSpeed + 1;\\n            } else {\\n                // If the total hours are within the given hour, update the answer to the current speed\\n                // and search for a potentially smaller speed in the lower half of the range.\\n                answer = midSpeed;\\n                maxSpeed = midSpeed;\\n            }\\n        }\\n\\n        return answer; // Return the minimum speed required to reach the destination on time\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist, hour):\\n        n = len(dist)  # Get the size of the input list \\'dist\\' (number of distances to travel)\\n        minSpeed, maxSpeed = 1, 10**7 + 1  # Initialize the minimum and maximum possible speeds\\n        answer = -1  # Initialize the variable to store the final answer\\n\\n        while minSpeed < maxSpeed:  # Binary search loop to find the minimum required speed\\n            midSpeed = minSpeed + (maxSpeed - minSpeed) // 2  # Calculate the middle speed\\n\\n            totalHours = 0.0  # Initialize total travel time to 0\\n\\n            # Calculate the total hours required to travel each distance at the current middle speed\\n            for i in range(n - 1):\\n                # Add the time taken to travel distance at index i using current midSpeed to totalHours\\n                totalHours += (dist[i] + midSpeed - 1) // midSpeed\\n\\n            # Add the time taken to travel the last distance using current midSpeed to totalHours\\n            totalHours += dist[n - 1] / midSpeed\\n\\n            if totalHours > hour:\\n                # If the total hours exceed the given hour, update minSpeed to consider higher speeds\\n                minSpeed = midSpeed + 1\\n            else:\\n                # If the total hours are within the given hour, update the answer to the current speed\\n                # and search for a potentially smaller speed in the lower half of the range.\\n                answer = midSpeed\\n                maxSpeed = midSpeed\\n\\n        return answer  # Return the minimum speed required to reach the destination on time\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```Described in code segments each line by line with comments details```\n```CPP []\\n\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(); // Get the size of the input vector \\'dist\\' (number of distances to travel)\\n        int minSpeed = 1, maxSpeed = 1e7 + 1; // Initialize the minimum and maximum possible speeds\\n        int answer = -1; // Initialize the variable to store the final answer\\n\\n        while (minSpeed < maxSpeed) { // Binary search loop to find the minimum required speed\\n            int midSpeed = minSpeed + (maxSpeed - minSpeed) / 2; // Calculate the middle speed\\n\\n            double totalHours = 0.0; // Initialize total travel time to 0\\n\\n            // Calculate the total hours required to travel each distance at the current middle speed\\n            for (int i = 0; i < n - 1; ++i) {\\n                // Add the time taken to travel distance at index i using current midSpeed to totalHours\\n                totalHours += std::ceil(static_cast<double>(dist[i]) / midSpeed);\\n            }\\n            // Add the time taken to travel the last distance using current midSpeed to totalHours\\n            totalHours += static_cast<double>(dist[n - 1]) / midSpeed;\\n\\n            if (totalHours > hour) {\\n                // If the total hours exceed the given hour, update minSpeed to consider higher speeds\\n                minSpeed = midSpeed + 1;\\n            } else {\\n                // If the total hours are within the given hour, update the answer to the current speed\\n                // and search for a potentially smaller speed in the lower half of the range.\\n                answer = midSpeed;\\n                maxSpeed = midSpeed;\\n            }\\n        }\\n\\n        return answer; // Return the minimum speed required to reach the destination on time\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist, hour):\\n        n = len(dist)  # Get the size of the input list \\'dist\\' (number of distances to travel)\\n        minSpeed, maxSpeed = 1, 10**7 + 1  # Initialize the minimum and maximum possible speeds\\n        answer = -1  # Initialize the variable to store the final answer\\n\\n        while minSpeed < maxSpeed:  # Binary search loop to find the minimum required speed\\n            midSpeed = minSpeed + (maxSpeed - minSpeed) // 2  # Calculate the middle speed\\n\\n            totalHours = 0.0  # Initialize total travel time to 0\\n\\n            # Calculate the total hours required to travel each distance at the current middle speed\\n            for i in range(n - 1):\\n                # Add the time taken to travel distance at index i using current midSpeed to totalHours\\n                totalHours += (dist[i] + midSpeed - 1) // midSpeed\\n\\n            # Add the time taken to travel the last distance using current midSpeed to totalHours\\n            totalHours += dist[n - 1] / midSpeed\\n\\n            if totalHours > hour:\\n                # If the total hours exceed the given hour, update minSpeed to consider higher speeds\\n                minSpeed = midSpeed + 1\\n            else:\\n                # If the total hours are within the given hour, update the answer to the current speed\\n                # and search for a potentially smaller speed in the lower half of the range.\\n                answer = midSpeed\\n                maxSpeed = midSpeed\\n\\n        return answer  # Return the minimum speed required to reach the destination on time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816882,
                "title": "binary-search-video-explanation-in-depth-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy linearly checking from speed 1 to 1^7 we will get tle its better to check by binary search because from binary search we can ignore the range which can not be answer.This will  help in finding efficiently.\\n\\nFor detailed explanation you can refer to my youtube channel (hindi Language) \\nhttps://youtu.be/-PXB7UH4xc4\\nor link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntime=distance/speed;\\nif speed increase time will decrease.\\n\\n1. We will perform a binary search to find Minimum Speed to Arrive on Time .\\n\\n2. Initialize two pointers, `i` and `j`, where `i` points to the minimum possible speed (1) and `j` points to the maximum possible speed (1e7 or 10^7).\\n\\n3. In each iteration of the binary search:\\n   - Calculate the mid-point `mid` between `i` and `j`.\\n   - Check if it is possible to reach office in time `hour` at the speed `mid`. If yes, update the minimum speed candidate and continue the search in the lower half by updating `j = mid - 1`.\\n   - If it is not possible to reach office at the current speed i.e taking time more than given hour then increase the speed so time will decrease , continue the search in the upper half by updating `i = mid + 1`.\\n\\n4. The binary search continues until `i` becomes greater than `j`.\\n\\n5. The function returns the minimum speed to arrive on time \\n\\n# Complexity\\n- Time complexity:$$O(nlogk)$$\\n(where k is 10^7)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>& dist,int speed,double hour){\\n        double ans=0;\\n        for(int i=0;i<dist.size();i++){\\n            double d=dist[i]*1.0/speed;\\n            if(i!=dist.size()-1)\\n            ans=ans+ceil(d);\\n            else\\n            ans+=d;\\n            if(ans>hour)\\n            return false;\\n        }\\n       if(ans<=hour)\\n       return true;\\n       return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int i=1;\\n        int j=1e7;\\n        int minspeed=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(ispossible(dist,mid,hour)){\\n               minspeed=mid;\\n               j=mid-1;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return minspeed;\\n    }\\n};\\n```\\n```java []\\n\\nclass Solution {\\n     public boolean isPossible(int[] dist, int speed, double hour) {\\n        double ans = 0;\\n        for (int i = 0; i < dist.length; i++) {\\n            double d = dist[i] * 1.0 / speed;\\n            if (i != dist.length - 1)\\n                ans = ans + Math.ceil(d);\\n            else\\n                ans += d;\\n            if (ans > hour)\\n                return false;\\n        }\\n        return ans <= hour;\\n    }\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n         int i = 1;\\n        int j = (int) 1e7;\\n        int minSpeed = -1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (isPossible(dist, mid, hour)) {\\n                minSpeed = mid;\\n                j = mid - 1;\\n            } else\\n                i = mid + 1;\\n        }\\n        return minSpeed;\\n    }\\n}\\n\\n```\\n```python3 []\\n\\nclass Solution:\\n    def isPossible(self, dist: List[int], speed: int, hour: float) -> bool:\\n        ans = 0\\n        for i in range(len(dist)):\\n            d = dist[i] * 1.0 / speed\\n            if i != len(dist) - 1:\\n                ans = ans + math.ceil(d)\\n            else:\\n                ans += d\\n            if ans > hour:\\n                return False\\n        return ans <= hour\\n\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        i, j = 1, int(1e7)\\n        min_speed = -1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if self.isPossible(dist, mid, hour):\\n                min_speed = mid\\n                j = mid - 1\\n            else:\\n                i = mid + 1\\n        return min_speed\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>& dist,int speed,double hour){\\n        double ans=0;\\n        for(int i=0;i<dist.size();i++){\\n            double d=dist[i]*1.0/speed;\\n            if(i!=dist.size()-1)\\n            ans=ans+ceil(d);\\n            else\\n            ans+=d;\\n            if(ans>hour)\\n            return false;\\n        }\\n       if(ans<=hour)\\n       return true;\\n       return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int i=1;\\n        int j=1e7;\\n        int minspeed=-1;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            if(ispossible(dist,mid,hour)){\\n               minspeed=mid;\\n               j=mid-1;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return minspeed;\\n    }\\n};\\n```\n```java []\\n\\nclass Solution {\\n     public boolean isPossible(int[] dist, int speed, double hour) {\\n        double ans = 0;\\n        for (int i = 0; i < dist.length; i++) {\\n            double d = dist[i] * 1.0 / speed;\\n            if (i != dist.length - 1)\\n                ans = ans + Math.ceil(d);\\n            else\\n                ans += d;\\n            if (ans > hour)\\n                return false;\\n        }\\n        return ans <= hour;\\n    }\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n         int i = 1;\\n        int j = (int) 1e7;\\n        int minSpeed = -1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (isPossible(dist, mid, hour)) {\\n                minSpeed = mid;\\n                j = mid - 1;\\n            } else\\n                i = mid + 1;\\n        }\\n        return minSpeed;\\n    }\\n}\\n\\n```\n```python3 []\\n\\nclass Solution:\\n    def isPossible(self, dist: List[int], speed: int, hour: float) -> bool:\\n        ans = 0\\n        for i in range(len(dist)):\\n            d = dist[i] * 1.0 / speed\\n            if i != len(dist) - 1:\\n                ans = ans + math.ceil(d)\\n            else:\\n                ans += d\\n            if ans > hour:\\n                return False\\n        return ans <= hour\\n\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        i, j = 1, int(1e7)\\n        min_speed = -1\\n        while i <= j:\\n            mid = i + (j - i) // 2\\n            if self.isPossible(dist, mid, hour):\\n                min_speed = mid\\n                j = mid - 1\\n            else:\\n                i = mid + 1\\n        return min_speed\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224638,
                "title": "clean-python-3-binary-search",
                "content": "Just binary search possible speed range\\nTime: `O(NlogR)`, where R is the possible speed range\\nSpace: `O(1)`\\n\\n```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        is_ontime = lambda s: sum(math.ceil(d / s) for d in dist[:-1]) + dist[-1] / s <= hour\\n        low, high = 0, 10**7\\n        while low + 1 < high:\\n            mid = low + (high - low) // 2\\n            if is_ontime(mid):\\n                high = mid\\n            else:\\n                low = mid\\n        return high if is_ontime(high) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        is_ontime = lambda s: sum(math.ceil(d / s) for d in dist[:-1]) + dist[-1] / s <= hour\\n        low, high = 0, 10**7\\n        while low + 1 < high:\\n            mid = low + (high - low) // 2\\n            if is_ontime(mid):\\n                high = mid\\n            else:\\n                low = mid\\n        return high if is_ontime(high) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817194,
                "title": "java-easy-solution",
                "content": "# Intuition\\nThe problem can be solved using binary search. We want to find the minimum positive integer speed such that we can reach the office on time. We can use binary search to efficiently find this speed.\\n\\n# Approach\\nThe `minSpeedOnTime` function uses binary search to find the minimum speed required for the trains to reach the office on time. It initializes the search space for the speed from 1 to 10^7 (as stated in the problem). It then iteratively performs binary search to narrow down the search space until it finds the minimum speed that allows reaching the office on time.\\n\\nThe `isPossible` function checks if it is possible to reach the office on time with a given speed. It calculates the time required for each train ride based on the given speed and adds up the time for all the rides. If the total time is less than or equal to the given hour, then it returns true; otherwise, it returns false.\\n\\n# Complexity\\n- ***Time complexity:*** O(log n * n), where n is the number of train rides.\\n\\n- ***Space complexity:*** O(1) because the algorithm uses a constant amount of extra space regardless of the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        \\n        int length = dist.length;\\n        \\n        int start = 1;\\n        int end = (int)1e7;\\n        int ans = -1;\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(isPossible(dist,hour,mid,length)){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int[] dist,double hour,int speed,int length){\\n        double ans = 0;\\n        for(int i=0;i<length;i++){\\n            double time = dist[i]*1.0/speed;\\n            if(i!=length-1)ans = ans + Math.ceil(time);\\n            else ans += time;\\n            if(ans>hour) return false;\\n        }\\n        return ans<=hour;\\n    }\\n}\\n```\\n\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/4b9d254d-769f-456a-bf0f-84b90753eb39_1690343995.8209772.webp)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        \\n        int length = dist.length;\\n        \\n        int start = 1;\\n        int end = (int)1e7;\\n        int ans = -1;\\n\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(isPossible(dist,hour,mid,length)){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int[] dist,double hour,int speed,int length){\\n        double ans = 0;\\n        for(int i=0;i<length;i++){\\n            double time = dist[i]*1.0/speed;\\n            if(i!=length-1)ans = ans + Math.ceil(time);\\n            else ans += time;\\n            if(ans>hour) return false;\\n        }\\n        return ans<=hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224716,
                "title": "simple-approach-using-binary-search-on-answer-easy-understandable-code-o-n-log-10-7",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n\\n**Simplified Problem Statement:** The task is to find the minimum speed(say S) such that the sum of ceil values the first (N - 1) distances/S + floor value of last distances/S is at most the given hour value.\\n\\n**Approach:** The given problem can be solved by using \"Binary Search on answer\". As the minimum and the maximum possible values of speed is 1 and 10000000 respectively. So the idea is to perform Binary Search for each value of the speed in this range check for the minimum value of S in this range satisfying the given criteria.\\n\\nBelow is the implementation with detailed comment:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to find the total number\\n    // hours needed to cover all the distances\\n    // with speed K\\n    double countTotalHours(vector<int> &arr, int N, int K) {\\n        \\n        // Stores the total hours needed\\n        double ans = 0.0;\\n\\n        // Find the sum of ceil values of\\n        // the first (N - 1) distances/K\\n        for(int i = 0; i < N - 1; i++) {\\n            ans += ceil((double)(1.0*arr[i])/K);\\n        }\\n        \\n        ans += (1.0*arr[N - 1])/K;\\n        \\n        // Return the total hours\\n        return ans;\\n        \\n    }\\n    \\n    // Driver Function\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int N = dist.size();\\n\\n        // Stores the resultant minimum speed value\\n        int ans = INT_MAX;\\n\\n        // Stores the minimum and the maximum ranges\\n        // of speed that can be possible\\n        int low = 1;\\n        int high = 10000000;\\n\\n        // Perform the Binary Search for the range\\n        // [low, high]\\n        while(low <= high) {\\n            \\n            // Find the middle speed value\\n            int mid = low + (high - low)/2;\\n\\n            // Function to find the total number\\n            // hours needed to cover all the distances\\n            // according to the given criteria\\n            double count = countTotalHours(dist, N, mid);\\n\\n            // If the count of hours is less than\\n            // the given hours then mid can be the\\n            // one of the possible values of hours\\n\\n            // Now, our range shrinks to\\n            // [low, mid]\\n            if(count <= hour) {\\n\\n                // Update the minimum\\n                // answer value of hour\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            \\n            // If the count of hours is greater\\n            // than the given hours then all values\\n            // before mid can\\'t be the possible\\n            //  values of hours\\n\\n            // Now, our range shrinks to\\n            // [mid + 1, high]\\n            \\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        // If the minimum speed doesn\\'t exists\\n        // then return -1. Otherwise, return ans\\n        return (ans == INT_MAX ? -1 : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to find the total number\\n    // hours needed to cover all the distances\\n    // with speed K\\n    double countTotalHours(vector<int> &arr, int N, int K) {\\n        \\n        // Stores the total hours needed\\n        double ans = 0.0;\\n\\n        // Find the sum of ceil values of\\n        // the first (N - 1) distances/K\\n        for(int i = 0; i < N - 1; i++) {\\n            ans += ceil((double)(1.0*arr[i])/K);\\n        }\\n        \\n        ans += (1.0*arr[N - 1])/K;\\n        \\n        // Return the total hours\\n        return ans;\\n        \\n    }\\n    \\n    // Driver Function\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int N = dist.size();\\n\\n        // Stores the resultant minimum speed value\\n        int ans = INT_MAX;\\n\\n        // Stores the minimum and the maximum ranges\\n        // of speed that can be possible\\n        int low = 1;\\n        int high = 10000000;\\n\\n        // Perform the Binary Search for the range\\n        // [low, high]\\n        while(low <= high) {\\n            \\n            // Find the middle speed value\\n            int mid = low + (high - low)/2;\\n\\n            // Function to find the total number\\n            // hours needed to cover all the distances\\n            // according to the given criteria\\n            double count = countTotalHours(dist, N, mid);\\n\\n            // If the count of hours is less than\\n            // the given hours then mid can be the\\n            // one of the possible values of hours\\n\\n            // Now, our range shrinks to\\n            // [low, mid]\\n            if(count <= hour) {\\n\\n                // Update the minimum\\n                // answer value of hour\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            }\\n            \\n            // If the count of hours is greater\\n            // than the given hours then all values\\n            // before mid can\\'t be the possible\\n            //  values of hours\\n\\n            // Now, our range shrinks to\\n            // [mid + 1, high]\\n            \\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        // If the minimum speed doesn\\'t exists\\n        // then return -1. Otherwise, return ans\\n        return (ans == INT_MAX ? -1 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817245,
                "title": "binary-search-easy-explanation-short-code-faster-than-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have ans limit from 1 to 10^7 and we have to find minimum speed to reach the office on time .\\nso whenever there is range given for ans then here comes binary search in picture.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make l=1 , r= 10^7\\n- Now we have to ceiling of all time until n-2 because we have to wait for next train to arrive at integer time.\\n- But last stop is our destination so we dont need to wait hence we can add non-integer time.\\n- For every mid we try to find minimum speed to reach destination.\\n- Base case: we need hours at least greater than n-1 because we have to wait for another train until next integer. \\n\\n# Complexity\\n- Time complexity:O(Nlog(10^7))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= n-1) return -1;\\n        int l=1 , r=1e7;\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            double time =0;\\n            for(int i=0 ; i<n-1 ; i++) time += ceil((double)dist[i]/mid);\\n            time += (double)dist[n-1]/mid;\\n\\n            if(time <= hour) r =mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= n-1) return -1;\\n        int l=1 , r=1e7;\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            double time =0;\\n            for(int i=0 ; i<n-1 ; i++) time += ceil((double)dist[i]/mid);\\n            time += (double)dist[n-1]/mid;\\n\\n            if(time <= hour) r =mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224727,
                "title": "easy-to-understand-python-solution-explained",
                "content": "This problem is *almost* the same as [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) problem on leetcode. The approach is to perform a binary search on the range of speed from `1 - 10^7` and see if it is reachable.\\n\\n```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n      def can_reach(speed):\\n        so_far = 0\\n        for i in range(len(dist) - 1):\\n            so_far += math.ceil(dist[i] / speed)\\n            if so_far > hour:\\n                return False\\n        return (so_far + (dist[-1] / speed)) <= hour\\n\\n      l = 1\\n      r = 10**7\\n      max_speed = -1\\n      while l <= r:\\n          m = (l + r) // 2\\n          if can_reach(m):\\n              max_speed = m\\n              r = m - 1\\n          else:\\n              l = m + 1\\n      return max_speed\\n```\\n\\nPlease upvote if you think this solution helped.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n      def can_reach(speed):\\n        so_far = 0\\n        for i in range(len(dist) - 1):\\n            so_far += math.ceil(dist[i] / speed)\\n            if so_far > hour:\\n                return False\\n        return (so_far + (dist[-1] / speed)) <= hour\\n\\n      l = 1\\n      r = 10**7\\n      max_speed = -1\\n      while l <= r:\\n          m = (l + r) // 2\\n          if can_reach(m):\\n              max_speed = m\\n              r = m - 1\\n          else:\\n              l = m + 1\\n      return max_speed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225082,
                "title": "binary-search-c-refer-to-more-question-given-in-post",
                "content": "**Binary search IMP question list**\\n**code in c++**\\n```\\nclass Solution {\\npublic:\\n    bool satisfy(int mid, vector<int>& dist, double hour)\\n    {\\n        double time = 0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            time += ceil((double)dist[i]/mid);\\n        }\\n        time+=((double)dist.back())/mid;\\n        if(time<=hour)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        // base condition\\n        if(n>ceil(hour))\\n        {\\n            return -1;\\n        }\\n        \\n        int i = 1; // as the lowest answer can be one\\n        int j = 1e7; // as maximum is given in the question\\n        int res = -1;\\n        while(i<=j)\\n        {\\n            int mid = (i+j)/2;\\n            if(satisfy(mid,dist,hour)==true)\\n            {\\n                res = mid;\\n                j = mid-1;\\n                \\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**REFER THESE QUESTIONS FOR MORE UNDERSTANDING**\\n*logic is same in all problems*\\n[875. Koko Eating Bananas\\n](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011. Capacity To Ship Packages Within D Days\\n](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[1283. Find the Smallest Divisor Given a Threshold\\n](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n[1482. Minimum Number of Days to Make m Bouquets\\n](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n[2064. Minimized Maximum of Products Distributed to Any Store\\n](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n\\n**i hope these problems will help**\\n**do upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool satisfy(int mid, vector<int>& dist, double hour)\\n    {\\n        double time = 0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            time += ceil((double)dist[i]/mid);\\n        }\\n        time+=((double)dist.back())/mid;\\n        if(time<=hour)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        // base condition\\n        if(n>ceil(hour))\\n        {\\n            return -1;\\n        }\\n        \\n        int i = 1; // as the lowest answer can be one\\n        int j = 1e7; // as maximum is given in the question\\n        int res = -1;\\n        while(i<=j)\\n        {\\n            int mid = (i+j)/2;\\n            if(satisfy(mid,dist,hour)==true)\\n            {\\n                res = mid;\\n                j = mid-1;\\n                \\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818295,
                "title": "simple-approach-binary-search-unbounded-self-explanatory-code-tc-o-n-log-1e7",
                "content": "# Intuition\\n1. Note that decimal part is only contributed by the last element.\\n2. _*hour*_ should be greater than minimum possible time.\\n\\n# Approach\\n1. Get the slowest possible speed and fastest possible speed using **Unbounded Binary Search.**\\n2. To check equality of _double_ value we are using : **abs(val1 - val2) <= 1e-12**\\n\\n# Complexity\\n- Time complexity: $$O(n * log(1e7))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Return time required for the given speed\\n    double timeFor(vector<int>& dist,int speed,double lastEle){\\n        double time = lastEle / (double)speed;\\n\\n        for(int &d:dist)\\n            time += ceil((double)d/(double)speed);\\n\\n        return time;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double lastEle = dist.back();\\n        dist.pop_back();\\n\\n        double minTime = lastEle/10000000 + (double)dist.size();\\n        double maxTime = 0.0+lastEle;\\n        for(int &d:dist)\\n            maxTime += 0.0+d;\\n\\n        if(hour >= minTime){\\n            int speedLo = 1;\\n            int speedHi = 1;\\n            while(true){\\n                double thisTime = timeFor(dist,speedHi,lastEle);\\n                if(thisTime <= hour){\\n                    speedLo = speedHi/2;\\n                    break;\\n                }\\n                speedHi *= 2;\\n            }\\n\\n            // answer is btn speedLo, speedHi\\n            int res = speedHi;\\n            while(speedLo <= speedHi){\\n                int speedMid = speedLo + (speedHi - speedLo)/2;\\n\\n                // if speedMid gives required answer then\\n                // search before speedMid\\n                double thisTime = timeFor(dist,speedMid,lastEle);\\n\\n                if(thisTime < hour || abs(thisTime - hour) <= 1e-12){\\n                    res = min(res,speedMid);\\n                    speedHi = speedMid-1;\\n                }\\n                else\\n                    speedLo = speedMid+1;\\n            }\\n            return res;\\n        }\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Return time required for the given speed\\n    double timeFor(vector<int>& dist,int speed,double lastEle){\\n        double time = lastEle / (double)speed;\\n\\n        for(int &d:dist)\\n            time += ceil((double)d/(double)speed);\\n\\n        return time;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double lastEle = dist.back();\\n        dist.pop_back();\\n\\n        double minTime = lastEle/10000000 + (double)dist.size();\\n        double maxTime = 0.0+lastEle;\\n        for(int &d:dist)\\n            maxTime += 0.0+d;\\n\\n        if(hour >= minTime){\\n            int speedLo = 1;\\n            int speedHi = 1;\\n            while(true){\\n                double thisTime = timeFor(dist,speedHi,lastEle);\\n                if(thisTime <= hour){\\n                    speedLo = speedHi/2;\\n                    break;\\n                }\\n                speedHi *= 2;\\n            }\\n\\n            // answer is btn speedLo, speedHi\\n            int res = speedHi;\\n            while(speedLo <= speedHi){\\n                int speedMid = speedLo + (speedHi - speedLo)/2;\\n\\n                // if speedMid gives required answer then\\n                // search before speedMid\\n                double thisTime = timeFor(dist,speedMid,lastEle);\\n\\n                if(thisTime < hour || abs(thisTime - hour) <= 1e-12){\\n                    res = min(res,speedMid);\\n                    speedHi = speedMid-1;\\n                }\\n                else\\n                    speedLo = speedMid+1;\\n            }\\n            return res;\\n        }\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816980,
                "title": "binary-search-video-solution-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/mV6aB5RPLmo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        if(hour<dist.length-1) return -1;\\n        int l = 0;\\n        int r = 10000000;\\n        int m;\\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2;            \\n            if(check(dist, hour, m)){\\n                ans = m;\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int [] dist, double hour, double speed){\\n       \\n        double time = 0;\\n        int i = 0;\\n        while(time<=hour && i<dist.length-1){\\n            time += Math.ceil(dist[i]/speed);\\n            i++;\\n        }\\n        time +=dist[dist.length-1]/speed;\\n        return (time<=hour);\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if (hour < dist.size() - 1) return -1;\\n        int l = 0;\\n        int r = 10000000;\\n        int m;\\n        int ans = -1;\\n        while (l <= r) {\\n            m = (l + r) / 2;            \\n            if (check(dist, hour, m)) {\\n                ans = m;\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(vector<int>& dist, double hour, int speed) {\\n        double time = 0;\\n        int i = 0;\\n        while (time <= hour && i < dist.size() - 1) {\\n            time += ceil(static_cast<double>(dist[i]) / speed);\\n            i++;\\n        }\\n        time += static_cast<double>(dist[dist.size() - 1]) / speed;\\n        return (time <= hour);\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour < len(dist) - 1:\\n            return -1\\n\\n        l, r = 1, 10**7\\n        ans = -1\\n\\n        while l <= r:\\n            m = (l + r) // 2\\n            if self.check(dist, hour, m):\\n                ans = m\\n                r = m - 1\\n            else:\\n                l = m + 1\\n\\n        return ans\\n\\n    def check(self, dist: List[int], hour: float, speed: int) -> bool:\\n        time = 0.0\\n        i = 0\\n        while time <= hour and i < len(dist) - 1:\\n            time += math.ceil(dist[i] / speed)\\n            i += 1\\n\\n        time += dist[-1] / speed\\n        return time <= hour\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        if(hour<dist.length-1) return -1;\\n        int l = 0;\\n        int r = 10000000;\\n        int m;\\n        int ans = -1;\\n        while(l<=r){\\n            m = (l+r)/2;            \\n            if(check(dist, hour, m)){\\n                ans = m;\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int [] dist, double hour, double speed){\\n       \\n        double time = 0;\\n        int i = 0;\\n        while(time<=hour && i<dist.length-1){\\n            time += Math.ceil(dist[i]/speed);\\n            i++;\\n        }\\n        time +=dist[dist.length-1]/speed;\\n        return (time<=hour);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if (hour < dist.size() - 1) return -1;\\n        int l = 0;\\n        int r = 10000000;\\n        int m;\\n        int ans = -1;\\n        while (l <= r) {\\n            m = (l + r) / 2;            \\n            if (check(dist, hour, m)) {\\n                ans = m;\\n                r = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(vector<int>& dist, double hour, int speed) {\\n        double time = 0;\\n        int i = 0;\\n        while (time <= hour && i < dist.size() - 1) {\\n            time += ceil(static_cast<double>(dist[i]) / speed);\\n            i++;\\n        }\\n        time += static_cast<double>(dist[dist.size() - 1]) / speed;\\n        return (time <= hour);\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour < len(dist) - 1:\\n            return -1\\n\\n        l, r = 1, 10**7\\n        ans = -1\\n\\n        while l <= r:\\n            m = (l + r) // 2\\n            if self.check(dist, hour, m):\\n                ans = m\\n                r = m - 1\\n            else:\\n                l = m + 1\\n\\n        return ans\\n\\n    def check(self, dist: List[int], hour: float, speed: int) -> bool:\\n        time = 0.0\\n        i = 0\\n        while time <= hour and i < len(dist) - 1:\\n            time += math.ceil(dist[i] / speed)\\n            i += 1\\n\\n        time += dist[-1] / speed\\n        return time <= hour\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226759,
                "title": "what-if-there-s-no-upper-limit-when-to-return-1",
                "content": "Here is my thinking process: \\n\\n1. There are n distances in the input array, even if the train runs at light speed it still takes minimum 1 hour on each stop from the first one to the (n-1)th.\\n\\n2. That is to say, if the train runs incredibly fast, and if there\\'s still remaining time for the last stop, we can calculate for a valid answer. Otherwise, return -1.\\n\\n\\t e.g: In Example #2, dist = [1,3,2], hour = 2.7. The train can take 2 hours minimum for distance 1 and 3, and there\\'s still 0.7 hours remaining for the last stop which has distance 2. There should be an answer for this case.\\n\\t \\n\\t Though in Example #3, dist = [1,3,2], hour = 1.9. After the train takes 2 hours minimum for distance 1 and 3, there\\'s no time left for the last stop. Thus returns -1.\\n\\t \\n\\t In code we can use a simple if statement to check:\\n\\t ```\\n\\t if (hour < (double)(dist.length - 1)) {\\n\\t\\treturn -1;\\n\\t}\\n\\t```\\n3. If there can be a valid answer, to find the minimum speed we can try with each possible speed from 1 to the fastest speed. If the speed can make us arrive on time we can say it is a valid speed, and our goal is to find the minimum one among all the valid speed. At this point I realize that this problem can be solved with binary search. Thus we need to find the fastest speed. \\n\\n4. I noticed that many high voted posts directly use the upper distance/time limit. This could be a nice trick but what if this upper limit is unknown? I think it will make more sense if we can find out the upper limit ourselves. \\n\\n\\tDuring the previous analysis I thought the previous n-1 stops were not important, so in the beginning I was focused on the distance of the last stop only. Taking example #2 I noticed that if the speed is (2 / 0.7) (last distance / remaining time), this could be the fastest speed. However my calculation based on this failed. In short the mistakes are:\\n\\t\\n\\ta. If the remaining time is large enough, say the last distance is 1 and the remaining time is 10 hours. Apparently, a slower speed can be 1 rather than 1/10 and I filtered it out. So we need to determine a fastest speed based on if the remining time is < 1.\\n\\t\\n\\tb. Focusing on the last stop is also wrong. Imagine a case like this dist = [1,1,100,1], if we choose the fastest speed as 1 we will spend 100 hours on the third stop rather than 1 hour minimum. Then I realize to find out the fastest speed, we also need to consider the longest travel distance in the entire input array.\\n\\t\\nHere is my AC solution:\\n```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n\\tint n = dist.length;\\n\\tif (hour < (double)(n - 1)) {\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint maxDistance = 0;\\n\\tfor (int d : dist) {\\n\\t\\tmaxDistance = Math.max(maxDistance, d);\\n\\t}\\n\\n\\t// Determine fastest speed, based on the train with max distance and the last time slot;\\n\\tint fastestSpd = hour - (double)(n - 1) >= 1 ? maxDistance :(int)Math.ceil((double)maxDistance / (hour - (double)(n - 1)));\\n\\n\\t// from speed 1 to fastestSpd, use binary search to find the min speed that is valid\\n\\tint start = 1;\\n\\tint end = fastestSpd;\\n\\twhile (start + 1 < end) {\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tif (isSpdValid(mid, dist, hour)) {\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tstart = mid;\\n\\t\\t}\\n\\t}\\n\\n\\tif (isSpdValid(start, dist, hour)) {\\n\\t\\treturn start;\\n\\t}\\n\\n\\treturn end;\\n}\\n\\nprivate boolean isSpdValid(int speed, int[] dist, double hour) {\\n\\tdouble time = 0d;\\n\\tfor (int i = 0; i < dist.length - 1; i++) {\\n\\t\\ttime += Math.ceil((double)dist[i] / (double)speed);\\n\\t}\\n\\n\\ttime += (double)dist[dist.length - 1] / (double)speed;\\n\\treturn time <= hour;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n\\t if (hour < (double)(dist.length - 1)) {\\n\\t\\treturn -1;\\n\\t}\\n\\t```\n```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n\\tint n = dist.length;\\n\\tif (hour < (double)(n - 1)) {\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tint maxDistance = 0;\\n\\tfor (int d : dist) {\\n\\t\\tmaxDistance = Math.max(maxDistance, d);\\n\\t}\\n\\n\\t// Determine fastest speed, based on the train with max distance and the last time slot;\\n\\tint fastestSpd = hour - (double)(n - 1) >= 1 ? maxDistance :(int)Math.ceil((double)maxDistance / (hour - (double)(n - 1)));\\n\\n\\t// from speed 1 to fastestSpd, use binary search to find the min speed that is valid\\n\\tint start = 1;\\n\\tint end = fastestSpd;\\n\\twhile (start + 1 < end) {\\n\\t\\tint mid = start + (end - start) / 2;\\n\\t\\tif (isSpdValid(mid, dist, hour)) {\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tstart = mid;\\n\\t\\t}\\n\\t}\\n\\n\\tif (isSpdValid(start, dist, hour)) {\\n\\t\\treturn start;\\n\\t}\\n\\n\\treturn end;\\n}\\n\\nprivate boolean isSpdValid(int speed, int[] dist, double hour) {\\n\\tdouble time = 0d;\\n\\tfor (int i = 0; i < dist.length - 1; i++) {\\n\\t\\ttime += Math.ceil((double)dist[i] / (double)speed);\\n\\t}\\n\\n\\ttime += (double)dist[dist.length - 1] / (double)speed;\\n\\treturn time <= hour;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766345,
                "title": "python-3-bs-allocate-books-koko-bananas-pattern-similar-problems-solutions",
                "content": "# Solution:\\nIt\\'s classic problem like [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/) or [Allocated Books (not leetcode)](https://www.algotree.org/algorithms/binary_search/allot_books/)\\n```python3 []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) > ceil(hour): return -1\\n\\n        def isEnoughSpeed(s):\\n            return sum(ceil(d/s) if i != L else d/s for i, d in enumerate(dist)) <= hour\\n\\n        l, r, L = 1, 10**7, len(dist)-1\\n        \\n        while l < r:\\n            speed = (l+r)//2\\n            if isEnoughSpeed(speed):\\n                r = speed\\n            else:\\n                l = speed + 1\\n        \\n        return l\\n```\\n# Pattern:\\nIs fixed right pointer `r = m` need to take left mid value like `(l+r)//2`, if fixed left pointer `l = m` take right mid value `(l+r+1)//2`).\\nPoints `l` and `r` can be different for each problem. The main idea how choose diapason: all possible values should be in the interval `[l, r]`.\\n```python3 []\\ndef doSomething:   \\n    l, r = 1, len(nums)\\n\\n    def isEnough(k):\\n        return True\\n\\n    while l < r:\\n        m = (l+r)//2\\n        if isEnough(m):\\n            r = m\\n        else:\\n            l = m + 1\\n\\n    return l\\n```\\n```python3 []\\ndef doSomething:   \\n    l, r = 1, len(nums)\\n\\n    def isEnough(k):\\n        return True\\n\\n    while l < r:\\n        m = (l+r+1)//2\\n        if isEnough(m):\\n            l = m\\n        else:\\n            r = m - 1\\n\\n    return l\\n```\\n# Similar problems links:\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/)\\n[1898. Maximum Number of Removable Characters](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\\n[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\\n\\n# Similar problems solutions:\\n[2187. Minimum Time to Complete Trips\\n](https://leetcode.com/problems/minimum-time-to-complete-trips/description)\\n```python3 []\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left, right = 1, min(time) * totalTrips\\n\\n        def isEnoughTime(tripsTime):\\n            return sum(tripsTime// t for t in time) >= totalTrips\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if isEnoughTime(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left  \\n```\\n[875. Koko Eating Bananas\\n](https://leetcode.com/problems/koko-eating-bananas/description/)\\n```python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        \\n        def isSufficientSpeed(cnt):\\n            return sum(ceil(i/cnt) for i in piles) <= h\\n\\n        while l < r:\\n            m = (l + r)//2\\n            if isSufficientSpeed(m):\\n                r = m\\n            else:\\n                l = m + 1\\n                \\n        return l\\n```\\n\\n[1482. Minimum Number of Days to Make m Bouquets\\n](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/)\\n```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = (l+r)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l        \\n```\\n\\n[1283. Find the Smallest Divisor Given a Threshold\\n](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/)\\n```python3 []\\nclass Solution:\\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\\n        l, r = 1, max(nums)\\n        def isEnough(k):\\n            return sum(ceil(n/k) for n in nums) <= threshold\\n        \\n        while l < r:\\n            mid = (l+r)//2\\n            if isEnough(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        return l   \\n```\\n[1011. Capacity To Ship Packages Within D Days\\n](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/)\\n```python3 []\\nclass Solution:\\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\\n        l, r = max(weights), sum(weights)\\n\\n        def isPossibleToShip(maxCapacity):\\n            needDays, curCapacity = 1, 0\\n            for w in weights:\\n                curCapacity += w\\n                if curCapacity > maxCapacity:\\n                    needDays += 1\\n                    curCapacity = w\\n                    if needDays > days: break\\n\\n            return needDays <= days\\n\\n        while l < r:\\n            m = l + (r-l)//2\\n            if isPossibleToShip(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l   \\n```\\n[1760. Minimum Limit of Balls in a Bag\\n](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/)\\n```python3 []\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n\\n        def isEnoughSize(size):\\n            operations = 0\\n            for n in nums:\\n                if n <= size: continue\\n                operations += (n-1)//size\\n                if operations > maxOperations: return False\\n\\n            return True\\n\\n        while l < r:\\n            m = (l+r)//2\\n            if isEnoughSize(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l \\n```\\n\\n[1552. Magnetic Force Between Two Balls\\n](https://leetcode.com/problems/magnetic-force-between-two-balls/description/)\\n```python3 []\\nclass Solution:\\n    def maxDistance(self, positions: List[int], m: int) -> int:\\n        def isEnough(step):\\n            balls, curPos = 1, first\\n            while balls < m:\\n                minDist = curPos + step\\n                if minDist > last: break\\n                curPos = positions[bisect_left(positions, minDist)]\\n                balls += 1\\n\\n            return balls == m\\n\\n        positions.sort()\\n        \\n        l, r, first, last = 1, positions[-1]//(m-1), positions[0], positions[-1]\\n        if m == 2: return last - first\\n\\n        while l < r:\\n            mid = (l+r+1)//2\\n            if isEnough(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n        \\n        return l \\n```\\n\\n[2226. Maximum Candies Allocated to K Children\\n](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/)\\n```python3 []\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        S = sum(candies)\\n        if S < k: return 0 \\n\\n        l, r = 1, S//k\\n\\n        def isEnough(p):\\n            return sum(c//p for c in candies) >= k\\n\\n        while l < r:\\n            m = (l+r+1)//2 # to get most right element\\n            if isEnough(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n```\\n\\n[2064. Minimized Maximum of Products Distributed to Any Store\\n](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/)\\n```python3 []\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        if n == 0: return quantities[0]\\n        \\n        def isEnough(maxCnt):\\n            return sum(ceil(q/maxCnt) for q in quantities) <= n\\n\\n        l, r = 1, max(quantities)\\n        while l < r:\\n            mid = (l+r)//2\\n            if isEnough(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```\\n\\n[1898. Maximum Number of Removable Characters\\n](https://leetcode.com/problems/maximum-number-of-removable-characters/description/)\\n```python3 []\\nclass Solution:\\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        l, r = 0, len(removable)\\n\\n        def isEnough(k):\\n            s_arr = list(s)\\n            for i in removable[:k]:\\n                s_arr[i] = \\'\\'\\n            return isSubsequence(p, s_arr)\\n            \\n        def isSubsequence(s, t):\\n            t = iter(t)\\n            flag = all(c in t for c in s)   \\n            return flag\\n\\n        while l < r:\\n            m = (l+r+1)//2\\n            if isEnough(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n```\\n\\n[668. Kth Smallest Number in Multiplication Table (hard)\\n](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n```python3 []\\nclass Solution:\\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\\n        def isEnough(x):\\n            cnt = 0 # count of values <= maxVal\\n            for i in range(1, m+1):\\n                cnt += min(x // i, n)\\n                if cnt > k: break\\n            return cnt >= k\\n        \\n        l, r = 1, m * n\\n\\n        while l < r:\\n            x = l + (r-l)//2\\n            if isEnough(x):\\n                r = x\\n            else:\\n                l = x + 1\\n        \\n        return l\\n```\\n\\n[410. Split Array Largest Sum (hard)\\n](https://leetcode.com/problems/split-array-largest-sum/)\\n```python3 []\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        l, r = max(nums), sum(nums)\\n        \\n        def isSplitted(maxSum):\\n            curSum, parts = 0, 1\\n            for n in nums:\\n                curSum += n\\n                if curSum > maxSum:\\n                    parts += 1\\n                    if parts > k: break\\n                    curSum = n\\n            return parts <= k\\n\\n        while l < r:\\n            m = l + (r-l)//2\\n            if isSplitted(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l\\n```\\n\\n[719. Find K-th Smallest Pair Distance (hard)\\n](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\\n```python3 []\\nclass Solution:\\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l, r = 0, len(nums)-1\\n\\n        def isKAndMorePairs(p):\\n            pairs = (p * (p-1))//2\\n            return pairs >= k\\n        \\n        while l < r:\\n            m = (l + r)//2\\n            if isKAndMorePairs(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) > ceil(hour): return -1\\n\\n        def isEnoughSpeed(s):\\n            return sum(ceil(d/s) if i != L else d/s for i, d in enumerate(dist)) <= hour\\n\\n        l, r, L = 1, 10**7, len(dist)-1\\n        \\n        while l < r:\\n            speed = (l+r)//2\\n            if isEnoughSpeed(speed):\\n                r = speed\\n            else:\\n                l = speed + 1\\n        \\n        return l\\n```\n```python3 []\\ndef doSomething:   \\n    l, r = 1, len(nums)\\n\\n    def isEnough(k):\\n        return True\\n\\n    while l < r:\\n        m = (l+r)//2\\n        if isEnough(m):\\n            r = m\\n        else:\\n            l = m + 1\\n\\n    return l\\n```\n```python3 []\\ndef doSomething:   \\n    l, r = 1, len(nums)\\n\\n    def isEnough(k):\\n        return True\\n\\n    while l < r:\\n        m = (l+r+1)//2\\n        if isEnough(m):\\n            l = m\\n        else:\\n            r = m - 1\\n\\n    return l\\n```\n```python3 []\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left, right = 1, min(time) * totalTrips\\n\\n        def isEnoughTime(tripsTime):\\n            return sum(tripsTime// t for t in time) >= totalTrips\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if isEnoughTime(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left  \\n```\n```python3 []\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        l, r = 1, max(piles)\\n        \\n        def isSufficientSpeed(cnt):\\n            return sum(ceil(i/cnt) for i in piles) <= h\\n\\n        while l < r:\\n            m = (l + r)//2\\n            if isSufficientSpeed(m):\\n                r = m\\n            else:\\n                l = m + 1\\n                \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def minDays(self, bloomDay: List[int], m: int, k: int) -> int:\\n        if len(bloomDay) < m * k: return -1\\n\\n        def isEnoughDays(days):\\n            flowers, bouquets = 0, 0\\n            for d in bloomDay:\\n                flowers = flowers + 1 if d <= days else 0\\n                if flowers == k:\\n                    bouquets += 1\\n                    if bouquets == m: break\\n                    flowers = 0\\n            \\n            return bouquets == m\\n\\n        l, r = 1, max(bloomDay)\\n        while l < r:\\n            days = (l+r)//2\\n            if isEnoughDays(days):\\n                r = days\\n            else:\\n                l = days + 1\\n        \\n        return l        \\n```\n```python3 []\\nclass Solution:\\n    def smallestDivisor(self, nums: List[int], threshold: int) -> int:\\n        l, r = 1, max(nums)\\n        def isEnough(k):\\n            return sum(ceil(n/k) for n in nums) <= threshold\\n        \\n        while l < r:\\n            mid = (l+r)//2\\n            if isEnough(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        return l   \\n```\n```python3 []\\nclass Solution:\\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\\n        l, r = max(weights), sum(weights)\\n\\n        def isPossibleToShip(maxCapacity):\\n            needDays, curCapacity = 1, 0\\n            for w in weights:\\n                curCapacity += w\\n                if curCapacity > maxCapacity:\\n                    needDays += 1\\n                    curCapacity = w\\n                    if needDays > days: break\\n\\n            return needDays <= days\\n\\n        while l < r:\\n            m = l + (r-l)//2\\n            if isPossibleToShip(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l   \\n```\n```python3 []\\nclass Solution:\\n    def minimumSize(self, nums: List[int], maxOperations: int) -> int:\\n        l, r = 1, max(nums)\\n\\n        def isEnoughSize(size):\\n            operations = 0\\n            for n in nums:\\n                if n <= size: continue\\n                operations += (n-1)//size\\n                if operations > maxOperations: return False\\n\\n            return True\\n\\n        while l < r:\\n            m = (l+r)//2\\n            if isEnoughSize(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l \\n```\n```python3 []\\nclass Solution:\\n    def maxDistance(self, positions: List[int], m: int) -> int:\\n        def isEnough(step):\\n            balls, curPos = 1, first\\n            while balls < m:\\n                minDist = curPos + step\\n                if minDist > last: break\\n                curPos = positions[bisect_left(positions, minDist)]\\n                balls += 1\\n\\n            return balls == m\\n\\n        positions.sort()\\n        \\n        l, r, first, last = 1, positions[-1]//(m-1), positions[0], positions[-1]\\n        if m == 2: return last - first\\n\\n        while l < r:\\n            mid = (l+r+1)//2\\n            if isEnough(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n        \\n        return l \\n```\n```python3 []\\nclass Solution:\\n    def maximumCandies(self, candies: List[int], k: int) -> int:\\n        S = sum(candies)\\n        if S < k: return 0 \\n\\n        l, r = 1, S//k\\n\\n        def isEnough(p):\\n            return sum(c//p for c in candies) >= k\\n\\n        while l < r:\\n            m = (l+r+1)//2 # to get most right element\\n            if isEnough(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def minimizedMaximum(self, n: int, quantities: List[int]) -> int:\\n        if n == 0: return quantities[0]\\n        \\n        def isEnough(maxCnt):\\n            return sum(ceil(q/maxCnt) for q in quantities) <= n\\n\\n        l, r = 1, max(quantities)\\n        while l < r:\\n            mid = (l+r)//2\\n            if isEnough(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        l, r = 0, len(removable)\\n\\n        def isEnough(k):\\n            s_arr = list(s)\\n            for i in removable[:k]:\\n                s_arr[i] = \\'\\'\\n            return isSubsequence(p, s_arr)\\n            \\n        def isSubsequence(s, t):\\n            t = iter(t)\\n            flag = all(c in t for c in s)   \\n            return flag\\n\\n        while l < r:\\n            m = (l+r+1)//2\\n            if isEnough(m):\\n                l = m\\n            else:\\n                r = m - 1\\n        \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\\n        def isEnough(x):\\n            cnt = 0 # count of values <= maxVal\\n            for i in range(1, m+1):\\n                cnt += min(x // i, n)\\n                if cnt > k: break\\n            return cnt >= k\\n        \\n        l, r = 1, m * n\\n\\n        while l < r:\\n            x = l + (r-l)//2\\n            if isEnough(x):\\n                r = x\\n            else:\\n                l = x + 1\\n        \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def splitArray(self, nums: List[int], k: int) -> int:\\n        l, r = max(nums), sum(nums)\\n        \\n        def isSplitted(maxSum):\\n            curSum, parts = 0, 1\\n            for n in nums:\\n                curSum += n\\n                if curSum > maxSum:\\n                    parts += 1\\n                    if parts > k: break\\n                    curSum = n\\n            return parts <= k\\n\\n        while l < r:\\n            m = l + (r-l)//2\\n            if isSplitted(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        \\n        return l\\n```\n```python3 []\\nclass Solution:\\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l, r = 0, len(nums)-1\\n\\n        def isKAndMorePairs(p):\\n            pairs = (p * (p-1))//2\\n            return pairs >= k\\n        \\n        while l < r:\\n            m = (l + r)//2\\n            if isKAndMorePairs(m):\\n                r = m\\n            else:\\n                l = m + 1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224740,
                "title": "binary-search",
                "content": "We binary-search for the slowest speed to reach the office on-time. \\n\\nAll rides, exept the last one, will take at least one hour as we need to wait for the next train. Therefore, we return `-1` if the alloted time is less or equal to the number of rides minus one.\\n\\nThe maximum train speed is `10 ^ 7`: we may need to finish the last ride in `0.01` hours, and the maximum distance is `10 ^ 5`. \\n\\n**C++**\\n```cpp\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n    if (hour <= dist.size() - 1)\\n        return -1;\\n    int l = 1, r = 10000000;\\n    while (l < r) {\\n        int m = (l + r) / 2, time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += dist[i] / m + (dist[i] % m ? 1 : 0);\\n        if ((double)dist.back() / m + time <= hour)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n    if (hour <= dist.size() - 1)\\n        return -1;\\n    int l = 1, r = 10000000;\\n    while (l < r) {\\n        int m = (l + r) / 2, time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += dist[i] / m + (dist[i] % m ? 1 : 0);\\n        if ((double)dist.back() / m + time <= hour)\\n            r = m;\\n        else\\n            l = m + 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819301,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing Binary Search to find the minimum speed\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/frpAeLiX1j0\\n\\n# Subscribe to my channel from here. I have 231 videos as of July 26th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other languages might be different a bit.\\n\\n1. The function `minSpeedOnTime` takes two parameters: `dist`, a list of integers representing the distances to be covered, and `hour`, a float representing the maximum allowed time to reach the destination.\\n\\n2. Inside the `minSpeedOnTime` function, a nested function `can_reach_on_time` is defined, which takes a `speed` parameter and checks if it\\'s possible to reach the destination office on time with that given speed.\\n\\n3. In the `can_reach_on_time` function, the variable `total_time` is calculated. It represents the total time required to reach the destination office with the given `speed`. It is calculated by iterating through the distances in `dist[:-1]`, summing up the time required to cover each distance with the given `speed` (taking into account any potential rounding up using `//` operator), and then adding the time required to cover the last distance (`dist[-1]`) using the given `speed`.\\n\\n4. The main function `minSpeedOnTime` then sets up the binary search to find the minimum speed needed to reach the destination office on time. The initial search space for the speed is between `1` and `10**7`.\\n\\n5. The binary search loop runs until `left` is less than `right`.\\n\\n6. In each iteration of the binary search loop, the middle value `mid` is calculated as `(left + right) // 2`.\\n\\n7. The `can_reach_on_time` function is called with `mid` as an argument to check if it\\'s possible to reach the office on time with the speed `mid`.\\n\\n8. If it\\'s possible to reach on time with the speed `mid`, the right boundary `right` is updated to `mid`, narrowing the search space to the left half.\\n\\n9. If it\\'s not possible to reach on time with the speed `mid`, the left boundary `left` is updated to `mid + 1`, narrowing the search space to the right half.\\n\\n10. The binary search continues until `left` and `right` converge, and when that happens, the loop stops.\\n\\n11. After the binary search loop, the function checks if it\\'s possible to reach on time with the speed `left`. If so, the function returns the `left` value, which represents the minimum speed needed to reach the destination on time.\\n\\n12. If it\\'s not possible to reach on time with any speed within the given search space, the function returns `-1`.\\n\\nIn summary, this algorithm uses binary search to efficiently find the minimum speed needed to reach the destination office on time. The time complexity is `O(N * log M)`, where `N` is the size of the `dist` list and `M` is the upper bound of the possible speeds. The space complexity is `O(1)` as it only uses a constant amount of additional space.\\n\\n# Complexity\\n- Time complexity: O(N * log M)\\n\\n1. The `can_reach_on_time` function contains a loop that iterates through the elements of the `dist` list. The number of iterations in this loop is proportional to the size of the `dist` list, which is `O(N)`, where `N` is the length of the `dist` list.\\n2. The binary search loop runs until `left` and `right` converge. The maximum number of iterations in the binary search is `O(log M)`, where `M` is the upper bound of the possible speeds (`10**7` in this case) because we are dividing the search space in half at each step.\\n3. The function `can_reach_on_time` is called multiple times during the binary search. The number of calls to this function is proportional to the number of iterations in the binary search, which is `O(log M)`.\\n\\nTherefore, the overall time complexity of the code is `O(N * log M)`, where `N` is the length of the `dist` list and `M` is the upper bound of the possible speeds.\\n\\n- Space Complexity: O(1)\\n\\n1. The only additional space used is for the can_reach_on_time function. The space used by this function is constant, as it does not depend on the size of the input.\\n2. The variables used in the binary search (e.g., left, right, mid) also consume constant space.\\n\\nThus, the overall space complexity of the code is O(1) (constant), which means the space used by the algorithm does not grow with the size of the input dist list.\\n\\n```python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\n        # check if it\\'s possible to reach the office on time with a given speed\\n        def can_reach_on_time(speed):\\n            total_time = sum( ((d + speed - 1) // speed) for d in dist[:-1]) + dist[-1] / speed\\n            return total_time <= hour\\n\\n        # binary search to find the minimum speed\\n        left, right = 1, 10**7\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_reach_on_time(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        if can_reach_on_time(left):\\n            return left\\n        else:\\n            return -1\\n```\\n```javascript []\\n/**\\n * @param {number[]} dist\\n * @param {number} hour\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    function canReachOnTime(speed) {\\n        let total_time = dist.slice(0, -1).reduce((acc, d) => acc + Math.ceil(d / speed), 0) + dist[dist.length - 1] / speed;\\n        return total_time <= hour;\\n    }\\n\\n    let left = 1, right = 10 ** 7;\\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canReachOnTime(mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    if (canReachOnTime(left)) {\\n        return left;\\n    } else {\\n        return -1;\\n    }    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1, right = 10_000_000;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canReachOnTime(mid, dist, hour)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        if (canReachOnTime(left, dist, hour)) {\\n            return left;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    // Check if it\\'s possible to reach the office on time with a given speed\\n    boolean canReachOnTime(int speed, int[] dist, double hour) {\\n        double totalTime = 0.0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            totalTime += Math.ceil((double) dist[i] / speed);\\n        }\\n        totalTime += dist[dist.length - 1] / (double) speed;\\n        return totalTime <= hour;\\n    }    \\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // check if it\\'s possible to reach the office on time with a given speed\\n        auto canReachOnTime = [&](int speed) -> bool {\\n            double total_time = std::accumulate(dist.begin(), dist.end() - 1, 0.0, [&](double acc, int d) { return acc + std::ceil((double) d / speed); }) + dist.back() / (double) speed;\\n            return total_time <= hour;\\n        };\\n\\n        int left = 1, right = 10\\'000\\'000;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canReachOnTime(mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        if (canReachOnTime(left)) {\\n            return left;\\n        } else {\\n            return -1;\\n        }        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\n        # check if it\\'s possible to reach the office on time with a given speed\\n        def can_reach_on_time(speed):\\n            total_time = sum( ((d + speed - 1) // speed) for d in dist[:-1]) + dist[-1] / speed\\n            return total_time <= hour\\n\\n        # binary search to find the minimum speed\\n        left, right = 1, 10**7\\n        while left < right:\\n            mid = (left + right) // 2\\n            if can_reach_on_time(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        if can_reach_on_time(left):\\n            return left\\n        else:\\n            return -1\\n```\n```javascript []\\n/**\\n * @param {number[]} dist\\n * @param {number} hour\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    function canReachOnTime(speed) {\\n        let total_time = dist.slice(0, -1).reduce((acc, d) => acc + Math.ceil(d / speed), 0) + dist[dist.length - 1] / speed;\\n        return total_time <= hour;\\n    }\\n\\n    let left = 1, right = 10 ** 7;\\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canReachOnTime(mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    if (canReachOnTime(left)) {\\n        return left;\\n    } else {\\n        return -1;\\n    }    \\n};\\n```\n```java []\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1, right = 10_000_000;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canReachOnTime(mid, dist, hour)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        if (canReachOnTime(left, dist, hour)) {\\n            return left;\\n        } else {\\n            return -1;\\n        }\\n    }\\n\\n    // Check if it\\'s possible to reach the office on time with a given speed\\n    boolean canReachOnTime(int speed, int[] dist, double hour) {\\n        double totalTime = 0.0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            totalTime += Math.ceil((double) dist[i] / speed);\\n        }\\n        totalTime += dist[dist.length - 1] / (double) speed;\\n        return totalTime <= hour;\\n    }    \\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // check if it\\'s possible to reach the office on time with a given speed\\n        auto canReachOnTime = [&](int speed) -> bool {\\n            double total_time = std::accumulate(dist.begin(), dist.end() - 1, 0.0, [&](double acc, int d) { return acc + std::ceil((double) d / speed); }) + dist.back() / (double) speed;\\n            return total_time <= hour;\\n        };\\n\\n        int left = 1, right = 10\\'000\\'000;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (canReachOnTime(mid)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        if (canReachOnTime(left)) {\\n            return left;\\n        } else {\\n            return -1;\\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333685,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func minSpeedOnTime(_ d: [Int], _ h: Double) -> Int {\\n        let lnD = d.count, hour = Int(h.rounded(.up))\\n        guard hour >= lnD else { return -1 }\\n        let maxD = Double(d.last!), maxH = h == h.rounded(.down) ? 1.0 : (h - h.rounded(.down))\\n        var lhs = 1, rhs = hour > lnD ? d.max()! : max(d.max()!, Int((maxD / maxH).rounded(.up)))\\n        while lhs < rhs {\\n            let mid = Double((lhs + rhs) / 2)\\n            var time = 0.0\\n            for i in 0..<(lnD - 1) { time += (Double(d[i]) / mid).rounded(.up) }\\n            time += maxD / mid\\n            time > h ? (lhs = Int(mid + 1)) : (rhs = Int(mid))\\n        }\\n        return lhs\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n</pre>\\n\\n```swift\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.minSpeedOnTime([1,3,2], 6)\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.minSpeedOnTime([1,3,2], 2.7)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.minSpeedOnTime([1,3,2], 1.9)\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minSpeedOnTime(_ d: [Int], _ h: Double) -> Int {\\n        let lnD = d.count, hour = Int(h.rounded(.up))\\n        guard hour >= lnD else { return -1 }\\n        let maxD = Double(d.last!), maxH = h == h.rounded(.down) ? 1.0 : (h - h.rounded(.down))\\n        var lhs = 1, rhs = hour > lnD ? d.max()! : max(d.max()!, Int((maxD / maxH).rounded(.up)))\\n        while lhs < rhs {\\n            let mid = Double((lhs + rhs) / 2)\\n            var time = 0.0\\n            for i in 0..<(lnD - 1) { time += (Double(d[i]) / mid).rounded(.up) }\\n            time += maxD / mid\\n            time > h ? (lhs = Int(mid + 1)) : (rhs = Int(mid))\\n        }\\n        return lhs\\n    }\\n}\\n```\n```swift\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.minSpeedOnTime([1,3,2], 6)\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.minSpeedOnTime([1,3,2], 2.7)\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test2() {\\n        let value = solution.minSpeedOnTime([1,3,2], 1.9)\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818021,
                "title": "c-97-binary-search-easy-explantion",
                "content": "We have ans limit from 1 to 10^7, but we don\\'t need to do binary search over all the number every time.\\n\\nInstead, we only need to do binary search in the possible range\\n\\nIn every step, we call `check` to check whether the speed is possible:\\nif possible, we try smaller speed\\nif not possible, we try larger speed\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int m, ans = -1, n = dist.size();\\n        if(hour < n - 1) return -1;\\n\\n        // find the possible range\\n        double dl = 0, dr = 0;\\n        for(auto d : dist) {\\n            double cur = d * 1.0;\\n            dl += (cur / hour);\\n            dr += (cur / (hour - n + 1));\\n        }\\n\\n        int l = floor(min(dl, 10e7));\\n        int r = ceil(min(dr, 10e7));\\n        int mid;\\n        while(l <= r){\\n            m = (l + r) / 2;\\n            if(check(dist, hour, m)){\\n                ans = m;\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(vector<int>& dist, double hour, int speed){\\n        double time = 0;\\n        int i=0;\\n        while(time <= hour && i < dist.size()-1){\\n            time += ceil(static_cast<double>(dist[i]) / speed);\\n            i++;\\n        }\\n        time += static_cast<double>(dist[dist.size() - 1]) / speed;\\n        return (time <= hour);\\n    }\\n};\\n```\\n\\n# Please UPVOTE if this helps\\n![image.png](https://assets.leetcode.com/users/images/d158b4d7-412f-4f4a-91e0-9303ab0c829a_1690357636.994227.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int m, ans = -1, n = dist.size();\\n        if(hour < n - 1) return -1;\\n\\n        // find the possible range\\n        double dl = 0, dr = 0;\\n        for(auto d : dist) {\\n            double cur = d * 1.0;\\n            dl += (cur / hour);\\n            dr += (cur / (hour - n + 1));\\n        }\\n\\n        int l = floor(min(dl, 10e7));\\n        int r = ceil(min(dr, 10e7));\\n        int mid;\\n        while(l <= r){\\n            m = (l + r) / 2;\\n            if(check(dist, hour, m)){\\n                ans = m;\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(vector<int>& dist, double hour, int speed){\\n        double time = 0;\\n        int i=0;\\n        while(time <= hour && i < dist.size()-1){\\n            time += ceil(static_cast<double>(dist[i]) / speed);\\n            i++;\\n        }\\n        time += static_cast<double>(dist[dist.size() - 1]) / speed;\\n        return (time <= hour);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048006,
                "title": "easy-soln-binary-search-c",
                "content": "Time : O(n log 10000000) , as 10000000 is the maximum speed possible \\nSpace: O(1)\\n```\\nclass Solution {\\npublic:\\n    bool ispossible(int mid, vector<int>& dist, double &hour, int n){\\n    /*  For the first n - 1 elements it will be ceiling value, \\n        as we need to wait for the next train.\\n        But for the last n\\'th element it will be floating value, \\n        as we dont need to wait for next train.   */\\n        int res = 0;\\n        for(int i = 0; i < n - 1; i++)\\n            res += ((dist[i] + mid - 1) / mid);\\n        double time = (dist[n - 1] * 1.0) / mid + res;\\n        return time <= hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        const int n = dist.size();\\n        int low = 1;\\n        int high = 10000000;//as the speed can go as high as 10^7\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(ispossible(mid, dist, hour, n)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(int mid, vector<int>& dist, double &hour, int n){\\n    /*  For the first n - 1 elements it will be ceiling value, \\n        as we need to wait for the next train.\\n        But for the last n\\'th element it will be floating value, \\n        as we dont need to wait for next train.   */\\n        int res = 0;\\n        for(int i = 0; i < n - 1; i++)\\n            res += ((dist[i] + mid - 1) / mid);\\n        double time = (dist[n - 1] * 1.0) / mid + res;\\n        return time <= hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        const int n = dist.size();\\n        int low = 1;\\n        int high = 10000000;//as the speed can go as high as 10^7\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(ispossible(mid, dist, hour, n)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816851,
                "title": "c-python-koko-like-solutions-with-small-searching-region",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike solving the binary search problem\\n[875. Koko Eating Bananas\\n](https://leetcode.com/problems/koko-eating-bananas/solutions/3685871/w-explanation-easy-binary-search-c-solution/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![1870. Minimum Speed to Arrive on Time.png](https://assets.leetcode.com/users/images/5dd3b273-9ec3-4903-8b0f-ce0c00693205_1690339084.9423194.png)\\n\\nIt is important to know that the function time(speed) is a monotonic (decreasing) function. That is the reason why the binary search can be applied.\\n\\nTo make the binary search efficient, it is suggested to choose the possible smallest searching range. It can derived as follows\\n$$\\nhour\\\\geq time(speed) \\\\\\\\\\n=\\\\sum_{i=0}^{n-2}ceil(\\\\frac{dist[i]}{speed})+\\\\frac{d[n-1]}{speed}\\\\\\\\\\n\\\\geq (n-1)+\\\\frac{d[n-1]}{speed} , if\\\\ speed \\\\geq max_{i=0,\\\\cdots,n-2} (dist[i])\\n$$\\nIt implies that\\n$$\\nspeed\\\\geq \\\\frac{dist[n-1]}{hour-n-1}\\n$$\\nSo we can choose the initial value for right\\n```\\nright=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)))\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log (m))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    double time(vector<int>& dist, int speed){\\n        double sum=0;\\n        for(int i=0; i<n-1; i++)\\n            sum+=(dist[i]+speed-1)/speed;//ceiling function\\n        sum+=(double)dist[n-1]/speed;// last one just normal division\\n        cout<<\"speed=\"<<speed<<\",time=\"<<sum<<endl;\\n        return sum;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        n=dist.size();\\n       \\n        if (hour<=n-1) return -1;\\n        long long left=1;\\n        int right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));\\n    //    cout<<right<<endl;\\n        int speed;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if (time(dist, mid)<=hour){\\n                speed=mid;\\n                right=mid-1;\\n            } \\n            else left=mid+1;\\n        }\\n        return speed;\\n    }\\n};\\n```\\n# Python code Beats 97.15%\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n=len(dist)\\n        if hour<=n-1: return -1\\n\\n        def time(speed):\\n            sum=0\\n            for x in dist[:n-1]:\\n                sum+=(x+speed-1)//speed #ceiling function\\n            sum+=dist[n-1]/speed\\n            return sum\\n        \\n        left=1\\n        right=1+max(max(dist), int(dist[-1]//(hour-n+1)))\\n        speed=0\\n        while left<=right:\\n            mid=(left+right)//2\\n            if time(mid)<= hour:\\n                speed=mid\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return speed\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nright=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)))\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    double time(vector<int>& dist, int speed){\\n        double sum=0;\\n        for(int i=0; i<n-1; i++)\\n            sum+=(dist[i]+speed-1)/speed;//ceiling function\\n        sum+=(double)dist[n-1]/speed;// last one just normal division\\n        cout<<\"speed=\"<<speed<<\",time=\"<<sum<<endl;\\n        return sum;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        n=dist.size();\\n       \\n        if (hour<=n-1) return -1;\\n        long long left=1;\\n        int right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));\\n    //    cout<<right<<endl;\\n        int speed;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if (time(dist, mid)<=hour){\\n                speed=mid;\\n                right=mid-1;\\n            } \\n            else left=mid+1;\\n        }\\n        return speed;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n=len(dist)\\n        if hour<=n-1: return -1\\n\\n        def time(speed):\\n            sum=0\\n            for x in dist[:n-1]:\\n                sum+=(x+speed-1)//speed #ceiling function\\n            sum+=dist[n-1]/speed\\n            return sum\\n        \\n        left=1\\n        right=1+max(max(dist), int(dist[-1]//(hour-n+1)))\\n        speed=0\\n        while left<=right:\\n            mid=(left+right)//2\\n            if time(mid)<= hour:\\n                speed=mid\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return speed\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3817178,
                "title": "c-binary-search-on-answer-with-intution-with-explantion",
                "content": "Firstly when we start this question we see that our speed can vary from 1km/hr to 1e7 km/hr. Since we have to give the minimum we will start traversing from 1 km/hr and when conditions are met we return the ans. This will take o(maxspeed) *o(size of array) hence inefficient.\\n\\nSince the answer space is sorted we can go for binary search. So every mid is our current speed we are trying for. If our total time with current speed is less than required hour this can surely be one of the ans but wait! we want minimum of all possible ans so we move hi to mid-1 and check for lesser answer if possible the fine, otherwise this current ans will be the ans. 2 nd case arises when the total hour at current speed crosses the hours given we cannot consider this speed as ans so we have to increase our speed to get lesser time so lo= mid+1\\n\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dist,int speed,double hour){\\n        double ans=0;\\n        int n= dist.size();\\n        for(int i=0; i<n-1; i++){\\n            if(dist[i]%speed==0){\\n                ans+= dist[i]/speed;\\n            }\\n            else{\\n                ans+= (dist[i]/speed)+1;\\n            }\\n        }\\n        ans+= (double)(dist[n-1])/(double)(speed);\\n        if(ans>hour) return false;\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int hi=1e7;\\n        int n= dist.size();  \\n        int lo= 1;\\n        while(lo<=hi){\\n            int mid= (lo+hi)/2;\\n            if(helper(dist,mid,hour)){\\n                ans= mid;\\n                hi= mid-1;\\n                \\n            }\\n            else{\\n                lo= mid+1;\\n            }\\n            \\n         }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n**Please Upvote if u understood!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dist,int speed,double hour){\\n        double ans=0;\\n        int n= dist.size();\\n        for(int i=0; i<n-1; i++){\\n            if(dist[i]%speed==0){\\n                ans+= dist[i]/speed;\\n            }\\n            else{\\n                ans+= (dist[i]/speed)+1;\\n            }\\n        }\\n        ans+= (double)(dist[n-1])/(double)(speed);\\n        if(ans>hour) return false;\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int hi=1e7;\\n        int n= dist.size();  \\n        int lo= 1;\\n        while(lo<=hi){\\n            int mid= (lo+hi)/2;\\n            if(helper(dist,mid,hour)){\\n                ans= mid;\\n                hi= mid-1;\\n                \\n            }\\n            else{\\n                lo= mid+1;\\n            }\\n            \\n         }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981346,
                "title": "java-c-binary-search",
                "content": "### Java\\n```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = (int) 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == (int) 1e8 ? -1 : right;\\n    }\\n\\n    private boolean arriveOnTime(int[] dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            time += Math.ceil((double) dist[i] / speed);\\n        }\\n        return time + (double) dist[dist.length - 1] / speed <= hour;\\n    }\\n```\\n### C++\\n```\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left = 1;\\n        int right = 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == 1e8 ? -1 : right;\\n    }\\n    \\nprivate: \\n    bool arriveOnTime(vector<int> dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.size() - 1; i++) {\\n            time += dist[i] / speed + ((dist[i] % speed == 0) ? 0 : 1);\\n        }\\n        return time + dist[dist.size() - 1] * 1.00 / speed <= hour;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = (int) 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == (int) 1e8 ? -1 : right;\\n    }\\n\\n    private boolean arriveOnTime(int[] dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            time += Math.ceil((double) dist[i] / speed);\\n        }\\n        return time + (double) dist[dist.length - 1] / speed <= hour;\\n    }\\n```\n```\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left = 1;\\n        int right = 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == 1e8 ? -1 : right;\\n    }\\n    \\nprivate: \\n    bool arriveOnTime(vector<int> dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.size() - 1; i++) {\\n            time += dist[i] / speed + ((dist[i] % speed == 0) ? 0 : 1);\\n        }\\n        return time + dist[dist.size() - 1] * 1.00 / speed <= hour;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592449,
                "title": "python-binary-search-with-explanation",
                "content": "By the condition, trains start only at the integer time. That means that if we pick any infinitely large speed, the smallest possible time to reach the office anyway will be bounded by that constrain. So we note that the minimum speed can be `1 km/h` and the maximum speed that makes sense is `max(dist)` (at the first glance). So we have lower and upper bound for the speed and that means we can use Binary Search to find the speed that satisfies the condition. \\n\\nAs for the upper bound, consider the following example:\\n```\\n[1,1,100000]\\n2.01\\n```\\nThe result for that unexpectedly will be `10000000` although we defined the upper bound as `max(dist)` which is for the example is just `100000`. So when deriving the upper bound we should take into account that the last distance is not rounded during the calculation of the required time. Thus we should update our formula for the upper bound to `ceil( max(dist) / dec )`, where `dec` is the decimal part of the input `hour`.\\n\\n### Complexity:\\nTime: **O(N*logN)** on each BS shot we have to calculate required time to reach the office given the speed\\nSpace: **O(1)** \\n\\nRuntime: 3074 ms, faster than **84.93%** of Python3 online submissions for Minimum Speed to Arrive on Time.\\nMemory Usage: 28.2 MB, less than **92.01%** of Python3 online submissions for Minimum Speed to Arrive on Time.\\n\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\t\\n\\t\\t# helper returns required time to reach the office given a speed\\n        def getRequiredTime(speed):\\n            time = sum([ceil(d/speed) for d in dist[:-1]])\\n            time += dist[-1]/speed\\n\\t\\t\\t\\n            return time\\n        \\n        dec = hour % 1 or 1 # decimal part of the `hour`\\n        lo, hi = 1, ceil( max(dist) / dec ) # min and max speed\\n\\t\\t\\n        res = -1\\n    \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            time = getRequiredTime(mid)\\n            if time == hour:\\n                return mid\\n            \\n            if time < hour:\\n                res = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n[1,1,100000]\\n2.01\\n```\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\t\\n\\t\\t# helper returns required time to reach the office given a speed\\n        def getRequiredTime(speed):\\n            time = sum([ceil(d/speed) for d in dist[:-1]])\\n            time += dist[-1]/speed\\n\\t\\t\\t\\n            return time\\n        \\n        dec = hour % 1 or 1 # decimal part of the `hour`\\n        lo, hi = 1, ceil( max(dist) / dec ) # min and max speed\\n\\t\\t\\n        res = -1\\n    \\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            \\n            time = getRequiredTime(mid)\\n            if time == hour:\\n                return mid\\n            \\n            if time < hour:\\n                res = mid\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225592,
                "title": "simple-binary-search-brute-force-also-explained",
                "content": "Requirement of the question is to find the minimum speed possible.\\nAlso it is given that  1<=speed<=1e7\\n\\n**Brute Force :**\\nWe can try to take speed as 1, 2, 3 ........ 1e7 and calculate for each speed  if the time required is less then or equal to given time. However this would result in a TLE, as for each speed we would do **O( size of array)** work and in worst case total time required would be   O( 1e7 *size of array) \\n \\n**Efficient Approach:**\\nTry to think of an efficient way to check for all speeds without actually trying  all the speeds.\\nThis can be done using Binary Search.\\n\\nBasic idea:\\nLet\\'s suppose we choose speed as 100 and we calculate the total time required with this speed. \\nThere are two cases which can occur \\nCase1: if the **calculated time <= given time**:   then we can say that the speed has to be less or equal to 100\\nCase2: if the **calculated time > given time**:    then we can say that the speed has to be more than 100 \\n\\nSo according to the cases which arises we can alter our binary search ranges.\\n\\n**Note: since we have to wait till time is an integer hour use ceil value. Also note that time for the last train does not has to be an integral hour as it is the last train so calculate it seperately.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        \\n        /// mini speed\\n        int minimum_speed=1;\\n        // max speed\\n        int maximum_speed=1e7;\\n        \\n        int n=dist.size();\\n        \\n        //// binary search the require speed\\n        while(minimum_speed<=maximum_speed){\\n            \\n            // check for the average speed \\n            int average_speed=(minimum_speed+maximum_speed)/2;\\n\\n            // total time require with each speed\\n            double total_time=0;\\n            for(int i=0;i<n-1;i++){\\n                total_time+=ceil((double)dist[i]/average_speed);\\n            }\\n            \\n            //// calculating total_time for the last train \\n            total_time+=(((double)dist.back())/average_speed);\\n            \\n            // check for total time and given time\\n            if(total_time>hour){\\n                minimum_speed=average_speed+1;\\n            }\\n            else {\\n                ans=average_speed;\\n                maximum_speed=average_speed-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        \\n        /// mini speed\\n        int minimum_speed=1;\\n        // max speed\\n        int maximum_speed=1e7;\\n        \\n        int n=dist.size();\\n        \\n        //// binary search the require speed\\n        while(minimum_speed<=maximum_speed){\\n            \\n            // check for the average speed \\n            int average_speed=(minimum_speed+maximum_speed)/2;\\n\\n            // total time require with each speed\\n            double total_time=0;\\n            for(int i=0;i<n-1;i++){\\n                total_time+=ceil((double)dist[i]/average_speed);\\n            }\\n            \\n            //// calculating total_time for the last train \\n            total_time+=(((double)dist.back())/average_speed);\\n            \\n            // check for total time and given time\\n            if(total_time>hour){\\n                minimum_speed=average_speed+1;\\n            }\\n            else {\\n                ans=average_speed;\\n                maximum_speed=average_speed-1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821244,
                "title": "beats-100-binary-search-on-ans-explained",
                "content": "# Intuition\\nUnderstanding the problem statement and knowing that velocity = distance / time. Due to the monotonicity of the problem\\'s constraint that all trains must travel at a minimum speed to reach the office on time, **binary searching** over train velocities or speeds is feasible.\\n# Approach\\nHow **monotonic** in nature? \\n\\nIf we increase the speed of the trains, then the time taken for each train ride will decrease, meaning that we\\'ll reach the office earlier. Thus, if it is possible to reach the office on time with a certain speed, then it is also possible to reach the office on time with any speed greater than that. \\n\\nThe valid lambda function harnesses the math relation, vel = dist / time\\nIt checks whether possible to reach the office on time with a given velocity. It takes as input a velocity value and returning a boolean that indicates whether it is possible to reach the office on time with that speed.\\n\\nCalculating the total time taken to reach the office by summing up the time taken by each train ride. For each train ride except the last one, it calculates the time taken as the distance of the train ride divided by velocity, rounding up to the nearest integer. This is because each train can only depart at an integer hour, so we may need to wait in between each train ride. Here comes an **edge case**.\\nFor the last train ride, it calculates the time taken as the distance of the train ride divided by the speed, without rounding it up as we don\\'t need to wait after the last train ride.\\n\\nAfter calculating the total time taken to reach the office, the function compares it with the given hour value and returns 1 if the total time is less than or equal to hour, and 0 otherwise. \\n# Complexity\\n- Time complexity:\\nTime complexity is O(n * log(mxv)) where the maximum possible velocity in the binary search be denoted by mxv as it is used to define the max search space(r)\\nmxv = (1e7+7).\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); \\n        int n((int)dist.size());\\n        auto valid = [&](int vel) -> bool {\\n            double t(0.0);\\n            for (int i(0); i <= n-2; ++i) \\n                t += (dist[i] + vel - 1) / vel;\\n            t += (double)dist[n-1] / vel;\\n            return t <= hour;\\n        };\\n\\n        int l(1), r((int)1e7+7), mid, ans(-1);\\n        while(l <= r) \\n            mid = (l + r) >> 1,\\n            (valid(mid))? (ans = mid, r = mid-1) : l = mid + 1;\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); \\n        int n((int)dist.size());\\n        auto valid = [&](int vel) -> bool {\\n            double t(0.0);\\n            for (int i(0); i <= n-2; ++i) \\n                t += (dist[i] + vel - 1) / vel;\\n            t += (double)dist[n-1] / vel;\\n            return t <= hour;\\n        };\\n\\n        int l(1), r((int)1e7+7), mid, ans(-1);\\n        while(l <= r) \\n            mid = (l + r) >> 1,\\n            (valid(mid))? (ans = mid, r = mid-1) : l = mid + 1;\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3818771,
                "title": "easy-explained-clean-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to minimize the speed.\\n- It is a monotonic function.\\n- Absolutely Binary-search\\n\\n# Complexity\\n- Time complexity: O(n)\\n  - As the function **findTime** traverses on dist vector.\\n  - And **minSpeedOnTime** needs O(1) time, since log(1e7) \\u2243 23 (constant)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double findTime(vector<int>& dist, int speed){\\n        double time = 0.0;\\n        int len = dist.size();\\n        for(int i=0; i<len-1; i++){\\n            double t = (double)dist[i]/(double)speed;\\n            time += ceil(t);\\n        }\\n        // no rules for round-off for last value.\\n        time += (double)dist[len-1]/(double)speed;\\n        return time;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int mini =1, maxi = 1e7;\\n        int speed=-1;\\n        while(mini <= maxi){\\n            int mid = mini  + (maxi-mini)/2;\\n            // fn will return the possible time, if hour is greater\\n            // it means we have more time, reduce the speed\\n            if(findTime(dist, mid) <= hour){\\n                speed = mid;\\n                maxi = mid-1;\\n            }else{\\n                mini = mid+1;\\n            }\\n\\n        }\\n        return speed; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double findTime(vector<int>& dist, int speed){\\n        double time = 0.0;\\n        int len = dist.size();\\n        for(int i=0; i<len-1; i++){\\n            double t = (double)dist[i]/(double)speed;\\n            time += ceil(t);\\n        }\\n        // no rules for round-off for last value.\\n        time += (double)dist[len-1]/(double)speed;\\n        return time;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int mini =1, maxi = 1e7;\\n        int speed=-1;\\n        while(mini <= maxi){\\n            int mid = mini  + (maxi-mini)/2;\\n            // fn will return the possible time, if hour is greater\\n            // it means we have more time, reduce the speed\\n            if(findTime(dist, mid) <= hour){\\n                speed = mid;\\n                maxi = mid-1;\\n            }else{\\n                mini = mid+1;\\n            }\\n\\n        }\\n        return speed; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549153,
                "title": "amazing-code-to-understand-c-binary-search",
                "content": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int>& a, int speed, double hour) {\\n        double time = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            time = ceil(time);\\n            time +=  (double)a[i] / speed;\\n            if (time > hour) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1;\\n        int high=1e9;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isvalid(dist,mid,hour)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool isvalid(vector<int>& a, int speed, double hour) {\\n        double time = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            time = ceil(time);\\n            time +=  (double)a[i] / speed;\\n            if (time > hour) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3817136,
                "title": "python3-99-99-faster-beats-11-lines-clean-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266880,
                "title": "easiest-solution-binary-search-approach-beginner-friendly-detailed-explanantion",
                "content": "# Approach\\n\\n1. minimum time can be 1, less than 1 can not possible.\\n2. maximum time can be 1e9.\\n3. we use binary search to chose optimally minimum speed that can be required to complete total distance by given array in given hour.\\n4. when time taken by \\'mid\\' speed  <= given hour, then our ans can be \\'mid\\' speed, but less than \\'mid\\' speed can be possible, so we reduce our search space.\\n5. when time taken by \\'mid\\' speed > given hour, then we have to increase speed so that time will be less.Due to this, we increase our start to increase mid.\\n6. In function func,for i==n-1, I added exact time(in decimal) to ans and for remain, I added round off value, because According to  question,if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double func(vector<int>&dist,int k)\\n    {\\n        double ans=0;\\n        int n = dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1)\\n            {\\n                ans+= (1.0*dist[i])/k;\\n            }\\n            else\\n            {\\n                ans += dist[i]/k;\\n                if(dist[i]%k>0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) \\n    {\\n        int s = 1,e = 1e9;\\n        int ans = e;\\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            double x = func(dist,mid);\\n            if(x<=hour)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans==e?-1:ans;\\n    }\\n};\\n```\\nIf you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............\\n![upvote.png](https://assets.leetcode.com/users/images/e4975fa4-ced6-4081-9afa-26365ee3abe5_1678162315.2257783.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double func(vector<int>&dist,int k)\\n    {\\n        double ans=0;\\n        int n = dist.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==n-1)\\n            {\\n                ans+= (1.0*dist[i])/k;\\n            }\\n            else\\n            {\\n                ans += dist[i]/k;\\n                if(dist[i]%k>0)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) \\n    {\\n        int s = 1,e = 1e9;\\n        int ans = e;\\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            double x = func(dist,mid);\\n            if(x<=hour)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans==e?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225585,
                "title": "python3-concise-binary-search-code-with-comments",
                "content": "```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\t\\t# the speed upper is either the longest train ride: max(dist),\\n\\t\\t# or the last train ride divide by 0.01: ceil(dist[-1] / 0.01).\\n\\t\\t# notice: \"hour will have at most two digits after the decimal point\"\\n        upper = max(max(dist), ceil(dist[-1] / 0.01))\\n        # \\n\\t\\t# the function to calcute total time consumed\\n        total = lambda speed: sum(map(lambda x: ceil(x / speed), dist[:-1])) + (dist[-1] / speed)\\n\\t\\t# the case of impossible to arrive office on time\\n        if total(upper) > hour:\\n            return -1\\n        # \\n\\t\\t# binary search: find the mimimal among \"all\" feasible answers\\n        left, right = 1, upper\\n        while left < right:            \\n            mid = left + (right - left) // 2\\n            if total(mid) > hour:\\n                left = mid + 1 # should be larger\\n            else:\\n                right = mid # should explore a smaller one\\n        return right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n\\t\\t# the speed upper is either the longest train ride: max(dist),\\n\\t\\t# or the last train ride divide by 0.01: ceil(dist[-1] / 0.01).\\n\\t\\t# notice: \"hour will have at most two digits after the decimal point\"\\n        upper = max(max(dist), ceil(dist[-1] / 0.01))\\n        # \\n\\t\\t# the function to calcute total time consumed\\n        total = lambda speed: sum(map(lambda x: ceil(x / speed), dist[:-1])) + (dist[-1] / speed)\\n\\t\\t# the case of impossible to arrive office on time\\n        if total(upper) > hour:\\n            return -1\\n        # \\n\\t\\t# binary search: find the mimimal among \"all\" feasible answers\\n        left, right = 1, upper\\n        while left < right:            \\n            mid = left + (right - left) // 2\\n            if total(mid) > hour:\\n                left = mid + 1 # should be larger\\n            else:\\n                right = mid # should explore a smaller one\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820279,
                "title": "brute-optimal-java-binary-search-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick one speed in range of **(1 -> 1e7)** and check that is it possible that you travelled with all trains and reach the office on time if yes then may be my answer. by checking **lineary** we will get TLE so here we use **Binary Search** to reduce the search space.\\n\\n# Complexity\\n- Time complexity:\\n  Brute Force - $$O(N*N)$$ \\n  Optimized - $$O(NLogN)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n### Optimized Code (Binary Search)\\n\\n```\\nclass Solution {\\n    public boolean isPossible(double speed, int[] dist, double hour){\\n        double total_hour_so_far = 0;\\n        <!-- Calculating total hour  -->\\n        for(int it = 0; it < dist.length - 1; it++){\\n            double h = dist[it]/speed;\\n            total_hour_so_far += Math.ceil(h);\\n\\n            if(total_hour_so_far > hour) return false;\\n        }\\n        <!-- Adding time of last train -->\\n        total_hour_so_far += dist[dist.length - 1] / speed;\\n        return total_hour_so_far <= hour ? true : false;\\n    }\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int low = 1;\\n        int high = (int)1e7;\\n        int ans = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            double speed = (double) mid;\\n\\n            if(isPossible(speed, dist, hour)){\\n                ans = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Brute Force \\n\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        for(double speed = 1; speed <= 10000000; speed++){\\n            double total_hour = 0.0;\\n            int it = 0;\\n            for(it = 0; it < dist.length - 1; it++){\\n                double h = dist[it]/speed;\\n                total_hour += Math.ceil(h);\\n\\n                if(total_hour > hour) break;\\n            }\\n            total_hour += dist[dist.length - 1] / speed;\\n            if(total_hour <= hour) return (int)speed;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(double speed, int[] dist, double hour){\\n        double total_hour_so_far = 0;\\n        <!-- Calculating total hour  -->\\n        for(int it = 0; it < dist.length - 1; it++){\\n            double h = dist[it]/speed;\\n            total_hour_so_far += Math.ceil(h);\\n\\n            if(total_hour_so_far > hour) return false;\\n        }\\n        <!-- Adding time of last train -->\\n        total_hour_so_far += dist[dist.length - 1] / speed;\\n        return total_hour_so_far <= hour ? true : false;\\n    }\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int low = 1;\\n        int high = (int)1e7;\\n        int ans = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            double speed = (double) mid;\\n\\n            if(isPossible(speed, dist, hour)){\\n                ans = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        for(double speed = 1; speed <= 10000000; speed++){\\n            double total_hour = 0.0;\\n            int it = 0;\\n            for(it = 0; it < dist.length - 1; it++){\\n                double h = dist[it]/speed;\\n                total_hour += Math.ceil(h);\\n\\n                if(total_hour > hour) break;\\n            }\\n            total_hour += dist[dist.length - 1] / speed;\\n            if(total_hour <= hour) return (int)speed;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820207,
                "title": "video-beats-95-all-aboard-the-coding-express-finding-the-minimum-speed-with-binary-search",
                "content": "# Intuition\\nUpon reading this problem, it quickly becomes clear that there\\'s a time constraint on the total journey to the office. This hints towards optimizing the speed of travel. Since we need to find the minimum speed, it seems like a good fit for a binary search algorithm, where we iteratively refine our search for the optimal speed.\\n\\nhttps://youtu.be/a3VgSDzD-B0\\n\\n# Approach\\nOur approach to solving this problem is to use a binary search algorithm to find the minimum speed. We start by checking whether it\\'s possible to reach the office in the given time. If it\\'s not possible, we return -1 immediately.\\n\\nNext, we perform a binary search from 1 to the maximum of the maximum distance and the last distance divided by the remaining time after each train ride takes 1 hour. We define a helper function, `canArriveOnTime`, that checks if we can arrive at the office on time with a given speed. This function calculates the total time taken by adding up the time each train takes to reach the destination. If we can arrive on time with the mid speed, we update the right bound to mid, otherwise, we update the left bound to mid + 1. We repeat this process until we find the minimum speed.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is \\\\(O(n \\\\log m)\\\\), where \\\\(n\\\\) is the number of train rides and \\\\(m\\\\) is the maximum distance. This is because for each possible speed, we check if we can arrive on time, which requires iterating over all the train rides.\\n\\n- Space complexity: The space complexity is \\\\(O(1)\\\\), as we only use a constant amount of space to store the speed, distances, and time.\\n\\nThis code effectively solves the problem using the power of binary search and some mathematical calculations, demonstrating the flexibility and usefulness of these techniques in solving complex problems.\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canArriveOnTime(speed): \\n            return sum(math.ceil(d / speed) for d in dist[:-1]) + dist[-1] / speed <= hour \\n\\n        n = len(dist) \\n        if n - 1 > hour or hour - n + 1 <= 0: \\n            return -1 \\n\\n        left, right = 1, max(max(dist), math.ceil(dist[-1] / (hour - n + 1))) \\n        while left < right: \\n            mid = (left + right) // 2 \\n            if canArriveOnTime(mid): \\n                right = mid \\n            else: \\n                left = mid + 1 \\n\\n        return left \\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = max(*max_element(dist.begin(), dist.end()), (int)ceil(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += ceil((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.Length;\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = Math.Max(dist.Max(), (int)Math.Ceiling(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += Math.Ceiling((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n``` Java []\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = Math.max(Arrays.stream(dist).max().getAsInt(), (int)Math.ceil(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += Math.ceil((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} dist\\n * @param {number} hour\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    const canArriveOnTime = (speed) => {\\n        return dist.slice(0, -1).reduce((total, d) => total + Math.ceil(d / speed), 0) + dist[dist.length - 1] / speed <= hour;\\n    };\\n\\n    let n = dist.length;\\n    if (n - 1 > hour || hour - n + 1 <= 0) {\\n        return -1;\\n    }\\n\\n    let left = 1, right = Math.max(...dist, Math.ceil(dist[dist.length - 1] / (hour - n + 1)));\\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canArriveOnTime(mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return left;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canArriveOnTime(speed): \\n            return sum(math.ceil(d / speed) for d in dist[:-1]) + dist[-1] / speed <= hour \\n\\n        n = len(dist) \\n        if n - 1 > hour or hour - n + 1 <= 0: \\n            return -1 \\n\\n        left, right = 1, max(max(dist), math.ceil(dist[-1] / (hour - n + 1))) \\n        while left < right: \\n            mid = (left + right) // 2 \\n            if canArriveOnTime(mid): \\n                right = mid \\n            else: \\n                left = mid + 1 \\n\\n        return left \\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = max(*max_element(dist.begin(), dist.end()), (int)ceil(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += ceil((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.Length;\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = Math.Max(dist.Max(), (int)Math.Ceiling(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += Math.Ceiling((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        if(n - 1 > hour || hour - n + 1 <= 0) return -1;\\n        int left = 1, right = Math.max(Arrays.stream(dist).max().getAsInt(), (int)Math.ceil(dist[n - 1] / (hour - n + 1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            double total_time = 0;\\n            for(int i = 0; i < n - 1; i++) total_time += Math.ceil((double)dist[i] / mid);\\n            total_time += (double)dist[n - 1] / mid;\\n            if(total_time <= hour) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} dist\\n * @param {number} hour\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    const canArriveOnTime = (speed) => {\\n        return dist.slice(0, -1).reduce((total, d) => total + Math.ceil(d / speed), 0) + dist[dist.length - 1] / speed <= hour;\\n    };\\n\\n    let n = dist.length;\\n    if (n - 1 > hour || hour - n + 1 <= 0) {\\n        return -1;\\n    }\\n\\n    let left = 1, right = Math.max(...dist, Math.ceil(dist[dist.length - 1] / (hour - n + 1)));\\n    while (left < right) {\\n        let mid = Math.floor((left + right) / 2);\\n        if (canArriveOnTime(mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return left;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818340,
                "title": "106-ms-100-optimal-time-and-space-complexity-with-binary-search-approach-javascript",
                "content": "# Intuition\\nFind the slowest train speed using **binary search** to reach the office on time. Trains leave at whole hours (1 sharp, 2 sharp, etc..).\\n\\n# Approach\\nSet the lowest speed to 1 (`lowerBound`) and highest speed to 10$$^7$$ (`upperBound`).\\nCalculate the middle speed.\\nWe find total time with current speed using the local `calcTime` function.\\nWe increase the lowest speed if time is more than the `hour`.\\nBut if the time is less than or equal to `hour`, we update the result and highest speed.\\nWe keep iterating with our binary search approach until we hit the lowest speed being equal or less than the highest speed.\\nFinally, we return result (which defaults to -1 if impossible).\\n\\n# Complexity\\n- Time complexity:\\n$$O(nLog-upperBound )$$ where `upperBound` is the maximum speed as stated in the description.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} dist //int array\\n * @param {number} hour //float - time you have to reach the office\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    let lowerBound = 1\\n    let upperBound = 10**7\\n\\n    let result = -1;\\n    const calcTime = function(d, s) {\\n      let travelTime = 0;\\n      for (let i = 0; i < d.length - 1; i++) {\\n        travelTime += Math.ceil(d[i]/s)\\n      }\\n      travelTime += d[d.length - 1]/s;\\n      return travelTime\\n    }\\n    \\n    while (lowerBound <= upperBound) {\\n      const m = Math.floor((lowerBound+upperBound)/2)\\n      const time = calcTime(dist, m)\\n      if (time > hour) lowerBound = m + 1\\n      else {\\n        result = m;\\n        upperBound = m - 1\\n      }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} dist //int array\\n * @param {number} hour //float - time you have to reach the office\\n * @return {number}\\n */\\nvar minSpeedOnTime = function(dist, hour) {\\n    let lowerBound = 1\\n    let upperBound = 10**7\\n\\n    let result = -1;\\n    const calcTime = function(d, s) {\\n      let travelTime = 0;\\n      for (let i = 0; i < d.length - 1; i++) {\\n        travelTime += Math.ceil(d[i]/s)\\n      }\\n      travelTime += d[d.length - 1]/s;\\n      return travelTime\\n    }\\n    \\n    while (lowerBound <= upperBound) {\\n      const m = Math.floor((lowerBound+upperBound)/2)\\n      const time = calcTime(dist, m)\\n      if (time > hour) lowerBound = m + 1\\n      else {\\n        result = m;\\n        upperBound = m - 1\\n      }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818277,
                "title": "c-binary-search-optimizations-beats-98",
                "content": "\\n# Method 1: Standard Binary Search | $$O(Nlog(1e7))$$\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n        int start = 1;\\n        int end = 1e7;\\n        if(hour<=(double)dist.size()-1)return -1;\\n        while(start<end){\\n            int mid = (start+end)>>1;\\n            for(int i = 0; i<n-1; i++){\\n                sum+=(double)dist[i]/mid;\\n                sum=ceil(sum);\\n            }\\n            sum+=(double)dist[n-1]/mid;\\n            if(sum<=hour)end=mid;\\n            else start=mid+1;\\n            sum=0;\\n        }\\n        return end;\\n    }\\n};\\n```\\n# Method 2: Optimization | $$O(Nlog(max(max-element,last/frac(hour))))$$\\n\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n        int start = 1;\\n        double limit = hour==floor(hour)?0:dist[n-1]/(hour-floor(hour))+1;\\n        int end = (int)max((double)*max_element(dist.begin(),dist.end()),limit);\\n        if(hour<=(double)dist.size()-1)return -1;\\n        while(start<end){\\n            int mid = (start+end)>>1;\\n            for(int i = 0; i<n-1; i++){\\n                sum+=(double)dist[i]/mid;\\n                sum=ceil(sum);\\n            }\\n            sum+=(double)dist[n-1]/mid;\\n            if(sum<=hour)end=mid;\\n            else start=mid+1;\\n            sum=0;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n        int start = 1;\\n        int end = 1e7;\\n        if(hour<=(double)dist.size()-1)return -1;\\n        while(start<end){\\n            int mid = (start+end)>>1;\\n            for(int i = 0; i<n-1; i++){\\n                sum+=(double)dist[i]/mid;\\n                sum=ceil(sum);\\n            }\\n            sum+=(double)dist[n-1]/mid;\\n            if(sum<=hour)end=mid;\\n            else start=mid+1;\\n            sum=0;\\n        }\\n        return end;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n        int start = 1;\\n        double limit = hour==floor(hour)?0:dist[n-1]/(hour-floor(hour))+1;\\n        int end = (int)max((double)*max_element(dist.begin(),dist.end()),limit);\\n        if(hour<=(double)dist.size()-1)return -1;\\n        while(start<end){\\n            int mid = (start+end)>>1;\\n            for(int i = 0; i<n-1; i++){\\n                sum+=(double)dist[i]/mid;\\n                sum=ceil(sum);\\n            }\\n            sum+=(double)dist[n-1]/mid;\\n            if(sum<=hour)end=mid;\\n            else start=mid+1;\\n            sum=0;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817610,
                "title": "99-beat-simple-and-clean-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if (n - 1 >= hour) {\\n            return -1;\\n        }\\n        int i = 1;\\n        int j = 10000000;\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            double sum = 0.0;\\n            for (int k = 0; k < n - 1; k++) {\\n                sum += ceil(dist[k] / (double)(mid));\\n            }\\n            sum += (double)(dist[n - 1]) / mid;\\n\\n            if (sum <= hour) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if (n - 1 >= hour) {\\n            return -1;\\n        }\\n        int i = 1;\\n        int j = 10000000;\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            double sum = 0.0;\\n            for (int k = 0; k < n - 1; k++) {\\n                sum += ceil(dist[k] / (double)(mid));\\n            }\\n            sum += (double)(dist[n - 1]) / mid;\\n\\n            if (sum <= hour) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817202,
                "title": "c-solution-well-commented-edge-case-check-and-beats-100-in-space-and-time",
                "content": "# Intuition\\nSame as described in the editorial\\n\\n# Complexity\\n- Time complexity:\\nO(log(10^7)*dist.Length) reduces to O(n);\\n\\n- Space complexity:\\nO(1) Not taking any additional space\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        //Cannot reach in time if hour\\'s integer part is less than\\n        // array length since every train takes at least one hour to \\n        // start\\n        if(dist.Length > Math.Ceiling(hour)) return -1;\\n\\n        //Using Binary search to find speed. Upper limit is given in \\n        // the question. Lower limit is anyway 1 (since output is int)\\n        int lSpeed = 1; int rSpeed = 10000000;\\n        while(lSpeed < rSpeed){\\n            int m = lSpeed + (rSpeed - lSpeed)/2;\\n            double outTime = TimeRequired(dist, m);\\n                      \\n            //Checking binary search condition\\n            if(outTime > hour){\\n                lSpeed = m + 1;\\n            } \\n            else{\\n                rSpeed = m;\\n            } \\n        }\\n\\n        //By the end, we would have found the optimal speed\\n        return lSpeed; \\n    }\\n\\n    private double TimeRequired(int[] dist, int speed){\\n        double outTime = 0;\\n        //Calculating int upper values of all but last dist[i] since each train leaves at the hour only\\n        for(int i = 0; i < dist.Length - 1; i++){\\n            outTime += Math.Ceiling((double)dist[i]/speed);\\n        }\\n        //Last dist entry can be float since last stop is right at our office. \\n        outTime += (double)dist[dist.Length - 1]/speed;\\n\\n        return outTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        //Cannot reach in time if hour\\'s integer part is less than\\n        // array length since every train takes at least one hour to \\n        // start\\n        if(dist.Length > Math.Ceiling(hour)) return -1;\\n\\n        //Using Binary search to find speed. Upper limit is given in \\n        // the question. Lower limit is anyway 1 (since output is int)\\n        int lSpeed = 1; int rSpeed = 10000000;\\n        while(lSpeed < rSpeed){\\n            int m = lSpeed + (rSpeed - lSpeed)/2;\\n            double outTime = TimeRequired(dist, m);\\n                      \\n            //Checking binary search condition\\n            if(outTime > hour){\\n                lSpeed = m + 1;\\n            } \\n            else{\\n                rSpeed = m;\\n            } \\n        }\\n\\n        //By the end, we would have found the optimal speed\\n        return lSpeed; \\n    }\\n\\n    private double TimeRequired(int[] dist, int speed){\\n        double outTime = 0;\\n        //Calculating int upper values of all but last dist[i] since each train leaves at the hour only\\n        for(int i = 0; i < dist.Length - 1; i++){\\n            outTime += Math.Ceiling((double)dist[i]/speed);\\n        }\\n        //Last dist entry can be float since last stop is right at our office. \\n        outTime += (double)dist[dist.Length - 1]/speed;\\n\\n        return outTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817158,
                "title": "using-binary-search-easy-to-unserstand",
                "content": "## Please upvote if you like the solution\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool f(vector<int>& dist, int v, double hour){\\n        double res = 0;\\n        int n = dist.size();\\n        for(int i = 0; i < n; i++){\\n            double t = (double)dist[i] / v;\\n            res += (i == n - 1) ? t : ceil(t);\\n            if(res > hour) return false;\\n        }\\n        return res <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 1, high = 1e7, ans = -1;\\n\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(f(dist, mid, hour)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool f(vector<int>& dist, int v, double hour){\\n        double res = 0;\\n        int n = dist.size();\\n        for(int i = 0; i < n; i++){\\n            double t = (double)dist[i] / v;\\n            res += (i == n - 1) ? t : ceil(t);\\n            if(res > hour) return false;\\n        }\\n        return res <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 1, high = 1e7, ans = -1;\\n\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(f(dist, mid, hour)){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816897,
                "title": "c-o-nlog-range-binary-search-over-range",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n* check if particular speed, it is possible to reach in time <= hour or not.\\n* if possible : check if we can reach in time with lesser speed (reducing search space to [left,right-1])\\n* if not possible: check if we can reach in time with higher speed (reducing search space to [left+1,right])\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& dist, double hour, int speed){\\n        int n=dist.size();\\n        \\n        double time=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            time += dist[i]/speed;\\n            \\n            if(dist[i]%speed!=0) time++; // waiting for next integer hour\\n        }\\n        time += double(dist[n-1])/speed; // at last station we don\\'t have to wait for additional time\\n        \\n        return (time<=hour);\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left=1;\\n        int right=(int)(1e7+5);\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(isPossible(dist,hour,mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return (left < 1e7+1 ? left:-1); // since max. allowed speed is 1e7\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(vector<int>& dist, double hour, int speed){\\n        int n=dist.size();\\n        \\n        double time=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            time += dist[i]/speed;\\n            \\n            if(dist[i]%speed!=0) time++; // waiting for next integer hour\\n        }\\n        time += double(dist[n-1])/speed; // at last station we don\\'t have to wait for additional time\\n        \\n        return (time<=hour);\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left=1;\\n        int right=(int)(1e7+5);\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(isPossible(dist,hour,mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return (left < 1e7+1 ? left:-1); // since max. allowed speed is 1e7\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200170,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n=dist.size();\\n        ll l=1,r=10000000;\\n        int ans=-1;\\n        while(l<=r){\\n           ll m=(l+r)/2;\\n           double tt=0;\\n           for(int i=0;i<n-1;i++){\\n               tt += (dist[i]) / m;\\n               if(dist[i]%m)tt++;\\n           }\\n           tt += (double)dist[n-1]/m;\\n           if(hour>=tt){\\n               ans=m;\\n               r=m-1;\\n           }\\n           else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/6c6e38c7-7dde-48b2-bf9c-50bf4963a54c_1676703434.1046567.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n=dist.size();\\n        ll l=1,r=10000000;\\n        int ans=-1;\\n        while(l<=r){\\n           ll m=(l+r)/2;\\n           double tt=0;\\n           for(int i=0;i<n-1;i++){\\n               tt += (dist[i]) / m;\\n               if(dist[i]%m)tt++;\\n           }\\n           tt += (double)dist[n-1]/m;\\n           if(hour>=tt){\\n               ans=m;\\n               r=m-1;\\n           }\\n           else l=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224905,
                "title": "python3-binary-search",
                "content": "\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        lo, hi = 1, 10_000_001\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            tm = sum((dist[i]+mid-1)//mid for i in range(0, len(dist)-1)) + dist[-1]/mid\\n            if tm <= hour: hi = mid\\n            else: lo = mid + 1\\n        return lo if lo < 10_000_001 else -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        lo, hi = 1, 10_000_001\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            tm = sum((dist[i]+mid-1)//mid for i in range(0, len(dist)-1)) + dist[-1]/mid\\n            if tm <= hour: hi = mid\\n            else: lo = mid + 1\\n        return lo if lo < 10_000_001 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821820,
                "title": "easy-solution-with-explanation-beginner-friendly",
                "content": "# Approach\\n- Check if its possible to tavel the whole distance with minimum speed in the given hour, if not then `return -1`\\n- Create `left` and `right` pointer \\n- Run while loop to the point where `left < right` :\\n    - calculate `mid = (left + right)//2`\\n    - check if the traversal time is less than given hour\\n        - if yes then update right pointer and explre `left` side of `mid`/threshold for minimum speed.\\n        - if not then update left pointer with `mid + 1` and explore right side of mid value.\\n- `return left` as answer \\n# Video Explanation\\nhttps://youtu.be/voRNrnZBsUQ\\n# Complexity\\n- Time complexity:\\nO(log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour+1 : return -1\\n\\n        left = 1\\n        right = 10**7\\n        while left < right:\\n            mid = (left + right)//2\\n\\n            if sum([ceil(i/mid) for i in dist[:-1]])+ (dist[-1]/mid) <= hour :\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n\\n```\\n#### Upvote if find this useful \\uD83D\\uDE80\\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour+1 : return -1\\n\\n        left = 1\\n        right = 10**7\\n        while left < right:\\n            mid = (left + right)//2\\n\\n            if sum([ceil(i/mid) for i in dist[:-1]])+ (dist[-1]/mid) <= hour :\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821057,
                "title": "c-beats-100-runtime-100-memory",
                "content": "# Intuition\\nI started to solve the problem using the brain, but it didn\\'t work, so you can see this approach.\\n\\n# Approach\\nThe main idea is to solve the problem without using the brain.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(m))$$\\nWhere $$m$$ - speed upper bound, $$n$$ - number of rides.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinSpeedOnTime(int[] dist, double hour)\\n    {\\n        int left = 1;\\n        int right = 10000000 + 1;\\n\\n        double timeTaken = 0;\\n        int min = 0;\\n\\n        while (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n\\n            timeTaken = 0;\\n            for (int i = 0; i < dist.Length - 1; i++)\\n            {\\n                timeTaken += Math.Ceiling((double) dist[i] / mid);\\n            }\\n\\n            timeTaken += (double) dist[^1] / mid;\\n            \\n            if (timeTaken > hour)\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                min = right;\\n                right = mid;\\n            }\\n        }\\n\\n        if (min == 0)\\n        {\\n            return -1;\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinSpeedOnTime(int[] dist, double hour)\\n    {\\n        int left = 1;\\n        int right = 10000000 + 1;\\n\\n        double timeTaken = 0;\\n        int min = 0;\\n\\n        while (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n\\n            timeTaken = 0;\\n            for (int i = 0; i < dist.Length - 1; i++)\\n            {\\n                timeTaken += Math.Ceiling((double) dist[i] / mid);\\n            }\\n\\n            timeTaken += (double) dist[^1] / mid;\\n            \\n            if (timeTaken > hour)\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                min = right;\\n                right = mid;\\n            }\\n        }\\n\\n        if (min == 0)\\n        {\\n            return -1;\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821056,
                "title": "c-100-runtime-and-memory-using-binary-search",
                "content": "# Intuition\\nAt first I tried to use brutefore iterating over all available velocities starting from 1 and going to $$10^7$$.\\n\\nIt didn\\'t turn out well...\\n\\n# Approach\\n\\nThe main idea behind this algorithm is not to use bruteforce. Using binary search over all available velocities we can fastly determine minimum velocity in $$O(n log m)$$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log m)$$ where m is upper bound of velocity\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MinSpeedOnTime(int[] dist, double hour)\\n    {\\n        int start = 1;\\n        int end = 10_000_000 + 1;\\n        int velocity;\\n        int minVelocity = int.MaxValue;\\n        double timeSpent;\\n\\n        while (start < end)\\n        {\\n            timeSpent = 0;\\n            velocity = (start + end) / 2;\\n\\n            for (int i = 0; i < dist.Length; i++)\\n            {\\n                if (i == dist.Length - 1)\\n                {\\n                    timeSpent += (double)dist[i] / (double)velocity;\\n                }\\n                else\\n                {\\n                    timeSpent += Math.Ceiling((double)dist[i] / velocity);\\n                }\\n            }\\n\\n            if (timeSpent <= hour)\\n            {\\n                end = velocity;\\n                if (velocity < minVelocity)\\n                {\\n                    minVelocity = velocity;\\n                }\\n            }\\n            else\\n            {\\n                start = velocity + 1;\\n            }\\n        }\\n\\n        if (minVelocity == int.MaxValue)\\n        {\\n            return -1;\\n        }\\n\\n        return minVelocity;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinSpeedOnTime(int[] dist, double hour)\\n    {\\n        int start = 1;\\n        int end = 10_000_000 + 1;\\n        int velocity;\\n        int minVelocity = int.MaxValue;\\n        double timeSpent;\\n\\n        while (start < end)\\n        {\\n            timeSpent = 0;\\n            velocity = (start + end) / 2;\\n\\n            for (int i = 0; i < dist.Length; i++)\\n            {\\n                if (i == dist.Length - 1)\\n                {\\n                    timeSpent += (double)dist[i] / (double)velocity;\\n                }\\n                else\\n                {\\n                    timeSpent += Math.Ceiling((double)dist[i] / velocity);\\n                }\\n            }\\n\\n            if (timeSpent <= hour)\\n            {\\n                end = velocity;\\n                if (velocity < minVelocity)\\n                {\\n                    minVelocity = velocity;\\n                }\\n            }\\n            else\\n            {\\n                start = velocity + 1;\\n            }\\n        }\\n\\n        if (minVelocity == int.MaxValue)\\n        {\\n            return -1;\\n        }\\n\\n        return minVelocity;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819025,
                "title": "binarysearch-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l=1;\\n        int r=10000000;\\n\\n        int minSpeed=-1;\\n        while(l<=r){\\n            int midSpeed=l+(r-l)/2;\\n            if(possible(dist ,midSpeed)<=hour){\\n                minSpeed=midSpeed;\\n                r=midSpeed-1;\\n            }else{\\n                l=midSpeed+1;\\n            }\\n        }\\n        return minSpeed;\\n    }\\n\\n    public double possible(int [] dist, int midSpeed){\\n        double time=0.0;\\n        for(int i=0; i<dist.length-1; i++){\\n            double t=(double)dist[i]/(double)midSpeed;\\n            time=time + Math.ceil(t);\\n        }\\n        time = (double) dist[dist.length-1]/(double) midSpeed +time;\\n\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l=1;\\n        int r=10000000;\\n\\n        int minSpeed=-1;\\n        while(l<=r){\\n            int midSpeed=l+(r-l)/2;\\n            if(possible(dist ,midSpeed)<=hour){\\n                minSpeed=midSpeed;\\n                r=midSpeed-1;\\n            }else{\\n                l=midSpeed+1;\\n            }\\n        }\\n        return minSpeed;\\n    }\\n\\n    public double possible(int [] dist, int midSpeed){\\n        double time=0.0;\\n        for(int i=0; i<dist.length-1; i++){\\n            double t=(double)dist[i]/(double)midSpeed;\\n            time=time + Math.ceil(t);\\n        }\\n        time = (double) dist[dist.length-1]/(double) midSpeed +time;\\n\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818758,
                "title": "video-solution-c-java",
                "content": "# Intuition, Approach and Time complexity dicussed in detail in video explanation\\nhttps://youtu.be/6HQzBdROi-I\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        return findMinS(dist, hour);\\n    }\\nprivate:\\n\\n    int findMinS(vector<int> &dist, double hour){\\n        int minS = -1, left = 0, right = 1e7 + 1;\\n        while(left <= right){\\n       \\n            int mid = left + (right - left)/2;\\n           \\n            if(isEnough(dist, hour, mid)){\\n                minS = mid;\\n                right = mid -1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return minS;\\n    }\\n    bool isEnough(vector<int> &dist, double hour, int speed){\\n         int sz = dist.size();\\n         double timeTkn = 0.0;\\n         for(int indx = 0; indx<sz; indx++){\\n              double crTimeTkn = (dist[indx] * 1.0) / speed;\\n              if(indx != sz - 1){\\n                  crTimeTkn = ceil(crTimeTkn);\\n              }\\n              timeTkn += (crTimeTkn);\\n         }\\n    \\n         return timeTkn <= hour;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n          return findMinS(dist, hour);\\n    }\\n    private int findMinS(int []dist, double hour){\\n        int minS = -1, left = 0, right = 10000007 + 1;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(isEnough(dist, hour, mid)){\\n                minS = mid;\\n                right = mid -1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return minS;\\n    }\\n    private boolean isEnough(int []dist, double hour, int speed){\\n         int sz = dist.length;\\n         double timeTkn = 0.0;\\n         for(int indx = 0; indx<sz; indx++){\\n              double crTimeTkn = (dist[indx] * 1.0) / speed;\\n              if(indx != sz - 1){\\n                  crTimeTkn = Math.ceil(crTimeTkn);\\n              }\\n              timeTkn += (crTimeTkn);\\n         }\\n         return timeTkn <= hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        return findMinS(dist, hour);\\n    }\\nprivate:\\n\\n    int findMinS(vector<int> &dist, double hour){\\n        int minS = -1, left = 0, right = 1e7 + 1;\\n        while(left <= right){\\n       \\n            int mid = left + (right - left)/2;\\n           \\n            if(isEnough(dist, hour, mid)){\\n                minS = mid;\\n                right = mid -1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return minS;\\n    }\\n    bool isEnough(vector<int> &dist, double hour, int speed){\\n         int sz = dist.size();\\n         double timeTkn = 0.0;\\n         for(int indx = 0; indx<sz; indx++){\\n              double crTimeTkn = (dist[indx] * 1.0) / speed;\\n              if(indx != sz - 1){\\n                  crTimeTkn = ceil(crTimeTkn);\\n              }\\n              timeTkn += (crTimeTkn);\\n         }\\n    \\n         return timeTkn <= hour;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n          return findMinS(dist, hour);\\n    }\\n    private int findMinS(int []dist, double hour){\\n        int minS = -1, left = 0, right = 10000007 + 1;\\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            if(isEnough(dist, hour, mid)){\\n                minS = mid;\\n                right = mid -1;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        return minS;\\n    }\\n    private boolean isEnough(int []dist, double hour, int speed){\\n         int sz = dist.length;\\n         double timeTkn = 0.0;\\n         for(int indx = 0; indx<sz; indx++){\\n              double crTimeTkn = (dist[indx] * 1.0) / speed;\\n              if(indx != sz - 1){\\n                  crTimeTkn = Math.ceil(crTimeTkn);\\n              }\\n              timeTkn += (crTimeTkn);\\n         }\\n         return timeTkn <= hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818178,
                "title": "java-binary-search-explained",
                "content": "**Idea:**\\n* We can try all possible speeds, from 1 to 10^7, to see which one will work. \\n* This would be linear search, but we can do binary search since the speed range is sorted\\n* Find total time (T) for the journey to complete at the given speed, rounding up the time at each stop\\n* If T > hour, then increase speed\\n* Else, record this working speed, and decrease it to continue finding a slower speed\\n>**T/S:** O(n lg M)/O(1), where n = size(distances), M = max speed possible\\n>In this case M = 10^7, so time complexity is O(n)\\n```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n\\tvar minSpeed = -1;\\n\\tvar high = (int) 1e7; // top speed allowed\\n\\n\\tfor (var low = 1; low <= high;) {\\n\\t\\tvar time = 0d;\\n\\t\\tvar mid = low + (high - low) / 2;\\n\\t\\tvar midDouble = (double) mid;\\n\\n\\t\\tfor (var distance : dist)\\n\\t\\t\\ttime = Math.ceil(time) + distance / midDouble;\\n\\n\\t\\tif (time > hour) {\\n\\t\\t\\tlow = mid + 1; // too slow, go faster\\n\\t\\t} else {\\n\\t\\t\\tminSpeed = mid; // record this speed\\n\\t\\t\\thigh = mid - 1; // this speed works, try going slower\\n\\t\\t}\\n\\t}\\n\\n\\treturn minSpeed;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minSpeedOnTime(int[] dist, double hour) {\\n\\tvar minSpeed = -1;\\n\\tvar high = (int) 1e7; // top speed allowed\\n\\n\\tfor (var low = 1; low <= high;) {\\n\\t\\tvar time = 0d;\\n\\t\\tvar mid = low + (high - low) / 2;\\n\\t\\tvar midDouble = (double) mid;\\n\\n\\t\\tfor (var distance : dist)\\n\\t\\t\\ttime = Math.ceil(time) + distance / midDouble;\\n\\n\\t\\tif (time > hour) {\\n\\t\\t\\tlow = mid + 1; // too slow, go faster\\n\\t\\t} else {\\n\\t\\t\\tminSpeed = mid; // record this speed\\n\\t\\t\\thigh = mid - 1; // this speed works, try going slower\\n\\t\\t}\\n\\t}\\n\\n\\treturn minSpeed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818051,
                "title": "easy-intuitive-two-function-solution-beats-90",
                "content": "# Intuition\\nThis problem seemed very clearly to be a two pointer / binary search problem. We need to find the lowest value which satisfy certain constraints.\\n# Approach\\nIntially was to check if it is possible to arrive on time.\\nIf there are more trains than hours+1, it is impossible to arrive on time. \\n# Complexity\\n- Time complexity:\\nThe speedcheck function is n and the binary search is log(n) giving us.\\n$$O(n*log(n))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        #Check if it is possible to find a solution.\\n        if len(dist)-1>=hour:\\n            return -1\\n        #A function to check if a certain speed is feasible.\\n        def speedcheck(speed):\\n            time=0\\n            #Adding time for each train rounded up.\\n            for i in dist[:-1]:\\n                time+=ceil(i/speed)\\n            #Not rounding up the last train.\\n            time+= dist[-1]/speed\\n            #If the final time is less than required time, return True\\n            if time<=hour:\\n                return True\\n        def search(slow, fastest):\\n            #Classic binary search starting with 1 as slow and 10^7 as fastest\\n            l=slow\\n            r= fastest\\n\\n            while l < r:\\n                #Find the value in the middle of l and r\\n                mid = floor((l+r)/2)\\n                #If the middle value is feasible, move right pointer there.\\n                if speedcheck(mid):\\n                    r=mid\\n                    continue\\n                #Otherwise move left pointer to one point right of mid. \\n                else:\\n                    l=mid+1\\n            return l\\n        return search(1,10**7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        #Check if it is possible to find a solution.\\n        if len(dist)-1>=hour:\\n            return -1\\n        #A function to check if a certain speed is feasible.\\n        def speedcheck(speed):\\n            time=0\\n            #Adding time for each train rounded up.\\n            for i in dist[:-1]:\\n                time+=ceil(i/speed)\\n            #Not rounding up the last train.\\n            time+= dist[-1]/speed\\n            #If the final time is less than required time, return True\\n            if time<=hour:\\n                return True\\n        def search(slow, fastest):\\n            #Classic binary search starting with 1 as slow and 10^7 as fastest\\n            l=slow\\n            r= fastest\\n\\n            while l < r:\\n                #Find the value in the middle of l and r\\n                mid = floor((l+r)/2)\\n                #If the middle value is feasible, move right pointer there.\\n                if speedcheck(mid):\\n                    r=mid\\n                    continue\\n                #Otherwise move left pointer to one point right of mid. \\n                else:\\n                    l=mid+1\\n            return l\\n        return search(1,10**7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817831,
                "title": "kotlin-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(maxAnswer))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun minSpeedOnTime(dist: IntArray, hour: Double): Int {\\n        var (l, r) = 1 to 10_000_000\\n        while (l <= r) {\\n            val m = (l + r) / 2\\n            var h = 0.0\\n            dist.forEachIndexed { i, v ->\\n                if (i != dist.size - 1) h += (v + m - 1) / m\\n                else h += v / m.toDouble()\\n            }\\n            if (h > hour) l = m + 1\\n            else if (h < hour) r = m - 1\\n            else return m\\n        }\\n        return if (l <= 10_000_000) l else -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    fun minSpeedOnTime(dist: IntArray, hour: Double): Int {\\n        var (l, r) = 1 to 10_000_000\\n        while (l <= r) {\\n            val m = (l + r) / 2\\n            var h = 0.0\\n            dist.forEachIndexed { i, v ->\\n                if (i != dist.size - 1) h += (v + m - 1) / m\\n                else h += v / m.toDouble()\\n            }\\n            if (h > hour) l = m + 1\\n            else if (h < hour) r = m - 1\\n            else return m\\n        }\\n        return if (l <= 10_000_000) l else -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817728,
                "title": "best-c-solution-list-of-10-similar-very-imp-problems-asked-in-faang-interviews",
                "content": "# [List of similar VERY IMP questions](https://leetcode.com/problems/koko-eating-bananas/solutions/3750804/best-c-solution-list-of-9-similar-very-imp-binary-search-questions/)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(), start = 1, end = 1e7, ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            double sum = 0;\\n            for(int i=0; i<n; i++){\\n                double d = dist[i]*1.0 / mid;\\n                sum = i==n-1 ? sum + d : sum + ceil(d);\\n            }\\n            if(sum <= hour)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(), start = 1, end = 1e7, ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            double sum = 0;\\n            for(int i=0; i<n; i++){\\n                double d = dist[i]*1.0 / mid;\\n                sum = i==n-1 ? sum + d : sum + ceil(d);\\n            }\\n            if(sum <= hour)\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817650,
                "title": "golang-binary-search",
                "content": "# Code\\n```\\nfunc solve(dist []int, val int) float64 {\\n    sum := 0.0\\n    for i := 0; i < len(dist) - 1; i++ {\\n        sum += math.Ceil(1.0 * float64(dist[i]) / float64(val))\\n    }\\n    return sum + (1.0 * float64(dist[len(dist) - 1]) / float64(val))\\n}\\n\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n    low := 1\\n    high := 10000000\\n    ans := math.MaxInt\\n    for low <= high {\\n        mid := low + (high - low) / 2\\n        if solve(dist, mid) > hour {\\n            low = mid + 1\\n        } else {\\n            if mid < ans {ans = mid}\\n            high = mid - 1\\n        }\\n    }\\n    if ans == math.MaxInt {return -1}\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc solve(dist []int, val int) float64 {\\n    sum := 0.0\\n    for i := 0; i < len(dist) - 1; i++ {\\n        sum += math.Ceil(1.0 * float64(dist[i]) / float64(val))\\n    }\\n    return sum + (1.0 * float64(dist[len(dist) - 1]) / float64(val))\\n}\\n\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n    low := 1\\n    high := 10000000\\n    ans := math.MaxInt\\n    for low <= high {\\n        mid := low + (high - low) / 2\\n        if solve(dist, mid) > hour {\\n            low = mid + 1\\n        } else {\\n            if mid < ans {ans = mid}\\n            high = mid - 1\\n        }\\n    }\\n    if ans == math.MaxInt {return -1}\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817189,
                "title": "binarysearch-on-ans-with-explanation-c",
                "content": "### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Approach\\n\\n1. `isFeasible` function:\\n   - This function takes three parameters: `speed` (an integer representing the speed of the vehicle), `dist` (a vector of integers representing the distances between checkpoints), and `hour` (a double representing the target time in hours).\\n   - It calculates the total time taken to travel the given distances at the given speed.\\n   - If the calculated time exceeds the target time (`hour`), it means the vehicle cannot complete the journey within the specified time, and the function returns `false`.\\n   - If the journey can be completed within the target time, the function returns `true`.\\n\\n2. `minSpeedOnTime` function:\\n   - This function takes two parameters: `dist` (a vector of integers representing the distances between checkpoints) and `hour` (a double representing the target time in hours).\\n   - It initializes variables `ll` (lower limit), `ul` (upper limit), `mid`, and `ans` (the answer to be returned).\\n   - The lower limit (`ll`) is set to 1, and the upper limit (`ul`) is set to 1e7.\\n   - It then enters a binary search loop to find the minimum speed required to complete the journey within the target time.\\n   - The `isFeasible` function is called within the loop with the current `mid` speed value, and based on the result, the lower or upper limit is updated accordingly.\\n   - The loop continues until `ll` is less than or equal to `ul`.\\n   - Finally, the minimum speed required to complete the journey within the target time is returned as the answer.\\n\\n### Overall, the `minSpeedOnTime` function uses binary search to efficiently find the minimum speed required to complete the journey on time. If such a speed exists, it returns the answer; otherwise, it returns -1 to indicate that the journey cannot be completed within the given time constraints.\\n\\n## **Note:** The `ceil` function is used in the `isFeasible` function to round up the calculated time to the nearest integer. This ensures that even if a fraction of an hour is left for the final checkpoint, the vehicle still has enough time to reach it.\\n# Complexity\\n```\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n```\\n\\n# Code\\n## Please Upvote if u found my Solution useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool isFeasible(int speed ,vector<int>& dist, double hour){\\n        double time_taken = 0;\\n        for(auto it : dist){\\n            time_taken += ((double)it / speed);\\n            if(time_taken > hour)\\n                return false;\\n            time_taken = ceil(time_taken);\\n        }\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(), ll = 1, ul = 1e7, mid = 0, ans = -1;\\n        while(ll <= ul){\\n            mid = ll + ul >> 1 ;\\n            if(isFeasible(mid, dist, hour)){\\n                ul = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    bool isFeasible(int speed ,vector<int>& dist, double hour){\\n        double time_taken = 0;\\n        for(auto it : dist){\\n            time_taken += ((double)it / speed);\\n            if(time_taken > hour)\\n                return false;\\n            time_taken = ceil(time_taken);\\n        }\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size(), ll = 1, ul = 1e7, mid = 0, ans = -1;\\n        while(ll <= ul){\\n            mid = ll + ul >> 1 ;\\n            if(isFeasible(mid, dist, hour)){\\n                ul = mid - 1;\\n                ans = mid;\\n            }\\n            else\\n                ll = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817131,
                "title": "easy-c-solution-using-binary-search-time-complexity-o-n-log-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the minimum speed needed to complete a journey represented by a vector of distances `dist` within a given time `hour`. We need to find the smallest possible speed that allows us to finish the journey in the given time. To solve this, we can use **`binary search`** over the possible speeds i.e 10^7.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. We will define a helper function `f()` that takes a `speed`, `hour`, and the vector `dist` as input and calculates the estimated time to complete the journey at the given speed. It traverses the distance vector and adds up the time taken to travel each segment at the given speed.\\n2. Next, we perform `binary search` for the minimum speed required. We initialize `low` as 1 (minimum possible speed) and `high` as a large value, such as `1e7`, which represents the maximum possible speed.\\n3. While `low` is less than or equal to high, we find the middle speed mid using bitwise right shift by 1 (equivalent to dividing by 2).We then convert mid to a double value speed.\\n4. We use the `f()` function to check if the estimated time to complete the journey at the current speed is less than or equal to the given hour. If it is, we update the ans variable with the current speed and search for a smaller speed in the left half by setting `high = mid - 1`.\\n5. If the estimated time is greater than the given hour, we search for a larger speed in the right half by setting `low = mid + 1`.\\nWe continue the binary search until low becomes greater than high, at which point we have found the minimum speed required to complete the journey within the given hour.\\n6. Finally, we return the `ans` variable, which will store the minimum speed needed.\\n# Complexity\\n- Time complexity: $$O(n log m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    -  The f() function has a time complexity of O(n), where n is the size of the dist vector. The binary search has a time complexity of O(log m), where m is the range of possible speeds (1e7 in this case). Overall, the time complexity is O(n log m).\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // Function to calculate the estimated time to complete the journey at a given speed\\n    bool f(double speed, double hour, vector<int>& dist) {\\n        double sum = 0;\\n        int n = dist.size();\\n        for (int i = 0; i < n; i++) {\\n            if (i != n - 1) {\\n                sum += ceil(dist[i] / speed);\\n            } else {\\n                sum += (double)dist[i] / speed;\\n            }\\n            if (sum > hour) {\\n                return false;\\n            }\\n        }\\n        return sum <= hour;\\n    }\\n\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 1;\\n        int high = 1e7;\\n        int ans = -1;\\n        while (low <= high) {\\n            int mid = (low + high) >> 1;\\n            double speed = double(mid);\\n\\n            // Check if we can complete the journey at the current speed\\n            if (f(speed, hour, dist)) {\\n                ans = speed;\\n                high = mid - 1; // Search for smaller speeds in the left half\\n            } else {\\n                low = mid + 1;  // Search for larger speeds in the right half\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Function to calculate the estimated time to complete the journey at a given speed\\n    bool f(double speed, double hour, vector<int>& dist) {\\n        double sum = 0;\\n        int n = dist.size();\\n        for (int i = 0; i < n; i++) {\\n            if (i != n - 1) {\\n                sum += ceil(dist[i] / speed);\\n            } else {\\n                sum += (double)dist[i] / speed;\\n            }\\n            if (sum > hour) {\\n                return false;\\n            }\\n        }\\n        return sum <= hour;\\n    }\\n\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 1;\\n        int high = 1e7;\\n        int ans = -1;\\n        while (low <= high) {\\n            int mid = (low + high) >> 1;\\n            double speed = double(mid);\\n\\n            // Check if we can complete the journey at the current speed\\n            if (f(speed, hour, dist)) {\\n                ans = speed;\\n                high = mid - 1; // Search for smaller speeds in the left half\\n            } else {\\n                low = mid + 1;  // Search for larger speeds in the right half\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817044,
                "title": "why-binary-search-similar-leetcode-codestorywithmik",
                "content": "YouTube Video Link - [Minimum Speed to Arrive on Time](https://www.youtube.com/watch?v=6VHDJMYtn3Q)\\nMy Github Treasure - [Minimum Speed to Arrive on Time](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Binary%20Search/Minimum%20Speed%20to%20Arrive%20on%20Time.cpp)\\n\\n\\n```\\n/*\\n  Two hints in this Qn which lead to Binary Search\\n  - The range of possible values here is 1 - 10^7. In binary search, we have to find answer from a sorted array. \\n    Here we are left of finding answer from a sorted range. That\\'s why it can be done using binary search\\n\\n  - We have to find a speed x such that total time taken is less than the time given in problem,\\n    if I take too less speed then, it will take much more time and\\n    if we take more speed it will take less time but we need to keep speed to minimum.\\n    It hints towards moving towards left or right which we do in Binary Search\\n*/\\n\\n//Binary Search\\nclass Solution {\\npublic:\\n    \\n    double possible(vector<int>& dist, int speed) {\\n        \\n        double time = 0.0;\\n        \\n        for(int i = 0; i < dist.size(); i++) {\\n            \\n            double t = (double)dist[i]/(double)speed;\\n            \\n            if(i == dist.size()-1)\\n                time += t;\\n            else\\n                time += ceil(t);\\n            \\n        }\\n        \\n        return time;\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1;\\n        int r = 1e7;\\n        \\n        int minSpeed = -1;\\n        \\n        while(l <= r) {\\n            \\n            int mid = l + (r-l)/2;\\n            \\n            if(possible(dist, mid) <= hour) {\\n                minSpeed = mid;\\n                r = mid-1;\\n            } else {\\n                l = mid+1; //need to speed up\\n            }\\n            \\n        }\\n        \\n        return minSpeed;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n  Two hints in this Qn which lead to Binary Search\\n  - The range of possible values here is 1 - 10^7. In binary search, we have to find answer from a sorted array. \\n    Here we are left of finding answer from a sorted range. That\\'s why it can be done using binary search\\n\\n  - We have to find a speed x such that total time taken is less than the time given in problem,\\n    if I take too less speed then, it will take much more time and\\n    if we take more speed it will take less time but we need to keep speed to minimum.\\n    It hints towards moving towards left or right which we do in Binary Search\\n*/\\n\\n//Binary Search\\nclass Solution {\\npublic:\\n    \\n    double possible(vector<int>& dist, int speed) {\\n        \\n        double time = 0.0;\\n        \\n        for(int i = 0; i < dist.size(); i++) {\\n            \\n            double t = (double)dist[i]/(double)speed;\\n            \\n            if(i == dist.size()-1)\\n                time += t;\\n            else\\n                time += ceil(t);\\n            \\n        }\\n        \\n        return time;\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1;\\n        int r = 1e7;\\n        \\n        int minSpeed = -1;\\n        \\n        while(l <= r) {\\n            \\n            int mid = l + (r-l)/2;\\n            \\n            if(possible(dist, mid) <= hour) {\\n                minSpeed = mid;\\n                r = mid-1;\\n            } else {\\n                l = mid+1; //need to speed up\\n            }\\n            \\n        }\\n        \\n        return minSpeed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817027,
                "title": "99-faster-python-solution-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is quite a classic problem at least on leetcode. We do binary search on the possible solutions in this case is the speed. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem has no solutions if the length of dist - 1 >= hour as that would mean there is\\'nt sufficient time for the last trip to be completed as all other trips takes time >= 1.\\nThe minimum speed is 1 but the maximum speed requires some calculations. \\nThe maximum speed is = max(max(dist), ceil(dist[-1]/tmp)); i.e. the maximum of the max of the dist and the maximum time required for the last trip.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(dist * log(max(max(dist), ceil(dist[-1]/tmp))))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) - 1 >= hour:\\n            return -1\\n        mini, maxi = 1, max(dist)\\n        tmp = hour - len(dist) + 1\\n        if tmp < 1:\\n            maxi = max(maxi, ceil(dist[-1]/tmp))\\n        d1, d2 = dist[:-1], dist[-1]\\n        res = -1\\n        while mini <= maxi:\\n            if mini == maxi:\\n                return mini\\n            speed = (mini+maxi)//2\\n            time = 0\\n            for d in d1:\\n                time += ceil(d/speed)\\n            time += (d2/speed)\\n            if time <= hour:\\n                res = speed\\n                maxi = speed\\n            else:\\n                mini = speed + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) - 1 >= hour:\\n            return -1\\n        mini, maxi = 1, max(dist)\\n        tmp = hour - len(dist) + 1\\n        if tmp < 1:\\n            maxi = max(maxi, ceil(dist[-1]/tmp))\\n        d1, d2 = dist[:-1], dist[-1]\\n        res = -1\\n        while mini <= maxi:\\n            if mini == maxi:\\n                return mini\\n            speed = (mini+maxi)//2\\n            time = 0\\n            for d in d1:\\n                time += ceil(d/speed)\\n            time += (d2/speed)\\n            if time <= hour:\\n                res = speed\\n                maxi = speed\\n            else:\\n                mini = speed + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817017,
                "title": "c-solution-for-minimum-speed-to-arrive-on-time-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the minimum speed (in kilometers per hour) that all the trains must travel at for the person to reach the office on time. Since the departure times of the trains are fixed and integral, we can use a binary search approach to find the minimum speed that allows the person to reach the office on time. By using binary search, we can efficiently search for the correct speed within a specified range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe binary search approach involves setting up a search range for the possible speeds. We start with a lower bound and an upper bound for the speed, and at each step, we calculate the total time required for each speed within the range to determine whether the person can reach the office on time or not. Based on the total time, we adjust the range of possible speeds until we find the minimum speed that works.\\n\\n- Initialize the lower bound (left) as 1 and the upper bound (right) as a large value (10^7 as mentioned in the problem constraints).\\n- Perform binary search while left is less than right.\\n- Calculate the mid-point mid of the current search range.\\n- Calculate the total time required to commute using the mid-point speed for all train rides.\\n- If the total time is less than or equal to the given hour, update the right bound to mid.\\n- If the total time is greater than hour, update the left bound to mid + 1.\\n- Repeat steps 3 to 6 until left is no longer less than right.\\n- After the binary search, we have the minimum speed in left which satisfies the time constraint.\\n- To validate the result, calculate the total time using the minimum speed and check if it is less than or equal to hour.\\n- If the validation check passes, return the left speed; otherwise, return -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the binary search approach is O(n * log(m)), where n is the number of train rides, and m is the search range (10^7 in this case, as mentioned in the problem constraints). For each mid-point speed, we need to calculate the total time, which involves iterating over the dist array of length n. The binary search reduces the search space by half at each step, leading to the logarithmic time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is O(1) since we use a constant amount of extra space for variables (left, right, mid, totalHours, and finalHours). The input array dist is not modified in-place, and no additional data structures are used during the algorithm\\'s execution. Therefore, the space complexity remains constant.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = 10000007; // The constraint mentioned in the problem\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            double totalHours = 0;\\n\\n            for (int i = 0; i < dist.Length - 1; i++) {\\n                totalHours += Math.Ceiling((double)dist[i] / mid);\\n            }\\n\\n            totalHours += (double)dist[dist.Length - 1] / mid;\\n            \\n            if (totalHours <= hour) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        // Check if the result is valid or not\\n        double finalHours = 0;\\n        for (int i = 0; i < dist.Length - 1; i++) {\\n            finalHours += Math.Ceiling((double)dist[i] / left);\\n        }\\n        finalHours += (double)dist[dist.Length - 1] / left;\\n\\n        return finalHours <= hour ? left : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = 10000007; // The constraint mentioned in the problem\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            double totalHours = 0;\\n\\n            for (int i = 0; i < dist.Length - 1; i++) {\\n                totalHours += Math.Ceiling((double)dist[i] / mid);\\n            }\\n\\n            totalHours += (double)dist[dist.Length - 1] / mid;\\n            \\n            if (totalHours <= hour) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        // Check if the result is valid or not\\n        double finalHours = 0;\\n        for (int i = 0; i < dist.Length - 1; i++) {\\n            finalHours += Math.Ceiling((double)dist[i] / left);\\n        }\\n        finalHours += (double)dist[dist.Length - 1] / left;\\n\\n        return finalHours <= hour ? left : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817014,
                "title": "swift-with-comments-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    func minSpeedOnTime(_ dist: [Int], _ hour: Double) -> Int {\\n        if Double(dist.count) - 1 > hour {\\n            return -1\\n        }\\n\\n        var s = 1\\n        var e = 1000000001\\n        var minTime = e\\n\\n        while s <= e {\\n            var mid = (s + e) / 2\\n            if canReach(mid) {\\n                minTime = min(minTime, mid)\\n                e = mid - 1\\n            } else {\\n                s = mid + 1\\n            }\\n        }\\n\\n        func canReach(_ speed: Int) -> Bool {\\n            var time = 0.0\\n            for i in 0 ..< dist.count - 1 {\\n                time += ceil(Double(dist[i]) / Double(speed))\\n            }\\n            time += (Double(dist.last!) / Double(speed)) // last one doesn\\'t need ceil up as you dont need to wait for another train!\\n            return time <= hour\\n        }\\n\\n        return minTime == 1000000001 ? -1 : minTime\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    func minSpeedOnTime(_ dist: [Int], _ hour: Double) -> Int {\\n        if Double(dist.count) - 1 > hour {\\n            return -1\\n        }\\n\\n        var s = 1\\n        var e = 1000000001\\n        var minTime = e\\n\\n        while s <= e {\\n            var mid = (s + e) / 2\\n            if canReach(mid) {\\n                minTime = min(minTime, mid)\\n                e = mid - 1\\n            } else {\\n                s = mid + 1\\n            }\\n        }\\n\\n        func canReach(_ speed: Int) -> Bool {\\n            var time = 0.0\\n            for i in 0 ..< dist.count - 1 {\\n                time += ceil(Double(dist[i]) / Double(speed))\\n            }\\n            time += (Double(dist.last!) / Double(speed)) // last one doesn\\'t need ceil up as you dont need to wait for another train!\\n            return time <= hour\\n        }\\n\\n        return minTime == 1000000001 ? -1 : minTime\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816856,
                "title": "beats-95-video-finding-the-minimum-speed-with-binary-search",
                "content": "# Intuition\\nInspired by vanAmsen\\'s approach, we recognize that this problem is about optimizing the speed of travel due to the time constraint on the total journey to the office. The requirement to find the minimum speed suggests a solution involving a binary search algorithm, which iteratively refines the search for the optimal speed.\\n\\n[vanAmsen\\'s - Video](https://youtu.be/a3VgSDzD-B0)\\n\\n# Approach\\nWe utilize a binary search algorithm to find the minimum speed. Our first step is to verify whether it\\'s possible to reach the office within the given time. If it\\'s not feasible, we immediately return -1.\\n\\nNext, we carry out a binary search from 1 to the maximum of the maximum distance and the last distance divided by the leftover time after each train ride takes 1 hour. We establish a helper function, `canArriveOnTime`, which checks whether we can arrive at the office on time with a given speed. This function calculates the total time taken by summing up the time each train ride takes to reach the destination. If it\\'s possible to arrive on time with the mid speed, we update the right bound to mid, otherwise, we adjust the left bound to mid + 1. We persist with this process until we identify the minimum speed.\\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is \\\\(O(n \\\\log m)\\\\), where \\\\(n\\\\) is the count of train rides and \\\\(m\\\\) is the maximum distance. This is due to the fact that we check if we can arrive on time for each potential speed, which demands iterating over all the train rides.\\n\\n- Space complexity: The space complexity is \\\\(O(1)\\\\), as we only use a constant quantity of space to store the speed, distances, and time.\\n\\nThis code effectively resolves the problem using the power of binary search and some mathematical calculations, underlining the versatility and usefulness of these techniques in solving complex problems.\\n\\n# Code\\n```Python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canArriveOnTime(speed): \\n            return sum(math.ceil(d / speed) for d in dist[:-1]) + dist[-1] / speed <= hour \\n\\n        n = len(dist) \\n        if n - 1 > hour or hour - n + 1 <= 0: \\n            return -1 \\n\\n        left, right = 1, max(max(dist), math.ceil(dist[-1] / (hour - n + 1))) \\n        while left < right: \\n            mid = (left + right) // 2 \\n            if canArriveOnTime(mid): \\n                right = mid \\n            else: \\n                left = mid + 1 \\n\\n        return left \\n```\\n``` C++ []\\n// Todo\\n```\\n``` Java []\\n// Todo\\n```\\n``` JavaScript []\\n// Todo\\n```\\n``` C# []\\n// Todo\\n```\\nThis solution, based on the insights of vanAmsen, provides a clear and efficient approach to this problem. The use of a binary search and a helper function, along with a careful analysis of time and space complexity, results in a high-performing solution.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canArriveOnTime(speed): \\n            return sum(math.ceil(d / speed) for d in dist[:-1]) + dist[-1] / speed <= hour \\n\\n        n = len(dist) \\n        if n - 1 > hour or hour - n + 1 <= 0: \\n            return -1 \\n\\n        left, right = 1, max(max(dist), math.ceil(dist[-1] / (hour - n + 1))) \\n        while left < right: \\n            mid = (left + right) // 2 \\n            if canArriveOnTime(mid): \\n                right = mid \\n            else: \\n                left = mid + 1 \\n\\n        return left \\n```\n``` C++ []\\n// Todo\\n```\n``` Java []\\n// Todo\\n```\n``` JavaScript []\\n// Todo\\n```\n``` C# []\\n// Todo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816778,
                "title": "begineer-friendly-easy-to-understand-line-by-line-explanation-97-faster",
                "content": "# Intuition\\u2705\\u2705\\nI have commented line by line code ,read code (it is like self explained)\\uD83C\\uDFC6\\n\\n\\n# Complexity\\u2705\\n- Time complexity:\\uD83D\\uDE80\\n  **O(n * log(m))** \\n\\nwhere **n** is the number of elements in the **input vector dist**, and** m is the maximum speed** (the range of binary search). \\n\\n- Space complexity:\\n   **constant O(1)**\\uD83D\\uDE80\\n\\n   \\uD83D\\uDE80**Kindly upvote if you find helpful**\\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to find the minimum speed required to complete the journey on time.\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n    int n = dist.size();\\n    long long l = 1; // Minimum speed (lower bound) for binary search\\n    long long r = 10000000; // Maximum speed (upper bound) for binary search\\n    int ans = -1; // Initialize the answer to -1, indicating no valid speed found yet.\\n\\n    while (l <= r) {\\n        long long m = (l + r) / 2; // Midpoint of the current search space\\n\\n        // Calculate the total time required to travel at speed m\\n        double total_time = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            total_time += dist[i] / m; // Time for the current segment\\n            if (dist[i] % m) {\\n                total_time++; // Add an additional hour if there is a remainder\\n            }\\n        }\\n        total_time += (double)dist[n - 1] / m; // Time for the last segment\\n\\n        if (hour >= total_time) {\\n            // If the total time required at speed m is less than or equal to the given hour,\\n            // then update the answer and search for a smaller speed.\\n            ans = m;\\n            r = m - 1;\\n        } else {\\n            // If the total time required at speed m is more than the given hour,\\n            // then search for a larger speed.\\n            l = m + 1;\\n        }\\n    }\\n\\n    return ans; // Return the minimum speed required to complete the journey on time.\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to find the minimum speed required to complete the journey on time.\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n    int n = dist.size();\\n    long long l = 1; // Minimum speed (lower bound) for binary search\\n    long long r = 10000000; // Maximum speed (upper bound) for binary search\\n    int ans = -1; // Initialize the answer to -1, indicating no valid speed found yet.\\n\\n    while (l <= r) {\\n        long long m = (l + r) / 2; // Midpoint of the current search space\\n\\n        // Calculate the total time required to travel at speed m\\n        double total_time = 0;\\n        for (int i = 0; i < n - 1; i++) {\\n            total_time += dist[i] / m; // Time for the current segment\\n            if (dist[i] % m) {\\n                total_time++; // Add an additional hour if there is a remainder\\n            }\\n        }\\n        total_time += (double)dist[n - 1] / m; // Time for the last segment\\n\\n        if (hour >= total_time) {\\n            // If the total time required at speed m is less than or equal to the given hour,\\n            // then update the answer and search for a smaller speed.\\n            ans = m;\\n            r = m - 1;\\n        } else {\\n            // If the total time required at speed m is more than the given hour,\\n            // then search for a larger speed.\\n            l = m + 1;\\n        }\\n    }\\n\\n    return ans; // Return the minimum speed required to complete the journey on time.\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816759,
                "title": "daily-leetcoding-challenge-july-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3601602,
                "title": "binary-search-c-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is almost same of the below mentioned problems. Here i apply binary Search to findout Minimum Speed.\\n\\nSpeed Belong to range **[1 to 1e^7+1]** apply binary search on this range and find out minimum speed that satisfy the given condition **(minimum positive speed  that all the trains must travel at for you to reach the office on time)**\\n\\n**First  = 1\\nLast   = 1e^7+1**\\n\\n**Find Minimum Speed?**\\n\\n\\n\\n**Note:- Related Problems With Same Approach**\\n**Problem:-** https://leetcode.com/problems/koko-eating-bananas/description/\\n**Solution:-** https://leetcode.com/problems/koko-eating-bananas/solutions/3601174/binary-search-c-with-explanation/\\n\\n**Problem:-** https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description/\\n**Solution:-** https://leetcode.com/problems/maximum-candies-allocated-to-k-children/solutions/3601419/binary-search-c-with-explanation/\\n\\n\\n\\n# Complexity\\n1. Time complexity: O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> arr,int mid,double h)\\n    {\\n        double time = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            if(i==arr.size()-1)\\n            time = time+(double(arr[i])/mid);\\n            else\\n            time = time+ceil(double(arr[i])/mid);\\n        }\\n        return time<=h;\\n    }\\n    int minSpeedOnTime(vector<int>& arr, double h) {\\n        int n = arr.size(),ans = INT_MAX;\\n        int first = 1,last = 1e7+1;\\n        while(first<last)\\n        {\\n            int mid = (first+last)/2;\\n            if(check(arr,mid,h))\\n            {\\n                last = mid;\\n                ans = min(ans,mid);\\n            }\\n            else first = mid+1;\\n        }\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8b89675d-06af-479f-82e4-7336cc1a996d_1685986580.5461094.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> arr,int mid,double h)\\n    {\\n        double time = 0;\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n            if(i==arr.size()-1)\\n            time = time+(double(arr[i])/mid);\\n            else\\n            time = time+ceil(double(arr[i])/mid);\\n        }\\n        return time<=h;\\n    }\\n    int minSpeedOnTime(vector<int>& arr, double h) {\\n        int n = arr.size(),ans = INT_MAX;\\n        int first = 1,last = 1e7+1;\\n        while(first<last)\\n        {\\n            int mid = (first+last)/2;\\n            if(check(arr,mid,h))\\n            {\\n                last = mid;\\n                ans = min(ans,mid);\\n            }\\n            else first = mid+1;\\n        }\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336362,
                "title": "binary-search-c-easy-to-understand-math",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use binary search to find the minimum positive integer speed that all the trains must travel at for you to reach the office on time.\\n\\nFirst, we check number of trains and number of hours given if ceil(hours) is less than number of trains we can return -1.\\n## Otherwise, we can use binary search to find the minimum speed required.\\n\\n->We start with the left and right boundaries of the search range, which are 1 and 10^7 respectively.\\n\\n->In each iteration of the binary search, we calculate the total time required for the journey using the current speed (mid). We iterate over all the trains except the last one, and for each train, we calculate the time required by dividing the distance by the speed (rounded up to the nearest integer). We add up these times to get the total time required for all the train rides. Finally, we add the time required for the last train ride (which doesn\\'t require any waiting time) to get the total time required for the entire journey.\\n\\n->If the total time required is greater than the given amount of time to reach the office (hour), then we update the left boundary to mid + 1. Otherwise, we update the right boundary to mid.\\n\\n### Once the binary search is complete we return left\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> &dist,int mid,double hour)\\n    {\\n        double time = 0;\\n        int i = 0;\\n        for(;i<dist.size()-1;i++)\\n        {\\n            time+= dist[i]/mid;\\n            if(dist[i]%mid)\\n            {\\n                time++;\\n            }\\n        }\\n        time += 1.0*dist[i]/mid;\\n        if(time <= hour)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if(ceil(hour) < dist.size())\\n        {\\n            return -1;\\n        }\\n        int left = 1;\\n        int right = 10000000;\\n        int mid;\\n        while(left<right)\\n        {\\n            mid = (left+right)/2;\\n            if(check(dist,mid,hour))\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> &dist,int mid,double hour)\\n    {\\n        double time = 0;\\n        int i = 0;\\n        for(;i<dist.size()-1;i++)\\n        {\\n            time+= dist[i]/mid;\\n            if(dist[i]%mid)\\n            {\\n                time++;\\n            }\\n        }\\n        time += 1.0*dist[i]/mid;\\n        if(time <= hour)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if(ceil(hour) < dist.size())\\n        {\\n            return -1;\\n        }\\n        int left = 1;\\n        int right = 10000000;\\n        int mid;\\n        while(left<right)\\n        {\\n            mid = (left+right)/2;\\n            if(check(dist,mid,hour))\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331908,
                "title": "c-beats-89-simplest-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code -saketh_1003\\n```\\nclass Solution {//please upvote if u like my solution :)\\npublic:\\nbool check(vector<int>&v,int mid,double h)\\n{\\n    double t=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        if(i!=v.size()-1)\\n        t+=ceil(v[i]/(mid*1.00));\\n        else\\n        t+=v[i]/(mid*1.00);\\n    }\\n    if(t<=h)\\n    return true;\\n    return false;\\n}\\n    int minSpeedOnTime(vector<int>& v, double h) {\\n        int n=v.size();\\n        int ans=1e9;\\n        int l=1,r=1e7;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(v,mid,h))\\n            {\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        if(ans==1e9)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {//please upvote if u like my solution :)\\npublic:\\nbool check(vector<int>&v,int mid,double h)\\n{\\n    double t=0;\\n    for(int i=0;i<v.size();i++)\\n    {\\n        if(i!=v.size()-1)\\n        t+=ceil(v[i]/(mid*1.00));\\n        else\\n        t+=v[i]/(mid*1.00);\\n    }\\n    if(t<=h)\\n    return true;\\n    return false;\\n}\\n    int minSpeedOnTime(vector<int>& v, double h) {\\n        int n=v.size();\\n        int ans=1e9;\\n        int l=1,r=1e7;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(v,mid,h))\\n            {\\n                ans=min(ans,mid);\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        if(ans==1e9)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116702,
                "title": "java-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    int n;\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        n = dist.length;\\n        if(n-1+1e-7>hour) return -1;\\n        int l = 1;\\n        int r = (int)1e7;\\n        int m = 0;\\n        while(l<r) {\\n            m = l + (r-l)/2;\\n            if(isPossible(dist, hour, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public boolean isPossible(int[] dist, double hour, int s) {\\n        int h = 0;\\n        for(int i=0; i<n-1; i++) {\\n            h += (dist[i]+s-1)/s;\\n        }\\n        double dh = h+(1d*dist[n-1])/s;\\n        return dh<=hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        n = dist.length;\\n        if(n-1+1e-7>hour) return -1;\\n        int l = 1;\\n        int r = (int)1e7;\\n        int m = 0;\\n        while(l<r) {\\n            m = l + (r-l)/2;\\n            if(isPossible(dist, hour, m)) {\\n                r = m;\\n            } else {\\n                l = m+1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public boolean isPossible(int[] dist, double hour, int s) {\\n        int h = 0;\\n        for(int i=0; i<n-1; i++) {\\n            h += (dist[i]+s-1)/s;\\n        }\\n        double dh = h+(1d*dist[n-1])/s;\\n        return dh<=hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116010,
                "title": "c-beginner-friendly-solution-binary-search",
                "content": "### Complexity\\n- Time complexity:  $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool good(vector<int>& dist, double hr, int h) {\\n        double cnt = 0;\\n        for(int i = 0; i < dist.size(); i++)\\n            if(i == dist.size() - 1) cnt += (double) dist[i] / h;\\n            else cnt += ((dist[i] + h - 1) / h);\\n        return cnt <= hr;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= n - 1) return -1;\\n        int lo = 1, hi = 1e9;\\n        while(lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if(good(dist, hour, mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(vector<int>& dist, double hr, int h) {\\n        double cnt = 0;\\n        for(int i = 0; i < dist.size(); i++)\\n            if(i == dist.size() - 1) cnt += (double) dist[i] / h;\\n            else cnt += ((dist[i] + h - 1) / h);\\n        return cnt <= hr;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= n - 1) return -1;\\n        int lo = 1, hi = 1e9;\\n        while(lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if(good(dist, hour, mid)) hi = mid;\\n            else lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355582,
                "title": "using-binary-search-on-ans",
                "content": "\\n    class Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l=1;\\n        int h=(int)1e9;\\n        \\n        int ans=-1;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(f(dist,hour,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean f(int arr[],double h,int mid){\\n        double t1=0.0;\\n        for(int i=0;i<arr.length;i++){\\n            if(i!=arr.length-1)\\n            t1+=Math.ceil((double)arr[i]/mid);\\n            else\\n                t1+=((double)arr[i]/mid);\\n        }\\n        return t1<=h;\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l=1;\\n        int h=(int)1e9;\\n        \\n        int ans=-1;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            if(f(dist,hour,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2125313,
                "title": "javascript-js-solution-ultrafast",
                "content": "JavaScript solution\\n\\n```\\nvar minSpeedOnTime = function(dist, hour) {\\n    const lastTime = hour - (dist.length - 1);\\n\\n    if (lastTime <= 0) {\\n        return -1;\\n    }\\n\\n    const minSpeed = dist.reduce((r, d, i) => i < dist.length - 1 ? Math.max(r, d) : r, 0);\\n    const lastSpeed = dist[dist.length - 1] / lastTime;\\n\\n    let left = 1;\\n    let right = Math.ceil(minSpeed + lastSpeed);\\n\\n    while (left <= right) {\\n        const speed = Math.floor((left + right) / 2);\\n        \\n        const time = dist.reduce((res, d, i) => {\\n            let hours = d / speed;\\n            \\n            if (i < dist.length - 1) {\\n                hours = Math.ceil(hours);\\n            }\\n\\n            return res + hours;\\n        }, 0);\\n\\n        if (time <= hour) {\\n            right = speed - 1;\\n        } else {\\n            left = speed + 1;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar minSpeedOnTime = function(dist, hour) {\\n    const lastTime = hour - (dist.length - 1);\\n\\n    if (lastTime <= 0) {\\n        return -1;\\n    }\\n\\n    const minSpeed = dist.reduce((r, d, i) => i < dist.length - 1 ? Math.max(r, d) : r, 0);\\n    const lastSpeed = dist[dist.length - 1] / lastTime;\\n\\n    let left = 1;\\n    let right = Math.ceil(minSpeed + lastSpeed);\\n\\n    while (left <= right) {\\n        const speed = Math.floor((left + right) / 2);\\n        \\n        const time = dist.reduce((res, d, i) => {\\n            let hours = d / speed;\\n            \\n            if (i < dist.length - 1) {\\n                hours = Math.ceil(hours);\\n            }\\n\\n            return res + hours;\\n        }, 0);\\n\\n        if (time <= hour) {\\n            right = speed - 1;\\n        } else {\\n            left = speed + 1;\\n        }\\n    }\\n    \\n    return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115868,
                "title": "c-step-by-step-detailed-explanation-time-o-nlogm-space-o-1",
                "content": "```\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n        /*\\n        TIME: O(N*logM) where N is size of input array (number of train rides) and M is maximum between dist of last train ride\\n        multiplied by 100 and largest element in array\\n        SPACE: O(1)\\n        \\n        STEP 1: Establish upper and lower bounds of Binary Search:\\n        \\n        But what is the upper bound? Limiting factor is the last train ride.\\n        For the example above let\\'s say we finished the first 2 train rides as fast as we could and spent 2 hours.\\n        The smallest hour requirement, that has 2 decimal points, and still makes it possible for us to arrive on time\\n        is 2.01. This means we have the ride the last train ride in .01 hour. \\n        How fast must we travel to get a .01 time? \\n        .01 is essentially 1 percent or 1/100 so we must 100x faster than given distance. \\n        In example, distance was 3, so we must travel 300 kilometers per hour -> 3/300 = .01 to arrive on time.\\n        \\n        -Thus, upper bound for LAST train ride is last element in input array (dist of last train ride) multipled by 100\\n        BUT, upper bound for ENTIRE array needs to also consider ALL distances so upper bound is maximum between \\n        largest element in array and distance of last train ride multiplied by 100.\\n        -Lower bound is 1 which is the slowest we could go since answer must be a positive integer\\n        \\n        STEP 2: After getting the mid value = (left + right)/2, iterate through every element in input array and divide\\n        by mid using ceiling division for all elements EXCEPT the last one. Get the sum of the quotient for every element. \\n        What are we doing?\\n        We are essentially computing the time it takes to travel by dividing the distance of every train ride by the kilometers\\n        per hour. Use ceiling division because we must wait until the next hour for the train to depart. On the last train ride\\n        we do not wait for another train ride to depart so must calculate if we arrived at the destination on time. \\n        \\n        STEP 3: If time we summed up is less than or equal to hour, we made it on time! Check to see if we can travel slower\\n        and still make it on time (right = mid-1).\\n        Else, we did not make it on time and must go faster (left=mid+1)\\n        \\n        Repeat STEPS 2-3 until binary search exits, return left pointer which is the slowest speed that still allows us to\\n        complete the journey on time\\n        */\\n        \\n        int N=dist.size();                                          // number of required train rides\\n        int furthest_ride=*max_element(dist.begin(), dist.end());   // furthest train ride (max element in input array)\\n        int l=1, r=max(furthest_ride, dist[N-1]*100), m;            // binary search variables\\n        double time=0;                                              // time it takes to complete journey if we travel at m speed\\n        \\n        /*\\n        Edge case: impossible to reach destination on time because each train ride, except that last ride, takes a least 1 hour\\n        So N-1, where N is the total number of train rides must be less than hour to spare time for the last train ride\\n        Example: [1, 2, 3], hour = 2\\n        There are 3 rides, N=3. The first 2 rides take at least 1 hour each which brings time spent to 2.\\n        2 is >= hour so impossible to complete ride because we still need to get on the 3rd train ride\\n        */\\n        if( N-1>=hour)\\n            return -1;\\n        \\n        while( l<=r)\\n        {\\n            m = (l+r)/2;\\n            time=0;\\n            \\n            // Compute time it takes to complete journey, traveling at m kilometers per hour\\n            for(int i=0; i<N; ++i)\\n            {\\n                time = ceil(time);  // round up for every train ride except on the last train ride\\n                time += (double)dist[i]/m;\\n            }\\n            // If we arrived exactly on time cannot go any slower and still make it on time, so return speed\\n            if( time == hour)\\n                return m;\\n            // If we made faster than time limit, try to find slower speed\\n            if( time < hour)\\n                r = m-1;\\n            // Else we need to travel faster to make it on time\\n            else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint minSpeedOnTime(vector<int>& dist, double hour) {\\n        /*\\n        TIME: O(N*logM) where N is size of input array (number of train rides) and M is maximum between dist of last train ride\\n        multiplied by 100 and largest element in array\\n        SPACE: O(1)\\n        \\n        STEP 1: Establish upper and lower bounds of Binary Search:\\n        \\n        But what is the upper bound? Limiting factor is the last train ride.\\n        For the example above let\\'s say we finished the first 2 train rides as fast as we could and spent 2 hours.\\n        The smallest hour requirement, that has 2 decimal points, and still makes it possible for us to arrive on time\\n        is 2.01. This means we have the ride the last train ride in .01 hour. \\n        How fast must we travel to get a .01 time? \\n        .01 is essentially 1 percent or 1/100 so we must 100x faster than given distance. \\n        In example, distance was 3, so we must travel 300 kilometers per hour -> 3/300 = .01 to arrive on time.\\n        \\n        -Thus, upper bound for LAST train ride is last element in input array (dist of last train ride) multipled by 100\\n        BUT, upper bound for ENTIRE array needs to also consider ALL distances so upper bound is maximum between \\n        largest element in array and distance of last train ride multiplied by 100.\\n        -Lower bound is 1 which is the slowest we could go since answer must be a positive integer\\n        \\n        STEP 2: After getting the mid value = (left + right)/2, iterate through every element in input array and divide\\n        by mid using ceiling division for all elements EXCEPT the last one. Get the sum of the quotient for every element. \\n        What are we doing?\\n        We are essentially computing the time it takes to travel by dividing the distance of every train ride by the kilometers\\n        per hour. Use ceiling division because we must wait until the next hour for the train to depart. On the last train ride\\n        we do not wait for another train ride to depart so must calculate if we arrived at the destination on time. \\n        \\n        STEP 3: If time we summed up is less than or equal to hour, we made it on time! Check to see if we can travel slower\\n        and still make it on time (right = mid-1).\\n        Else, we did not make it on time and must go faster (left=mid+1)\\n        \\n        Repeat STEPS 2-3 until binary search exits, return left pointer which is the slowest speed that still allows us to\\n        complete the journey on time\\n        */\\n        \\n        int N=dist.size();                                          // number of required train rides\\n        int furthest_ride=*max_element(dist.begin(), dist.end());   // furthest train ride (max element in input array)\\n        int l=1, r=max(furthest_ride, dist[N-1]*100), m;            // binary search variables\\n        double time=0;                                              // time it takes to complete journey if we travel at m speed\\n        \\n        /*\\n        Edge case: impossible to reach destination on time because each train ride, except that last ride, takes a least 1 hour\\n        So N-1, where N is the total number of train rides must be less than hour to spare time for the last train ride\\n        Example: [1, 2, 3], hour = 2\\n        There are 3 rides, N=3. The first 2 rides take at least 1 hour each which brings time spent to 2.\\n        2 is >= hour so impossible to complete ride because we still need to get on the 3rd train ride\\n        */\\n        if( N-1>=hour)\\n            return -1;\\n        \\n        while( l<=r)\\n        {\\n            m = (l+r)/2;\\n            time=0;\\n            \\n            // Compute time it takes to complete journey, traveling at m kilometers per hour\\n            for(int i=0; i<N; ++i)\\n            {\\n                time = ceil(time);  // round up for every train ride except on the last train ride\\n                time += (double)dist[i]/m;\\n            }\\n            // If we arrived exactly on time cannot go any slower and still make it on time, so return speed\\n            if( time == hour)\\n                return m;\\n            // If we made faster than time limit, try to find slower speed\\n            if( time < hour)\\n                r = m-1;\\n            // Else we need to travel faster to make it on time\\n            else\\n                l = m+1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2016954,
                "title": "c-binary-search-solution-easy-to-understand",
                "content": "```\\n//function to check whether the the speed(mid) can be my answer or not\\nbool  favorable(vector<int>dist ,int mid,double hour){\\n        double time=0;\\n        for(int i=0;i<dist.size()-1;i++){\\n            time =time + ceil((double)dist[i]/(double)mid);\\n            if(time>hour){return false;}\\n        }\\n        time +=(double)dist[dist.size()-1]/(double)mid;\\n        if(time>hour){return false;}\\n        else{\\n            return true;\\n        }\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int lo=0;\\n        // int hi=*max_element(dist.begin(),dist.end());\\n        int hi =INT_MAX-1;\\n        int res=-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(favorable(dist,mid,hour)){\\n                res=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n//function to check whether the the speed(mid) can be my answer or not\\nbool  favorable(vector<int>dist ,int mid,double hour){\\n        double time=0;\\n        for(int i=0;i<dist.size()-1;i++){\\n            time =time + ceil((double)dist[i]/(double)mid);\\n            if(time>hour){return false;}\\n        }\\n        time +=(double)dist[dist.size()-1]/(double)mid;\\n        if(time>hour){return false;}\\n        else{\\n            return true;\\n        }\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int lo=0;\\n        // int hi=*max_element(dist.begin(),dist.end());\\n        int hi =INT_MAX-1;\\n        int res=-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            if(favorable(dist,mid,hour)){\\n                res=mid;\\n                hi=mid-1;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986963,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = (int) 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == (int) 1e8 ? -1 : right;\\n    }\\n\\n    private boolean arriveOnTime(int[] dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            time += Math.ceil((double) dist[i] / speed);\\n        }\\n        return time + (double) dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```\\n\\n***JavaScript***\\n```\\nvar minSpeedOnTime = function(dist, hour) {\\n    let left=1,right=10000000,speed,sum,ans=-1;\\n    while(left<=right){\\n        //We need to return the minimum positive integer speed (in kilometers per hour) that all the trains must travel. So speed will always be an integer ranging from 1 to 10000000 as per the question description. \\n        speed = left + Math.floor((right-left)/2);\\n        sum=0;\\n        for(let i=0;i<dist.length-1;i++){\\n            sum += Math.ceil((dist[i]/speed));\\n        }\\n        sum += (dist[dist.length-1]/speed);//For the last train we need not to do Math.ceil\\n        if(sum<=hour){//sum(time taken is less than the required time, so it can be our answer, but we will keep looking for the another smaller speed until left<=right)\\n            ans=speed;\\n            right = speed-1;\\n        }else{\\n            left=speed+1;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution\\n{\\n    bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour <= len(dist)-1:\\n            return -1\\n        \\n        def condition(x):\\n            cnt = 0 \\n            n = len(dist)\\n            for i in range(n):\\n                if i < n-1:\\n                    f = dist[i]/x\\n                    if f == int(f):\\n                        cnt += f\\n                    else:\\n                        cnt += int(f) + 1\\n                else: # i == n-1\\n                    f = dist[i]/x\\n                    cnt += f\\n            return cnt \\n\\n        \\n        left, right = 1, 10**7\\n        \\n        while left < right:\\n            mid = (left + right) //2\\n            if condition(mid) <= hour:   \\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n***Kotlin***\\n```\\n fun minSpeedOnTime(dist: IntArray, hour: Double): Int {\\n        val given = DoubleArray(dist.size) { i -> dist[i].toDouble() }\\n        fun isPossible(speed: Int): Boolean {\\n            var time = 0.0\\n            for (d in given) {\\n                time += Math.ceil(d / speed)\\n            }\\n            time -= Math.ceil(given.last() / speed) // don\\'t wait for last train ride\\n            time += (given.last() / speed) // need to add floating point wait time for last ride\\n            return time <= hour\\n        }\\n        var (low, high) = 1 to 100000000\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (isPossible(mid).not())\\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        if (isPossible(low)) // make sure the value is correct\\n            return low\\n        return -1\\n    }\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func minSpeedOnTime(_ dist: [Int], _ hour: Double) -> Int {\\n        let n = dist.count, maxDist = dist.max()!\\n        let intHour = Int(hour.rounded(.up)), lastHour = hour == hour.rounded(.down) ? 1.0 : (hour - hour.rounded(.down))\\n        guard intHour >= n else { return -1 }\\n        var left = 1, right = intHour > n ? maxDist : max(maxDist, Int((Double(dist.last!) / lastHour).rounded(.up)))\\n        while left < right {\\n            let center = (left + right) / 2\\n            var totalTime = 0.0\\n            for i in 0..<(n - 1) {\\n                totalTime += (Double(dist[i]) / Double(center)).rounded(.up)\\n            }\\n            totalTime += Double(dist.last!) / Double(center)\\n            if totalTime > hour {\\n                left = center + 1\\n            } else {\\n                right = center\\n            }\\n        }\\n        return left\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = (int) 1e8;\\n\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (arriveOnTime(dist, hour, middle))\\n                right = middle;\\n            else left = middle + 1;\\n        }\\n\\n        return right == (int) 1e8 ? -1 : right;\\n    }\\n\\n    private boolean arriveOnTime(int[] dist, double hour, int speed) {\\n        int time = 0;\\n        for (int i = 0; i < dist.length - 1; i++) {\\n            time += Math.ceil((double) dist[i] / speed);\\n        }\\n        return time + (double) dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```\n```\\nvar minSpeedOnTime = function(dist, hour) {\\n    let left=1,right=10000000,speed,sum,ans=-1;\\n    while(left<=right){\\n        //We need to return the minimum positive integer speed (in kilometers per hour) that all the trains must travel. So speed will always be an integer ranging from 1 to 10000000 as per the question description. \\n        speed = left + Math.floor((right-left)/2);\\n        sum=0;\\n        for(let i=0;i<dist.length-1;i++){\\n            sum += Math.ceil((dist[i]/speed));\\n        }\\n        sum += (dist[dist.length-1]/speed);//For the last train we need not to do Math.ceil\\n        if(sum<=hour){//sum(time taken is less than the required time, so it can be our answer, but we will keep looking for the another smaller speed until left<=right)\\n            ans=speed;\\n            right = speed-1;\\n        }else{\\n            left=speed+1;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution\\n{\\n    bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour <= len(dist)-1:\\n            return -1\\n        \\n        def condition(x):\\n            cnt = 0 \\n            n = len(dist)\\n            for i in range(n):\\n                if i < n-1:\\n                    f = dist[i]/x\\n                    if f == int(f):\\n                        cnt += f\\n                    else:\\n                        cnt += int(f) + 1\\n                else: # i == n-1\\n                    f = dist[i]/x\\n                    cnt += f\\n            return cnt \\n\\n        \\n        left, right = 1, 10**7\\n        \\n        while left < right:\\n            mid = (left + right) //2\\n            if condition(mid) <= hour:   \\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```\\n fun minSpeedOnTime(dist: IntArray, hour: Double): Int {\\n        val given = DoubleArray(dist.size) { i -> dist[i].toDouble() }\\n        fun isPossible(speed: Int): Boolean {\\n            var time = 0.0\\n            for (d in given) {\\n                time += Math.ceil(d / speed)\\n            }\\n            time -= Math.ceil(given.last() / speed) // don\\'t wait for last train ride\\n            time += (given.last() / speed) // need to add floating point wait time for last ride\\n            return time <= hour\\n        }\\n        var (low, high) = 1 to 100000000\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (isPossible(mid).not())\\n                low = mid + 1\\n            else\\n                high = mid\\n        }\\n        if (isPossible(low)) // make sure the value is correct\\n            return low\\n        return -1\\n    }\\n```\n```\\nclass Solution {\\n    func minSpeedOnTime(_ dist: [Int], _ hour: Double) -> Int {\\n        let n = dist.count, maxDist = dist.max()!\\n        let intHour = Int(hour.rounded(.up)), lastHour = hour == hour.rounded(.down) ? 1.0 : (hour - hour.rounded(.down))\\n        guard intHour >= n else { return -1 }\\n        var left = 1, right = intHour > n ? maxDist : max(maxDist, Int((Double(dist.last!) / lastHour).rounded(.up)))\\n        while left < right {\\n            let center = (left + right) / 2\\n            var totalTime = 0.0\\n            for i in 0..<(n - 1) {\\n                totalTime += (Double(dist[i]) / Double(center)).rounded(.up)\\n            }\\n            totalTime += Double(dist.last!) / Double(center)\\n            if totalTime > hour {\\n                left = center + 1\\n            } else {\\n                right = center\\n            }\\n        }\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339860,
                "title": "golang-100-solution",
                "content": "```go\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n\\tif hour <= float64(len(dist)-1) {\\n\\t\\treturn -1\\n\\t}\\n    // math.MaxInt32 is large enough for right-bound\\n\\tl, r := 1, math.MaxInt32\\n\\tfor l <= r {\\n\\t\\tspeed := (l+r)>>1\\n\\t\\ttotal := float64(dist[len(dist)-1]) / float64(speed)\\n\\t\\tfor i := 0; i < len(dist)-1; i++ {\\n\\t\\t\\ttotal += math.Ceil(float64(dist[i])/float64(speed))\\n\\t\\t}\\n        // float64 equal, not 100% right\\n        // use fraction for last train is better and 100% right\\n        if math.Abs(total-hour) < 0.00000001 {\\n            return speed\\n        }\\n\\t\\tif total > hour {\\n\\t\\t\\tl = speed+1\\n\\t\\t} else {\\n\\t\\t\\tr = speed-1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n\\tif hour <= float64(len(dist)-1) {\\n\\t\\treturn -1\\n\\t}\\n    // math.MaxInt32 is large enough for right-bound\\n\\tl, r := 1, math.MaxInt32\\n\\tfor l <= r {\\n\\t\\tspeed := (l+r)>>1\\n\\t\\ttotal := float64(dist[len(dist)-1]) / float64(speed)\\n\\t\\tfor i := 0; i < len(dist)-1; i++ {\\n\\t\\t\\ttotal += math.Ceil(float64(dist[i])/float64(speed))\\n\\t\\t}\\n        // float64 equal, not 100% right\\n        // use fraction for last train is better and 100% right\\n        if math.Abs(total-hour) < 0.00000001 {\\n            return speed\\n        }\\n\\t\\tif total > hour {\\n\\t\\t\\tl = speed+1\\n\\t\\t} else {\\n\\t\\t\\tr = speed-1\\n\\t\\t}\\n\\t}\\n\\treturn r+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313680,
                "title": "simple-c-binary-search",
                "content": "**Time  = Distance travelled / speed** \\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 0 , high = 1e9;  \\n        int n = dist.size() , ans = -1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2; \\n            double sum = 0;\\n            for(int i=0;i<n-1;i++)\\n                sum +=ceil(((double)dist[i])/mid);         \\n\\t\\t\\t\\t\\n            sum += ((double)dist[dist.size()-1])/mid ; //no need to wait at the last stop\\n            if(sum>hour){\\n                low = mid+1;  //if you cannot reach within \\'hours\\' then increase the speed. \\n            }\\n            else {\\n                high = mid-1;  //else search if you can reach the office even if the speed is slower\\n                ans = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 0 , high = 1e9;  \\n        int n = dist.size() , ans = -1;\\n        while(low<=high){\\n            int mid = low+(high-low)/2; \\n            double sum = 0;\\n            for(int i=0;i<n-1;i++)\\n                sum +=ceil(((double)dist[i])/mid);         \\n\\t\\t\\t\\t\\n            sum += ((double)dist[dist.size()-1])/mid ; //no need to wait at the last stop\\n            if(sum>hour){\\n                low = mid+1;  //if you cannot reach within \\'hours\\' then increase the speed. \\n            }\\n            else {\\n                high = mid-1;  //else search if you can reach the office even if the speed is slower\\n                ans = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247564,
                "title": "easy-solution-for-beginner-and-common-mistake-to-avoid-in-c",
                "content": "Before diving into the code, let\\'s go through it\\'s appoach:\\n\\nFirst lets discuss without the corner case\\'s ie when answer will not be -1:\\n\\nHere our answer can be anyway between 1 to 10 ^ 7 so instead of checking through all the values we can use the bianry seach.\\nFor each mid point we will calculate if it\\'s a fisible solution or not.\\n\\nTo check the fisibility, we will add the ceil(dist[i]/ mid) to res for all the elements except the last one as in the last element ceiling is not required as per question and we will check whether res is less than or equal to hour or not for each iteration.\\n\\n\\nHere we need to take the double for the result in each iternation it can be done by following ways:\\n1) (double)\\n2) (1.0)\\n\\nFor taking ceiling, below approach doesnot work.\\nres += ceil(dist[i]/mid) \\n\\nCorrect approach is as follow:\\nres += ceil((1.0)(1.0*arr[i])/K);\\nres += (dist[i] + mid - 1)/mid;\\n\\nTime complexity  - O(nlogn)\\nSpace Complexity  - O(1)\\n\\n*Upvote this if you find useful*\\n\\n```\\nbool calculate(vector<int> dist, int mid, double hour){\\n        double res = 0;\\n        \\n        for (int i=0; i< dist.size()-1;i++){\\n            res += (dist[i] + mid - 1)/mid;\\n        }\\n        \\n        res += (1.0 * dist[dist.size()-1]/mid);\\n        return res <= hour;\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if (hour <= 1.0 * (dist.size()-1))\\n            return -1;\\n        \\n        int low = 1;\\n        int high = 1e7;\\n        \\n        while (low < high){\\n            int mid = (low + high)/2;\\n            \\n            if (calculate(dist,mid,hour))\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return high;\\n        \\n    }\\n\\t\\n\\tDo let me know if you have any query.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool calculate(vector<int> dist, int mid, double hour){\\n        double res = 0;\\n        \\n        for (int i=0; i< dist.size()-1;i++){\\n            res += (dist[i] + mid - 1)/mid;\\n        }\\n        \\n        res += (1.0 * dist[dist.size()-1]/mid);\\n        return res <= hour;\\n        \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if (hour <= 1.0 * (dist.size()-1))\\n            return -1;\\n        \\n        int low = 1;\\n        int high = 1e7;\\n        \\n        while (low < high){\\n            int mid = (low + high)/2;\\n            \\n            if (calculate(dist,mid,hour))\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return high;\\n        \\n    }\\n\\t\\n\\tDo let me know if you have any query.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237268,
                "title": "python3-binary-search-with-detailed-explanation",
                "content": "Python3 Solution of the problem with Binary Search Approach.\\n\\nI am still wondering if there is a better way to identify that the most optimal approach to solving a given problem is just going brute force. By brute force, I mean trying out all possible speeds (even if in binary search manner). Suggestions would be very much welcome!\\n\\nTime Complexity: O(10e7 * n)\\nSpace Complexity: O(1)\\n\\n```\\nimport math\\n\\nclass Solution:\\n    \\n    @staticmethod\\n    def _is_on_time(s, dist, hour):\\n        \"\"\"\\n        Calculates if for a given speed, it is possible to reach withinh the given time\\n        \"\"\"\\n        # This is the fastest method that I could find.\\n        # Credits: https://leetcode.com/problems/minimum-speed-to-arrive-on-time/discuss/1224638/Clean-Python-3-binary-search\\n        # Original method vs New Method led to a 50% reduction in run time!\\n        return sum(math.ceil(d / s) for d in dist[:-1]) + dist[-1] / s <= hour\\n\\n    def _find_optimal_speed(self,dist, min_speed, max_speed, hour):\\n        # Could be better handled by having this check before this function was called\\n        if min_speed > max_speed:\\n            return float(\\'inf\\')\\n        if min_speed == max_speed:\\n            if self._is_on_time(min_speed, dist, hour):\\n                return min_speed\\n            return float(\\'inf\\')\\n        \\n        # The below code can be represented in the following steps:-\\\\\\n        # 1. Find the mid value between min_speed and max_speed\\n        # 2. Check if the mid value speed allows us to reach the destination within the given time\\n        # 3. If yes, then check for values between min_speed and mid-1\\n                # THIS IS IMPORTANT CONDITION\\n        # 4. If no, then check for values betweeen mid+1, max_speed\\n        #       # THIS IS IMPORTANT CONDITION\\n        mid = int((min_speed + max_speed)/2)\\n        if self._is_on_time(mid, dist, hour):\\n            return min(self._find_optimal_speed(dist, min_speed, mid-1, hour), mid)\\n        else:\\n            return self._find_optimal_speed(dist, mid+1, max_speed, hour)\\n            \\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        min_speed = 1  # lowest integer speed possible     \\n        max_speed = 10000000 # highest integer speed possible (given in the problem description itself)\\n        optimal_speed = self._find_optimal_speed(dist, min_speed, max_speed, hour)\\n        \\n        # To handle the case when the result is infinity, which implies that we failed to find\\n        # any solution\\n        # Suggestions are welcome! :) \\n        if optimal_speed > max_speed:\\n            return -1\\n        return optimal_speed\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    \\n    @staticmethod\\n    def _is_on_time(s, dist, hour):\\n        \"\"\"\\n        Calculates if for a given speed, it is possible to reach withinh the given time\\n        \"\"\"\\n        # This is the fastest method that I could find.\\n        # Credits: https://leetcode.com/problems/minimum-speed-to-arrive-on-time/discuss/1224638/Clean-Python-3-binary-search\\n        # Original method vs New Method led to a 50% reduction in run time!\\n        return sum(math.ceil(d / s) for d in dist[:-1]) + dist[-1] / s <= hour\\n\\n    def _find_optimal_speed(self,dist, min_speed, max_speed, hour):\\n        # Could be better handled by having this check before this function was called\\n        if min_speed > max_speed:\\n            return float(\\'inf\\')\\n        if min_speed == max_speed:\\n            if self._is_on_time(min_speed, dist, hour):\\n                return min_speed\\n            return float(\\'inf\\')\\n        \\n        # The below code can be represented in the following steps:-\\\\\\n        # 1. Find the mid value between min_speed and max_speed\\n        # 2. Check if the mid value speed allows us to reach the destination within the given time\\n        # 3. If yes, then check for values between min_speed and mid-1\\n                # THIS IS IMPORTANT CONDITION\\n        # 4. If no, then check for values betweeen mid+1, max_speed\\n        #       # THIS IS IMPORTANT CONDITION\\n        mid = int((min_speed + max_speed)/2)\\n        if self._is_on_time(mid, dist, hour):\\n            return min(self._find_optimal_speed(dist, min_speed, mid-1, hour), mid)\\n        else:\\n            return self._find_optimal_speed(dist, mid+1, max_speed, hour)\\n            \\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        min_speed = 1  # lowest integer speed possible     \\n        max_speed = 10000000 # highest integer speed possible (given in the problem description itself)\\n        optimal_speed = self._find_optimal_speed(dist, min_speed, max_speed, hour)\\n        \\n        # To handle the case when the result is infinity, which implies that we failed to find\\n        # any solution\\n        # Suggestions are welcome! :) \\n        if optimal_speed > max_speed:\\n            return -1\\n        return optimal_speed\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229647,
                "title": "binary-search-c",
                "content": "```\\n    bool helper(long mid, vector<int>& dist, double hour) {\\n        double ho=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            ho+=ceil((1.00*dist[i])/mid);\\n        }\\n        ho+=(dist[dist.size()-1]/(mid*1.00));\\n        // cout<<mid<<\" \"<<ho<<endl;\\n        return ho<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            maxi=max(maxi,dist[i]);\\n        }\\n        int i=0,j=10000001;\\n        int ans=-1;\\n        while(i<=j)\\n        {\\n            long mid=(i+j)/2;\\n            if(helper(mid,dist,hour)){\\n                    ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool helper(long mid, vector<int>& dist, double hour) {\\n        double ho=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            ho+=ceil((1.00*dist[i])/mid);\\n        }\\n        ho+=(dist[dist.size()-1]/(mid*1.00));\\n        // cout<<mid<<\" \"<<ho<<endl;\\n        return ho<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<dist.size();i++)\\n        {\\n            maxi=max(maxi,dist[i]);\\n        }\\n        int i=0,j=10000001;\\n        int ans=-1;\\n        while(i<=j)\\n        {\\n            long mid=(i+j)/2;\\n            if(helper(mid,dist,hour)){\\n                    ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n                i=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1225281,
                "title": "python3-binary-search-solution-explained",
                "content": "Please refer to this image for explaination : (https://res.cloudinary.com/swap2001/image/upload/v1621757431/image_nxdm81.jpg)\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        sum_ = sum(dist)\\n        self.ans = float(\"inf\")\\n        \\n        def can_reach_office(speed):\\n            time = sum([math.ceil(dist[i]/speed) for i in range(len(dist)-1)])\\n            return (time+(dist[-1]/speed)) <= hour\\n            \\n            \\n        def binary_search(left,right):\\n            while left<=right:\\n                speed = left + (right-left)//2\\n                if can_reach_office(speed):\\n                    self.ans = min(self.ans,speed)\\n                    right = speed - 1\\n                else:\\n                    left = speed + 1\\n            \\n        binary_search(1,10**7)\\n        return -1 if self.ans == float(\"inf\") else self.ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        sum_ = sum(dist)\\n        self.ans = float(\"inf\")\\n        \\n        def can_reach_office(speed):\\n            time = sum([math.ceil(dist[i]/speed) for i in range(len(dist)-1)])\\n            return (time+(dist[-1]/speed)) <= hour\\n            \\n            \\n        def binary_search(left,right):\\n            while left<=right:\\n                speed = left + (right-left)//2\\n                if can_reach_office(speed):\\n                    self.ans = min(self.ans,speed)\\n                    right = speed - 1\\n                else:\\n                    left = speed + 1\\n            \\n        binary_search(1,10**7)\\n        return -1 if self.ans == float(\"inf\") else self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224690,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double timetaken(vector<int>&dist,int s)\\n    {\\n        double res=0;\\n        for(int i=0; i<dist.size()-1; i++)\\n        {\\n            if(dist[i]%s==0)\\n                res+=dist[i]/s;\\n            else\\n                res+=dist[i]/s+1;\\n        }\\n        res+=(double)dist[dist.size()-1]/(double)s;\\n        return res;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n       double tm;\\n       int lo=1,hi=10000000,mid;\\n       int res=-1;\\n       while(lo<=hi)\\n       {\\n           mid=lo+(hi-lo)/2;\\n           tm=timetaken(dist,mid);\\n           if(tm<=hour)\\n           {\\n               res=mid;\\n               hi=mid-1;\\n           }\\n           else\\n           {\\n               lo=mid+1;\\n           }\\n       }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double timetaken(vector<int>&dist,int s)\\n    {\\n        double res=0;\\n        for(int i=0; i<dist.size()-1; i++)\\n        {\\n            if(dist[i]%s==0)\\n                res+=dist[i]/s;\\n            else\\n                res+=dist[i]/s+1;\\n        }\\n        res+=(double)dist[dist.size()-1]/(double)s;\\n        return res;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n       double tm;\\n       int lo=1,hi=10000000,mid;\\n       int res=-1;\\n       while(lo<=hi)\\n       {\\n           mid=lo+(hi-lo)/2;\\n           tm=timetaken(dist,mid);\\n           if(tm<=hour)\\n           {\\n               res=mid;\\n               hi=mid-1;\\n           }\\n           else\\n           {\\n               lo=mid+1;\\n           }\\n       }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224648,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1, r = 1e9 + 100;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            double total = 0;\\n            for(int i = 0; i < dist.size(); i++) {\\n                total = ceil(total);\\n                int d = dist[i];\\n                total += d * 1.0 / mid;\\n            }\\n            if(total > hour) {\\n                l = mid + 1;\\n            }else{\\n                r = mid;\\n            }\\n        }\\n        if(l > 1e9) return -1;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1, r = 1e9 + 100;\\n        while(l < r) {\\n            int mid = (l + r) / 2;\\n            double total = 0;\\n            for(int i = 0; i < dist.size(); i++) {\\n                total = ceil(total);\\n                int d = dist[i];\\n                total += d * 1.0 / mid;\\n            }\\n            if(total > hour) {\\n                l = mid + 1;\\n            }else{\\n                r = mid;\\n            }\\n        }\\n        if(l > 1e9) return -1;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854466,
                "title": "minimum-speed-to-arrive-on-time-binary-search-c-easiest-solution",
                "content": "**Description:**\\n\\n\\uD83D\\uDE80 Check out my C++ solution for the \"Minimum Speed to Arrive On Time\" problem on LeetCode!\\n\\uD83D\\uDE95 The challenge is to find the minimum speed required to reach the destination on time.\\n\\uD83D\\uDDFA\\uFE0F Given the distances between checkpoints and the total travel time allowed (in hours).\\n**Approach:**\\n\\n\\uD83D\\uDD0D I\\'ve used a binary search approach to efficiently find the minimum speed.\\n\\uD83D\\uDCC8 The check() function calculates the total time required to reach the destination at a given speed (m).\\n\\uD83D\\uDEE3\\uFE0F It iterates through the distances between checkpoints, adding the time taken with the given speed.\\n\\uD83C\\uDFC1 The minSpeedOnTime() function initializes a binary search range for the minimum speed.\\n\\uD83C\\uDFAF If the total travel time allowed (hour) is less than the total number of checkpoints minus one, return -1.\\n\\u23E9 During binary search, we update the search range based on whether the calculated time is greater or lesser than the allowed travel time.\\n\\u23F3 The binary search continues until we find the minimum speed that allows us to arrive on time.\\n# **Time Complexity:**(NLOG(N))\\n\\n\\u23F0 Binary search: O(log n) where n is the maximum speed (1e9).\\n\\u23F0 check() function: Linear time O(n) where n is the number of checkpoints.\\n**Conclusion:**\\n\\n\\uD83C\\uDF89 I hope you find my binary search solution helpful for solving the \"Minimum Speed to Arrive On Time\" problem on LeetCode.\\n\\uD83D\\uDCAC Feel free to comment if you have any questions or suggestions for improvement.\\n\\uD83D\\uDCC8 Happy coding and keep pushing your problem-solving skills to new heights!\\nBest regards,\\n**VIVEK JAIN **\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(double m,vector<int>& dist, double hour){\\n        double tot=0.0;int n=dist.size();\\n        for(int i=0;i<n-1;i++){\\n            tot+=ceil((double)(dist[i]/m));\\n        }\\n        tot+=(double) dist[n-1]/m;\\n        return hour>=tot;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l=1,h=1e9;int ans=-1;\\n        int n=dist.size();\\n        if(hour <= n-1) return -1;\\n        while(l<=h){\\n            double m=(l+h)>>1;\\n            if(check(m,dist,hour)){\\n                h=m-1;\\n                ans=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(double m,vector<int>& dist, double hour){\\n        double tot=0.0;int n=dist.size();\\n        for(int i=0;i<n-1;i++){\\n            tot+=ceil((double)(dist[i]/m));\\n        }\\n        tot+=(double) dist[n-1]/m;\\n        return hour>=tot;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l=1,h=1e9;int ans=-1;\\n        int n=dist.size();\\n        if(hour <= n-1) return -1;\\n        while(l<=h){\\n            double m=(l+h)>>1;\\n            if(check(m,dist,hour)){\\n                h=m-1;\\n                ans=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821298,
                "title": "beats-96-92-in-time",
                "content": "\\n# Code\\n```\\nimport math\\n\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        len_path = len(dist)\\n        max_dist = max(dist)\\n        # Paths that will have to the next full hour takes 1 hour each\\n        if len_path - 1 >= hour:\\n            return -1\\n        # If # of paths is equal to hours, they must last at most 1 hour\\n        if len_path == hour:\\n            return max_dist\\n        # If # of paths is equal to # of full hours, the time will be given by the last path\\n        if len_path - 1 == int(hour):\\n            return max(max_dist,round(dist[-1]/(hour-int(hour))))\\n        # Computing the least vel that would work if dist.length = 1\\n        vel = sum(dist)/hour\\n        # If this vel is lower than 1, means that the minimum valid vel works\\n        if vel <= 1:\\n            return 1\\n        # Computing a velocity that we are sure doesn\\'t work, to the binary search\\n        vel = math.floor(vel) - 1\\n        left = vel              #Granting left will be the highest that doesn\\'t work until now\\n        right = max_dist        #Granting right will be the lowest that worked until now\\n        aux = (left+right)//2\\n        while True:\\n            dur = 0\\n            # Testing the velocity\\n            for dis in dist:\\n                dur += dis/aux\\n                if dur > hour:\\n                    dur = -1\\n                    break\\n                else:\\n                    dur = math.ceil(dur)\\n            if dur == -1:\\n                left = aux\\n            else:\\n                right = aux\\n            # Ends when left is adjacent to right\\n            if left == right - 1:\\n                break\\n            aux = (left + right)//2\\n            \\n        return right\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        len_path = len(dist)\\n        max_dist = max(dist)\\n        # Paths that will have to the next full hour takes 1 hour each\\n        if len_path - 1 >= hour:\\n            return -1\\n        # If # of paths is equal to hours, they must last at most 1 hour\\n        if len_path == hour:\\n            return max_dist\\n        # If # of paths is equal to # of full hours, the time will be given by the last path\\n        if len_path - 1 == int(hour):\\n            return max(max_dist,round(dist[-1]/(hour-int(hour))))\\n        # Computing the least vel that would work if dist.length = 1\\n        vel = sum(dist)/hour\\n        # If this vel is lower than 1, means that the minimum valid vel works\\n        if vel <= 1:\\n            return 1\\n        # Computing a velocity that we are sure doesn\\'t work, to the binary search\\n        vel = math.floor(vel) - 1\\n        left = vel              #Granting left will be the highest that doesn\\'t work until now\\n        right = max_dist        #Granting right will be the lowest that worked until now\\n        aux = (left+right)//2\\n        while True:\\n            dur = 0\\n            # Testing the velocity\\n            for dis in dist:\\n                dur += dis/aux\\n                if dur > hour:\\n                    dur = -1\\n                    break\\n                else:\\n                    dur = math.ceil(dur)\\n            if dur == -1:\\n                left = aux\\n            else:\\n                right = aux\\n            # Ends when left is adjacent to right\\n            if left == right - 1:\\n                break\\n            aux = (left + right)//2\\n            \\n        return right\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821142,
                "title": "python-short-and-clean-binarysearch-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n \\\\cdot log(k))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of dist array`,\\n`k is maximum speed possible, i.e 1e7`\\n\\n# Code\\n```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\\n        n = len(dist)\\n        if hour <= n - 1: return -1\\n\\n        l = int(max(sum(dist) // hour, 1))\\n        r = int(max(max(dist), dist[-1] / (hour - (n - 1)))) + 1\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            ds = reversed(dist)\\n            t = sum((ceil(d / m) for d in ds), next(ds) / m)\\n            l, r = (l, m) if t < hour or isclose(t, hour, rel_tol=1e-12) else (m + 1, r)\\n        \\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\\n        n = len(dist)\\n        if hour <= n - 1: return -1\\n\\n        l = int(max(sum(dist) // hour, 1))\\n        r = int(max(max(dist), dist[-1] / (hour - (n - 1)))) + 1\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            ds = reversed(dist)\\n            t = sum((ceil(d / m) for d in ds), next(ds) / m)\\n            l, r = (l, m) if t < hour or isclose(t, hour, rel_tol=1e-12) else (m + 1, r)\\n        \\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821132,
                "title": "binary-search-in-c-python-beats-100-using-tighter-limits",
                "content": "# Intuition\\nThe approach I used is a simple binary search, as everybody did. But to get a slight performance improvement, I calculate boundaries for the speed instead of using hard-coded 1 to `1e7` boundary.\\n\\nWe are given a sequence of distances `dist` denoted as $a_n$, and maximum time `hour` denoted as $c$.\\nThen the problem can be restated in the following way:\\nFind minimum speed $x \\\\in \\\\mathbb{N}$, such that the following holds:\\n$$\\n\\\\begin{align}\\n\\\\sum_{i=1}^{n-1}\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil + \\\\frac{a_n}{x} \\\\le c\\n\\\\end{align}\\n$$\\n\\nGiven that all distances and speed are natural numbers, that is, greater or equal to 1, we find that $\\\\frac{a_i}{x}>0$, therefore $\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil \\\\ge 1$.\\n\\nThen the sum $\\\\sum_{i=1}^{n-1}\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil \\\\ge n-1$ and $\\\\frac{a_n}{x}>0$. Therefore, if $c<=n-1$, then there is no such $x$ that sutisfy the constraint.\\n\\nWe know that ceiling function $\\\\lceil x \\\\rceil$ always returns result $[x, x+1)$. Therefore, $\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil$ will be in range $[\\\\frac{a_i}{x},\\\\frac{a_i}{x}+1)$. Then the two boundaries of $c$ are:\\n\\n$$\\n\\\\begin{align}\\n\\\\sum_{i=1}^{n-1}\\\\frac{a_i}{x} + \\\\frac{a_n}{x} = c_1 \\\\\\\\\\n\\\\sum_{i=1}^{n-1}\\\\left(\\\\frac{a_i}{x} + 1 \\\\right) + \\\\frac{a_n}{x} = c_2 \\\\\\\\\\nc_1 \\\\le c < c_2\\n\\\\end{align}\\n$$\\n\\nAfter some simplifications we get the boundaries of $x$:\\n\\n$$\\n\\\\begin{align}\\n\\\\frac{\\\\sum_{i=1}^{n-1}a_i + a_n}{c} = x_1 \\\\\\\\\\n\\\\frac{\\\\sum_{i=1}^{n-1}a_i + a_n}{c-n+1} = x_2 \\\\\\\\\\nx_1 \\\\le x < x_2 \\\\\\\\\\n\\\\end{align}\\n$$\\n\\nThe code runs faster than 100% in C++:\\n![image.png](https://assets.leetcode.com/users/images/9dac1486-2745-4049-a42f-a3f22fbab66a_1690461980.6774032.png)\\n\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/Qc6KU4dF/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "# Intuition\\nThe approach I used is a simple binary search, as everybody did. But to get a slight performance improvement, I calculate boundaries for the speed instead of using hard-coded 1 to `1e7` boundary.\\n\\nWe are given a sequence of distances `dist` denoted as $a_n$, and maximum time `hour` denoted as $c$.\\nThen the problem can be restated in the following way:\\nFind minimum speed $x \\\\in \\\\mathbb{N}$, such that the following holds:\\n$$\\n\\\\begin{align}\\n\\\\sum_{i=1}^{n-1}\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil + \\\\frac{a_n}{x} \\\\le c\\n\\\\end{align}\\n$$\\n\\nGiven that all distances and speed are natural numbers, that is, greater or equal to 1, we find that $\\\\frac{a_i}{x}>0$, therefore $\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil \\\\ge 1$.\\n\\nThen the sum $\\\\sum_{i=1}^{n-1}\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil \\\\ge n-1$ and $\\\\frac{a_n}{x}>0$. Therefore, if $c<=n-1$, then there is no such $x$ that sutisfy the constraint.\\n\\nWe know that ceiling function $\\\\lceil x \\\\rceil$ always returns result $[x, x+1)$. Therefore, $\\\\left\\\\lceil\\\\frac{a_i}{x}\\\\right\\\\rceil$ will be in range $[\\\\frac{a_i}{x},\\\\frac{a_i}{x}+1)$. Then the two boundaries of $c$ are:\\n\\n$$\\n\\\\begin{align}\\n\\\\sum_{i=1}^{n-1}\\\\frac{a_i}{x} + \\\\frac{a_n}{x} = c_1 \\\\\\\\\\n\\\\sum_{i=1}^{n-1}\\\\left(\\\\frac{a_i}{x} + 1 \\\\right) + \\\\frac{a_n}{x} = c_2 \\\\\\\\\\nc_1 \\\\le c < c_2\\n\\\\end{align}\\n$$\\n\\nAfter some simplifications we get the boundaries of $x$:\\n\\n$$\\n\\\\begin{align}\\n\\\\frac{\\\\sum_{i=1}^{n-1}a_i + a_n}{c} = x_1 \\\\\\\\\\n\\\\frac{\\\\sum_{i=1}^{n-1}a_i + a_n}{c-n+1} = x_2 \\\\\\\\\\nx_1 \\\\le x < x_2 \\\\\\\\\\n\\\\end{align}\\n$$\\n\\nThe code runs faster than 100% in C++:\\n![image.png](https://assets.leetcode.com/users/images/9dac1486-2745-4049-a42f-a3f22fbab66a_1690461980.6774032.png)\\n\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/Qc6KU4dF/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3821047,
                "title": "beats-99-5-binary-search-improved-by-starting-with-smart-lower-and-upper-bounds",
                "content": "Useful tip: If you define a class that implements `__getitem__`, you can use the built in bisect module instead of implementing your own binary search.\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour <= len(dist)-1:\\n            return -1\\n\\n        lo = max(1, int(sum(dist) / hour))\\n        hi = max(max([0]+dist[:-1]), math.ceil(dist[-1]/(hour-len(dist)+1))) + 1\\n\\n        return bisect.bisect_left(CanMakeIt(dist, hour), True, lo, hi)\\n\\nclass CanMakeIt:\\n    def __init__(self, dist, hour):\\n        self._dist = dist\\n        self._hour = hour\\n\\n    def __getitem__(self, speed):\\n        time = sum(-(d // -speed) for d in self._dist[:-1]) + self._dist[-1]/speed\\n        return time <= self._hour\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if hour <= len(dist)-1:\\n            return -1\\n\\n        lo = max(1, int(sum(dist) / hour))\\n        hi = max(max([0]+dist[:-1]), math.ceil(dist[-1]/(hour-len(dist)+1))) + 1\\n\\n        return bisect.bisect_left(CanMakeIt(dist, hour), True, lo, hi)\\n\\nclass CanMakeIt:\\n    def __init__(self, dist, hour):\\n        self._dist = dist\\n        self._hour = hour\\n\\n    def __getitem__(self, speed):\\n        time = sum(-(d // -speed) for d in self._dist[:-1]) + self._dist[-1]/speed\\n        return time <= self._hour\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820828,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n     public boolean isPossible(int[] dist, int speed, double hour) {\\n        double ans = 0;\\n        for (int i = 0; i < dist.length; i++) {\\n            double d = dist[i] * 1.0 / speed;\\n            if (i != dist.length - 1)\\n                ans = ans + Math.ceil(d);\\n            else\\n                ans += d;\\n            if (ans > hour)\\n                return false;\\n        }\\n        return ans <= hour;\\n    }\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n         int i = 1;\\n        int j = (int) 1e7;\\n        int minSpeed = -1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (isPossible(dist, mid, hour)) {\\n                minSpeed = mid;\\n                j = mid - 1;\\n            } else\\n                i = mid + 1;\\n        }\\n        return minSpeed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n     public boolean isPossible(int[] dist, int speed, double hour) {\\n        double ans = 0;\\n        for (int i = 0; i < dist.length; i++) {\\n            double d = dist[i] * 1.0 / speed;\\n            if (i != dist.length - 1)\\n                ans = ans + Math.ceil(d);\\n            else\\n                ans += d;\\n            if (ans > hour)\\n                return false;\\n        }\\n        return ans <= hour;\\n    }\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n         int i = 1;\\n        int j = (int) 1e7;\\n        int minSpeed = -1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (isPossible(dist, mid, hour)) {\\n                minSpeed = mid;\\n                j = mid - 1;\\n            } else\\n                i = mid + 1;\\n        }\\n        return minSpeed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820704,
                "title": "binary-search-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        # if n-1>hour:\\n        #     return -1\\n        def calc_time(speed):\\n            time_taken = 0\\n            ## main logic is here the last time can be in decimal because there is no distance after it..........\\n            for i in dist[:-1]:\\n                time_taken+=ceil(i/speed)\\n            time_taken+=dist[-1]/speed\\n            return time_taken\\n        left = 1\\n        right = 10**7 +1\\n\\n        while left<right:\\n            mid = (left+right)//2\\n            if calc_time(mid)<=hour:\\n                right = mid\\n            else:\\n                left = mid+1\\n        return left if left != 10**7 + 1 else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        # if n-1>hour:\\n        #     return -1\\n        def calc_time(speed):\\n            time_taken = 0\\n            ## main logic is here the last time can be in decimal because there is no distance after it..........\\n            for i in dist[:-1]:\\n                time_taken+=ceil(i/speed)\\n            time_taken+=dist[-1]/speed\\n            return time_taken\\n        left = 1\\n        right = 10**7 +1\\n\\n        while left<right:\\n            mid = (left+right)//2\\n            if calc_time(mid)<=hour:\\n                right = mid\\n            else:\\n                left = mid+1\\n        return left if left != 10**7 + 1 else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820639,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if (n - 1 >= hour) {\\n            return -1;\\n        }\\n        int i = 1;\\n        int j = 10000000;\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            double sum = 0.0;\\n            for (int k = 0; k < n - 1; k++) {\\n                sum += ceil(dist[k] / (double)(mid));\\n            }\\n            sum += (double)(dist[n - 1]) / mid;\\n\\n            if (sum <= hour) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if (n - 1 >= hour) {\\n            return -1;\\n        }\\n        int i = 1;\\n        int j = 10000000;\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            double sum = 0.0;\\n            for (int k = 0; k < n - 1; k++) {\\n                sum += ceil(dist[k] / (double)(mid));\\n            }\\n            sum += (double)(dist[n - 1]) / mid;\\n\\n            if (sum <= hour) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820488,
                "title": "c-super-easy-clean-code-classic-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& dist, int speed, double hour){\\n        double time = 0;\\n        int n = dist.size();\\n\\n        for(int i=0; i<n; i++){\\n           time = ceil(time);\\n           time += 1.0 * dist[i]/speed;\\n        }\\n\\n        return time <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int low = 1;\\n        int high = 1e7;\\n\\n        int minSpeed = -1;\\n\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n\\n            if(isPossible(dist,mid,hour)){\\n                minSpeed = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return minSpeed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPossible(vector<int>& dist, int speed, double hour){\\n        double time = 0;\\n        int n = dist.size();\\n\\n        for(int i=0; i<n; i++){\\n           time = ceil(time);\\n           time += 1.0 * dist[i]/speed;\\n        }\\n\\n        return time <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int low = 1;\\n        int high = 1e7;\\n\\n        int minSpeed = -1;\\n\\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n\\n            if(isPossible(dist,mid,hour)){\\n                minSpeed = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n\\n        return minSpeed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820480,
                "title": "c-apni-bhasha-mein-sidhi-baat-no-bakwas-bs-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Main ek employee hu mujhe office pahuchna hain \"hour\" mein .\\n    2. Office pahuchne ke liye mujhe \"n\" trains in sequential order leni hain.\\n    3. \"dist\" array diya hain jo har train kitna distance chalti hain wo batata\\n    hain.\\n    4. Ab every train will depart at \"integer hour\" matlab\\u27530.33 ke bajaye vo\\n    1.00 per depart karegi .\\n    5. Ab aisi kya min speed ho train ki , ki ham hours mein pahuch jaye.\\n    6. Hame bahut jaldi bhi nahin pahuchna just 1 min pehle bhi pahuch jayu\\n    hours se to it is success.\\n\\n    INTUITION & APPROACH\\n    1. This is a variant of \"BS ON ANSWERS PATTERN\".\\n    2. How\\u2753\\n    - Because we know ki jo bhi speed hogi wo \"0\" to \"1e7\" ke beech mein\\n     ho sakti hain. 1e7 to ques mein bhi mentioned hain.\\n    - So the answer is lying in the above range we only have to search in halves\\n    3. \"low=0\",\"high=1e7\"\\n    4. har mid ke liye ham time nikalenge har train ka.\\n    5. Agar no of hours se kam le kisi speed ke liye to it can be one of \\n    the answer.\\n    6. Ham speed aur kam karlenge (\"high=mid-1\")because we have to find\\n     the \"minimum positive integer\".\\n    7. Agar speed jyada chahiye to \"low=mid+1\"\\n    8. Is chiz ka dhyan rakhna hain ki train hamesha \"integer hour\" per depart\\n    hogi magar last ke liye integer hour calc karne ki jarurat nahin.\\n    9. Why\\u2753-> Ab agar ek baar final station per pahuch gaye to ham kyo wait\\n    karenge train ke departure ka.\\n    10. \"ceil\",\"float\" ka dhyan rakhna padega.\\n\\n//===============================================================================================================================================\\n        double findTime(vector<int> &dist, int speed)\\n        {\\n            double totalTime = 0.0;\\n            //total time required for a specific speed\\n            for (int i = 0; i < dist.size() - 1; i++)\\n            {\\n                int distance = dist[i];\\n               double time = distance*1.0/speed;\\n               //Calculating time for each distance\\n                totalTime += ceil(time);\\n                //Rounding off to integer because train can depart\\n                //at integer hours only\\n            }\\n            totalTime += dist[dist.size() - 1] *1.0/speed;\\n            //Last distance cover karne ke baad employee dosen\\'t\\n            //have to wait.\\n            return totalTime;\\n        }\\n    int minSpeedOnTime(vector<int> &dist, double hour)\\n    {\\n        int low = 0;\\n        int high = 1e7;\\n        //ans will lie between low and high\\n        int ans = -1;\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n        //mid speed\\n            if (findTime(dist, mid) <= hour)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n                //Found one optimal answer now have to find more\\n                //optimal answer\\n            }\\n            else\\n                low = mid + 1;\\n                //Speed required will be more\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $O(logN)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. Main ek employee hu mujhe office pahuchna hain \"hour\" mein .\\n    2. Office pahuchne ke liye mujhe \"n\" trains in sequential order leni hain.\\n    3. \"dist\" array diya hain jo har train kitna distance chalti hain wo batata\\n    hain.\\n    4. Ab every train will depart at \"integer hour\" matlab\\u27530.33 ke bajaye vo\\n    1.00 per depart karegi .\\n    5. Ab aisi kya min speed ho train ki , ki ham hours mein pahuch jaye.\\n    6. Hame bahut jaldi bhi nahin pahuchna just 1 min pehle bhi pahuch jayu\\n    hours se to it is success.\\n\\n    INTUITION & APPROACH\\n    1. This is a variant of \"BS ON ANSWERS PATTERN\".\\n    2. How\\u2753\\n    - Because we know ki jo bhi speed hogi wo \"0\" to \"1e7\" ke beech mein\\n     ho sakti hain. 1e7 to ques mein bhi mentioned hain.\\n    - So the answer is lying in the above range we only have to search in halves\\n    3. \"low=0\",\"high=1e7\"\\n    4. har mid ke liye ham time nikalenge har train ka.\\n    5. Agar no of hours se kam le kisi speed ke liye to it can be one of \\n    the answer.\\n    6. Ham speed aur kam karlenge (\"high=mid-1\")because we have to find\\n     the \"minimum positive integer\".\\n    7. Agar speed jyada chahiye to \"low=mid+1\"\\n    8. Is chiz ka dhyan rakhna hain ki train hamesha \"integer hour\" per depart\\n    hogi magar last ke liye integer hour calc karne ki jarurat nahin.\\n    9. Why\\u2753-> Ab agar ek baar final station per pahuch gaye to ham kyo wait\\n    karenge train ke departure ka.\\n    10. \"ceil\",\"float\" ka dhyan rakhna padega.\\n\\n//===============================================================================================================================================\\n        double findTime(vector<int> &dist, int speed)\\n        {\\n            double totalTime = 0.0;\\n            //total time required for a specific speed\\n            for (int i = 0; i < dist.size() - 1; i++)\\n            {\\n                int distance = dist[i];\\n               double time = distance*1.0/speed;\\n               //Calculating time for each distance\\n                totalTime += ceil(time);\\n                //Rounding off to integer because train can depart\\n                //at integer hours only\\n            }\\n            totalTime += dist[dist.size() - 1] *1.0/speed;\\n            //Last distance cover karne ke baad employee dosen\\'t\\n            //have to wait.\\n            return totalTime;\\n        }\\n    int minSpeedOnTime(vector<int> &dist, double hour)\\n    {\\n        int low = 0;\\n        int high = 1e7;\\n        //ans will lie between low and high\\n        int ans = -1;\\n        while (low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n        //mid speed\\n            if (findTime(dist, mid) <= hour)\\n            {\\n                ans = mid;\\n                high = mid - 1;\\n                //Found one optimal answer now have to find more\\n                //optimal answer\\n            }\\n            else\\n                low = mid + 1;\\n                //Speed required will be more\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820299,
                "title": "c-binary-search-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n    int left = 1;\\n    int right = (int)1e7;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (CanReachOffice(dist, hour, mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return CanReachOffice(dist, hour, left) ? left : -1;\\n}\\nprivate bool CanReachOffice(int[] dist, double hour, int speed) {\\n    double totalTime = 0;\\n\\n    for (int i = 0; i < dist.Length - 1; i++) {\\n        totalTime += Math.Ceiling((double)dist[i] / speed);\\n    }\\n\\n    totalTime += (double)dist[dist.Length - 1] / speed;\\n\\n    return totalTime <= hour;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n    int left = 1;\\n    int right = (int)1e7;\\n\\n    while (left < right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (CanReachOffice(dist, hour, mid)) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n\\n    return CanReachOffice(dist, hour, left) ? left : -1;\\n}\\nprivate bool CanReachOffice(int[] dist, double hour, int speed) {\\n    double totalTime = 0;\\n\\n    for (int i = 0; i < dist.Length - 1; i++) {\\n        totalTime += Math.Ceiling((double)dist[i] / speed);\\n    }\\n\\n    totalTime += (double)dist[dist.Length - 1] / speed;\\n\\n    return totalTime <= hour;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819450,
                "title": "c-all-cases-explained-easy-binary-search-solution-w-comments",
                "content": "# Intuition\\nIn such questions, it is important to think about the permisibble values of speed that is possible and after realizing that, you tend to *form a **search space*** for your answer!\\n\\n\\n# Complexity\\n- Time complexity:\\n O( N log(K))  \\nwhere, N=no. of trains, K= range of our search space\\n\\n- Space complexity:\\n linear space complexity!\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    double time(int speed, vector<int> &dist){ //speed = m;\\n\\n        double totalt = 0; //totalt = totaltime including the fact that we can board train only at integrral hours! (so ceil fn is used)\\n\\n        for(int i=0; i<dist.size(); i++){\\n            double num =  dist[i]/(double)speed;\\n            if(i!=dist.size()-1){\\n                num = ceil(num); // to get integral val (so ceil fn is used)\\n            }\\n            totalt+=num;\\n        }\\n        return totalt;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int n = dist.size();\\n        int l = 1; int h = 1e7; //minimun speed(l) shall be atleast 1 hence l=1;\\n                                //h = 10^7 accordin to question description\\n\\n        if(dist.size()>ceil(hour)) return -1; //ONLY case when u return -1\\n\\n        while(l<=h){\\n\\n            int m = l + (h-l)/2;\\n            double val = time(m,dist);\\n\\n            if(val<=hour){\\n                h=m-1;\\n            }\\n            else if(val>hour){\\n                l=m+1;\\n            }\\n        }\\n\\n        return l; //gives you the min integral value of speed that helps you reach in given time!\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double time(int speed, vector<int> &dist){ //speed = m;\\n\\n        double totalt = 0; //totalt = totaltime including the fact that we can board train only at integrral hours! (so ceil fn is used)\\n\\n        for(int i=0; i<dist.size(); i++){\\n            double num =  dist[i]/(double)speed;\\n            if(i!=dist.size()-1){\\n                num = ceil(num); // to get integral val (so ceil fn is used)\\n            }\\n            totalt+=num;\\n        }\\n        return totalt;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int n = dist.size();\\n        int l = 1; int h = 1e7; //minimun speed(l) shall be atleast 1 hence l=1;\\n                                //h = 10^7 accordin to question description\\n\\n        if(dist.size()>ceil(hour)) return -1; //ONLY case when u return -1\\n\\n        while(l<=h){\\n\\n            int m = l + (h-l)/2;\\n            double val = time(m,dist);\\n\\n            if(val<=hour){\\n                h=m-1;\\n            }\\n            else if(val>hour){\\n                l=m+1;\\n            }\\n        }\\n\\n        return l; //gives you the min integral value of speed that helps you reach in given time!\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819423,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   double getspeed(vector<int>& d, int t)\\n    {\\n        int n = d.size();\\n        double res = 0.0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            double v = (double(d[i])/double(t));\\n            res+=ceil(v);\\n        }\\n       \\n       res+=(d[n-1]/double(t));\\n        return res;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& d, double hr) {\\n        int l = 1;\\n        int h = 10000001;\\n        int ans = -1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n\\n            \\n            if(getspeed(d,mid)<=hr)\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return ans;\\n            \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   double getspeed(vector<int>& d, int t)\\n    {\\n        int n = d.size();\\n        double res = 0.0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            double v = (double(d[i])/double(t));\\n            res+=ceil(v);\\n        }\\n       \\n       res+=(d[n-1]/double(t));\\n        return res;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& d, double hr) {\\n        int l = 1;\\n        int h = 10000001;\\n        int ans = -1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n\\n            \\n            if(getspeed(d,mid)<=hr)\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        \\n        return ans;\\n            \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819405,
                "title": "90-faster-easiest-code-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool cond(int &speed,vector<int>& dist, double &hour)\\n    {\\n        double time=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            time+=dist[i]/speed;                // it adds integer values on dividing\\n            time+=(dist[i]%speed==0)?0:1;       // eg if 3/2=1.5 so in int 1.5 =1 so for extra 0.5 we add 1 bcz train comes at mark 2 so time it would take in total is 2 not 1 if decimal value add 1;\\n        }\\n        time+=(dist[dist.size()-1]*1.0)/speed;  // last distance is deciding weather we will be before time or not\\n        return time<=hour;                    // true or false it returns\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if((double)dist.size()-1>=hour) return -1;\\n\\n        int left=1;\\n        int right=1e7;  // will check on all range using binary search algo\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(cond(mid,dist,hour))\\n            {\\n                right=mid-1;\\n            }\\n            else {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool cond(int &speed,vector<int>& dist, double &hour)\\n    {\\n        double time=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            time+=dist[i]/speed;                // it adds integer values on dividing\\n            time+=(dist[i]%speed==0)?0:1;       // eg if 3/2=1.5 so in int 1.5 =1 so for extra 0.5 we add 1 bcz train comes at mark 2 so time it would take in total is 2 not 1 if decimal value add 1;\\n        }\\n        time+=(dist[dist.size()-1]*1.0)/speed;  // last distance is deciding weather we will be before time or not\\n        return time<=hour;                    // true or false it returns\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if((double)dist.size()-1>=hour) return -1;\\n\\n        int left=1;\\n        int right=1e7;  // will check on all range using binary search algo\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(cond(mid,dist,hour))\\n            {\\n                right=mid-1;\\n            }\\n            else {\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819362,
                "title": "daily-challenge-binary-search-o-nlogn-c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoose the starting pointer as 0 ans end pointer as 1e7. Find the mid and check for the mid that whether it can be the solution or not. If it is then decrease the end pointer else increase the starting pointer.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double k=0;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++){\\n            k+=dist[i];\\n        }\\n        int ans=-1;\\n        if(n-1>hour)return -1;\\n        if(k==hour)return 1;\\n        int st=1;\\n        int en=1e7;\\n       \\n        while(st<=en){\\n            int mid=(st+en)/2;\\n            double l=0;\\n            for(int i=0;i<n;i++){\\n                if(i!=n-1){\\n                    if(dist[i]%mid==0){\\n                        l+=dist[i]/mid;\\n                    }\\n                    else{\\n                        l+=(dist[i]+mid)/mid;\\n                    }\\n                }\\n                else{\\n                    l+=(double)(dist[i])/(double)(mid);\\n                }\\n            }\\n            if(l<=hour){\\n                ans=mid;\\n                en=mid-1;\\n\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        double k=0;\\n        int n=dist.size();\\n        for(int i=0;i<n;i++){\\n            k+=dist[i];\\n        }\\n        int ans=-1;\\n        if(n-1>hour)return -1;\\n        if(k==hour)return 1;\\n        int st=1;\\n        int en=1e7;\\n       \\n        while(st<=en){\\n            int mid=(st+en)/2;\\n            double l=0;\\n            for(int i=0;i<n;i++){\\n                if(i!=n-1){\\n                    if(dist[i]%mid==0){\\n                        l+=dist[i]/mid;\\n                    }\\n                    else{\\n                        l+=(dist[i]+mid)/mid;\\n                    }\\n                }\\n                else{\\n                    l+=(double)(dist[i])/(double)(mid);\\n                }\\n            }\\n            if(l<=hour){\\n                ans=mid;\\n                en=mid-1;\\n\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819326,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &dist, double temp){\\n        int n=dist.size();\\n        double hour=0;\\n        for(int i=0;i<n;i++){ \\n            if(i==n-1){\\n                double x=(double)(dist[i])/(double)(mid);\\n                hour+=x;\\n            }\\n            else{\\n                int y=(dist[i])/(mid);\\n                if((dist[i]%mid)!=0) y+=1;\\n                hour+=y;\\n            }\\n        }\\n        if(hour<=temp) return true;\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=1e7;\\n        int mini=-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (check(mid,dist,hour)){\\n                // cout<<mid<<\" \";\\n                mini=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return mini;\\n    }\\n};\\n\\n// class Solution {\\n// public:\\n//     bool check(int mid,vector<int> &dist, double temp){\\n//         int n=dist.size();\\n//         double hour=0;\\n//         for(int i=0;i<n;i++){ \\n//             if(i==n-1){\\n//                 double x=(double)(dist[i])/(double)(mid);\\n//                 hour+=x;\\n//             }\\n//             else{\\n//                 int y=(dist[i])/(mid);\\n//                 if((dist[i]%mid)!=0) y+=1;\\n//                 hour+=y;\\n//             }\\n//         }\\n//         if(hour>temp) return false;\\n//         return true;\\n//     }\\n//     int minSpeedOnTime(vector<int>& dist, double hour) {\\n//         int low=1;\\n//         int high=1e7;\\n//         int mini=-1;\\n//         while(low<=high){\\n//             int mid=(low+high)/2;\\n//             if (check(mid,dist,hour)){\\n//                 mini=mid;\\n//                 high=mid-1;\\n//             }\\n//             else low=mid+1;\\n//         }\\n//         return\\xA0mini;\\n// \\xA0\\xA0\\xA0\\xA0}\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &dist, double temp){\\n        int n=dist.size();\\n        double hour=0;\\n        for(int i=0;i<n;i++){ \\n            if(i==n-1){\\n                double x=(double)(dist[i])/(double)(mid);\\n                hour+=x;\\n            }\\n            else{\\n                int y=(dist[i])/(mid);\\n                if((dist[i]%mid)!=0) y+=1;\\n                hour+=y;\\n            }\\n        }\\n        if(hour<=temp) return true;\\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=1e7;\\n        int mini=-1;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if (check(mid,dist,hour)){\\n                // cout<<mid<<\" \";\\n                mini=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return mini;\\n    }\\n};\\n\\n// class Solution {\\n// public:\\n//     bool check(int mid,vector<int> &dist, double temp){\\n//         int n=dist.size();\\n//         double hour=0;\\n//         for(int i=0;i<n;i++){ \\n//             if(i==n-1){\\n//                 double x=(double)(dist[i])/(double)(mid);\\n//                 hour+=x;\\n//             }\\n//             else{\\n//                 int y=(dist[i])/(mid);\\n//                 if((dist[i]%mid)!=0) y+=1;\\n//                 hour+=y;\\n//             }\\n//         }\\n//         if(hour>temp) return false;\\n//         return true;\\n//     }\\n//     int minSpeedOnTime(vector<int>& dist, double hour) {\\n//         int low=1;\\n//         int high=1e7;\\n//         int mini=-1;\\n//         while(low<=high){\\n//             int mid=(low+high)/2;\\n//             if (check(mid,dist,hour)){\\n//                 mini=mid;\\n//                 high=mid-1;\\n//             }\\n//             else low=mid+1;\\n//         }\\n//         return\\xA0mini;\\n// \\xA0\\xA0\\xA0\\xA0}\\n// };\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3819235,
                "title": "best-java-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int s = 1;\\n        int e = 10000001;\\n        int ans = -1;\\n        while(s < e){\\n            int m = s+(e-s)/2;\\n\\n            double v = 0;\\n            for(int i = 0 ; i < n-1 ; i++){\\n           \\n             v+= Math.ceil((double)dist[i]/m);\\n            }\\n            v+= (double)dist[n-1]/m;\\n\\n            if(v > hour){\\n                s = m+1;\\n            }else{\\n                ans = m;\\n                e = m;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n   \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int s = 1;\\n        int e = 10000001;\\n        int ans = -1;\\n        while(s < e){\\n            int m = s+(e-s)/2;\\n\\n            double v = 0;\\n            for(int i = 0 ; i < n-1 ; i++){\\n           \\n             v+= Math.ceil((double)dist[i]/m);\\n            }\\n            v+= (double)dist[n-1]/m;\\n\\n            if(v > hour){\\n                s = m+1;\\n            }else{\\n                ans = m;\\n                e = m;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n   \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819038,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int possible(int speed, double hours, vector<int>& dist) {\\n        double time_taken = 0;\\n        for (int i = 0; i < dist.size(); i++) {\\n            double curr_time = (double)dist[i]/ speed;\\n            time_taken +=  i == dist.size() - 1 ? curr_time : ceil(curr_time);\\n        }\\n        return time_taken <= hours;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 0, high = 1e7;\\n        while (low + 1 < high) {\\n            int mid = (low + high) >> 1;\\n            if (possible(mid, hour, dist)) {\\n                high = mid;\\n            }\\n            else {\\n                low = mid;\\n            }\\n        }\\n        \\n        return possible(low, hour, dist) ? low : possible(high, hour, dist) ? high : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int possible(int speed, double hours, vector<int>& dist) {\\n        double time_taken = 0;\\n        for (int i = 0; i < dist.size(); i++) {\\n            double curr_time = (double)dist[i]/ speed;\\n            time_taken +=  i == dist.size() - 1 ? curr_time : ceil(curr_time);\\n        }\\n        return time_taken <= hours;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low = 0, high = 1e7;\\n        while (low + 1 < high) {\\n            int mid = (low + high) >> 1;\\n            if (possible(mid, hour, dist)) {\\n                high = mid;\\n            }\\n            else {\\n                low = mid;\\n            }\\n        }\\n        \\n        return possible(low, hour, dist) ? low : possible(high, hour, dist) ? high : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818798,
                "title": "java-binary-search-prefix-sum-6ms-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLimit the search space. The high end is max dist, the low end is average speed.\\n\\nSince for `n - 1` rides only integer hours considered, count and prefix sum the dists at first, then `f(intHour, speed) = distcount[intHour * speed] - distcount[(intHour - 1) * speed]` is the count of all dists which will spend `intHour` time for given `speed`. And `f(intHour, speed) * intHour` gives the hours needed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(hlog(distmax - avgspeed))$$ where `distmax` is high end of search, `avgspeed` is low end. `h` is integer hours and related to the speed being searched: `distmax / speed`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(c)$$ for dists count, $$10^5$$ constant\\n\\n# Runtime\\n6ms\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int last = n - 1;\\n\\n        // Hour limit must be greater than `n - 1`,\\n        // otherwise there is no way to arrive on time\\n        if (hour <= last) {\\n            return -1;\\n        }\\n\\n        int distmax = 0;\\n        long distsum = 0;\\n        int[] distcount = new int[100_000 + 1];\\n        for (int i = 0; i < n; i++) {\\n            distmax = Math.max(distmax, dist[i]);\\n            distsum += dist[i];\\n            distcount[dist[i]]++;\\n        }\\n\\n        // When hour limit is greater than sum of dist, speed 1 is enough\\n        if (hour >= distsum) {\\n            return 1;\\n        }\\n        // When hour between (n - 1, n], means `n - 1` trains need spend exactly `n - 1` hours (1 hour for each),\\n        // thus distmax is minimum speed required. Also consider fraction hour spent by last train.\\n        if (hour <= n) {\\n            return Math.max(distmax, divide(dist[last], hour - last));\\n        }\\n        // When only 1 ride, average speed is the minimum speed\\n        int avgspeed = divide(distsum, hour);\\n        if (n == 1) {\\n            return avgspeed;\\n        }\\n\\n        // The `distcount` is used to calculate integer hours of `n - 1` rides, need exclude last ride\\n        distcount[dist[last]]--;\\n        for (int i = 1; i <= distmax; i++) {\\n            // prefix sum\\n            distcount[i] += distcount[i - 1];\\n        }\\n\\n        // Now hour > n, average speed is low end of search space, `distmax` is the high end\\n        int low = avgspeed, high = distmax;\\n\\n        while (low <= high) {\\n            int speed = (high + low) >>> 1;\\n\\n            // distcount[speed] is count of all dists <= speed, which will spend 1 integer hour for each\\n            int time = distcount[speed];\\n            int hourmax = (int) Math.ceil((double) distmax / speed);\\n            for (int intHour = 2; intHour <= hourmax; intHour++) {\\n                // distcount[intHour * speed] - distcount[(intHour - 1) * speed] is count of all dists within\\n                // ((intHour-1) * speed, intHour * speed], which will spend intHour time for each\\n                time += intHour * (distcount[Math.min(distmax, intHour * speed)] - distcount[(intHour - 1) * speed]);\\n            }\\n\\n            if (time + (double) dist[last] / speed > hour) {\\n                // Exceed hour limit, increase speed\\n                low = speed + 1;\\n            } else {\\n                // Within hour limit, decrease speed to find minimum\\n                high = speed - 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private int divide(long dist, double hour) {\\n        hour = Math.round(hour * 100);\\n        return (int) Math.ceil(dist * 100 / hour);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int last = n - 1;\\n\\n        // Hour limit must be greater than `n - 1`,\\n        // otherwise there is no way to arrive on time\\n        if (hour <= last) {\\n            return -1;\\n        }\\n\\n        int distmax = 0;\\n        long distsum = 0;\\n        int[] distcount = new int[100_000 + 1];\\n        for (int i = 0; i < n; i++) {\\n            distmax = Math.max(distmax, dist[i]);\\n            distsum += dist[i];\\n            distcount[dist[i]]++;\\n        }\\n\\n        // When hour limit is greater than sum of dist, speed 1 is enough\\n        if (hour >= distsum) {\\n            return 1;\\n        }\\n        // When hour between (n - 1, n], means `n - 1` trains need spend exactly `n - 1` hours (1 hour for each),\\n        // thus distmax is minimum speed required. Also consider fraction hour spent by last train.\\n        if (hour <= n) {\\n            return Math.max(distmax, divide(dist[last], hour - last));\\n        }\\n        // When only 1 ride, average speed is the minimum speed\\n        int avgspeed = divide(distsum, hour);\\n        if (n == 1) {\\n            return avgspeed;\\n        }\\n\\n        // The `distcount` is used to calculate integer hours of `n - 1` rides, need exclude last ride\\n        distcount[dist[last]]--;\\n        for (int i = 1; i <= distmax; i++) {\\n            // prefix sum\\n            distcount[i] += distcount[i - 1];\\n        }\\n\\n        // Now hour > n, average speed is low end of search space, `distmax` is the high end\\n        int low = avgspeed, high = distmax;\\n\\n        while (low <= high) {\\n            int speed = (high + low) >>> 1;\\n\\n            // distcount[speed] is count of all dists <= speed, which will spend 1 integer hour for each\\n            int time = distcount[speed];\\n            int hourmax = (int) Math.ceil((double) distmax / speed);\\n            for (int intHour = 2; intHour <= hourmax; intHour++) {\\n                // distcount[intHour * speed] - distcount[(intHour - 1) * speed] is count of all dists within\\n                // ((intHour-1) * speed, intHour * speed], which will spend intHour time for each\\n                time += intHour * (distcount[Math.min(distmax, intHour * speed)] - distcount[(intHour - 1) * speed]);\\n            }\\n\\n            if (time + (double) dist[last] / speed > hour) {\\n                // Exceed hour limit, increase speed\\n                low = speed + 1;\\n            } else {\\n                // Within hour limit, decrease speed to find minimum\\n                high = speed - 1;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private int divide(long dist, double hour) {\\n        hour = Math.round(hour * 100);\\n        return (int) Math.ceil(dist * 100 / hour);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818773,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& dist, int mid, double hour){\\n\\t\\n        double hours=0;\\n        for(int i=0;i<dist.size()-1;i++){\\n            hours+=dist[i]/mid;\\n            if (dist[i] % mid != 0)\\n                hours++; \\n        }\\n\\t\\t\\n        hours+=dist[dist.size()-1]/(double)mid; //for the last index we need the exact hours so we are calculating it separately\\n\\n        return hours<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=1000000;\\n        int ans=INT_MAX;\\n\\t\\t\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(dist,mid,hour)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\t\\t\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& dist, int mid, double hour){\\n\\t\\n        double hours=0;\\n        for(int i=0;i<dist.size()-1;i++){\\n            hours+=dist[i]/mid;\\n            if (dist[i] % mid != 0)\\n                hours++; \\n        }\\n\\t\\t\\n        hours+=dist[dist.size()-1]/(double)mid; //for the last index we need the exact hours so we are calculating it separately\\n\\n        return hours<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=1000000;\\n        int ans=INT_MAX;\\n\\t\\t\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isPossible(dist,mid,hour)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n\\t\\t\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818753,
                "title": "c-easy-to-understand-binary-search-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& dist, double hour, int speed){\\n        double time=0;\\n\\n        for(int i=0 ; i<dist.size()-1 ; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += dist[dist.size()-1]/(double)speed;\\n\\n        if(time <= hour) return true;\\n        \\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n\\n        if((double)(n-1) >= hour)\\n            return -1;\\n\\n        int maxSpeed = *max_element(dist.begin(),dist.end());\\n\\n        // Considering hour will have at most two digits after the decimal point.\\n        maxSpeed *= 100;\\n\\n        int i=1,j=maxSpeed;\\n        int ans = -1;\\n\\n        while(i<=j){\\n            int mid = i + ( j - i ) / 2;\\n\\n            if(isPossible(dist,hour,mid)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& dist, double hour, int speed){\\n        double time=0;\\n\\n        for(int i=0 ; i<dist.size()-1 ; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += dist[dist.size()-1]/(double)speed;\\n\\n        if(time <= hour) return true;\\n        \\n        return false;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n\\n        if((double)(n-1) >= hour)\\n            return -1;\\n\\n        int maxSpeed = *max_element(dist.begin(),dist.end());\\n\\n        // Considering hour will have at most two digits after the decimal point.\\n        maxSpeed *= 100;\\n\\n        int i=1,j=maxSpeed;\\n        int ans = -1;\\n\\n        while(i<=j){\\n            int mid = i + ( j - i ) / 2;\\n\\n            if(isPossible(dist,hour,mid)){\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818746,
                "title": "c-begineer-friendly-easily-understandable-with-commments-and-approach",
                "content": "\\n# Approach : \\n\\nThis code is implementing a binary search algorithm to find the minimum speed needed to complete a given distance in a specified amount of time. Let\\'s break down the code step-by-step:\\n\\n1. The function `minSpeedOnTime` takes two inputs: a vector `dist` representing the distances between consecutive points and a `double` variable `hour` representing the maximum time allowed to cover all the distances.\\n\\n2. Two integer variables `low` and `high` are initialized to 1 and 10000009 (a large value) respectively. These variables will be used to keep track of the range of possible speeds for completion.\\n\\n3. The binary search loop starts with `while (low < high)`. This means the loop will continue as long as the search space has not been narrowed down to a single element.\\n\\n4. Inside the loop, the mid-point of the current range is calculated as `int mid = (low + high) / 2`.\\n\\n5. A double variable `time` is initialized to 0. This variable will be used to keep track of the total time required to cover the distances at the current speed `mid`.\\n\\n6. A for loop iterates over each element `it` in the `dist` vector.\\n\\n7. Inside the loop, the time taken to cover the current distance at the current speed is calculated and added to the `time` variable.\\n\\n8. The next distance is covered, and the time is updated again. The code ensures that if there is any fractional time remaining, it is rounded up to the next integer using `(int)time + 1`.\\n\\n9. After calculating the total time `time` required at the current speed `mid`, a comparison is made with the allowed `hour`. If the calculated time exceeds the given hour, it means the current speed is too slow to complete the distance in the given time. Therefore, `low` is updated to `mid + 1` to search for faster speeds in the upper half of the search space.\\n\\n10. If the calculated time is less than or equal to the given hour, it means the current speed is sufficient to complete the distance in the given time. In this case, `high` is updated to `mid` to search for slower speeds in the lower half of the search space.\\n\\n11. The loop continues to narrow down the search space by adjusting `low` and `high` until they converge to a single element. At that point, the loop exits.\\n\\n12. Finally, the function returns `low` as the minimum speed needed to cover the distances in the given time. However, there is a conditional check `(low > 10000000 ? -1 : low)` to handle a special case. If the loop exits with `low` still greater than the upper limit, which means no speed was found within the specified time, the function returns -1 to indicate that it\\'s not possible to cover the distance in the given time.\\n\\nIn summary, this code uses binary search to find the minimum speed needed to complete a set of distances in a given time. If it finds a valid speed, it returns that speed; otherwise, it returns -1 to indicate that the distance cannot be covered in the given time.\\n\\n\\n# CODE C++ :\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // Set the initial range of possible speeds.\\n        int low = 1;\\n        int high = 10000009; // A large value, acts as an upper bound for the speed.\\n\\n        // Binary search loop to find the minimum required speed.\\n        while (low < high) {\\n            // Calculate the middle speed.\\n            int mid = (low + high) / 2;\\n\\n            // Variable to keep track of the total time needed to cover the distances at the current speed.\\n            double time = 0;\\n\\n            // Calculate the total time taken to cover the distances at the current speed.\\n            for (auto it : dist) {\\n                // If there is any fractional time remaining, round it up to the next integer.\\n                if (time > (int)time)\\n                    time = double((int)time + 1);\\n\\n                // Calculate the time taken to cover the current distance at the current speed.\\n                time += (double)it / (double)mid;\\n            }\\n\\n            // Compare the calculated time with the allowed hour.\\n            if (time > hour) {\\n                // If the calculated time exceeds the given hour, the current speed is too slow.\\n                // Search for faster speeds in the upper half of the range.\\n                low = mid + 1;\\n            } else {\\n                // If the calculated time is within the given hour, the current speed is sufficient.\\n                // Search for slower speeds in the lower half of the range.\\n                high = mid;\\n            }\\n        }\\n\\n        // At the end of the loop, low and high will converge to a single value.\\n        // Check if low exceeds the upper limit; if so, return -1 to indicate it\\'s not possible to complete the distance in the given time.\\n        return (low > 10000000 ? -1 : low);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // Set the initial range of possible speeds.\\n        int low = 1;\\n        int high = 10000009; // A large value, acts as an upper bound for the speed.\\n\\n        // Binary search loop to find the minimum required speed.\\n        while (low < high) {\\n            // Calculate the middle speed.\\n            int mid = (low + high) / 2;\\n\\n            // Variable to keep track of the total time needed to cover the distances at the current speed.\\n            double time = 0;\\n\\n            // Calculate the total time taken to cover the distances at the current speed.\\n            for (auto it : dist) {\\n                // If there is any fractional time remaining, round it up to the next integer.\\n                if (time > (int)time)\\n                    time = double((int)time + 1);\\n\\n                // Calculate the time taken to cover the current distance at the current speed.\\n                time += (double)it / (double)mid;\\n            }\\n\\n            // Compare the calculated time with the allowed hour.\\n            if (time > hour) {\\n                // If the calculated time exceeds the given hour, the current speed is too slow.\\n                // Search for faster speeds in the upper half of the range.\\n                low = mid + 1;\\n            } else {\\n                // If the calculated time is within the given hour, the current speed is sufficient.\\n                // Search for slower speeds in the lower half of the range.\\n                high = mid;\\n            }\\n        }\\n\\n        // At the end of the loop, low and high will converge to a single value.\\n        // Check if low exceeds the upper limit; if so, return -1 to indicate it\\'s not possible to complete the distance in the given time.\\n        return (low > 10000000 ? -1 : low);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818626,
                "title": "c-binary-search-minimum-speed-to-arrive-on-time",
                "content": "# Intuition\\nBinary serach \\n\\n# Approach\\nBinary search approach\\n\\n# Complexity\\n- Time complexity:\\n\\n1. The helper function iterates through the dist vector, which has a size of n, to calculate the time taken for each segment. This takes O(n) time.\\n2. The minSpeedOnTime function uses binary search to find the minimum speed required. The binary search has a time complexity of O(log S), where S is the search space. Here, the search space is from 1 to 1e7 (10^7). Therefore, the binary search takes O(log 1e7) \\u2248 O(23) \\u2248 O(1) time.\\nOverall, the time complexity of the code is dominated by the O(n) time complexity of the helper function.\\n\\n- Space complexity:\\n\\n1. The helper function uses a constant amount of extra space, regardless of the size of the input vector dist. It creates a few variables, but they do not depend on the size of the input. Therefore, the space complexity of the helper function is O(1).\\n2. The minSpeedOnTime function also uses a constant amount of extra space for variables like l, r, and speed, which do not depend on the size of the input. Therefore, the space complexity of the minSpeedOnTime function is also O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double helper(vector<int>& dist, int speed)\\n    {\\n        double time = 0.0;\\n        int len = dist.size();\\n\\n        for(int i = 0; i < len-1; i++)\\n        {\\n            double t = (double)dist[i] / (double)speed;\\n            time += ceil(t);\\n        }\\n        time += (double)dist[len-1] / (double)speed;\\n\\n        return time;\\n    }\\n\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1;\\n        int r = 1e7;\\n\\n        int speed = -1;\\n\\n        while(l <= r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(helper(dist,mid) <= hour)\\n            {\\n                speed = mid;\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return speed;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double helper(vector<int>& dist, int speed)\\n    {\\n        double time = 0.0;\\n        int len = dist.size();\\n\\n        for(int i = 0; i < len-1; i++)\\n        {\\n            double t = (double)dist[i] / (double)speed;\\n            time += ceil(t);\\n        }\\n        time += (double)dist[len-1] / (double)speed;\\n\\n        return time;\\n    }\\n\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int l = 1;\\n        int r = 1e7;\\n\\n        int speed = -1;\\n\\n        while(l <= r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(helper(dist,mid) <= hour)\\n            {\\n                speed = mid;\\n                r = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n        }\\n        return speed;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818607,
                "title": "easy-c-binary-search-similar-to-book-allocation-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk)\\n-> n for is possible \\n->logk for binary search\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double ispossible(vector<int>& dist, int mid){\\n        double time = 0.0;\\n        int n= dist.size();\\n        for(int i=0;i<n-1;i++){\\n            double t = (double)dist[i]/(double)mid;\\n            time += ceil(t);\\n        }\\n        time += (double)dist[n-1]/(double)mid;\\n        return time;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int start=1;\\n        int end= 1e7;\\n        int minspeed= -1;\\n        while(start<=end){\\n            int mid= start+(end-start)/2;\\n            if(ispossible(dist, mid)<=hour){\\n                minspeed= mid;\\n                end= mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return minspeed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double ispossible(vector<int>& dist, int mid){\\n        double time = 0.0;\\n        int n= dist.size();\\n        for(int i=0;i<n-1;i++){\\n            double t = (double)dist[i]/(double)mid;\\n            time += ceil(t);\\n        }\\n        time += (double)dist[n-1]/(double)mid;\\n        return time;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int start=1;\\n        int end= 1e7;\\n        int minspeed= -1;\\n        while(start<=end){\\n            int mid= start+(end-start)/2;\\n            if(ispossible(dist, mid)<=hour){\\n                minspeed= mid;\\n                end= mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return minspeed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818476,
                "title": "binary-search-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minSpeedOnTime(self, dist, hour):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type hour: float\\n        :rtype: int\\n        \"\"\"\\n        if hour<=len(dist)-1:\\n            return -1\\n        l=1\\n        r=max(dist)*100000\\n        while l<r:\\n            #speed=sum(dist)//hour+1\\n            mid=(l+r)//2\\n            time=0\\n            for i in range(len(dist)-1):\\n                time+=math.ceil(float(dist[i])/mid)\\n            time+=float(dist[-1])/mid\\n            #print(time,mid)\\n            if time<=hour:\\n                r=mid\\n                #print(time)\\n                #print(time,mid)\\n            else:\\n                l=mid+1\\n        #print(l,r)\\n        return l\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minSpeedOnTime(self, dist, hour):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type hour: float\\n        :rtype: int\\n        \"\"\"\\n        if hour<=len(dist)-1:\\n            return -1\\n        l=1\\n        r=max(dist)*100000\\n        while l<r:\\n            #speed=sum(dist)//hour+1\\n            mid=(l+r)//2\\n            time=0\\n            for i in range(len(dist)-1):\\n                time+=math.ceil(float(dist[i])/mid)\\n            time+=float(dist[-1])/mid\\n            #print(time,mid)\\n            if time<=hour:\\n                r=mid\\n                #print(time)\\n                #print(time,mid)\\n            else:\\n                l=mid+1\\n        #print(l,r)\\n        return l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818459,
                "title": "image-explanation-c-java-python-binary-search-on-answer",
                "content": "**Cheers Coders!**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Monotonic speed**\\n**Binary Search on Answer**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-07-26 at 14.52.58.jpg](https://assets.leetcode.com/users/images/1ffc9aad-7313-49cc-a910-7ff271b3f9bf_1690364431.495103.jpeg)\\n\\n![WhatsApp Image 2023-07-26 at 14.52.53.jpg](https://assets.leetcode.com/users/images/7368a1a5-bdc4-4adb-ba7a-b0067bda2ca4_1690364448.6248956.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Java\\n```\\nclass Solution {\\n    private boolean check(int[] arr,int speed,double hour){\\n        double curr=0;\\n        for(int i=0;i<arr.length;++i){\\n            double time=(arr[i]*1.0)/speed;\\n            if(i<arr.length-1)time=Math.ceil(time);\\n            curr+=time;\\n            if(curr>hour)return false;\\n        }\\n        return true;\\n    }\\n    public int minSpeedOnTime(int[] arr, double hour) {\\n        int f=1,l=10000000,ans=-1;\\n        while(f<=l){\\n            int mid=f+((l-f)>>1);\\n            if(check(arr,mid,hour)){\\n                ans=mid;\\n                l=mid-1;\\n            }\\n            else f=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\nprivate:\\n    bool check(vector<int>& arr,int speed,double hour){\\n        double curr=0;\\n        for(int i=0;i<arr.size();++i){\\n            double time=(arr[i]*1.0)/speed;\\n            if(i<arr.size()-1)time=ceil(time);\\n            curr+=time;\\n            if(curr>hour)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        int f=0,l=10000000,ans=-1;\\n        while(f<=l){\\n            int mid=f+((l-f)>>1);\\n            if(check(arr,mid,hour)){\\n                ans=mid;\\n                l=mid-1;\\n            }\\n            else f=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def check(self,arr,speed,hour):\\n        curr=0\\n        for i in range(0,len(arr)):\\n            time=(arr[i]*1.0)/speed\\n            if i<len(arr)-1:\\n                time=math.ceil(time)\\n            curr+=time\\n            if curr>hour: \\n                return False\\n        return True\\n    \\n    def minSpeedOnTime(self, arr, hour):\\n        f,l=1,10000000\\n        ans=-1\\n        while f<=l:\\n            mid=f+((l-f)>>1)\\n            val=self.check(arr,mid,hour)\\n            if val==True:\\n                ans=mid\\n                l=mid-1\\n            else: \\n                f=mid+1\\n        return ans\\n```\\n\\nKeeps coding\\n**Please Upvote if you like \\uD83D\\uDC4D\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    private boolean check(int[] arr,int speed,double hour){\\n        double curr=0;\\n        for(int i=0;i<arr.length;++i){\\n            double time=(arr[i]*1.0)/speed;\\n            if(i<arr.length-1)time=Math.ceil(time);\\n            curr+=time;\\n            if(curr>hour)return false;\\n        }\\n        return true;\\n    }\\n    public int minSpeedOnTime(int[] arr, double hour) {\\n        int f=1,l=10000000,ans=-1;\\n        while(f<=l){\\n            int mid=f+((l-f)>>1);\\n            if(check(arr,mid,hour)){\\n                ans=mid;\\n                l=mid-1;\\n            }\\n            else f=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\nprivate:\\n    bool check(vector<int>& arr,int speed,double hour){\\n        double curr=0;\\n        for(int i=0;i<arr.size();++i){\\n            double time=(arr[i]*1.0)/speed;\\n            if(i<arr.size()-1)time=ceil(time);\\n            curr+=time;\\n            if(curr>hour)return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        int f=0,l=10000000,ans=-1;\\n        while(f<=l){\\n            int mid=f+((l-f)>>1);\\n            if(check(arr,mid,hour)){\\n                ans=mid;\\n                l=mid-1;\\n            }\\n            else f=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def check(self,arr,speed,hour):\\n        curr=0\\n        for i in range(0,len(arr)):\\n            time=(arr[i]*1.0)/speed\\n            if i<len(arr)-1:\\n                time=math.ceil(time)\\n            curr+=time\\n            if curr>hour: \\n                return False\\n        return True\\n    \\n    def minSpeedOnTime(self, arr, hour):\\n        f,l=1,10000000\\n        ans=-1\\n        while f<=l:\\n            mid=f+((l-f)>>1)\\n            val=self.check(arr,mid,hour)\\n            if val==True:\\n                ans=mid\\n                l=mid-1\\n            else: \\n                f=mid+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818308,
                "title": "c-solution-binary-search-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                              `Binary Search`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `timeReq(vector<int>& d, int ele)`: This function calculates the time required to cover a given distance using a specific speed (`ele`). The function takes two arguments - a vector `d` containing integers representing the distances between checkpoints or segments of the journey, and an integer `ele` representing the speed at which the distance is covered.\\n\\n2. `minSpeedOnTime(vector<int>& dist, double hour)`: This is the main function that will be called to find the minimum speed required to complete the journey within a specified time (`hour`). It takes a vector `dist` representing the distances between checkpoints and a double hour representing the maximum allowed time for the journey.\\n\\n3. Now, let\\'s analyze how the minSpeedOnTime function works:\\n  It first initializes some variables:\\n\\n4. `n`: The number of distances in the dist vector (size of the vector).\\nres: The variable to store the result, which is the minimum speed required. It is initially set to -1.\\n`l`: The left boundary of the search space for binary search. It is initialized to 1.\\n`r`: The right boundary of the search space for binary search. It is set to a large value 1e9+7.\\n\\n5. Inside the binary search loop, it calculates the middle value` mid` as `l+(r-l)/2`. timeReq(dist, mid): It calls the timeReq function with the speed mid and checks whether the time required to cover the distance at that speed is less than or equal to the given hour.\\n\\n6. If timeReq(dist, mid) is less than or equal to hour, it means the speed mid is a valid candidate. The code updates the res to mid (potential solution) and narrows down the search space by updating `r` to `mid - 1` (search in the left half).\\n\\n7. If timeReq(dist, mid) is greater than hour, it means the speed mid is too high, and we need to search in the right half. So, the code updates `l` to `mid + 1`.\\n\\n8. The binary search continues until l is less than or equal to r.\\nWhen the binary search is complete, the code returns the value of `res`, which represents the minimum speed required to complete the journey within the given time.\\n\\n# Complexity\\nHere, `N` is the number of rides, and `K` is the size of the search space. \\n\\n .\\n- Time complexity:$$O(NlogK)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double timeReq(vector<int>&d, int ele){\\n       int n=d.size();\\n       double t=0.0;\\n\\n       for(int i=0;i<n;i++){\\n        \\n           double time=(double)d[i]/(double)ele;\\n\\n           // we have to round off to next integer, if its not the last ride\\n           t+=(i==n-1?time:ceil(time));\\n       }\\n\\n    return t;\\n\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int n=dist.size();\\n        int res=-1;\\n\\n        int l=1;\\n        int r=1e9+7;\\n\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n\\n            if(timeReq(dist,mid)<=hour){\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n\\n        }\\n    \\n    return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double timeReq(vector<int>&d, int ele){\\n       int n=d.size();\\n       double t=0.0;\\n\\n       for(int i=0;i<n;i++){\\n        \\n           double time=(double)d[i]/(double)ele;\\n\\n           // we have to round off to next integer, if its not the last ride\\n           t+=(i==n-1?time:ceil(time));\\n       }\\n\\n    return t;\\n\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int n=dist.size();\\n        int res=-1;\\n\\n        int l=1;\\n        int r=1e9+7;\\n\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n\\n            if(timeReq(dist,mid)<=hour){\\n                res=mid;\\n                r=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n\\n        }\\n    \\n    return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818214,
                "title": "simple-explanation-beats-100-optimized-start-speed",
                "content": "Since `time = distance / speed`, we\\'re actually required to find a minimum ***integer*** speed `s`, ***less than 10^7***, such that\\n```\\nSUM( ceiling(d[i] / s) ) <= hour\\n```\\nInstead of brute force, we can use binary search, of course. Upper limit is given, but the staring lower limit speed can be computed as the **`whole distance / ideal time`**;\\n\\nAlso, since each distance segment takes at least 1 hour, we can check in the beginning whether the answer is obviously impossible.\\n\\nPlease press **upvote** below if this solution helped. **Thank you!**\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) \\n    {\\n        var n = dist.Length;\\n        \\n        if (Math.Ceiling(hour) < n)\\n            return -1;\\n        \\n        // don\\'t do dist.Sum() directly because OverflowException\\n        double sum = 0;\\n        for(int i = 0; i < n; i++)\\n            sum += dist[i] * 1.0 / hour;\\n        \\n        int l = (int)Math.Floor(sum);\\n        int r = 10000000; \\n\\n        while(l < r)\\n        {\\n            var mid = (l + r) / 2;\\n\\n            // compute total time, pay attention to excluding last segment from rounding up\\n            sum = 0;\\n            for(int i = 0; i < n - 1; i++)\\n                sum += Math.Ceiling(dist[i] * 1.0 / mid);\\n            sum += dist[n - 1] * 1.0 / mid;\\n\\n            if (sum > hour)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nSUM( ceiling(d[i] / s) ) <= hour\\n```\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) \\n    {\\n        var n = dist.Length;\\n        \\n        if (Math.Ceiling(hour) < n)\\n            return -1;\\n        \\n        // don\\'t do dist.Sum() directly because OverflowException\\n        double sum = 0;\\n        for(int i = 0; i < n; i++)\\n            sum += dist[i] * 1.0 / hour;\\n        \\n        int l = (int)Math.Floor(sum);\\n        int r = 10000000; \\n\\n        while(l < r)\\n        {\\n            var mid = (l + r) / 2;\\n\\n            // compute total time, pay attention to excluding last segment from rounding up\\n            sum = 0;\\n            for(int i = 0; i < n - 1; i++)\\n                sum += Math.Ceiling(dist[i] * 1.0 / mid);\\n            sum += dist[n - 1] * 1.0 / mid;\\n\\n            if (sum > hour)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818196,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nThe goal is to find the minimum speed needed to complete a distance within a specified time. So we use Binary Search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSteps:\\n\\n- We calculate the time taken to cover the entire distance at the middle speed (mid) in each iteration.\\n- If the calculated time exceeds the given time limit, we narrow the search range to the upper half (low = mid + 1).\\n- If the calculated time is within the time limit, we narrow the search range to the lower half (high = mid).\\n- We continue the binary search until low becomes greater than or equal to high.\\n- At the end, we return the minimum speed (low) required to complete the journey within the given time. And if low becomes greater than 10000000, we return -1 (indicating impossibility).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=10000009;\\n        while(low<high){\\n            int mid=(low+high)/2;\\n            double time=0;\\n            for(auto it:dist){\\n                if(time>(int)time) time=double((int)time+1);\\n                time+=((double)it)/((double)mid);\\n            }\\n            if(time>hour) low=mid+1;\\n            else high=mid;\\n        }\\n        return (low>10000000 ? -1 : low);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int low=1,high=10000009;\\n        while(low<high){\\n            int mid=(low+high)/2;\\n            double time=0;\\n            for(auto it:dist){\\n                if(time>(int)time) time=double((int)time+1);\\n                time+=((double)it)/((double)mid);\\n            }\\n            if(time>hour) low=mid+1;\\n            else high=mid;\\n        }\\n        return (low>10000000 ? -1 : low);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818176,
                "title": "simple-binary-search-c-no-need-of-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nLogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int MaxSpeed=1e7,MinSpeed=1,MinRequiredSpeed=INT_MAX;//constrains \\n        while(MinSpeed<=MaxSpeed){\\n            int CurrSpeed=(MinSpeed + MaxSpeed)/2;\\n            double CurrHour=0.0;\\n            for(int i=0;i<dist.size();i++){\\n               CurrHour+=(i!=dist.size()-1)?ceil(double(dist[i])/CurrSpeed):double(dist[i])/CurrSpeed;\\n            }//counting the hours based on the current speed after that comparing them \\n            if(hour>=CurrHour){\\n                MinRequiredSpeed=min(MinRequiredSpeed,CurrSpeed);\\n                MaxSpeed=CurrSpeed-1;\\n            }\\n            else{\\n                MinSpeed=CurrSpeed+1;\\n            }\\n        }\\n       if(MinRequiredSpeed==INT_MAX)return -1;//return if there is no speedbina\\n       return MinRequiredSpeed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int MaxSpeed=1e7,MinSpeed=1,MinRequiredSpeed=INT_MAX;//constrains \\n        while(MinSpeed<=MaxSpeed){\\n            int CurrSpeed=(MinSpeed + MaxSpeed)/2;\\n            double CurrHour=0.0;\\n            for(int i=0;i<dist.size();i++){\\n               CurrHour+=(i!=dist.size()-1)?ceil(double(dist[i])/CurrSpeed):double(dist[i])/CurrSpeed;\\n            }//counting the hours based on the current speed after that comparing them \\n            if(hour>=CurrHour){\\n                MinRequiredSpeed=min(MinRequiredSpeed,CurrSpeed);\\n                MaxSpeed=CurrSpeed-1;\\n            }\\n            else{\\n                MinSpeed=CurrSpeed+1;\\n            }\\n        }\\n       if(MinRequiredSpeed==INT_MAX)return -1;//return if there is no speedbina\\n       return MinRequiredSpeed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818115,
                "title": "simple-binary-search-on-answer",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n*log(INT_MAX))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log(INT_MAX))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool valid(int mid,vector<int>&dist,double &hour){\\n    double hm=0;\\n\\n    for(auto i:dist){\\n        hm=ceil(hm);\\n\\n        if(hour<hm)\\n        return false;\\n\\n        hm+=1.0*i/mid;\\n    }\\n    if(hour<hm)\\n    return false;\\n\\n    return true;\\n   \\n}\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        long long st=1,e=INT_MAX;\\nint ans=-1;\\n        while(st<=e){\\n            long long mid=st+(e-st)/2;\\n            if(valid(mid,dist,hour)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n            st=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool valid(int mid,vector<int>&dist,double &hour){\\n    double hm=0;\\n\\n    for(auto i:dist){\\n        hm=ceil(hm);\\n\\n        if(hour<hm)\\n        return false;\\n\\n        hm+=1.0*i/mid;\\n    }\\n    if(hour<hm)\\n    return false;\\n\\n    return true;\\n   \\n}\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        long long st=1,e=INT_MAX;\\nint ans=-1;\\n        while(st<=e){\\n            long long mid=st+(e-st)/2;\\n            if(valid(mid,dist,hour)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n            st=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818113,
                "title": "java-binary-solution-easy-explanation-1870-minimum-speed-to-arrive-on-time",
                "content": "# Intuition\\nWe have to find the min speed of the train and it is given in the question that ans will lie in the range between 1- 10^7.\\nso for this range we can not use linear approach to find ans. therefore we will be using binary search to  find the min index that will give us the minspeed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will be using binary search for the index in the range between 1 to 10^7.\\nfor this range we will calculate the mid value.\\nfor this mid value we  will calculate the total time that is being taken by the train.\\n    \\n\\n---\\n\\nTo calculate the time taken by train, \\nwe will iterate through dist array, and then calculate the time that is required at that particular index.\\nif the iterator (i) will reach the last index than simply we will add the time in a sum variable.\\notherwise we have to first find the ceil value and then add that value to the sum variable.\\n\\nand simply return if the calculated sum<=hour(given).\\nif this condition is true than it indicates that the mid point can be the ans. \\nelse we have to search in the right side of mid.\\n# Complexity\\n- Time complexity: O(nlogk)  n ->length of dis[] , k-> the binary search space.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l =1 ;\\n        int r = (int)1e7;\\n        int minspeed = -1;\\n  \\n        while(l<=r){\\n          int mid = l+(r-l)/2;\\n          if(check(dist , hour , mid)){\\n            minspeed = mid;\\n            r = mid-1;\\n          }\\n          else{\\n            l  = mid+1;\\n          }\\n        }\\n        return minspeed;\\n    }\\n    public static boolean check(int[]dist , double hour , int speed){\\n      int n = dist.length;\\n      double sum = 0.0;\\n      for(int i =0 ; i<n ; i++){\\n        double time = (double)dist[i]/(double)speed;\\n        if(i == n-1) sum +=time;\\n        else sum = sum + Math.ceil(time);\\n        if(sum>hour) return false;\\n      }\\n      return sum<=hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int l =1 ;\\n        int r = (int)1e7;\\n        int minspeed = -1;\\n  \\n        while(l<=r){\\n          int mid = l+(r-l)/2;\\n          if(check(dist , hour , mid)){\\n            minspeed = mid;\\n            r = mid-1;\\n          }\\n          else{\\n            l  = mid+1;\\n          }\\n        }\\n        return minspeed;\\n    }\\n    public static boolean check(int[]dist , double hour , int speed){\\n      int n = dist.length;\\n      double sum = 0.0;\\n      for(int i =0 ; i<n ; i++){\\n        double time = (double)dist[i]/(double)speed;\\n        if(i == n-1) sum +=time;\\n        else sum = sum + Math.ceil(time);\\n        if(sum>hour) return false;\\n      }\\n      return sum<=hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818092,
                "title": "python-3-binary-search-runtime-beats-89",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to the task\\'s description:\\n- Speed ranges between $$1$$ and $$10^7$$ km/h.\\n- We don\\'t need to wait additional time after the last train.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse binary search for the speed, ceil the time taken for each train but the last.\\n\\n# Complexity \\n- Time complexity: $$O(N*LOG(C))$$, where $$C$$ is the range $$[1..10^7]$$, or just $$O(N)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$, the algorithm uses constant additional space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```python3\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canReach(s):\\n            return sum([ceil(d / s) for d in dist[:-1]], 0) + dist[-1] / s <= hour\\n        \\n        lo, hi = 1, 10 ** 7\\n        min_speed = -1\\n        while lo <= hi:\\n            speed = (hi - lo) // 2 + lo\\n            if canReach(speed):\\n                min_speed = speed\\n                hi = speed - 1\\n            else:\\n                lo = speed + 1\\n        return min_speed\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python3\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        def canReach(s):\\n            return sum([ceil(d / s) for d in dist[:-1]], 0) + dist[-1] / s <= hour\\n        \\n        lo, hi = 1, 10 ** 7\\n        min_speed = -1\\n        while lo <= hi:\\n            speed = (hi - lo) // 2 + lo\\n            if canReach(speed):\\n                min_speed = speed\\n                hi = speed - 1\\n            else:\\n                lo = speed + 1\\n        return min_speed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818029,
                "title": "easy-bs-on-answer-solution-fully-explained-self-explanatory",
                "content": "# Intuition\\n    F F F F T T T T\\n    1 2 3 4 5 6 7 8 \\n    \\n    F means - With this speed, it is not possible to reach office on time\\n    T means - With this speed, it is possible to reach office on time\\n\\n    We can see a monotonic sequence (of speed) \\n    and hence BINARY SEARCH on ANSWER\\n\\n# Complexity\\n- Time complexity : $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(Nlog(range))$$ , range - 1e7\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= 1.0*(n-1)) return -1;\\n        \\n        int low = 1;\\n        int high = 1e7;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            double x = isPossible(dist,mid);\\n            if(x <= hour) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    double isPossible(vector<int> &dist, int mid) {\\n        int n = dist.size();\\n        double x = 0.0;\\n        for(int i=0 ; i<n-1 ; i++) {\\n            int z = (dist[i]+mid-1)/mid; // finding the ceil of dist[i]/mid\\n            x += 1.0*z;\\n        }\\n        x += (double)(1.0*dist[n-1])/(mid*1.0);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if(hour <= 1.0*(n-1)) return -1;\\n        \\n        int low = 1;\\n        int high = 1e7;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n\\n            double x = isPossible(dist,mid);\\n            if(x <= hour) high = mid-1;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n\\n    double isPossible(vector<int> &dist, int mid) {\\n        int n = dist.size();\\n        double x = 0.0;\\n        for(int i=0 ; i<n-1 ; i++) {\\n            int z = (dist[i]+mid-1)/mid; // finding the ceil of dist[i]/mid\\n            x += 1.0*z;\\n        }\\n        x += (double)(1.0*dist[n-1])/(mid*1.0);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817988,
                "title": "go-binary-search",
                "content": "# Approach\\nUse binary search to get correct time. Use `10^7` as right border \\n\\n# Complexity\\n- Time complexity:\\n$$O(Log(n))$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n\\tl := 0\\n\\tr := 10000000\\n\\tfor l < r {\\n\\t\\tm := (l + r) / 2\\n\\t\\tif CheckTime(dist, hour, m) {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m\\n\\t\\t}\\n\\t}\\n\\tcurTime := GetTimeSpeed(dist, l)\\n\\tif curTime > hour {\\n\\t\\tl = -1\\n\\t}\\n\\treturn l\\n}\\nfunc CheckTime(dist []int, hour float64, speed int) bool {\\n\\tcurrentTime := GetTimeSpeed(dist, speed)\\n\\treturn currentTime > hour\\n}\\nfunc GetTimeSpeed(dist []int, speed int) float64 {\\n\\tcurrentTime := 0.0\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tcurrentTime = math.Ceil(currentTime)\\n\\t\\tcurrentTime += float64(dist[i]) / float64(speed)\\n\\t}\\n\\treturn currentTime\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc minSpeedOnTime(dist []int, hour float64) int {\\n\\tl := 0\\n\\tr := 10000000\\n\\tfor l < r {\\n\\t\\tm := (l + r) / 2\\n\\t\\tif CheckTime(dist, hour, m) {\\n\\t\\t\\tl = m + 1\\n\\t\\t} else {\\n\\t\\t\\tr = m\\n\\t\\t}\\n\\t}\\n\\tcurTime := GetTimeSpeed(dist, l)\\n\\tif curTime > hour {\\n\\t\\tl = -1\\n\\t}\\n\\treturn l\\n}\\nfunc CheckTime(dist []int, hour float64, speed int) bool {\\n\\tcurrentTime := GetTimeSpeed(dist, speed)\\n\\treturn currentTime > hour\\n}\\nfunc GetTimeSpeed(dist []int, speed int) float64 {\\n\\tcurrentTime := 0.0\\n\\tfor i := 0; i < len(dist); i++ {\\n\\t\\tcurrentTime = math.Ceil(currentTime)\\n\\t\\tcurrentTime += float64(dist[i]) / float64(speed)\\n\\t}\\n\\treturn currentTime\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817897,
                "title": "c-beginner-friendly-code-binary-search-faster-than-92",
                "content": "The Question is very simple and uses Binary search, just we have to check some edge cases\\n#### Thinking ->\\nSince we know we have to return a integer, so my answer will lie somewhere in Between 1 to 1e7, (not 0 -> because with 0 speed we can never reach to office lmao)\\nNow,\\n* We apply Binary seach in the search space (1 to 1e7), and we will get some mid value(ie mid = l + (r-l) / 2)\\n* Now in the ispossible function, we check this mid value through out the dist array, and check is this train speed is sufficient enough to reach out destionation in time?\\n* If yes then we will become a bit greedy and reduce our search space (r = mid-1)\\n* else we will increase our search space (l = mid + 1)\\n\\n ##### Some Points to keep in mind in the isPossible function\\n* Notice that in the question it is stated that the train will only come at interger time, thus we have wait until the next integer\\nFor Example : If I reached at time \"1.34\" and my next train will only come \"2\", so I have to wait upto time 2, thus in the total time I\\'ll add is the ceil value of \"1.34\" ie 2\\nBut if I am on my last train (ie ind = n-1) and I reaches at some float value, I dont have to convert it to the next ceil value, beacause I dont need to catch another train.\\n\\n* At the end we return the lowest value!!\\n\\n```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>& dist,double &hour, int x)\\n    {\\n        int n = dist.size();\\n        double time = 0.00;\\n        for(int i=0;i<n;i++)\\n        {\\n            double temp = (double)dist[i]/x;\\n    \\n            if(i!=n-1)\\n                time += ceil(temp);\\n            else\\n                time += temp;\\n        }\\n\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        int l = 1;\\n        int r = 1e7;\\n        if (hour <= (double)(n - 1))\\n            return -1;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            \\n            if(ispossible(dist,hour,mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nPlease Upvote if it was helpful\\uD83D\\uDE01",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>& dist,double &hour, int x)\\n    {\\n        int n = dist.size();\\n        double time = 0.00;\\n        for(int i=0;i<n;i++)\\n        {\\n            double temp = (double)dist[i]/x;\\n    \\n            if(i!=n-1)\\n                time += ceil(temp);\\n            else\\n                time += temp;\\n        }\\n\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        int l = 1;\\n        int r = 1e7;\\n        if (hour <= (double)(n - 1))\\n            return -1;\\n        while(l<=r)\\n        {\\n            int mid = l+(r-l)/2;\\n            \\n            if(ispossible(dist,hour,mid))\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817784,
                "title": "binary-search-easy-explanation-short-code-faster-than-99",
                "content": "# Intuition\\nBy linearly checking from speed 1 to 1^7 we will get tle its better to check by binary search because from binary search we can ignore the range which can not be answer.This will help in finding efficiently.\\n\\n# Approach\\nFirstly when we start this question we see that our speed can vary from 1km/hr to 1e7 km/hr. Since we have to give the minimum we will start traversing from 1 km/hr and when conditions are met we return the ans. This will take o(maxspeed) *o(size of array) hence inefficient.\\n\\nSince the answer space is sorted we can go for binary search. So every mid is our current speed we are trying for. If our total time with current speed is less than required hour this can surely be one of the ans but wait! we want minimum of all possible ans so we move hi to mid-1 and check for lesser answer if possible the fine, otherwise this current ans will be the ans. 2 nd case arises when the total hour at current speed crosses the hours given we cannot consider this speed as ans so we have to increase our speed to get lesser time so lo= mid+1\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dist,int speed,double hour){\\n        double ans=0;\\n        int n= dist.size();\\n        for(int i=0; i<n-1; i++){\\n            if(dist[i]%speed==0){\\n                ans+= dist[i]/speed;\\n            }\\n            else{\\n                ans+= (dist[i]/speed)+1;\\n            }\\n        }\\n        ans+= (double)(dist[n-1])/(double)(speed);\\n        if(ans>hour) return false;\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int hi=1e7;\\n        int n= dist.size();  \\n        int lo= 1;\\n        while(lo<=hi){\\n            int mid= (lo+hi)/2;\\n            if(helper(dist,mid,hour)){\\n                ans= mid;\\n                hi= mid-1;\\n                \\n            }\\n            else{\\n                lo= mid+1;\\n            }\\n            \\n         }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&dist,int speed,double hour){\\n        double ans=0;\\n        int n= dist.size();\\n        for(int i=0; i<n-1; i++){\\n            if(dist[i]%speed==0){\\n                ans+= dist[i]/speed;\\n            }\\n            else{\\n                ans+= (dist[i]/speed)+1;\\n            }\\n        }\\n        ans+= (double)(dist[n-1])/(double)(speed);\\n        if(ans>hour) return false;\\n        return true;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int hi=1e7;\\n        int n= dist.size();  \\n        int lo= 1;\\n        while(lo<=hi){\\n            int mid= (lo+hi)/2;\\n            if(helper(dist,mid,hour)){\\n                ans= mid;\\n                hi= mid-1;\\n                \\n            }\\n            else{\\n                lo= mid+1;\\n            }\\n            \\n         }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817760,
                "title": "c-brute-force-and-binary-search-approach",
                "content": "\\n# 1) Brute Force Approach\\n\\n# Complexity\\n- Time complexity: In worst Case O(10^7);\\n\\n- Space complexity: Constant Space O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, int speed, double hour){\\n        int i=0;\\n        double time = 0;\\n        for(; i<dist.size()-1; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += (double)dist[i]/speed;\\n        return time<=hour;\\n    }\\n\\n    int BruteForce(vector<int>& dist, double hour){\\n        \\n        for(int speed=1; speed<=10000000; speed++){\\n            if(check(dist, speed, hour)){\\n                return speed;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n\\n        // Brute Force;\\n        return BruteForce(dist, hour);\\n\\n    }\\n};\\n```\\n\\n\\n\\n\\n# 2) Binary Search Approach\\n\\n# Complexity\\n- Time complexity: In worst Case O(log(10^7));\\n\\n- Space complexity: Constant Space O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, int speed, double hour){\\n        int i=0;\\n        double time = 0;\\n        for(; i<dist.size()-1; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += (double)dist[i]/speed;\\n        return time<=hour;\\n    }\\n\\n    \\n    int BinarySearch(vector<int>& dist, double hour){\\n        int start = 1, end = 10000000; //Range of speed\\n        \\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n\\n            if(check(dist, mid, hour)){ //Check if possible\\n                ans = mid;\\n                end = mid-1; //if possible then we need to find \"minimum speed\"\\n            }else{\\n                start = mid+1; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n\\n        // Binary Search\\n        return BinarySearch(dist, hour);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, int speed, double hour){\\n        int i=0;\\n        double time = 0;\\n        for(; i<dist.size()-1; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += (double)dist[i]/speed;\\n        return time<=hour;\\n    }\\n\\n    int BruteForce(vector<int>& dist, double hour){\\n        \\n        for(int speed=1; speed<=10000000; speed++){\\n            if(check(dist, speed, hour)){\\n                return speed;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n\\n        // Brute Force;\\n        return BruteForce(dist, hour);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, int speed, double hour){\\n        int i=0;\\n        double time = 0;\\n        for(; i<dist.size()-1; i++){\\n            time += ceil((double)dist[i]/speed);\\n        }\\n        time += (double)dist[i]/speed;\\n        return time<=hour;\\n    }\\n\\n    \\n    int BinarySearch(vector<int>& dist, double hour){\\n        int start = 1, end = 10000000; //Range of speed\\n        \\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n\\n            if(check(dist, mid, hour)){ //Check if possible\\n                ans = mid;\\n                end = mid-1; //if possible then we need to find \"minimum speed\"\\n            }else{\\n                start = mid+1; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n\\n        // Binary Search\\n        return BinarySearch(dist, hour);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817621,
                "title": "very-easy-approach-beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        speed=sum(dist)//int(hour)\\n        l=1\\n        r=10000000\\n        p=float(\\'inf\\')\\n        while l<=r:\\n            mid=(l+r)//2\\n            c=0\\n            for k in range(len(dist)-1):\\n                mynum=dist[k]/mid\\n                if isinstance(mynum,float):\\n                    c+=math.ceil(dist[k]/mid)\\n                else:\\n                    c+=mynum\\n            c+=dist[-1]/mid\\n            if c<=hour:\\n                r=mid-1\\n                p=min(p,mid)\\n\\n            else:\\n                l=mid+1\\n        if p==float(\\'inf\\'):\\n            return -1\\n        else:\\n            return p\\n            \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        speed=sum(dist)//int(hour)\\n        l=1\\n        r=10000000\\n        p=float(\\'inf\\')\\n        while l<=r:\\n            mid=(l+r)//2\\n            c=0\\n            for k in range(len(dist)-1):\\n                mynum=dist[k]/mid\\n                if isinstance(mynum,float):\\n                    c+=math.ceil(dist[k]/mid)\\n                else:\\n                    c+=mynum\\n            c+=dist[-1]/mid\\n            if c<=hour:\\n                r=mid-1\\n                p=min(p,mid)\\n\\n            else:\\n                l=mid+1\\n        if p==float(\\'inf\\'):\\n            return -1\\n        else:\\n            return p\\n            \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817478,
                "title": "simple-approach-daily-26-07-23-minimum-speed-to-arrive-on-time-1870",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSearch for minimum speed in the given limit of maximum speed $$10^7$$. Used binary search for efficiency.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Applying binay search : given that speed cann\\'t exceed $$10^7$$ so searched between 1 and $$10^7$$ and find minimum speed      \\n\\nAt each step :\\n- Checked if this speed will be enough to reach on time or not\\n- - if not, then increase the lower limit so that I can check for higher speeds\\n- - if yes, then store this speed as minimum speed, but continued to search in lower half so that may be more smaller speed can satisfy\\n- Created function \\'timetaken\\' to check speed \\n- - function to check if at a given speed office can be reached or not\\n- - Math.ceil function returns value equal to or greater than a given decimal : fits best here\\n- - Haven\\'t included last train distance in loop because after last train I will reach office so no need to wait - thus no round off to nearest integer ( no Math.ceil for last train)\\n\\nHave a look at the code , still have any confusion then please let me know in the comments\\nKeep Solving.:)\\n\\n# Complexity\\n- Time complexity : $$O(nlogr)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nn = length of dist[ ]\\nr = binary search range : $$ 1 - 10^7$$\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int s = -1;       \\n        // Applying binay search : given that speed cann\\'t exceed 10^7 so we will search between 1 and 10^7 and find minimum speed                       \\n        int l = 1;\\n        int r = (int) 1e7;\\n\\n        while( l <= r){\\n            int m = ( l + r)/2;\\n            if( timetaken( dist, m) > hour){     // check if this speed will be enough to reach on time or not\\n                l = m + 1;                       // if not, then increase the lower limit so that we can check for higher speeds \\n            }\\n            else{                                // if yes, then store this speed as minimum speed, but continue to search in lower half so that may be more smaller speed can satisfy\\n                s = m;   \\n                r = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n\\n    static double timetaken( int[] distances, int speed){       // function to check if at a given speed office can be reached or not\\n        double time = 0;\\n        for( int i = 0; i < distances.length - 1; i++){         // Math.ceil function returns value equal to or greater than a given decimal : fits best here\\n            time += Math.ceil( (double)distances[i] / speed );\\n        }                                                       // i haven\\'t included last train distance in loop because after last train i will reach office so no need to wait - thus no round off to nearest integer ( no Math.ceil for last train)\\n        return time + (double)distances[ distances.length - 1]/speed;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int s = -1;       \\n        // Applying binay search : given that speed cann\\'t exceed 10^7 so we will search between 1 and 10^7 and find minimum speed                       \\n        int l = 1;\\n        int r = (int) 1e7;\\n\\n        while( l <= r){\\n            int m = ( l + r)/2;\\n            if( timetaken( dist, m) > hour){     // check if this speed will be enough to reach on time or not\\n                l = m + 1;                       // if not, then increase the lower limit so that we can check for higher speeds \\n            }\\n            else{                                // if yes, then store this speed as minimum speed, but continue to search in lower half so that may be more smaller speed can satisfy\\n                s = m;   \\n                r = m - 1;\\n            }\\n        }\\n        return s;\\n    }\\n\\n    static double timetaken( int[] distances, int speed){       // function to check if at a given speed office can be reached or not\\n        double time = 0;\\n        for( int i = 0; i < distances.length - 1; i++){         // Math.ceil function returns value equal to or greater than a given decimal : fits best here\\n            time += Math.ceil( (double)distances[i] / speed );\\n        }                                                       // i haven\\'t included last train distance in loop because after last train i will reach office so no need to wait - thus no round off to nearest integer ( no Math.ceil for last train)\\n        return time + (double)distances[ distances.length - 1]/speed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817427,
                "title": "easy-c-binary-search-solution",
                "content": "# Intuition\\nSince, we need to minimize the time, means like given some ranges of time where it\\'s possible for some greater time while not for less, we just need to find min time where it\\'s possible...\\n\\n# Approach\\nUsing Binary Search on range 0 to 1e8, since, given max time can be 1e7 so r>1e7, and l<1 since invariants for binary search would be:\\n1. time(right) <= hour\\n2. time(left) > hour\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk)    since, n operations performed log k times\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution{\\nprivate:\\n    int n;\\n    bool f(vector<int>& dist, double hour, double speed){\\n        double time=0.0;\\n        for(int i=0;i<n-1;i++){\\n            time += ceil(dist[i]/speed);\\n        }\\n        time += dist[n-1]/speed;\\n        return time <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour){\\n        // using Binary Search\\n        // the pattern will be like . . . 0 0 0 1 1 . . .  \\n        // we need to find first 1  \\n        n=dist.size(); \\n        int l=0, r= 1e8;\\n        while(r>l+1){\\n            int m=(l+r)/2;\\n            if(f(dist,hour,m))\\n                r=m;\\n            else\\n                l=m;\\n        }\\n        return r==1e8?-1:r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution{\\nprivate:\\n    int n;\\n    bool f(vector<int>& dist, double hour, double speed){\\n        double time=0.0;\\n        for(int i=0;i<n-1;i++){\\n            time += ceil(dist[i]/speed);\\n        }\\n        time += dist[n-1]/speed;\\n        return time <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour){\\n        // using Binary Search\\n        // the pattern will be like . . . 0 0 0 1 1 . . .  \\n        // we need to find first 1  \\n        n=dist.size(); \\n        int l=0, r= 1e8;\\n        while(r>l+1){\\n            int m=(l+r)/2;\\n            if(f(dist,hour,m))\\n                r=m;\\n            else\\n                l=m;\\n        }\\n        return r==1e8?-1:r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817384,
                "title": "python-using-binary-search-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minSpeedOnTime(self, dist, hour):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type hour: float\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(dist) > math.ceil(hour) :\\n            return -1\\n\\n        r = 10E7\\n        l = 1\\n        res = 0\\n\\n        while l <= r :\\n            mid = int((l+r)/2)\\n\\n            total = 0 \\n\\n            for i in range (len(dist) - 1):\\n                total += math.ceil(float(dist[i])/mid)\\n\\n            total += float(dist[-1])/mid\\n\\n            if total > hour :\\n                l = mid + 1\\n                res = mid + 1\\n            else :\\n                res = mid\\n                r = mid - 1\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def minSpeedOnTime(self, dist, hour):\\n        \"\"\"\\n        :type dist: List[int]\\n        :type hour: float\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(dist) > math.ceil(hour) :\\n            return -1\\n\\n        r = 10E7\\n        l = 1\\n        res = 0\\n\\n        while l <= r :\\n            mid = int((l+r)/2)\\n\\n            total = 0 \\n\\n            for i in range (len(dist) - 1):\\n                total += math.ceil(float(dist[i])/mid)\\n\\n            total += float(dist[-1])/mid\\n\\n            if total > hour :\\n                l = mid + 1\\n                res = mid + 1\\n            else :\\n                res = mid\\n                r = mid - 1\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817377,
                "title": "c-binary-search-on-answer-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int  mid,vector<int>&dist,double hour)\\n    {\\n        int sz=dist.size();\\n        double time=0;\\n        for(int i=0;i<sz-1;i++)\\n        {\\n            time+=(dist[i]+mid-1)/mid;\\n        }\\n        time+=((double)dist[sz-1]/(double)mid);\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n     {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(check(mid,dist,hour))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int  mid,vector<int>&dist,double hour)\\n    {\\n        int sz=dist.size();\\n        double time=0;\\n        for(int i=0;i<sz-1;i++)\\n        {\\n            time+=(dist[i]+mid-1)/mid;\\n        }\\n        time+=((double)dist[sz-1]/(double)mid);\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n     {\\n        int low=1,high=1e9;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(check(mid,dist,hour))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            low=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817365,
                "title": "easy-to-understand-c-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, double hour, int speed){\\n        double h = 0;\\n        int n = dist.size();\\n        for(int i=0; i<n-1; i++){\\n            int d = dist[i];\\n            h += (d/speed + (d%speed == 0 ? 0 : 1));\\n        }\\n        h += ((double)dist[n-1]/speed);\\n        return hour >= h;\\n    }\\n\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if((int)hour < n-1) return -1;\\n        long long l = 1, r = INT_MAX;\\n\\n        int ans = -1;\\n        while(l <= r){\\n            long long m = l + (r-l)/2;\\n\\n            if(check(dist,hour,m) == true){\\n                ans = m;\\n                r = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& dist, double hour, int speed){\\n        double h = 0;\\n        int n = dist.size();\\n        for(int i=0; i<n-1; i++){\\n            int d = dist[i];\\n            h += (d/speed + (d%speed == 0 ? 0 : 1));\\n        }\\n        h += ((double)dist[n-1]/speed);\\n        return hour >= h;\\n    }\\n\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int n = dist.size();\\n        if((int)hour < n-1) return -1;\\n        long long l = 1, r = INT_MAX;\\n\\n        int ans = -1;\\n        while(l <= r){\\n            long long m = l + (r-l)/2;\\n\\n            if(check(dist,hour,m) == true){\\n                ans = m;\\n                r = m-1;\\n            }\\n            else l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817228,
                "title": "easy-c-solution-binary-search-on-answer",
                "content": "# Intuition\\nThe answer can be within a range so we will apply Binary Search on ANSWER.\\n\\n# Approach\\nInitialize low and high with minimum and maximum value which answer can be possible.\\n\\nNow Apply Simple Binary Search on ANSWER code and write the feasible condition.\\n\\nIn feasible condition we will take a variable time and calculate the total time taken for the speed which we calculated using mid.\\nReturn true if required time is <= hour.\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool feasible(int speed, vector<int>& nums, double hour){\\n        double time=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i==n-1){\\n                time+=(double)nums[i]/(double)speed;\\n            }\\n            else{\\n                double t;\\n                if(nums[i]%speed==0) t=nums[i]/speed;\\n                else t=1+(nums[i]/speed);\\n                time+=t;\\n            }\\n        }\\n\\n        return (time<=hour);\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int low=1;\\n        int high=1e8;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(feasible(mid, dist, hour)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool feasible(int speed, vector<int>& nums, double hour){\\n        double time=0;\\n        int n=nums.size();\\n        for(int i=0; i<n; i++){\\n            if(i==n-1){\\n                time+=(double)nums[i]/(double)speed;\\n            }\\n            else{\\n                double t;\\n                if(nums[i]%speed==0) t=nums[i]/speed;\\n                else t=1+(nums[i]/speed);\\n                time+=t;\\n            }\\n        }\\n\\n        return (time<=hour);\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int ans=-1;\\n        int low=1;\\n        int high=1e8;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(feasible(mid, dist, hour)){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817177,
                "title": "c-binary-search-easy-to-understand-medium-problem-1870-minimum-speed-to-arrive-on-time",
                "content": "# C++ | Binary Search | Easy to Understand | Medium Problem | 1870. Minimum Speed to Arrive on Time\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& arr, double hr, int mid){\\n        double time=0;\\n        for(int i=0;i<arr.size()-1;i++)\\n            time+=ceil((double)arr[i]/mid); //due to waiting we converted it into ceil\\n\\n        time+=((double)arr.back()/mid); // no train left so no witing time\\n        if(time<=hr) return true;\\n        return false;       \\n\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s=1;\\n        int e=1e7;\\n        int ans=-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(isPossible(dist,hour,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& arr, double hr, int mid){\\n        double time=0;\\n        for(int i=0;i<arr.size()-1;i++)\\n            time+=ceil((double)arr[i]/mid); //due to waiting we converted it into ceil\\n\\n        time+=((double)arr.back()/mid); // no train left so no witing time\\n        if(time<=hr) return true;\\n        return false;       \\n\\n    }\\n\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s=1;\\n        int e=1e7;\\n        int ans=-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            if(isPossible(dist,hour,mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else s=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817169,
                "title": "python-binary-search-easy-to-understand-medium-problem-1870-minimum-speed-to-arrive-on-time",
                "content": "# Python | Binary Search | Easy to Understand | Medium Problem | 1870. Minimum Speed to Arrive on Time\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        if hour <= n - 1:\\n            return -1\\n        \\n        lo = 1\\n        hi = max(dist) * 100\\n        while (lo < hi):\\n            speed = (lo + hi) // 2\\n            time = 0\\n            for i in range(n-1):\\n                time += math.ceil(dist[i] / speed)\\n            time += dist[-1] / speed\\n            if time <= hour:\\n                hi = speed\\n            else:\\n                lo = speed + 1\\n\\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        if hour <= n - 1:\\n            return -1\\n        \\n        lo = 1\\n        hi = max(dist) * 100\\n        while (lo < hi):\\n            speed = (lo + hi) // 2\\n            time = 0\\n            for i in range(n-1):\\n                time += math.ceil(dist[i] / speed)\\n            time += dist[-1] / speed\\n            if time <= hour:\\n                hi = speed\\n            else:\\n                lo = speed + 1\\n\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817163,
                "title": "easy-explanation-beginner-friendly-clean-code",
                "content": "# Intuition\\nWHEN WE HAVE QUESTIONS WHERE RANGE OF ANSWER IS FIXED{HERE SPEED}.\\nAND WE WANT MINIMUM OR MAXIMUM WITH CONDITION. AND THE CONSTRAINTS GENERALLY ARE ~1E5 . THEN WE CAN THINK OF APPLYING BINARY SEARCH ON ANSWERS.\\n\\n# Approach\\nspeed = dis / time\\ntime =dis/speed\\nwe are given distance , we want select min speed .\\nSuch that summation of all dis/(speed(selected)) is less than given variable hour \\nWe are catching train in integer hours till the last train . \\nWe can take double value of dis/(speed(selected))last train as per question .\\n\\n# Complexity\\n- Time complexity:\\nO(NLOG(1E10)) --> ~ O(N*(34)).\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(double mid,int n , vector<int>&dist,double hour){\\n        double total_time=0;\\n        for(int i=0;i<n-1;i++){\\n            total_time+=ceil(dist[i]/mid);\\n        }\\n        if(total_time>=hour)return 0;\\n        total_time+=(dist[n-1]/mid);\\n        return total_time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // binary search on speed . and speed will be integer given.\\n        int n=dist.size();\\n        long int low=1,high=1e10;\\n        while(low<=high){\\n            double mid=low+(high-low)/2;\\n            if(check(mid,n,dist,hour)){\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        bool final_check=check(low,n,dist,hour);\\n        if(!final_check)return -1;\\n        return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(double mid,int n , vector<int>&dist,double hour){\\n        double total_time=0;\\n        for(int i=0;i<n-1;i++){\\n            total_time+=ceil(dist[i]/mid);\\n        }\\n        if(total_time>=hour)return 0;\\n        total_time+=(dist[n-1]/mid);\\n        return total_time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        // binary search on speed . and speed will be integer given.\\n        int n=dist.size();\\n        long int low=1,high=1e10;\\n        while(low<=high){\\n            double mid=low+(high-low)/2;\\n            if(check(mid,n,dist,hour)){\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        bool final_check=check(low,n,dist,hour);\\n        if(!final_check)return -1;\\n        return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817090,
                "title": "java-4ms-100-binary-search-and-prefix-sums-speed-optimizations",
                "content": "The first code below is a prefix sum and binary search algorithm, which is from what was the fastest bar on the runtime graph.  The code was modified to run faster.  My slower original code is the second code sample, which runs in 18ms.\\n\\n**Algorithm**\\n\\n1. If only one train, then return easy calculation of speed for that train.\\n2. If required hours is more than the number of trains-1, then no solution so return -1.\\n3. Get the maximum distance for any train to travel (`maxDist`).\\n4. If the needed speed is greater than `maxDist`, then directly calculate the speed and return.\\n5. Calculate the count of trains at each distance.\\n6. Calculate the prefix sums of the count of trains at each distance.\\n7. Set binary search limits to 1..maxDist.\\n8. If `maxDist` is big, then try to optimize binary search limits by factors of 10.\\n9. Loop to do a binary search to test different proposed speed values (`mid` value in binary search) to find the lowest speed that arrives at the office at or before the required hours.\\n10. Return the result of the binary search, which is the slowest integer speed that is sufficient to get to the office in time.\\n\\n**Explanation of Algorithm step #4**\\n\\nBefore starting the binary search, check if the answer speed for this test case is greater than the maximum distance for any train to travel (`maxDist`).  If the answer speed will be `maxDist` or greater, then we can simply and directly calculate the actual speed required to get to work exactly on time WITHOUT a binary search.  If this calculated speed is greater than 10e7, then return -1 because the leetcode problem gives 10e7 as the maximum valid speed.  Otherwise return the calculated speed.  We can do this simple calculation for the speed because with a speed of `maxDist` or higher, the time between taking any two trains will always be between 0 and 1, rounded up to 1 hour.  The total time to get to work will therefore be the number of trains, except the last train, plus the distance of the last train, divided by the as yet unknown speed of the train:\\n\\n`timeToWork = (dist.length - 1) + dist[dist.length-1] / speed`\\n\\nSolving for speed will give:\\n\\n`speed = dist[dist.length-1] / (timeToWork - dist.length + 1)`\\n\\nThis will give the speed required to get to work exactly on time.  But because the problem requires returning an integer speed, do a ceiling on the calculated speed, minus a tiny value to handle floating-point calculation errors due to non-exact representation of a theoretical mathematical value into a floating-point double.\\n\\nIf useful, please upvote.\\n\\n**-------- From fastest code on runtime graph (July 29, 2023), then modified to run at 4ms --------**\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        final int last = dist.length - 1;\\n        if (dist.length == 1)  return (int)Math.ceil(dist[0] / hour - 0.00000005);\\n        if (hour <= last)  return -1;\\n\\n        int maxDist = 0;\\n        for (int i = 0; i < last; i++) \\n            maxDist = Math.max(maxDist, dist[i]);\\n\\n        if ((double)(last) + (double)dist[last] / maxDist > hour) {\\n            double speed = Math.ceil((double)dist[last] / (hour - last) - 0.000001);\\n            return (speed > 10_000_000) ? -1 : (int)speed;\\n        }\\n\\n        int[] sums = new int[maxDist + 1];\\n        for (int i = 0; i < last; i++)  sums[dist[i]]++;\\n        for (int i = 1; i <= maxDist; i++) sums[i] += sums[i - 1];\\n\\n        int left = 1;\\n        int right = maxDist;\\n        if (maxDist >= 1000) {\\n            while (left * 10 < right && !onTime(left * 10, dist, sums, hour, maxDist))  left *= 10;\\n            while (right / 10 > left && onTime(right / 10, dist, sums, hour, maxDist))  right /= 10;\\n        }\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (onTime(mid, dist, sums, hour, maxDist))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean onTime(int speed, int[] dist, int[] sums, double hour, int maxDist) {\\n        int curTime = sums[speed];\\n        int limit = (maxDist + speed - 1) / speed;\\n        for (int i = 2; i <= limit; i++) \\n            curTime += i * (sums[Math.min(maxDist, i * speed)] - sums[i * speed - speed]);\\n        return (double)curTime + (double)dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```\\n\\n\\n**-------- My original code that ran in 18ms --------**\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        if (dist.length == 1)  \\n            return (int)Math.ceil(dist[0] / hour - 0.00000005);\\n        if (Math.ceil(hour) < dist.length)  \\n            return -1;\\n        \\n        int maxDist = 1;\\n        for (int d : dist)  if (d > maxDist)  maxDist = d;\\n\\n        if (!onTime(dist, hour, maxDist, maxDist-1, maxDist)) {\\n            double speed = Math.ceil((double)dist[dist.length - 1] / (hour - dist.length + 1) - 0.000001);\\n            return (speed > 10_000_000) ? -1 : (int)speed;\\n        }\\n        \\n        int left = 1;\\n        int right = 10_000_000;\\n        if (onTime(dist, hour, 100, 100-1, maxDist)) {\\n            right = (onTime(dist, hour, 10, 10, maxDist)) ? 10 : 100;\\n        } else if (onTime(dist, hour, 10_000, 10_000-1, maxDist)) {\\n            right = (onTime(dist, hour, 1000, 1000-1, maxDist)) ? 1000 : 10_000;\\n        } else if (onTime(dist, hour, 1_000_000, 1_000_000-1, maxDist)) {\\n            right = (onTime(dist, hour, 100_000, 100_000-1, maxDist)) ? 100_000 : 1_000_000;\\n        } \\n        if (right > maxDist)  right = maxDist;\\n            \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (onTime(dist, hour, mid, mid - 1, maxDist))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    \\n    private boolean onTime(int[] dist, double hour, int speed, int speedM1, int maxDist) {\\n        int curTime = 0;\\n        if (speed >= maxDist)\\n            curTime = dist.length - 1;\\n        else {\\n            int limit = dist.length - 1;\\n            for (int i = 0; i < limit; i++) \\n                curTime += (dist[i] + speedM1) / speed;\\n        }\\n        return (double)curTime + (double)dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        final int last = dist.length - 1;\\n        if (dist.length == 1)  return (int)Math.ceil(dist[0] / hour - 0.00000005);\\n        if (hour <= last)  return -1;\\n\\n        int maxDist = 0;\\n        for (int i = 0; i < last; i++) \\n            maxDist = Math.max(maxDist, dist[i]);\\n\\n        if ((double)(last) + (double)dist[last] / maxDist > hour) {\\n            double speed = Math.ceil((double)dist[last] / (hour - last) - 0.000001);\\n            return (speed > 10_000_000) ? -1 : (int)speed;\\n        }\\n\\n        int[] sums = new int[maxDist + 1];\\n        for (int i = 0; i < last; i++)  sums[dist[i]]++;\\n        for (int i = 1; i <= maxDist; i++) sums[i] += sums[i - 1];\\n\\n        int left = 1;\\n        int right = maxDist;\\n        if (maxDist >= 1000) {\\n            while (left * 10 < right && !onTime(left * 10, dist, sums, hour, maxDist))  left *= 10;\\n            while (right / 10 > left && onTime(right / 10, dist, sums, hour, maxDist))  right /= 10;\\n        }\\n        \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (onTime(mid, dist, sums, hour, maxDist))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    private boolean onTime(int speed, int[] dist, int[] sums, double hour, int maxDist) {\\n        int curTime = sums[speed];\\n        int limit = (maxDist + speed - 1) / speed;\\n        for (int i = 2; i <= limit; i++) \\n            curTime += i * (sums[Math.min(maxDist, i * speed)] - sums[i * speed - speed]);\\n        return (double)curTime + (double)dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        if (dist.length == 1)  \\n            return (int)Math.ceil(dist[0] / hour - 0.00000005);\\n        if (Math.ceil(hour) < dist.length)  \\n            return -1;\\n        \\n        int maxDist = 1;\\n        for (int d : dist)  if (d > maxDist)  maxDist = d;\\n\\n        if (!onTime(dist, hour, maxDist, maxDist-1, maxDist)) {\\n            double speed = Math.ceil((double)dist[dist.length - 1] / (hour - dist.length + 1) - 0.000001);\\n            return (speed > 10_000_000) ? -1 : (int)speed;\\n        }\\n        \\n        int left = 1;\\n        int right = 10_000_000;\\n        if (onTime(dist, hour, 100, 100-1, maxDist)) {\\n            right = (onTime(dist, hour, 10, 10, maxDist)) ? 10 : 100;\\n        } else if (onTime(dist, hour, 10_000, 10_000-1, maxDist)) {\\n            right = (onTime(dist, hour, 1000, 1000-1, maxDist)) ? 1000 : 10_000;\\n        } else if (onTime(dist, hour, 1_000_000, 1_000_000-1, maxDist)) {\\n            right = (onTime(dist, hour, 100_000, 100_000-1, maxDist)) ? 100_000 : 1_000_000;\\n        } \\n        if (right > maxDist)  right = maxDist;\\n            \\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (onTime(dist, hour, mid, mid - 1, maxDist))\\n                right = mid - 1;\\n            else\\n                left = mid + 1;\\n        }\\n        return left;\\n    }\\n    \\n    \\n    private boolean onTime(int[] dist, double hour, int speed, int speedM1, int maxDist) {\\n        int curTime = 0;\\n        if (speed >= maxDist)\\n            curTime = dist.length - 1;\\n        else {\\n            int limit = dist.length - 1;\\n            for (int i = 0; i < limit; i++) \\n                curTime += (dist[i] + speedM1) / speed;\\n        }\\n        return (double)curTime + (double)dist[dist.length - 1] / speed <= hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817079,
                "title": "binary-search-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        i,j=1,10**7+1\\n        res=-1\\n        def check(mid):\\n            val=0\\n            for i in range(len(dist)-1):\\n                val+=ceil(dist[i]/mid)\\n            return val+(dist[-1]/mid)\\n        while i<j:\\n            mid=(i+j)//2\\n            ans=check(mid)\\n            # print(mid,ans,i,j)\\n            if ans<=hour:\\n                res=mid\\n                j=mid\\n            else:\\n                i=mid+1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        i,j=1,10**7+1\\n        res=-1\\n        def check(mid):\\n            val=0\\n            for i in range(len(dist)-1):\\n                val+=ceil(dist[i]/mid)\\n            return val+(dist[-1]/mid)\\n        while i<j:\\n            mid=(i+j)//2\\n            ans=check(mid)\\n            # print(mid,ans,i,j)\\n            if ans<=hour:\\n                res=mid\\n                j=mid\\n            else:\\n                i=mid+1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816954,
                "title": "concise-binary-search-c",
                "content": "```\\nclass Solution {\\n    bool good(double x, vector<int> dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n\\n        for(int i=0; i<n-1; i++) {\\n            double d = ceil((double)dist[i] / x);\\n            sum += d;\\n        }\\n\\n        return sum + dist.back() / x <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s = 0, e = 1e9, ans = -1;\\n        \\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, dist, hour)) {\\n                e = m - 1;\\n                ans = m;\\n            }\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    bool good(double x, vector<int> dist, double hour) {\\n        double sum = 0;\\n        int n = dist.size();\\n\\n        for(int i=0; i<n-1; i++) {\\n            double d = ceil((double)dist[i] / x);\\n            sum += d;\\n        }\\n\\n        return sum + dist.back() / x <= hour;\\n    }\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s = 0, e = 1e9, ans = -1;\\n        \\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, dist, hour)) {\\n                e = m - 1;\\n                ans = m;\\n            }\\n            else s = m + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816941,
                "title": "easy-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int celing(int a,int b){\\n        if(a%b==0)\\n        return a/b;\\n        return a/b+1;\\n    }\\n    double fun(int a,int b){\\n        double a1=a;\\n        double b1=b;\\n        return a1/b1;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left=0;\\n        int right=2e9;\\n        int ans=-1,n=dist.size();\\n        while(left<=right){\\n            int v=right+(left-right)/2;\\n            double time=0;\\n            if(v==0)\\n            return 1;\\n            for(int i=0;i<n-1;i++)\\n            time+=celing(dist[i],v);\\n            time+=fun(dist[n-1],v);\\n            if(time<=hour){\\n                ans=v;\\n                right=v-1;\\n            }\\n            else\\n            left=v+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int celing(int a,int b){\\n        if(a%b==0)\\n        return a/b;\\n        return a/b+1;\\n    }\\n    double fun(int a,int b){\\n        double a1=a;\\n        double b1=b;\\n        return a1/b1;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int left=0;\\n        int right=2e9;\\n        int ans=-1,n=dist.size();\\n        while(left<=right){\\n            int v=right+(left-right)/2;\\n            double time=0;\\n            if(v==0)\\n            return 1;\\n            for(int i=0;i<n-1;i++)\\n            time+=celing(dist[i],v);\\n            time+=fun(dist[n-1],v);\\n            if(time<=hour){\\n                ans=v;\\n                right=v-1;\\n            }\\n            else\\n            left=v+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816933,
                "title": "python-simple-bs-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n#### Search the boundary of valid arrival time.\\n\\n<hr />\\n\\n# Complexity\\n\\n#### Time: $$O(logN)$$\\n#### Space: $$O(1)$$\\n\\n<hr />\\n\\n# Code\\n```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        if n >= hour + 1: return -1\\n        lo, hi = 1,  max(max(dist), ceil(dist[-1] / (hour + 1 - n)))\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum([ceil(d / mid) for d in dist[:-1]]) + dist[-1] / mid <= hour:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        n = len(dist)\\n        if n >= hour + 1: return -1\\n        lo, hi = 1,  max(max(dist), ceil(dist[-1] / (hour + 1 - n)))\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if sum([ceil(d / mid) for d in dist[:-1]]) + dist[-1] / mid <= hour:\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        return hi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816929,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity: `O(n log m)` --> `m = 1e7`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        // length of input\\n        int n = dist.size();\\n\\n        // range of binary search\\n        int lo = 1 , hi = 1e7;\\n        int minSpeed = -1;\\n\\n        // binary search\\n        while(lo <= hi){\\n            \\n            // find mid or you can say current speed\\n            int mid = lo + (hi - lo) / 2;\\n            double currTime = 0;\\n\\n            for(int i=0;i<n-1;i++){\\n                \\n                // if any distance is not completely divisible current speed \\n                // then add one otherwise do nothing\\n                if(dist[i] % mid) currTime += (dist[i] / mid) + 1;\\n                else currTime += (dist[i] / mid);\\n\\n            }\\n\\n            // last element need exact division\\n            currTime += ((double)dist[n-1] / (double)mid);\\n\\n            // check for minimum speed and go for a valid answer\\n            if(currTime <= hour){\\n                minSpeed = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        // return minimum speed\\n        return minSpeed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        // length of input\\n        int n = dist.size();\\n\\n        // range of binary search\\n        int lo = 1 , hi = 1e7;\\n        int minSpeed = -1;\\n\\n        // binary search\\n        while(lo <= hi){\\n            \\n            // find mid or you can say current speed\\n            int mid = lo + (hi - lo) / 2;\\n            double currTime = 0;\\n\\n            for(int i=0;i<n-1;i++){\\n                \\n                // if any distance is not completely divisible current speed \\n                // then add one otherwise do nothing\\n                if(dist[i] % mid) currTime += (dist[i] / mid) + 1;\\n                else currTime += (dist[i] / mid);\\n\\n            }\\n\\n            // last element need exact division\\n            currTime += ((double)dist[n-1] / (double)mid);\\n\\n            // check for minimum speed and go for a valid answer\\n            if(currTime <= hour){\\n                minSpeed = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        // return minimum speed\\n        return minSpeed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816894,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        low=1\\n        high=10**7+1\\n        n=len(dist)\\n        while low<high:\\n            mid=(low+high)//2\\n            time=sum((dist[i]+mid-1)//mid for i in range(0,n-1))+dist[-1]/mid\\n            if time<=hour:\\n                high=mid\\n\\n            else:\\n                low=mid+1\\n\\n        return low if low <10**7+1 else-1            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        low=1\\n        high=10**7+1\\n        n=len(dist)\\n        while low<high:\\n            mid=(low+high)//2\\n            time=sum((dist[i]+mid-1)//mid for i in range(0,n-1))+dist[-1]/mid\\n            if time<=hour:\\n                high=mid\\n\\n            else:\\n                low=mid+1\\n\\n        return low if low <10**7+1 else-1            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816875,
                "title": "simple-and-easy-binary-search-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(speed)) // n max =10^5, and speed max=1e7;\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(int &mid, vector<int> &v, double &hour)\\n{\\n    int n=v.size();\\n    double total=0;\\n    bool flag=false;\\n    for(int i=0; i<n; ++i)\\n    {\\n        if(total!=int(total))\\n        total=int(total)+1;\\n        if(total>hour) return false;\\n        total+=double(v[i])/double(mid);\\n        \\n    }\\n    if(total>hour) return false;\\n    return true;\\n}\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int st=1, end=1e7;\\n        int ans=-1;\\n        int mid;\\n        while(st<=end)\\n        {\\n            mid=st+(end-st)/2;\\n            if(check(mid, dist, hour)) \\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(int &mid, vector<int> &v, double &hour)\\n{\\n    int n=v.size();\\n    double total=0;\\n    bool flag=false;\\n    for(int i=0; i<n; ++i)\\n    {\\n        if(total!=int(total))\\n        total=int(total)+1;\\n        if(total>hour) return false;\\n        total+=double(v[i])/double(mid);\\n        \\n    }\\n    if(total>hour) return false;\\n    return true;\\n}\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int st=1, end=1e7;\\n        int ans=-1;\\n        int mid;\\n        while(st<=end)\\n        {\\n            mid=st+(end-st)/2;\\n            if(check(mid, dist, hour)) \\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }else st=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816857,
                "title": "short-crisp-c-binary-search-o-n-log-1e7",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>&dist,double hour)\\n    {\\n        double h_sum=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            double k=(double)dist[i]/mid;\\n            h_sum= h_sum + ceil(k);\\n        }\\n        h_sum+=(double)(dist[dist.size()-1])/mid;\\n        \\n        return h_sum<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int i=1;\\n        int j=1e7;\\n        int ans=-1;\\n        int mid;\\n        while(i<=j)\\n        {\\n            mid=(i+j)/2;\\n            if(check(mid,dist,hour))\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIF YOU LIKED MY SOLUTION PLS UPVOTE !!!",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>&dist,double hour)\\n    {\\n        double h_sum=0;\\n        for(int i=0;i<dist.size()-1;i++)\\n        {\\n            double k=(double)dist[i]/mid;\\n            h_sum= h_sum + ceil(k);\\n        }\\n        h_sum+=(double)(dist[dist.size()-1])/mid;\\n        \\n        return h_sum<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int i=1;\\n        int j=1e7;\\n        int ans=-1;\\n        int mid;\\n        while(i<=j)\\n        {\\n            mid=(i+j)/2;\\n            if(check(mid,dist,hour))\\n            {\\n                ans=mid;\\n                j=mid-1;\\n            }\\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480569,
                "title": "c-did-just-as-mentioned-in-the-question-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int speed,vector<int>& dist, double hour )\\n    {\\n        \\n        double s = speed;\\n        double time =0;\\n        for(int it: dist)\\n        {\\n            time = ceil(time);\\n            double d = it;\\n            double t = d/s;\\n            time+=t;\\n        }\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int l =0, h = 1e7;\\n        int mid;\\n        int n = dist.size();\\n        if(n-1 >=hour)\\n            return -1;\\n        int ans =0;\\n        while(l<=h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(isvalid(mid,dist,hour))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int speed,vector<int>& dist, double hour )\\n    {\\n        \\n        double s = speed;\\n        double time =0;\\n        for(int it: dist)\\n        {\\n            time = ceil(time);\\n            double d = it;\\n            double t = d/s;\\n            time+=t;\\n        }\\n        return time<=hour;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        \\n        int l =0, h = 1e7;\\n        int mid;\\n        int n = dist.size();\\n        if(n-1 >=hour)\\n            return -1;\\n        int ans =0;\\n        while(l<=h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(isvalid(mid,dist,hour))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305043,
                "title": "binary-search-easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N LOGN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double compare(vector<int>& dist,int mid, double hour){\\n        double h = 0 ;\\n        for(int i = 0 ; i<dist.size();i++){\\n              if ( i == dist.size()-1 ){\\n                  h += ((double)dist[i]/mid);    \\n              }\\n              else {\\n                  h+= (dist[i] + (mid - 1))/mid;\\n              }\\n        }\\n        return h;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s = 1;\\n        int e = 10000000;\\n        int ans = -1; \\n       while(s<=e){\\n           int mid = s + (e - s)/2;\\n            if(compare(dist,mid,hour )<=hour){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else  s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double compare(vector<int>& dist,int mid, double hour){\\n        double h = 0 ;\\n        for(int i = 0 ; i<dist.size();i++){\\n              if ( i == dist.size()-1 ){\\n                  h += ((double)dist[i]/mid);    \\n              }\\n              else {\\n                  h+= (dist[i] + (mid - 1))/mid;\\n              }\\n        }\\n        return h;\\n    }\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s = 1;\\n        int e = 10000000;\\n        int ans = -1; \\n       while(s<=e){\\n           int mid = s + (e - s)/2;\\n            if(compare(dist,mid,hour )<=hour){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else  s = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273355,
                "title": "java-solution-using-binary-search",
                "content": "# code\\n```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int min = 1, max = 10000000;\\n        int ans = -1;\\n        while(min <= max){\\n            int mid = (max + min)/2;\\n            double sum = 0;\\n            for(int i = 0; i<n-1; ++i){\\n                sum += Math.ceil( ( (double) dist[i]) /mid);\\n            }\\n            sum = sum + ( ( (double) dist[n-1]) /mid);\\n            if(sum > hour){\\n                min = mid+1;\\n            }else{\\n                ans = mid;\\n                max = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int n = dist.length;\\n        int min = 1, max = 10000000;\\n        int ans = -1;\\n        while(min <= max){\\n            int mid = (max + min)/2;\\n            double sum = 0;\\n            for(int i = 0; i<n-1; ++i){\\n                sum += Math.ceil( ( (double) dist[i]) /mid);\\n            }\\n            sum = sum + ( ( (double) dist[n-1]) /mid);\\n            if(sum > hour){\\n                min = mid+1;\\n            }else{\\n                ans = mid;\\n                max = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271485,
                "title": "range-bs-very-easy-to-understand",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        \\n        //we know that (distance = speed * time)\\n        //we know that (time = distance / speed)\\n        long long int ans = INT_MAX;\\n\\n        long long int start = 0;\\n        long long int end = INT_MAX;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n\\n            \\n            bool flag = get_time(arr,mid,hour);\\n            \\n            \\n            if(flag == true)\\n            {\\n                if(mid < ans) ans = mid;\\n                end = mid-1;\\n            }\\n            else if(flag == false)\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n    bool get_time(vector<int>&arr,long long int &mid,double hour)\\n    {\\n         if(mid == 0)\\n         return false;\\n\\n         double time = 0;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if(i < (arr.size()-1))\\n             {\\n                int temp = ceil(((arr[i]*1.00)/(mid)));\\n                time += temp;\\n             }\\n             else if(i == (arr.size()-1))\\n             {\\n                 double temp = (((arr[i]*1.00)/(mid)));\\n                 time += temp;\\n             }\\n         }     \\n         if(time <= hour) return true;\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        \\n        //we know that (distance = speed * time)\\n        //we know that (time = distance / speed)\\n        long long int ans = INT_MAX;\\n\\n        long long int start = 0;\\n        long long int end = INT_MAX;\\n\\n        while(start <= end)\\n        {\\n            long long int mid = (start + ((end - start)/2));\\n\\n            \\n            bool flag = get_time(arr,mid,hour);\\n            \\n            \\n            if(flag == true)\\n            {\\n                if(mid < ans) ans = mid;\\n                end = mid-1;\\n            }\\n            else if(flag == false)\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return ans;\\n    }\\n    bool get_time(vector<int>&arr,long long int &mid,double hour)\\n    {\\n         if(mid == 0)\\n         return false;\\n\\n         double time = 0;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             if(i < (arr.size()-1))\\n             {\\n                int temp = ceil(((arr[i]*1.00)/(mid)));\\n                time += temp;\\n             }\\n             else if(i == (arr.size()-1))\\n             {\\n                 double temp = (((arr[i]*1.00)/(mid)));\\n                 time += temp;\\n             }\\n         }     \\n         if(time <= hour) return true;\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3271477,
                "title": "easy-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        //minimum speed=1\\n        //maximum speed=1e7\\n        int start=1;\\n        int end=1e7;\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(dist,hour,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,double &hour,int &mid)\\n    {\\n        double time=0;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            time=time+ceil(arr[i]/(mid*1.00));\\n        }\\n        time=time+(arr[arr.size()-1]/(mid*1.00));\\n        if(time<=hour) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        //minimum speed=1\\n        //maximum speed=1e7\\n        int start=1;\\n        int end=1e7;\\n        int mid;\\n        int ans=INT_MAX;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if(fun(dist,hour,mid)==true)\\n            {\\n                ans=min(ans,mid);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        if(ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n    bool fun(vector<int>&arr,double &hour,int &mid)\\n    {\\n        double time=0;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            time=time+ceil(arr[i]/(mid*1.00));\\n        }\\n        time=time+(arr[arr.size()-1]/(mid*1.00));\\n        if(time<=hour) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156635,
                "title": "python-short-clean-bisect",
                "content": "# Code\\n```\\nfrom bisect import bisect_left\\nfrom math import ceil\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        a, b = dist[:-1], dist[-1]\\n        if len(dist) - 1 >= hour:\\n            return -1\\n\\n        def time(speed):\\n            return sum(ceil(i / speed) for i in a) + b / speed\\n\\n        return bisect_left(range(1, 10**7 + 1), -hour, key=lambda a: -time(a)) + 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\nfrom math import ceil\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        a, b = dist[:-1], dist[-1]\\n        if len(dist) - 1 >= hour:\\n            return -1\\n\\n        def time(speed):\\n            return sum(ceil(i / speed) for i in a) + b / speed\\n\\n        return bisect_left(range(1, 10**7 + 1), -hour, key=lambda a: -time(a)) + 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101139,
                "title": "binary-search-on-answers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(1e7)).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s=1,e=1e7;\\n        int ans=-1;\\n        int n=dist.size();\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            double hr=0;\\n            for(int i=0;i<n;i++){\\n                if(i<n-1)\\n                hr+=ceil((double)dist[i]/m);\\n                else hr+=((double)dist[i]/m);\\n            }\\n            if(hr<=hour){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else s=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int s=1,e=1e7;\\n        int ans=-1;\\n        int n=dist.size();\\n        while(s<=e){\\n            int m=s+(e-s)/2;\\n            double hr=0;\\n            for(int i=0;i<n;i++){\\n                if(i<n-1)\\n                hr+=ceil((double)dist[i]/m);\\n                else hr+=((double)dist[i]/m);\\n            }\\n            if(hr<=hour){\\n                ans=m;\\n                e=m-1;\\n            }\\n            else s=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031051,
                "title": "binary-search-c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        var n = dist.Length;\\n        var res = Int32.MaxValue;\\n\\n        var left = 1;\\n        var right = 10000000;\\n\\n        while (left <= right) {\\n            var speed = left + (right - left) / 2;\\n\\n            double totalTime = 0;\\n            for (var i = 0; i < n - 1; i++) {\\n                var d = dist[i];\\n                totalTime += (d / speed) + (d % speed > 0 ? 1 : 0);\\n            }\\n\\n            totalTime += ((double)dist[n - 1]) / ((double)speed);\\n\\n            if (totalTime - hour > 0) {\\n                left = speed + 1;\\n            } else {\\n                res = Math.Min(res, speed);\\n                right = speed - 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSpeedOnTime(int[] dist, double hour) {\\n        var n = dist.Length;\\n        var res = Int32.MaxValue;\\n\\n        var left = 1;\\n        var right = 10000000;\\n\\n        while (left <= right) {\\n            var speed = left + (right - left) / 2;\\n\\n            double totalTime = 0;\\n            for (var i = 0; i < n - 1; i++) {\\n                var d = dist[i];\\n                totalTime += (d / speed) + (d % speed > 0 ? 1 : 0);\\n            }\\n\\n            totalTime += ((double)dist[n - 1]) / ((double)speed);\\n\\n            if (totalTime - hour > 0) {\\n                left = speed + 1;\\n            } else {\\n                res = Math.Min(res, speed);\\n                right = speed - 1;\\n            }\\n        }\\n\\n        return res == Int32.MaxValue ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939507,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if(hour<=dist.size()-1){return -1;}\\n        int i=1, j=1e7;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            double cnt=0;\\n            for(int k=0; k<dist.size()-1; k++){\\n                cnt+=dist[k]/mid+(dist[k]%mid!=0);\\n            }\\n            //cout<<cnt<<\" \"<<mid<<endl;\\n            if(((double)dist[dist.size()-1]/mid)+cnt>hour){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        if(hour<=dist.size()-1){return -1;}\\n        int i=1, j=1e7;\\n        while(i<=j){\\n            int mid=i+(j-i)/2;\\n            double cnt=0;\\n            for(int k=0; k<dist.size()-1; k++){\\n                cnt+=dist[k]/mid+(dist[k]%mid!=0);\\n            }\\n            //cout<<cnt<<\" \"<<mid<<endl;\\n            if(((double)dist[dist.size()-1]/mid)+cnt>hour){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2824895,
                "title": "java-simple-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public boolean possible(int[] dist, double hour, int speed) {\\n        double time = 0d;\\n        for(int i=0;i<dist.length-1;i++) {\\n            time += (double)dist[i]/speed;\\n            time = Math.ceil(time);\\n        }\\n        time += (double)dist[dist.length-1]/speed;\\n        return time <= hour;\\n    }\\n    \\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = 1000000005;\\n        int ans = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            if(possible(dist, hour, mid)) {\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else\\n                left = mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possible(int[] dist, double hour, int speed) {\\n        double time = 0d;\\n        for(int i=0;i<dist.length-1;i++) {\\n            time += (double)dist[i]/speed;\\n            time = Math.ceil(time);\\n        }\\n        time += (double)dist[dist.length-1]/speed;\\n        return time <= hour;\\n    }\\n    \\n    public int minSpeedOnTime(int[] dist, double hour) {\\n        int left = 1;\\n        int right = 1000000005;\\n        int ans = -1;\\n        while(left<=right) {\\n            int mid = left + (right-left)/2;\\n            if(possible(dist, hour, mid)) {\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else\\n                left = mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766282,
                "title": "python-easy-to-read-and-understand-binary-search",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def timetaken(self, dist, speed, k):\\n        time = 0\\n        for i in dist[:-1]:\\n            time += math.ceil(i/speed)\\n        time += dist[-1]/speed\\n        return time\\n    \\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        res = -1\\n        lo, hi = 1, 10**7\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            time = self.timetaken(dist, mid, hour)\\n            #print(time, mid)\\n            if time <= hour:\\n                res = mid\\n                hi = mid-1\\n            elif time > hour:\\n                lo = mid+1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def timetaken(self, dist, speed, k):\\n        time = 0\\n        for i in dist[:-1]:\\n            time += math.ceil(i/speed)\\n        time += dist[-1]/speed\\n        return time\\n    \\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        res = -1\\n        lo, hi = 1, 10**7\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            time = self.timetaken(dist, mid, hour)\\n            #print(time, mid)\\n            if time <= hour:\\n                res = mid\\n                hi = mid-1\\n            elif time > hour:\\n                lo = mid+1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2723424,
                "title": "c-o-n-log-n-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &arr, double hour, int k){\\n        double cnt = 0;\\n        for(int i = 0;i<arr.size()-1;i++){\\n            cnt += ceil((double)arr[i] / (double)k);\\n        }\\n        cnt += (double)arr[arr.size()-1] / (double)k;\\n        return cnt <= hour;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        int l = 1, h = 10000000;\\n        int ans = -1;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if(check(arr, hour, mid)){\\n                ans = mid;\\n                h  = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```\\n If you like the solution please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &arr, double hour, int k){\\n        double cnt = 0;\\n        for(int i = 0;i<arr.size()-1;i++){\\n            cnt += ceil((double)arr[i] / (double)k);\\n        }\\n        cnt += (double)arr[arr.size()-1] / (double)k;\\n        return cnt <= hour;\\n    }\\n    \\n    int minSpeedOnTime(vector<int>& arr, double hour) {\\n        int l = 1, h = 10000000;\\n        int ans = -1;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if(check(arr, hour, mid)){\\n                ans = mid;\\n                h  = mid - 1;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t/* If you like the solution please upvote */\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708418,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\n bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n bool canReachInTime(const vector<int>& dist, const double hour, int speed)\\n    {\\n        double time = 0;\\n        for (int i = 0; i < dist.size() - 1; ++i)\\n            time += ((dist[i] + speed - 1) / speed);\\n        \\n        time += ((double)dist.back()) / speed;\\n        return time <= hour;\\n    }\\n    \\npublic:\\n    int minSpeedOnTime(vector<int>& dist, double hour)\\n    {\\n        int N = dist.size();\\n        if (hour <= (double)(N - 1))\\n            return -1;\\n        \\n        int lo = 1, hi = 1e7, mi;\\n        while (lo < hi)\\n        {\\n            mi = (lo + hi) / 2;\\n            if (canReachInTime(dist, hour, mi))\\n                hi = mi;\\n            else\\n                lo = mi + 1;\\n        }\\n        \\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406380,
                "title": "c-binary-search-short-and-concise",
                "content": "If we can complete the journey in speed S then we can also complete the journey in speed S+1 which inspires for a binary search solution, after adding the journey time we convert the time to next integer to catch the next train (unless its the last train)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &dist, double hour, int speed) {\\n        double t=0;\\n        for(int i=0; i<dist.size(); i++) {\\n            int d = dist[i];\\n            t+=(d*1.0/speed*1.0);\\n            if(t!=int(t) and i!=dist.size()-1) t=ceil(t);\\n        }\\n        return t <= hour; \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int lo=1, hi=1e7, ans=1e9;\\n        while(lo <= hi) {\\n            int mid = (lo+hi)>>1;\\n            if(check(dist,hour,mid)) ans=min(ans,mid),hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return ans < 1e9 ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &dist, double hour, int speed) {\\n        double t=0;\\n        for(int i=0; i<dist.size(); i++) {\\n            int d = dist[i];\\n            t+=(d*1.0/speed*1.0);\\n            if(t!=int(t) and i!=dist.size()-1) t=ceil(t);\\n        }\\n        return t <= hour; \\n    }\\n    \\n    int minSpeedOnTime(vector<int>& dist, double hour) {\\n        int lo=1, hi=1e7, ans=1e9;\\n        while(lo <= hi) {\\n            int mid = (lo+hi)>>1;\\n            if(check(dist,hour,mid)) ans=min(ans,mid),hi=mid-1;\\n            else lo=mid+1;\\n        }\\n        return ans < 1e9 ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1815333,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986535,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986490,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1739929,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986841,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986502,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986563,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986559,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986543,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986889,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1815333,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986535,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986490,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1739929,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986841,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986502,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986563,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986559,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986543,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986889,
                "content": [
                    {
                        "username": "sleepingonee",
                        "content": "Interesting testcase:\\ndist = [1,1,100000]\\nhour = 2.01\\nExpected 10000000\\n\\nI definately need 10000000 km/hour train to get to work on time."
                    },
                    {
                        "username": "JetHsu",
                        "content": "This test case is incorrect."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@zhibin-wang09](/zhibin-wang09) shouldn\\'t it be max value * max value of n? = 10**10\\uD83D\\uDE05"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "I think divide an conquor on speed works like first check if speed = 10^7 is possible if not speed/=2 till its fesiable to get the lower bound then upper to lower bound iterate and return the min speed using greedy what do you say!! ."
                    },
                    {
                        "username": "sayanpatel",
                        "content": "so what should be the max value for the search space if not 10**5?"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "my code has returned 9999999"
                    },
                    {
                        "username": "govinda_P",
                        "content": "\\uD83D\\uDE02 "
                    },
                    {
                        "username": "aDDyy",
                        "content": "[@zhibin-wang09](/zhibin-wang09) same i was also going till 1e5(MAX searchSpace) initially but soon realised after my tc failed at dist = [1,1,100000]\nhour = 2.01 🙂"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": " I also failed at this test case but it wasn't because of rounding error. I initially had the search space max range to be the max value in input dist[i] but I realized that it had to be the maximum constraint of dist[i] which is 10^7."
                    },
                    {
                        "username": "Tuyixiang",
                        "content": "And we all notice this testcase because of rounding error. "
                    },
                    {
                        "username": "a_andreasian",
                        "content": "bad description"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Wouldn\\'t be able to solve it under 10 minutes 2 months back. feelsgoodman"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) aah that happens, then you got it quick asw. For upper and lower values I just yeet anything coz it\\'s O(logN) even r=10^9 won\\'t amount to much (Obviously take care of mid to not overflow). "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@kiryu_0](/kiryu_0) I realized immediately that this was a binary search problem. One thing that slowed me down was determining the upper value. I originally treated ``distSize-1 < hour < distSize`` as an edge case but getting the last digit in the calculations correct proved difficult."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@lolloo](/lolloo) Well, haven\\'t done this problem before. But my comment was more so on the fact that 2 months back, I wouldn\\'t even recognize the pattern let alone solve it under 10 mins. Consistency can do wonders ;)"
                    },
                    {
                        "username": "lolloo",
                        "content": "God, your comment confuses me more than any hard problems. You said 2 month back it takes you more times to solve it. Now it took under 10 mins, but is it because you improved or because you already did this problem? your description is even worse than the question."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "[@kiryu_0](/kiryu_0) yeah even I thought of binary search but only the implementation taking me time looks like need more practice."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "[@psionl0](/psionl0) lmao, think I got lucky since binary search clicked very quickly to me looking at this problem :P \\nfyi to sharpen your sense regarding this topic https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template"
                    },
                    {
                        "username": "bishalkundu17",
                        "content": "[@psionl0](/psionl0) its ok. after practicing more and more maybe after few months you will also solve this under 10 mins."
                    },
                    {
                        "username": "psionl0",
                        "content": "Way to harsh my buzz man. I was feeling good about being able to solve this problem without looking up a hint but it still took me a lot longer than 10 minutes."
                    },
                    {
                        "username": "Adinapunyo",
                        "content": "The trick here is to understand the final station scenario. We don\\'t need to compute the ceiling time for the final station!"
                    },
                    {
                        "username": "little_late",
                        "content": "bruhhhh!!!!!"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "Should we take relativistic effects into consideration?"
                    },
                    {
                        "username": "CodeArmy",
                        "content": "Look dawg I am a perfectionist so i prefer to get my answer correct to atleast 100 decimal places. That\\'s why i have added a \\nv-v0/Math.sqrt(1-(v2/c2)) factor in my predicate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Good question. The most extreme need for speed is the test case [1,1,100000], 2.01 which required the 3rd train to go 10,000,000 km/h or 2,778 km/s. This is considerably less than the speed of light (300,000 km/s) so while relativity might add a couple of decimal places of accuracy, we can survive without it."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is an interesting question like Koko eating bananas! One needs defining a function for time  to need!\n# 875. Koko Eating Bananas\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**To commute to the office**, `LOL if u live in bangalore or gurgaon, no logic makes sense in their evening traffic`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "not a good description"
                    },
                    {
                        "username": "aitachii",
                        "content": "For example 3: dist = [1,3,2], hour = 1.9\nThe reason it is impossible is because you need at least 2 hours to ride the first 2 trains.\n# TL;DR: Each train ride, except for the last, takes at least 1 hour, including travel time and waiting time for the next train.\n\n\nFor example, you have a speed of 5.\nThe first train should take 1/5 = 0.2 hours, then you'll have to wait (1 - 0.2) = 0.8 hours to take the second train since each train can only depart at an integer hour(eg. hour 1, hour 2, hour 5, but not hour 0.2). For a total of 0.2 riding time + 0.8 waiting time = 1 hour (Or just ceil(0.2) = 1 hour).\nThe second train should take 3/5 = 0.6 hours, then you'll have to wait 0.4 hours to take the third train. For a total of 0.4 train time + 0.6 wait time = 1 hour.\nThe time it takes for the first two trains is already 2 hours which is greater than 1.9 hours, taking the third train would add an additional 2/5 = 0.4 hours. There is no waiting time since this is the last train.\nIn total: you would spend 1 + 1 + 0.4 = 2.4 hours for all the three trains.\n\nEven with a faster speed(e.g. 1e7) taking the three trains would still take 1 + 1 + 0.0000001 = 2.0000001 hours > 1.9 hours."
                    },
                    {
                        "username": "mohitkalshan",
                        "content": "bhai kehna kya chahte ho?  bad description"
                    }
                ]
            },
            {
                "id": 1986636,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987150,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987729,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1986632,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1986572,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1986561,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1997901,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987913,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987693,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987388,
                "content": [
                    {
                        "username": "webguru77777",
                        "content": "Failed on these two cases:\\n\\n```\\n[1, 1, 100000]\\n2.01\\n```\\n\\n```\\n[1, 1]\\n1.0\\n```\\n\\n"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@shivam_singh098](/shivam_singh098) So return -1"
                    },
                    {
                        "username": "shivam_singh098",
                        "content": "for 2nd : hour < dist.size() -> one train takes atleast 1 hour. so  1 + 1  =  2 hours at least to complete the journey but given was 1.0."
                    },
                    {
                        "username": "samDeopa",
                        "content": "check the range you bs on , put it from 1 to 10000000"
                    },
                    {
                        "username": "psionl0",
                        "content": "Make sure that you set the upper limit to 10^7."
                    },
                    {
                        "username": "danielmascena",
                        "content": "The description of the problem is not good at all"
                    },
                    {
                        "username": "dleyba042",
                        "content": "I think understanding the description is enough of a challenge."
                    },
                    {
                        "username": "samDeopa",
                        "content": "P.S. dont try to round off the double or float to 2 decimal places.\\n"
                    },
                    {
                        "username": "breathermachine",
                        "content": "Things to look out for when optimizing:\\n1. Use multiplication than division. Pass in the reciprocal of the speed and multiply it with the distance to compute the time.\\n2. Make the speed computation function take the time cap as a parameter and return early if the provided speed is too slow.\\n```\\nboolean onTime(int[] dists, double speedInv, double cap) // Returns true if the trip can be done onTime with the given reciprocal of the speed\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@breathermachine](/breathermachine) Just for completeness, this is my version of the time taken function:\n```\ndouble timeTaken(int *dist, int distSize, int speed) {\n    int i, t;\n    double totalTime = 0.0;\n    for (i = 0; i < distSize-1; ++i) {\n        t = dist[i] / speed;\n        if (dist[i] % speed != 0) {\n            ++t;\n        }\n        totalTime += (double) t;\n    }\n    return totalTime + (double) dist[distSize-1] / (double) speed;\n}\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "[@psionl0](/psionl0) Good catch!\\nI reworked the function like this\\n\\n```    \\nboolean onTime(int[] dists, int speed, double cap) {\\n        int time = 0;\\n        for (int i = 0; i < dists.length - 1; ++i) {\\n            time += dists[i] / speed;\\n            if (dists[i] % speed != 0) {\\n                time++;\\n            }\\n            if (time > cap) {\\n                return false;\\n            }\\n        }\\n        return time + (double)dists[dists.length - 1] / speed <= cap;\\n    }\\n```\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t understand the first requirement. ``speed`` is a non-zero integer and the times for the first n-1 stations are also integers. You just need to round up if ``speed`` is not a factor of ``dist[i]``. It is only when summing the times taken and computing the time taken for the last station that these numbers need to be cast into doubles."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "binary search days going on"
                    },
                    {
                        "username": "githubdudu",
                        "content": "My javacript code just give me this:\\n `9/50 + 1 = 1.1800000000000002 `.\\nSo the test case dist= [1,9], hour= 1.18, I get wrong answer 51."
                    },
                    {
                        "username": "tifv",
                        "content": "Such problems are usually solved by fuzzy comparisons. One can introduce a constant like `EPS = 1e-12`, and replace comparisons like `time <= target` with `time <= target + EPS`."
                    },
                    {
                        "username": "danlavrushko",
                        "content": "hmm, for some reason I can't reproduce this error, you can refer to this submission https://leetcode.com/problems/minimum-speed-to-arrive-on-time/submissions/1010872805/"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@githubdudu](/githubdudu) this is due to Floating point math, check out this post on SO https://stackoverflow.com/q/588004/2120382.\n\nAccording to description, \"hour will have at most two digits after the decimal point\". So as a workaround,  you can try multiple `dist` and `hour` by 100 and solve with integer values"
                    },
                    {
                        "username": "z3eg",
                        "content": "*cries in Java*"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n- Initialize low as 1 and high as a large value (e.g., 10^7). These represent the lower and upper bounds for the possible speeds.\\n- Perform binary search until low becomes greater than high.\\n- Inside the binary search loop, calculate the mid speed as the middle value between low and high.\\n- Calculate the total time required to complete the journey at speed mid using a loop through the dist array. For each distance i, calculate the time taken as i / mid. Sum up all these times.\\n- Compare the total time with the given hour.\\n- If the total time is greater than hour, it means the speed is too slow to complete the journey in the given time. Therefore, update low to mid + 1.\\n- If the total time is less than or equal to hour, it means the speed is sufficient to complete the journey in the given time. However, we want to minimize the speed, so update high to mid.\\n- After the binary search, the low value will represent the minimum speed required to complete the journey on time."
                    },
                    {
                        "username": "layyy",
                        "content": "ceil is not required for the last station"
                    }
                ]
            },
            {
                "id": 1987139,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1986983,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1986549,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1994342,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987972,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987916,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987900,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987805,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987802,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987774,
                "content": [
                    {
                        "username": "dheeraj2002_",
                        "content": "The edge cases in this question really took a toll over me, but I am happy to complete the challenge without looking at the solution. I used Binary Search by maintaining an `upperBound` and `lowerBound`. What approach did you all use?"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "I don't understand the second example.\n```\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\n```\n1. You have to wait until 2.0 to depart, so at 2.0 you get on the train with distance 1.\n2. Regardless of the speed of the train, the train with distance 3 can depart at 1.0 **at the earliest**\n3. By the time you are at the platform waiting for train 2 the time you have left is a decimal between 0 and 1. Thus you can never get on the third train.\n\nBy that logic it's impossible and the answer is -1.\n\nWhat am I misunderstanding here?"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "Initially Hour is 0 lets say u got on the first train i.e dist[0] for this train with it would take you 1 hour if your speed is >=1, After that with speed >=3 it would take you 1 hour to travel 3 unit distance regardless if you reach early and after that it would take you 0.66 if you travel with speed 3 adding the time we get 2.66 which is less than 3,\\nHope it is clearly written and easy to understand"
                    },
                    {
                        "username": "0p3r4t0r",
                        "content": "Is `hour` here being used to represent **both** the current hour as well as the time you have left?"
                    },
                    {
                        "username": "Thomaswang0822",
                        "content": "For case 63, hour = 59999.18\\nUsing C++, cout << hour gives 59999.2\\nWhy is that?"
                    },
                    {
                        "username": "moodyman",
                        "content": "Who comes up with such ridiculous TCs like 58th one with the huge array????? Even my IDE can\\'t run it and says \"code too large\""
                    },
                    {
                        "username": "tanishchugh01",
                        "content": "You can take the ceil as 100 times the maximum of dist, as we are given the precision can be upto 2 decimal points.\\n\\nIf  \\n`hour = 2.01`\\n`dist = [1,1,100]`\\nYou will require at most 100*100= 10000 speed at max"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Tips if your binary search is not working properly:\nKeep in mind that, when your `estimatedHours > hour` ,  our speed is in the low range. So, we should modify our left pointer. \nOn the other hand, if the **estimatedHours is less than or equal to hour**, we have very high speed. So, need to decrease the right side."
                    },
                    {
                        "username": "YuqiWen",
                        "content": "for testcase dist=[69], hour=4.6\nwhy double sum=15, int l=ceil(sum) return 16, can anyone explain"
                    },
                    {
                        "username": "cc2002",
                        "content": "This seems very similar to [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/). The main difference appears to be that since the time constraint, `hour`, is a float, you need to add the true elapsed time (not the ceiling) of the final train ride to the total journey duration in order to account for testcases where the time constraint has decimals."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "this is a nasty one it should be Hard"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "I return INT_MIN cause I am unemployed  \\uD83D\\uDE42"
                    }
                ]
            },
            {
                "id": 1987765,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987691,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987590,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987437,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987396,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987387,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987379,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987368,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987218,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987189,
                "content": [
                    {
                        "username": "nevatianuj11",
                        "content": "when i am using double instead of float my code running fine but if i use float , its giving error for a test case.\ncan anyone explain why??                                         \nError Test Case is\n   [1,1,100000]\n   2.01\n\nC++ CODE ---->\n\nclass Solution {\npublic:\n\n    double timeR(vector<int>& dist, double speed){\n        double sum = 0;\n        for(int i=0; i<dist.size()-1; i++)\n        {\n            sum += ceil(dist[i]/speed);\n        }\n        sum += (dist[dist.size()-1]/speed);\n        return sum;\n}\n    \n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        int low = 1;\n        int high = 1e7;\n        int ans = -1;\n\n        while(low <= high){\n            double mid = low + (high-low)/2;\n            double timeReq = timeR(dist, mid);\n            if(timeReq <= hour){\n                ans = mid;\n                high = mid-1;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Optimization is using divide an conquor aka binary search but for me it took less to figure out but taking more time to implement that code part."
                    },
                    {
                        "username": "samorV",
                        "content": "I set the BS left bound to\\n`int left = (int) Math.ceil(totalDistance / hour);`\\nwhich seemed solid until it got hit with 69/4.6 and returned 16...\\nGotta love them floating points"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Welcome to 12th board. Prepare for `JEE Advanced`. \nDo you remember `s = u*t`"
                    },
                    {
                        "username": "Ultron03",
                        "content": "I am facing a problem in a testcase ,in which it shows TLE when i submit the code for that testcase but when i simply run the same code it is giving me correct ans..\\n\\nSomeone please explain!!!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "try divide an conqueor approch"
                    },
                    {
                        "username": "tifv",
                        "content": "It may happen that the test case would not cause TLE by itself, but when ran together with other test cases the execution time adds up, exceeding the limit."
                    },
                    {
                        "username": "PModhe_09",
                        "content": "why right limit should be 1e7 ? not 1e5 ?"
                    },
                    {
                        "username": "tifv",
                        "content": "Consider the test case `dist = [1,1,100000]`, `hour = 2.01`."
                    },
                    {
                        "username": "vinnie17",
                        "content": "how to know if      l < r Or l <= r  ??"
                    },
                    {
                        "username": "Aqdas_Ali",
                        "content": "l<r if u use low=mid+1 & high=mid .... l<=r  for low=mid+1 & high=mid-1"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "This is a good follow-up to Koko"
                    },
                    {
                        "username": "sarthakkharabanda",
                        "content": "even just a month ago, i would have taken some good time to figure this out. but i figured out the logic for it almost instantly(except where to put my high at because of TLE). feels so good :')\ni guess i have been practicing binary search lately that's why"
                    },
                    {
                        "username": "paradoxtown",
                        "content": "TL;DR"
                    }
                ]
            },
            {
                "id": 1987124,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986991,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986989,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986914,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986878,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986877,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986871,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986869,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986851,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986837,
                "content": [
                    {
                        "username": "deCodeIt",
                        "content": "If you can find the upper bound on the speed of train ( M km / hour ) then given that the min speed is 1 km / hour, all you need to do is a binary search between 1 to M to get a min speed value such that you reach the destination.\\n\\nNote that the `There will be at most two digits after the decimal point in hour` is a big hint while calculating the upper bound."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "If I want to find the ceil of \"dist[i] / speed\", is \"(dist[i] + speed - 1) / speed\" faster than \"Math.ceil(dist[i] / speed)\" ? Thanks"
                    },
                    {
                        "username": "atr3us_112",
                        "content": "AAARGHHHHH......the double precision error !!!!!\\nanyway solved it "
                    },
                    {
                        "username": "khe1154",
                        "content": "the description could be improved"
                    },
                    {
                        "username": "Vucius",
                        "content": "Below is my code:\n```\n# your code goes here\n# @param {Integer[]} dist\n# @param {Float} hour\n# @return {Integer}\n\n# return the cost of time\ndef return_time_cost(dist, speed)\n\tans = 0.0\n\tdist[0...-1].each do |e|\n\t\tans += (e * 1.0 / speed).ceil\n\tend\n\tans += dist.last * 1.0 / speed\n\tp ans\n\tans\nend\ndef min_speed_on_time(dist, hour)\n\treturn -1 if dist.length - 1 >= hour\n    dl, dr = 0.0, 0.0\n    dist.each do |e|\n    \tdl += ((e * 1.0) / hour)\n    \tdr += ((e * 1.0) / (hour - dist.length + 1))\n    end\n    left, right = [dl, 10_000_000].min.floor, [dr, 10_000_000].min.ceil\n    mid = 0\n    while left <= right\n    \tmid = left + (right - left) / 2\n\t\t\tp \"left #{left} right #{right} mid #{mid}\"\n    \tdr = return_time_cost(dist, mid)\n    \tif dr == hour\n    \t\treturn mid\n    \telsif dr < hour\n    \t\tright = mid - 1\n    \telse\n    \t\tleft = mid + 1\n    \tend\n\t\t\tp \"left #{left} right #{right}  \"\n    end\n    left\nend\n```\nI noticed that in the example below, it will fall into a divide by 0 error(FloatDomainError). But in fact, this should not happen.:\n```\ndist = [2,1,5,4,4,3,2,9,2,10]\nhour = 75.12\n```\nAccording to this Stdout, it can be noticed that `left` suddenly becomes 0. This is a very strange thing. When I tested it on www.ideone.com, this error did not occur.\nStdout:\n```\n\"left 1 right 2 mid 1\"\n6.0\n\"left 2 right 9 mid 5\"\n2.4\n\"left 2 right 4  \"\n\"left 2 right 4 mid 3\"\n2.6666666666666665\n\"left 2 right 2  \"\n\"left 2 right 2 mid 2\"\n4.0\n\"left 3 right 2  \"\n\"left 0 right 1 mid 0\"\n```"
                    },
                    {
                        "username": "Vucius",
                        "content": "After investigation, I have found the issue: In C++, dividing by 0 will result in infinity. However, in Ruby, dividing by 0 will result in `FloatDomainError`."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Its pretty easy. just keep low as 1 and high as 10^7 and there you go!"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "can somebody explain to me ?\\n"
                    },
                    {
                        "username": "pyush98",
                        "content": "You can just use the right boundary constraint as the right boundary for your search. But it is faster to calculate the EXACT rightmost boundary yourself"
                    },
                    {
                        "username": "ajit_2828",
                        "content": " instead of float use Double"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Use double instead of float, otherwise you will get rounding error."
                    },
                    {
                        "username": "psionl0",
                        "content": "Does anybody ever use float when they could use double instead?"
                    }
                ]
            },
            {
                "id": 1986826,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986814,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986810,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986784,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986776,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986772,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986739,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986700,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986647,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            },
            {
                "id": 1986610,
                "content": [
                    {
                        "username": "oops_moment",
                        "content": "When encountering this problem, think of applying the binary search technique, similar to the \"Koko Eats Bananas\" problem. Here, we perform binary search on the speed to efficiently determine the minimum speed required to reach the destination on time. Depending on the time taken at a particular speed, we adjust the search space by increasing or decreasing the speed accordingly. This approach allows us to quickly converge to the optimal solution.\n\nALSO: FOR THE LAST STATION DON'T USE CEIL, think why? (because you don't need to wait for next train anymore XD)"
                    },
                    {
                        "username": "sanskar01",
                        "content": "Koko Travelling"
                    },
                    {
                        "username": "Veetish_07",
                        "content": "Search space ->\\nlow speed=1;\\nhigh speed =(sum of distance of the array) /(min time);\\nmin time will be 0.01 hour (as per the question hour is only up to two digit decimal places)->> high speed =sum*100;\\ntake low and high as long long "
                    },
                    {
                        "username": "bruh_",
                        "content": "Can someone pls help me in understanding the upper limit of speed? "
                    },
                    {
                        "username": "bruh_",
                        "content": "Damn, overlooked that statement \nThank you [@Dan Lavrushko](/danlavrushko)"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "according to problem description, \"answer will not exceed $10^7$\""
                    },
                    {
                        "username": "vacherkasskiy",
                        "content": "Quess binary search week begins"
                    },
                    {
                        "username": "psionl0",
                        "content": "Every time somebody says that the topic changes the next day."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Kinda a fun one. Took me about 30 minutes."
                    },
                    {
                        "username": "nitishah",
                        "content": "I dont understand this description specifically for the given sample below\\nInput: dist = [1,3,2], hour = 1.9\\nOutput: -1\\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\\n\\nif the above example result is -1 then why for below example it is not -1\\ndist =\\n[1,1,100000]\\nhour =\\n2.01\\n\\nCan someone please guide. I am new to this."
                    },
                    {
                        "username": "psionl0",
                        "content": "The earliest the third train can depart is also at the 2 hour mark which is less than 2.01 hours. Of course, you have only 0.01 hours left to cover the remaining 100000 km."
                    },
                    {
                        "username": "webguru77777",
                        "content": "Time to travel by i-th train is `Math.ceil(dist[i] / speed)`\\nEdge case is the last train will take `dist[i] / speed` because you don\\'t need to wait for the next one."
                    },
                    {
                        "username": "psionl0",
                        "content": "\"There will be at most two digits after the decimal point in ``hour``.\"\\n\\nNow THERE is an irrelevant piece of information. When stored as a double, there is still likely to be a round-off in spite of the limited number of decimal places unless the decimal part can be expressed as a fraction where the denominator is a power of 2."
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "my approach for defining the right bound, `right  = max(max(dist), ceil(dist[-1] / (hour - n + 1))) ` does left need to be 1 or is there some way to restrict it? "
                    },
                    {
                        "username": "psionl0",
                        "content": "Since ``1 <= hour <= 10^9`` just use those numbers as your bounds. Since you are doing a binary search, a way too big number will only add a few steps to the search process."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@webguru77777](/webguru77777) My solution:\\n```right=1+max(*max_element(dist.begin(), dist.end()), int(dist[n-1]/(hour-n+1)));```"
                    },
                    {
                        "username": "webguru77777",
                        "content": "left is 1 yes. but i wonder if right is correct. my right definition: `hi = int(math.Ceil(float64(hi) / (hour - math.Floor(hour))))`, if `math.Floor(hour) != hour`"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "If I need a speed=10000000km/h to commute to office, am I a fool to care the accuracy for two digits after the decimal point??????..."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@psionl0](/psionl0) If I have that speed, I guess I will contribute to aerospace field, instead of a programmer.:p"
                    },
                    {
                        "username": "psionl0",
                        "content": "If your job is programmer then I guess that you will have to care very much about those 2 digits."
                    }
                ]
            }
        ]
    }
]