[
    {
        "title": "Simplify Path",
        "question_content": "Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\nIn a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\nThe canonical path should have the following format:\n\n\tThe path starts with a single slash '/'.\n\tAny two directories are separated by a single slash '/'.\n\tThe path does not end with a trailing '/'.\n\tThe path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\n\nReturn the simplified canonical path.\n&nbsp;\nExample 1:\n\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.\n\nExample 2:\n\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\nExample 3:\n\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n\n&nbsp;\nConstraints:\n\n\t1 <= path.length <= 3000\n\tpath consists of English letters, digits, period '.', slash '/' or '_'.\n\tpath is a valid absolute Unix path.",
        "solutions": [
            {
                "id": 1847357,
                "title": "c-easy-stack-simple-explained-algorithm",
                "content": "# 71. Simplify Path\\n**KNOCKCAT**\\n\\nPlease ALso have a look to my Leetcode Repository Link Given Below :)\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](https://github.com/knockcat/Leetcode)     **LINK TO LEETCODE REPOSITORY**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n``` ```\\n\\n**EXPLANATION**\\n* Create a **Stack of String** with following condition.\\n\\t* **Iterate the loop till you doesn\\'t reaches the end of string.**\\n\\t* If you **encounter a  \"/\" then ignore it.**\\n\\t* **Create a temp String** & **Iterate the while loop** till you **doesn\\'t find  \"/\"** and **append it to temp**.\\n\\t* Now check if **temp  == \".\"** , t**hen ignore it**.\\n\\t* If **temp == \"..\"** then **pop the element from the stack if it exists.**\\n\\t* If **no of the above 2 matches** **push temp to stack** as you find a valid path.\\n\\t* **Check out temp** string on **basis of above conditions till you doesn\\'t find \"/\".**\\n* \\tNow **add all stack elements** to result as **res = \"/\" + st.top() + res**\\n* \\tIf **res.size() is 0** then **return \"/\"**  if no directory or file is present.\\n* \\tAt last **return res**.\\n\\n```\\nInput: path = \"/../\"\\nOutput: \"/\"\\nInput: path = \"/home//foo/\"\\nOutput: \"/home/foo\"\\n```\\n\\n**ALGORITHM**\\n* By looking at examples we can see that the above **simplification process** just **behaves like a stack**.\\n* **Whenever we encounter any file\\u2019s name**, **we simply push it into the stack**.\\n* when we come across **\\u201D . \\u201D** **we do nothing**\\n* When **we find \\u201C..\\u201D** in our path, **we simply pop the topmost element** as we **have to jump back to parent\\u2019s directory.**\\n* When we **see multiple \\u201C////\\u201D** we **just ignore them** as **they are equivalent to one single \\u201C/\\u201D.** \\n* After **iterating through the whole string** the **elements remaining in the stack** is our **simplified absolute path.**\\n\\n\\n``` ```\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack<string> st;\\n        string res;\\n        \\n        for(int i = 0;  i<path.size(); ++i)\\n        {\\n            if(path[i] == \\'/\\')    \\n                continue;\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last /\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n\\t\\t\\t\\t// add path to temp string\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\")\\n                continue;\\n\\t\\t\\t// pop the top element from stack if exists\\n            else if(temp == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n        \\n\\t\\t// adding all the stack elements to res\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        \\n\\t\\t// if no directory or file is present\\n        if(res.size() == 0)\\n            return \"/\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Problem with Initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\nInput: path = \"/../\"\\nOutput: \"/\"\\nInput: path = \"/home//foo/\"\\nOutput: \"/home/foo\"\\n```\n``` ```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack<string> st;\\n        string res;\\n        \\n        for(int i = 0;  i<path.size(); ++i)\\n        {\\n            if(path[i] == \\'/\\')    \\n                continue;\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last /\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n\\t\\t\\t\\t// add path to temp string\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\")\\n                continue;\\n\\t\\t\\t// pop the top element from stack if exists\\n            else if(temp == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n        \\n\\t\\t// adding all the stack elements to res\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        \\n\\t\\t// if no directory or file is present\\n        if(res.size() == 0)\\n            return \"/\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847526,
                "title": "best-explanation-ever-possible-not-a-clickbait",
                "content": "How\\'s going Ladies - n - GentleMen, today we are going to solve another coolest problem i.e. **Simplify Path**\\n\\nAlright, so let\\'s understand this problem with an example :-\\n\\n**Input:** `path = \"/a/./b/../../c/\"`\\n**Output:** `\"/c\"`\\n\\nLet\\'s understand what this mean\\'s, so basically this seems like you a path of your folder, so generically we use this kind of command\\'s in terminal. I hope u know a bit about that. Anyway\\'s let\\'s move further on.\\n\\n* okay, so the first command `/a/` means get into the folder `/a/`\\n\\n\\n* The next command is `/./` means stay over there\\n* The next command is `/b/` means get into the folder `/b/`\\n* The next command is `/../` means come out from the folder `/b/`\\n* The next command is `/../` means come out from the folder `/a/`\\n* Now we are kind of in home directory\\n* The next command is `/c/` means get into the folder `/c/`\\n* And in the output we return what command we left with.\\n\\nLet\\'s understand it a bit visually.\\n* Going to **`/a/./b/`**\\n![image](https://assets.leetcode.com/users/images/fda0afe4-f04d-4ab4-a5e8-950859e88a94_1647224192.301499.png)\\n* Coming out **`/../../`**\\n![image](https://assets.leetcode.com/users/images/d4a78ce7-b5a1-40c6-bf09-39270dd86a90_1647224302.6337845.png)\\n* Going to **`/c/`**\\n![image](https://assets.leetcode.com/users/images/1490e3dd-f3be-4b22-bcc9-0518f99ad38c_1647224553.681243.png)\\n\\nSo, basically what are we doing:-\\n**Pushing** and **Popping** directory names based on rules\\n\\nAnd what are the rules :-\\n1. **/..** come out from the directory\\n2. **/nameOfDirectory** going into directory\\n\\nNow you say, Dude that\\'s A-OK but which Data Structure do we use to solve this problem. Well. i had already gives you a hint if you remember **Pushing** and **Popping**. So where do we Generically used in `Stack` or `Queue`\\n\\nWe\\'ll solve this problem using Stack. But if you want the solution of `Queue` as well, **do lemmino (:**\\n\\nAlright, back to the problem - So, what we can do is by looking at the rules, split the directrory by the slash`/` given and that will give us in the form of array e.g :- **`[a, ., b, .., .., c]`**\\n\\nLet\\'s understand it\\'s working visually:-\\n\\n![image](https://assets.leetcode.com/users/images/2a40a0e0-3a9d-4e4a-bdf6-19f3aada5bea_1647225944.7493086.gif)\\n\\nBut remeber when returning we have to go in the form of reverse order. Because Stack use **LIFO** order and the highest one will comes out. But we need the lowest once first. So, we need to append in the carefull manner.\\n\\n*I hope ladies and gentlemen approach is clear* **Let\\'s code it up**\\n\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** O(N)\\n\\n* **Space Complexity :-** O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25686,
                "title": "java-10-lines-solution-with-stack",
                "content": "Hi guys!\\n\\nThe main idea is to push to the stack every valid file name (not in {\"\",\".\",\"..\"}), popping only if there's smth to pop and we met \"..\". I don't feel like the code below needs any additional comments.\\n\\n    public String simplifyPath(String path) {\\n        Deque<String> stack = new LinkedList<>();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\\n        for (String dir : path.split(\"/\")) {\\n            if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!skip.contains(dir)) stack.push(dir);\\n        }\\n        String res = \"\";\\n        for (String dir : stack) res = \"/\" + dir + res;\\n        return res.isEmpty() ? \"/\" : res;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nThe main idea is to push to the stack every valid file name (not in {\"\",\".\",\"..\"}), popping only if there's smth to pop and we met \"..\". I don't feel like the code below needs any additional comments.\\n\\n    public String simplifyPath(String path) {\\n        Deque<String> stack = new LinkedList<>();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\\n        for (String dir : path.split(\"/\")) {\\n            if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!skip.contains(dir)) stack.push(dir);\\n        }\\n        String res = \"\";\\n        for (String dir : stack) res = \"/\" + dir + res;\\n        return res.isEmpty() ? \"/\" : res;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 25680,
                "title": "c-10-lines-solution",
                "content": "C++ also have  *getline* which acts like Java's *split*. I guess the code can comment itself.\\n\\n    string simplifyPath(string path) {\\n        string res, tmp;\\n        vector<string> stk;\\n        stringstream ss(path);\\n        while(getline(ss,tmp,'/')) {\\n            if (tmp == \"\" or tmp == \".\") continue;\\n            if (tmp == \"..\" and !stk.empty()) stk.pop_back();\\n            else if (tmp != \"..\") stk.push_back(tmp);\\n        }\\n        for(auto str : stk) res += \"/\"+str;\\n        return res.empty() ? \"/\" : res;\\n    }",
                "solutionTags": [],
                "code": "C++ also have  *getline* which acts like Java's *split*. I guess the code can comment itself.\\n\\n    string simplifyPath(string path) {\\n        string res, tmp;\\n        vector<string> stk;\\n        stringstream ss(path);\\n        while(getline(ss,tmp,'/')) {\\n            if (tmp == \"\" or tmp == \".\") continue;\\n            if (tmp == \"..\" and !stk.empty()) stk.pop_back();\\n            else if (tmp != \"..\") stk.push_back(tmp);\\n        }\\n        for(auto str : stk) res += \"/\"+str;\\n        return res.empty() ? \"/\" : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1050573,
                "title": "python-short-stack-solution-explained",
                "content": "When you see this problem, you should think about stack. Why? Because we have directories and you can go deeper or come back and when you come back, you basically forgot about all element after and stack is ideal simulation of this process. Also in python you can use `.split(\"/\")` function, which will split our string into parts, separated by `/` symbol.\\n\\nSo, the algorithm will look like this:\\n1. If stack is not empty and we meet `..` element, it means, that we need to go one level up, so we just pop element from stack and forgot about it.\\n2. If we have any other element except several cases, we put it to the end of stack. So, what cases we need to avoid: if we meet `.`, it means current directory according to problem description, so we do not need to go deeper; if we meet `..`, and it means that stack is empty, so we already at the top of our path, so we againd do nothing in this case. Finally, we can meet empty string also, it corresponds to case, when we have `//`, then there is empty string between two `/`.\\n3. In the end we reconstruct string from all element, using `/` to join them.\\n\\n**Complexity**: time complexity is `O(n)`, because we only traverse our path once. Space complexity is `O(n)`, because there can be potentially `O(n)` elements inside.\\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path):\\n        stack = []\\n        for elem in path.split(\"/\"):\\n            if stack and elem == \"..\":\\n                stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path):\\n        stack = []\\n        for elem in path.split(\"/\"):\\n            if stack and elem == \"..\":\\n                stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25691,
                "title": "9-lines-of-python-code",
                "content": "    class Solution(object):\\n        def simplifyPath(self, path):\\n            places = [p for p in path.split(\"/\") if p!=\".\" and p!=\"\"]\\n            stack = []\\n            for p in places:\\n                if p == \"..\":\\n                    if len(stack) > 0:\\n                        stack.pop()\\n                else:\\n                    stack.append(p)\\n            return \"/\" + \"/\".join(stack)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def simplifyPath(self, path):\\n            places = [p for p in path.split(\"/\") if p!=\".\" and p!=\"\"]\\n            stack = []\\n            for p in places:\\n                if p == \"..\":\\n                    if len(stack) > 0:\\n                        stack.pop()\\n                else:\\n                    stack.append(p)\\n            return \"/\" + \"/\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 25778,
                "title": "java-easy-to-understand-stack-solution",
                "content": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (int i = 0; i < p.length; i++) {\\n            if (!stack.empty() && p[i].equals(\"..\"))\\n                stack.pop();\\n            else if (!p[i].equals(\".\") && !p[i].equals(\"\") && !p[i].equals(\"..\"))\\n                stack.push(p[i]);\\n        }\\n        List<String> list = new ArrayList(stack);\\n        return \"/\"+String.join(\"/\", list);\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (int i = 0; i < p.length; i++) {\\n            if (!stack.empty() && p[i].equals(\"..\"))\\n                stack.pop();\\n            else if (!p[i].equals(\".\") && !p[i].equals(\"\") && !p[i].equals(\"..\"))\\n                stack.push(p[i]);\\n        }\\n        List<String> list = new ArrayList(stack);\\n        return \"/\"+String.join(\"/\", list);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3407361,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires to convert a given absolute path to a simplified canonical path. The simplified canonical path should have the following format:\\n- The path starts with a single slash \\'/\\'.\\n\\n- Any two directories are separated by a single slash \\'/\\'.\\n\\n- The path does not end with a trailing \\'/\\'.\\n\\n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \\'.\\' or double period \\'..\\').\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be solved using a stack to keep track of the directories in the path. We split the input path by slash \\'/\\', iterate over the directories, and perform the following operations:\\n\\n- Ignore the current directory \\'.\\' and empty directories.\\n- Go one level up for double period \\'..\\' by popping the top element from the stack if it is not empty.\\n- For any other directory, push it to the stack.\\n- Finally, we join the directories in the stack with slash \\'/\\' and add a slash at the beginning to form the simplified canonical path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is $$O(n)$$, where n is the length of the input path. This is because we iterate over each directory in the path only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity of the algorithm is $$O(n)$$ where n is the length of\\n\\n \\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>(); // create a stack to keep track of directories\\n        String[] directories = path.split(\"/\"); // split the path by slash \\'/\\'\\n        for (String dir : directories) { // iterate over the directories\\n            if (dir.equals(\".\") || dir.isEmpty()) { // ignore the current directory \\'.\\' and empty directories\\n                continue;\\n            } else if (dir.equals(\"..\")) { // go one level up for double period \\'..\\'\\n                if (!stack.isEmpty()) { // if stack is not empty, pop the top element\\n                    stack.pop();\\n                }\\n            } else { // for any other directory, push it to the stack\\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); // join the directories in the stack with slash \\'/\\' and add a slash at the beginning\\n    }\\n}\\n```\\n```JavaScript []\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const stack = [];\\n    const directories = path.split(\"/\");\\n    for (const dir of directories) {\\n        if (dir === \".\" || !dir) {\\n            continue;\\n        } else if (dir === \"..\") {\\n            if (stack.length > 0) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push(dir);\\n        }\\n    }\\n    return \"/\" + stack.join(\"/\");\\n};\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (dir.empty() || dir == \".\") {\\n                continue;\\n            } else if (dir == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(dir);\\n            }\\n        }\\n        string res;\\n        while (!s.empty()) {\\n            res = \"/\" + s.top() + res;\\n            s.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>(); // create a stack to keep track of directories\\n        String[] directories = path.split(\"/\"); // split the path by slash \\'/\\'\\n        for (String dir : directories) { // iterate over the directories\\n            if (dir.equals(\".\") || dir.isEmpty()) { // ignore the current directory \\'.\\' and empty directories\\n                continue;\\n            } else if (dir.equals(\"..\")) { // go one level up for double period \\'..\\'\\n                if (!stack.isEmpty()) { // if stack is not empty, pop the top element\\n                    stack.pop();\\n                }\\n            } else { // for any other directory, push it to the stack\\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); // join the directories in the stack with slash \\'/\\' and add a slash at the beginning\\n    }\\n}\\n```\n```JavaScript []\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const stack = [];\\n    const directories = path.split(\"/\");\\n    for (const dir of directories) {\\n        if (dir === \".\" || !dir) {\\n            continue;\\n        } else if (dir === \"..\") {\\n            if (stack.length > 0) {\\n                stack.pop();\\n            }\\n        } else {\\n            stack.push(dir);\\n        }\\n    }\\n    return \"/\" + stack.join(\"/\");\\n};\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (dir.empty() || dir == \".\") {\\n                continue;\\n            } else if (dir == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(dir);\\n            }\\n        }\\n        string res;\\n        while (!s.empty()) {\\n            res = \"/\" + s.top() + res;\\n            s.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406788,
                "title": "image-explanation-simple-easy-concise-stack-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Simplify Path` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/0dcce590-ae89-40a6-81b8-727f896098a7_1681264846.7869709.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/6c0be3d7-dea4-44ec-a4a8-2dccaaa8620b_1681261958.6440732.png)\\n![image.png](https://assets.leetcode.com/users/images/02bb1515-d70c-42dc-973a-fc331bd0a580_1681261967.111279.png)\\n![image.png](https://assets.leetcode.com/users/images/d3e91201-18f5-4795-8b3a-867b24b72210_1681261976.8542857.png)\\n![image.png](https://assets.leetcode.com/users/images/323ca517-6e1b-4add-bc63-31eef7febcf1_1681261985.6800873.png)\\n![image.png](https://assets.leetcode.com/users/images/33c5dffa-174b-448b-a205-cdce9b775339_1681261994.3601491.png)\\n![image.png](https://assets.leetcode.com/users/images/18a44cdd-62af-447a-a754-13d4e7ec1d6a_1681262007.9926193.png)\\n![image.png](https://assets.leetcode.com/users/images/f39db0ae-1a00-4d22-a9e9-434dd10ee4df_1681262020.5986128.png)\\n![image.png](https://assets.leetcode.com/users/images/a1639cf9-ff51-4139-a191-29b7b8f18834_1681262026.56356.png)\\n![image.png](https://assets.leetcode.com/users/images/8016c9ad-edc6-48ae-ae80-2ebfbdd28597_1681262033.6350305.png)\\n![image.png](https://assets.leetcode.com/users/images/e74fbc13-897d-4397-b6ae-90fdc991544a_1681262039.6172855.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dirOrFiles;\\n        stringstream ss(path);\\n        string dirOrFile;\\n        while (getline(ss, dirOrFile, \\'/\\')) {\\n            if (!dirOrFiles.empty() && dirOrFile == \"..\") {\\n                dirOrFiles.pop_back();\\n            } else if (dirOrFile != \".\" && dirOrFile != \"\" && dirOrFile != \"..\") {\\n                dirOrFiles.push_back(dirOrFile);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dirOrFile : dirOrFiles) {\\n            simplified_path += \"/\" + dirOrFile;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dirOrFiles = new ArrayDeque<>();\\n        for (String dirOrFile : path.split(\"/\")) {\\n            if (!dirOrFiles.isEmpty() && dirOrFile.equals(\"..\")) {\\n                dirOrFiles.removeLast();\\n            } else if (!dirOrFile.equals(\".\") && !dirOrFile.equals(\"\") && !dirOrFile.equals(\"..\")) {\\n                dirOrFiles.addLast(dirOrFile);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dirOrFile : dirOrFiles) {\\n            simplified_path.append(\"/\").append(dirOrFile);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dirOrFiles = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dirOrFiles and elem == \"..\":\\n                dirOrFiles.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dirOrFiles.append(elem)\\n                \\n        return \"/\" + \"/\".join(dirOrFiles)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dirOrFiles;\\n        stringstream ss(path);\\n        string dirOrFile;\\n        while (getline(ss, dirOrFile, \\'/\\')) {\\n            if (!dirOrFiles.empty() && dirOrFile == \"..\") {\\n                dirOrFiles.pop_back();\\n            } else if (dirOrFile != \".\" && dirOrFile != \"\" && dirOrFile != \"..\") {\\n                dirOrFiles.push_back(dirOrFile);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dirOrFile : dirOrFiles) {\\n            simplified_path += \"/\" + dirOrFile;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dirOrFiles = new ArrayDeque<>();\\n        for (String dirOrFile : path.split(\"/\")) {\\n            if (!dirOrFiles.isEmpty() && dirOrFile.equals(\"..\")) {\\n                dirOrFiles.removeLast();\\n            } else if (!dirOrFile.equals(\".\") && !dirOrFile.equals(\"\") && !dirOrFile.equals(\"..\")) {\\n                dirOrFiles.addLast(dirOrFile);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dirOrFile : dirOrFiles) {\\n            simplified_path.append(\"/\").append(dirOrFile);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dirOrFiles = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dirOrFiles and elem == \"..\":\\n                dirOrFiles.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dirOrFiles.append(elem)\\n                \\n        return \"/\" + \"/\".join(dirOrFiles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050620,
                "title": "c-stack-o-n-0ms-beats-100-easy-explanation",
                "content": "**EXPLANATION** (Idea is pretty simple)\\n- First make sure the given *path* **starts and ends** with ```\\'/\\'``` if **not** so then **append** a ```\\'/\\'``` at the end of *path*.\\n- Create a **stack of string**.\\n- Initialize **ans** string to ```\"\"``` and start iterating the *path* string from **\\'1\\' index as path[0] will always be ```\\'/\\'```**.\\n- Create a **temp** variable which will keep **substrings** upto ```\\'/\\'```, after that it will be checked with some conditions and then reset it back to ```\"\"```. \\n- In each iteration check whether **```path[i] == \\'/\\'```**, if **true** then check our **temp string** on the basis of below conditions (according to question ) :\\n\\t- If ```temp==\"\" || temp==\".\"``` then **ignore.**\\n\\t- If ```temp==\"..\"``` then **pop the top element from stack if it exists**.\\n\\t- If ```non of above matches``` then **push temp to stack**. \\nAfter checking the above conditions, **reset temp to ```\"\"```**\\n- Finally, after the above loop ends, **pop all the elements of the stack and store it in ans** with a ```\\'/\\'``` in front, shown as follows : ```ans=\"/\"+s.top()+ans```.\\n - Return **ans**\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int n=path.length();\\n        stack<string>s;\\n                \\n        if(path[n-1]!=\\'/\\') // so that initially path always ends with \\'/\\'\\n            path+=\"/\", ++n;\\n            \\n        int i=1; // since path always starts from \\'/\\'\\n        string ans=\"\";\\n        string temp=\"\";\\n        while(i<n){\\n            \\n            if(path[i]==\\'/\\'){ // check only if we encounter \\'/\\'\\n                \\n                if(temp==\"\" || temp==\".\"){\\n                    // ignore\\n                }\\n                else if(temp==\"..\"){\\n                    if(!s.empty()) s.pop(); // pop the top element from stack if exists\\n                }\\n                else{\\n                    s.push(temp); //push the directory or file name to stack\\n                }\\n                \\n                temp=\"\"; // reset temp\\n            }\\n            else{\\n                temp.push_back(path[i]); // else append to temp\\n            }\\n            \\n            ++i; // increment index\\n        }\\n        \\n        while(!s.empty()){ // add all the stack elements\\n            ans=\"/\"+s.top()+ans;\\n            s.pop();\\n        }\\n        \\n        if(ans.length()==0) // if no directory or file is present\\n            ans=\"/\"; // minimum root directory must be present in ans\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**NOTE**\\nBecause of ```ans=\"/\"+s.top()+ans``` , the time complexity will be **O(n^2)**, but it can be further optimized to **O(n) amotized time-complexity** by reversing the stack using another stack and then then appending it to the end of the same memory of the *ans* string, ```ans+=reversed_stack.top()+\"/\"``` as shown below :\\n```\\nans=\"/\";\\n\\nstack<string>reversed_stack;\\n\\nif(s.empty()){\\n    return ans;\\n}\\n\\nwhile(!s.empty()){ // reverse the stack elements\\n    reversed_stack.push(s.top());\\n    s.pop();\\n}\\n\\nwhile(!reversed_stack.empty()){\\n    ans+=reversed_stack.top()+\"/\";\\n    reversed_stack.pop();\\n}\\n\\nreturn ans.substr(0,ans.length()-1);\\n```\\n\\n\\n**TIME COMPLEXITY**\\nO(n) [ Because of the iterating the path string once ]\\n\\n**SPACE COMPLEXITY**\\nO(n+n) [ Because of the above two stacks ]",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\'/\\'```\n```\\'/\\'```\n```\"\"```\n```\\'/\\'```\n```\\'/\\'```\n```\"\"```\n```path[i] == \\'/\\'```\n```temp==\"\" || temp==\".\"```\n```temp==\"..\"```\n```non of above matches```\n```\"\"```\n```\\'/\\'```\n```ans=\"/\"+s.top()+ans```\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int n=path.length();\\n        stack<string>s;\\n                \\n        if(path[n-1]!=\\'/\\') // so that initially path always ends with \\'/\\'\\n            path+=\"/\", ++n;\\n            \\n        int i=1; // since path always starts from \\'/\\'\\n        string ans=\"\";\\n        string temp=\"\";\\n        while(i<n){\\n            \\n            if(path[i]==\\'/\\'){ // check only if we encounter \\'/\\'\\n                \\n                if(temp==\"\" || temp==\".\"){\\n                    // ignore\\n                }\\n                else if(temp==\"..\"){\\n                    if(!s.empty()) s.pop(); // pop the top element from stack if exists\\n                }\\n                else{\\n                    s.push(temp); //push the directory or file name to stack\\n                }\\n                \\n                temp=\"\"; // reset temp\\n            }\\n            else{\\n                temp.push_back(path[i]); // else append to temp\\n            }\\n            \\n            ++i; // increment index\\n        }\\n        \\n        while(!s.empty()){ // add all the stack elements\\n            ans=\"/\"+s.top()+ans;\\n            s.pop();\\n        }\\n        \\n        if(ans.length()==0) // if no directory or file is present\\n            ans=\"/\"; // minimum root directory must be present in ans\\n        \\n        return ans;\\n    }\\n};\\n```\n```ans=\"/\"+s.top()+ans```\n```ans+=reversed_stack.top()+\"/\"```\n```\\nans=\"/\";\\n\\nstack<string>reversed_stack;\\n\\nif(s.empty()){\\n    return ans;\\n}\\n\\nwhile(!s.empty()){ // reverse the stack elements\\n    reversed_stack.push(s.top());\\n    s.pop();\\n}\\n\\nwhile(!reversed_stack.empty()){\\n    ans+=reversed_stack.top()+\"/\";\\n    reversed_stack.pop();\\n}\\n\\nreturn ans.substr(0,ans.length()-1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25779,
                "title": "9-line-python-solution-easy-to-understand",
                "content": "    def simplifyPath(self, path):\\n        stack = []\\n        for token in path.split('/'):\\n            if token in ('', '.'):\\n                pass\\n            elif token == '..':\\n                if stack: stack.pop()\\n            else:\\n                stack.append(token)\\n        return '/' + '/'.join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def simplifyPath(self, path):\\n        stack = []\\n        for token in path.split('/'):\\n            if token in ('', '.'):\\n                pass\\n            elif token == '..':\\n                if stack: stack.pop()\\n            else:\\n                stack.append(token)\\n        return '/' + '/'.join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 3406682,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 10,000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n# Video Solution\\n\\n**Search \\uD83D\\uDC49 `Simplify Path by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (14).png](https://assets.leetcode.com/users/images/a5f0dbb8-6a74-403e-b875-e24a2ba32966_1681263193.499577.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\n- Initialize an empty stack to hold the directories in the simplified path.\\n- Split the input path string into individual directories using the forward slash (\"/\") as a separator.\\nFor each directory:\\n- If the directory is a parent directory reference (\"..\") and the stack is non-empty, pop the last directory off the stack to remove the preceding directory.\\n- If the directory is not a special directory reference (i.e. neither \".\", \"\" nor \"..\"), append it to the stack.\\n- Construct the simplified path by joining the directories in the stack with forward slashes (\"/\") and adding a leading forward slash (\"/\").\\n\\n\\n# Intuition:\\nThe problem asks us to simplify a path in the Unix-style directory format, which consists of a sequence of directory names separated by forward slashes. The path may contain special directory references, such as \".\" (current directory), \"\" (empty directory), and \"..\" (parent directory). We need to remove any redundant directories and parent directory references to simplify the path.\\n\\nTo solve the problem, we can use a stack to keep track of the directories in the simplified path. We iterate over each directory in the input path and perform the following actions:\\n\\n- If the directory is a parent directory reference (\"..\") and the stack is non-empty, we pop the last directory off the stack to remove the preceding directory.\\n- If the directory is not a special directory reference, we append it to the stack.\\n- We then construct the simplified path by joining the directories in the stack with forward slashes and adding a leading forward slash.\\n- Using a stack allows us to keep track of the directories in the path in a last-in-first-out (LIFO) order, which is convenient for removing parent directory references. By only appending non-special directories to the stack, we can ensure that the simplified path does not contain any redundant directories or empty directory references. - Finally, joining the directories in the stack with forward slashes gives us the simplified path in the correct format.\\n\\n\\n```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dir_stack = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dir_stack and elem == \"..\":\\n                dir_stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dir_stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(dir_stack)\\n\\n```\\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dir_stack = new ArrayDeque<>();\\n        for (String dir : path.split(\"/\")) {\\n            if (!dir_stack.isEmpty() && dir.equals(\"..\")) {\\n                dir_stack.removeLast();\\n            } else if (!dir.equals(\".\") && !dir.equals(\"\") && !dir.equals(\"..\")) {\\n                dir_stack.addLast(dir);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dir : dir_stack) {\\n            simplified_path.append(\"/\").append(dir);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dir_stack;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (!dir_stack.empty() && dir == \"..\") {\\n                dir_stack.pop_back();\\n            } else if (dir != \".\" && dir != \"\" && dir != \"..\") {\\n                dir_stack.push_back(dir);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dir : dir_stack) {\\n            simplified_path += \"/\" + dir;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```Python []\\nclass Solution:\\n    def simplifyPath(self, path):\\n        dir_stack = []\\n        path = path.split(\"/\")\\n        for elem in path:\\n            if dir_stack and elem == \"..\":\\n                dir_stack.pop()\\n            elif elem not in [\".\", \"\", \"..\"]:\\n                dir_stack.append(elem)\\n                \\n        return \"/\" + \"/\".join(dir_stack)\\n\\n```\n```Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dir_stack = new ArrayDeque<>();\\n        for (String dir : path.split(\"/\")) {\\n            if (!dir_stack.isEmpty() && dir.equals(\"..\")) {\\n                dir_stack.removeLast();\\n            } else if (!dir.equals(\".\") && !dir.equals(\"\") && !dir.equals(\"..\")) {\\n                dir_stack.addLast(dir);\\n            }\\n        }\\n        StringBuilder simplified_path = new StringBuilder();\\n        for (String dir : dir_stack) {\\n            simplified_path.append(\"/\").append(dir);\\n        }\\n        return simplified_path.length() == 0 ? \"/\" : simplified_path.toString();\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> dir_stack;\\n        stringstream ss(path);\\n        string dir;\\n        while (getline(ss, dir, \\'/\\')) {\\n            if (!dir_stack.empty() && dir == \"..\") {\\n                dir_stack.pop_back();\\n            } else if (dir != \".\" && dir != \"\" && dir != \"..\") {\\n                dir_stack.push_back(dir);\\n            }\\n        }\\n        string simplified_path = \"\";\\n        for (string dir : dir_stack) {\\n            simplified_path += \"/\" + dir;\\n        }\\n        return simplified_path.empty() ? \"/\" : simplified_path;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25687,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string res, s;\\n        stack<string>stk;\\n        stringstream ss(path);\\n        while(getline(ss, s, '/')) {\\n            if (s == \"\" || s == \".\") continue;\\n            if (s == \"..\" && !stk.empty()) stk.pop();\\n            else if (s != \"..\") stk.push(s);\\n        }\\n        while(!stk.empty()){\\n            res = \"/\"+ stk.top() + res;\\n            stk.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string res, s;\\n        stack<string>stk;\\n        stringstream ss(path);\\n        while(getline(ss, s, '/')) {\\n            if (s == \"\" || s == \".\") continue;\\n            if (s == \"..\" && !stk.empty()) stk.pop();\\n            else if (s != \"..\") stk.push(s);\\n        }\\n        while(!stk.empty()){\\n            res = \"/\"+ stk.top() + res;\\n            stk.pop();\\n        }\\n        return res.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050697,
                "title": "c-simple-and-easy-solution-faster-than-94",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> stack;\\n        string res, temp;\\n        stringstream p(path);\\n        \\n        while (getline(p, temp, \\'/\\')) {\\n            if (temp == \"\" or temp == \".\") continue;\\n            if (!stack.empty() && temp == \"..\")\\n                stack.pop_back();\\n            else if (temp != \"..\")\\n                stack.push_back(temp);\\n        }\\n        \\n        for (auto s : stack)\\n            res += \"/\" + s;\\n        \\n        return stack.empty() ? \"/\" : res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> stack;\\n        string res, temp;\\n        stringstream p(path);\\n        \\n        while (getline(p, temp, \\'/\\')) {\\n            if (temp == \"\" or temp == \".\") continue;\\n            if (!stack.empty() && temp == \"..\")\\n                stack.pop_back();\\n            else if (temp != \"..\")\\n                stack.push_back(temp);\\n        }\\n        \\n        for (auto s : stack)\\n            res += \"/\" + s;\\n        \\n        return stack.empty() ? \"/\" : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500734,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Split commands with `/`\\n2. Use a stack to apply commands\\n``` javascript\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = [];\\n    path = path.split(\\'/\\');\\n    \\n    for (let i=0;i<path.length;i++) {\\n        if (path[i]==\\'.\\' || path[i]==\\'\\') continue;\\n        if (path[i]==\\'..\\') stack.pop();\\n        else stack.push(path[i]);\\n    }\\n    \\n    return \\'/\\'+stack.join(\\'/\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = [];\\n    path = path.split(\\'/\\');\\n    \\n    for (let i=0;i<path.length;i++) {\\n        if (path[i]==\\'.\\' || path[i]==\\'\\') continue;\\n        if (path[i]==\\'..\\') stack.pop();\\n        else stack.push(path[i]);\\n    }\\n    \\n    return \\'/\\'+stack.join(\\'/\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25773,
                "title": "my-o-n-ac-code-just-need-to-handle-two-special-cases",
                "content": " 1. traverse the string to record each folder name.\\n 2. two special cases:\\n\\na.double dot:pop one.\\n  \\nb.single dot: do nothing (don`t push it).\\n\\n\\n\\n\\n    string simplifyPath(string path) {\\n    \\tvector<string>   nameVect;\\n    \\tstring name;\\n    \\t\\n    \\tpath.push_back('/');\\n    \\tfor(int i=0;i<path.size();i++){\\n    \\t\\tif(path[i]=='/'){\\n    \\t\\t\\tif(name.size()==0)continue;\\n    \\t\\t\\tif(name==\"..\"){\\t\\t//special case 1\\uff1adouble dot\\uff0cpop dir\\n    \\t\\t\\t     if(nameVect.size()>0)nameVect.pop_back();\\n    \\t\\t\\t}else if(name==\".\"){//special case 2:singel dot\\uff0cdon`t push\\n    \\t\\t\\t}else{\\t\\t\\t\\n    \\t\\t\\t\\tnameVect.push_back(name);\\n    \\t\\t\\t}\\n    \\t\\t\\tname.clear();\\n    \\t\\t}else{\\n    \\t\\t\\tname.push_back(path[i]);//record the name\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tstring result;\\n    \\tif(nameVect.empty())return \"/\";\\n    \\tfor(int i=0;i<nameVect.size();i++){\\n    \\t\\tresult.append(\"/\"+nameVect[i]);\\n    \\t}\\n    \\treturn result;\\n    }",
                "solutionTags": [],
                "code": " 1. traverse the string to record each folder name.\\n 2. two special cases:\\n\\na.double dot:pop one.\\n  \\nb.single dot: do nothing (don`t push it).\\n\\n\\n\\n\\n    string simplifyPath(string path) {\\n    \\tvector<string>   nameVect;\\n    \\tstring name;\\n    \\t\\n    \\tpath.push_back('/');\\n    \\tfor(int i=0;i<path.size();i++){\\n    \\t\\tif(path[i]=='/'){\\n    \\t\\t\\tif(name.size()==0)continue;\\n    \\t\\t\\tif(name==\"..\"){\\t\\t//special case 1\\uff1adouble dot\\uff0cpop dir\\n    \\t\\t\\t     if(nameVect.size()>0)nameVect.pop_back();\\n    \\t\\t\\t}else if(name==\".\"){//special case 2:singel dot\\uff0cdon`t push\\n    \\t\\t\\t}else{\\t\\t\\t\\n    \\t\\t\\t\\tnameVect.push_back(name);\\n    \\t\\t\\t}\\n    \\t\\t\\tname.clear();\\n    \\t\\t}else{\\n    \\t\\t\\tname.push_back(path[i]);//record the name\\n    \\t\\t}\\n    \\t}\\n    \\n    \\tstring result;\\n    \\tif(nameVect.empty())return \"/\";\\n    \\tfor(int i=0;i<nameVect.size();i++){\\n    \\t\\tresult.append(\"/\"+nameVect[i]);\\n    \\t}\\n    \\treturn result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3406777,
                "title": "c-java-python-beginner-friendly-explanation-multiple-testcase-using-stack",
                "content": "# Approach\\n1. Create a Stack of String with following condition.\\n2. Iterate the loop till you doesn\\'t reaches the end of string.\\n3. If you encounter a \"/\" then ignore it.\\n4. Create a temp String & Iterate the while loop till you doesn\\'t find \"/\" and append it to temp.\\n4. Now check if temp == \".\" , then ignore it.\\n5. If temp == \"..\" then pop the element from the stack if it exists.\\n6. If no of the above 2 matches push temp to stack as you find a valid path.\\n7. Check out temp string on basis of above conditions till you doesn\\'t find \"/\".\\n8. Now add all stack elements to result as res = \"/\" + st.top() + res\\n9. If res.size() is 0 then return \"/\" if no directory or file is present.\\nAt last return res.\\n```\\n**See This Testcase for better understanding **\\ninput : \"/home/../foo/\"             output : \"/foo\"\\ninput : \"/home/test/../foo/\"        output : \"/home/foo\"\\ninput : \"/home/...//foo/\"           output : \"/home/.../foo\"\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n```C++ []\\nclass Solution {\\npublic:\\nclass Solution\\n{\\npublic:\\n    string simplifyPath(string path)\\n    {\\n\\n        stack<string> st;\\n        string res;\\n\\n        for (int i = 0; i < path.size(); ++i)\\n        {\\n            if (path[i] == \\'/\\')\\n                continue;\\n            string temp;\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if (temp == \".\")\\n                continue;\\n            else if (temp == \"..\")\\n            {\\n                if (!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(temp);\\n        }\\n\\n        while (!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n\\n        if (res.size() == 0)\\n            return \"/\";\\n\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution\\n{\\npublic\\n    String simplifyPath(String path)\\n    {\\n        Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories)\\n        { \\n            if (dir.equals(\".\") || dir.isEmpty())\\n            { \\n                continue;\\n            }\\n            else if (dir.equals(\"..\"))\\n            { \\n                if (!stack.isEmpty())\\n                { \\n                    stack.pop();\\n                }\\n            }\\n            else\\n            { \\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); \\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n```\\n![Screenshot 2023-04-12 at 11.31.36 AM.png](https://assets.leetcode.com/users/images/69e6623a-6d9d-43dd-8618-c170cb4d1a33_1681279337.5105672.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String",
                    "Stack"
                ],
                "code": "```\\n**See This Testcase for better understanding **\\ninput : \"/home/../foo/\"             output : \"/foo\"\\ninput : \"/home/test/../foo/\"        output : \"/home/foo\"\\ninput : \"/home/...//foo/\"           output : \"/home/.../foo\"\\n```\n```C++ []\\nclass Solution {\\npublic:\\nclass Solution\\n{\\npublic:\\n    string simplifyPath(string path)\\n    {\\n\\n        stack<string> st;\\n        string res;\\n\\n        for (int i = 0; i < path.size(); ++i)\\n        {\\n            if (path[i] == \\'/\\')\\n                continue;\\n            string temp;\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if (temp == \".\")\\n                continue;\\n            else if (temp == \"..\")\\n            {\\n                if (!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(temp);\\n        }\\n\\n        while (!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n\\n        if (res.size() == 0)\\n            return \"/\";\\n\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution\\n{\\npublic\\n    String simplifyPath(String path)\\n    {\\n        Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories)\\n        { \\n            if (dir.equals(\".\") || dir.isEmpty())\\n            { \\n                continue;\\n            }\\n            else if (dir.equals(\"..\"))\\n            { \\n                if (!stack.isEmpty())\\n                { \\n                    stack.pop();\\n                }\\n            }\\n            else\\n            { \\n                stack.push(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", stack); \\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        directories = path.split(\"/\")\\n        for dir in directories:\\n            if dir == \".\" or not dir:\\n                continue\\n            elif dir == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493083,
                "title": "java-tc-o-n-sc-o-n-using-stack-stringbuilder",
                "content": "```\\n/**\\n * Time Complexity: O(N)\\n * 1. O(N) - Each character will be traversed once.\\n * 2. O(N) - Each character will be added to StringBuilder.\\n * 3. O(N) - sb.toString()\\n *\\n * Space Complexity: O(N)\\n * 1. StringBuilder can take upto N characters.\\n * 2. Stack will store an integer for each valid directory. (This is also bounded by O(N))\\n *\\n * N = Length of input path.\\n */\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        if (path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        // Stack is used to store the length of StringBuilder until previous directory.\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n        int len = path.length();\\n\\n        while (i < len) {\\n            if (path.charAt(i) == \\'/\\') {\\n                i++;\\n                continue;\\n            }\\n\\n            StringBuilder dir = new StringBuilder();\\n            while (i < len && path.charAt(i) != \\'/\\') {\\n                dir.append(path.charAt(i));\\n                i++;\\n            }\\n\\n            String dirName = dir.toString();\\n            switch (dirName) {\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if (!stack.isEmpty()) {\\n                        sb.setLength(stack.pop());\\n                    }\\n                    break;\\n                default:\\n                    stack.push(sb.length());\\n                    sb.append(\\'/\\').append(dirName);\\n            }\\n        }\\n\\n        return sb.length() != 0 ? sb.toString() : \"/\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(N)\\n * 1. O(N) - Each character will be traversed once.\\n * 2. O(N) - Each character will be added to StringBuilder.\\n * 3. O(N) - sb.toString()\\n *\\n * Space Complexity: O(N)\\n * 1. StringBuilder can take upto N characters.\\n * 2. Stack will store an integer for each valid directory. (This is also bounded by O(N))\\n *\\n * N = Length of input path.\\n */\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null) {\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        if (path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        // Stack is used to store the length of StringBuilder until previous directory.\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n        int len = path.length();\\n\\n        while (i < len) {\\n            if (path.charAt(i) == \\'/\\') {\\n                i++;\\n                continue;\\n            }\\n\\n            StringBuilder dir = new StringBuilder();\\n            while (i < len && path.charAt(i) != \\'/\\') {\\n                dir.append(path.charAt(i));\\n                i++;\\n            }\\n\\n            String dirName = dir.toString();\\n            switch (dirName) {\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if (!stack.isEmpty()) {\\n                        sb.setLength(stack.pop());\\n                    }\\n                    break;\\n                default:\\n                    stack.push(sb.length());\\n                    sb.append(\\'/\\').append(dirName);\\n            }\\n        }\\n\\n        return sb.length() != 0 ? sb.toString() : \"/\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25704,
                "title": "share-my-8ms-java-solution",
                "content": "\\tpublic String simplifyPath(String path) {\\n\\t\\tString[] dir = path.split(\"/\");\\n\\t\\tString[] stack = new String[dir.length];\\n\\t\\tint ptr = 0;\\n\\t\\tfor(int i = 0; i < dir.length; i++){\\n\\t\\t\\tif(dir[i].equals(\".\") || dir[i].equals(\"\")){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}else if(dir[i].equals(\"..\")){\\n\\t\\t\\t\\tif(ptr > 0) ptr--;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack[ptr] = dir[i];\\n\\t\\t\\t\\tptr++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringBuilder result = new StringBuilder();\\n\\t\\tfor(int i = 0; i < ptr; i++){\\n\\t\\t\\tresult.append(\"/\");\\n\\t\\t\\tresult.append(stack[i]);\\n\\t\\t}\\n\\t\\treturn result.length() == 0 ? \"/\" : result.toString();\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic String simplifyPath(String path) {\\n\\t\\tString[] dir = path.split(\"/\");\\n\\t\\tString[] stack = new String[dir.length];\\n\\t\\tint ptr = 0;\\n\\t\\tfor(int i = 0; i < dir.length; i++){\\n\\t\\t\\tif(dir[i].equals(\".\") || dir[i].equals(\"\")){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}else if(dir[i].equals(\"..\")){\\n\\t\\t\\t\\tif(ptr > 0) ptr--;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tstack[ptr] = dir[i];\\n\\t\\t\\t\\tptr++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tStringBuilder result = new StringBuilder();\\n\\t\\tfor(int i = 0; i < ptr; i++){\\n\\t\\t\\tresult.append(\"/\");\\n\\t\\t\\tresult.append(stack[i]);\\n\\t\\t}\\n\\t\\treturn result.length() == 0 ? \"/\" : result.toString();\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3407155,
                "title": "java-explained-with-example-beginner-friendly-stack",
                "content": "# Intuition\\nSince our operations of moving ahead or moving down a directory depend on the current string we see, so data structure that comes to mind is Stack\\n\\nIf you have used linux based system you must be already aware of these\\n- /abc/  --> means get into the folder /abc/\\n- /./  --> \".\" indicates current directory, that is stay where you are\\n- /../ --> \"..\" means step down a directory where you are, equivalent to a back in windows.\\n\\n- Now Lets understand by an **Example**\\n**Input**: \"/a/./b/../../c/\"\\n**Output**: /c\\nWe always start with home directory\\nAfter spilting Array [\"a\", \".\", \"b\", \"..\", \"..\", \"c]\\n\"a\" --> move to /a\\n\".\" --> stay in current directory still in /a\\n\"b\" --> move to directory b i.e /a/b\\n\"..\" --> move back i.e is /a again\\n\"..\" --> move back i.e back to home directory /\\n\"c\" --> move to c directory i.e /c\\nAnswer is /c\\n---\\n\\n# Approach\\n1) Split the input string on basis of \\'/\\'\\nThis will separate all input will also resolve are double \\'//\\' cases(leading to \"\" empty string).\\n2) Now that we got a \\'/\\' speparated string array\\n3) We define a skip set (\"..\", \".\", \"\")\\n- if we encouter \".\" means stay in the current directory\\n- \"\" is a result of // being separated, so skip that\\nI mainted a skip set to write clean code\\n\\n```\\nif(!dir.equals(\"..\") || !dir.equals(\".\") || !dir.equals(\"\"))\\n//instead did this\\nif(!skip.contains(dir))\\n```\\n4) Now we start iterating over array. \\n- If we encouter \"..\" and stack is non empty than we need to pop-out or move backwards\\n- If we encounter anything other than these (\"..\", \".\", \"\") we add to stack\\n5) At end, form a Stringbuilder out of the stack.\\n### Why StringBuilder and not String is being used. [See this](https://leetcode.com/problems/removing-stars-from-a-string/solutions/3402865/java-explained-why-use-stringbuilder-than-string-beginner-friendly/)\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) : Since we are going through all the elements of the string once.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n   public String simplifyPath(String path) {\\n    Stack<String> stack = new Stack<>();\\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n    for (String dir : path.split(\"/\")) {\\n        if (dir.equals(\"..\") && !stack.isEmpty())\\n         stack.pop();\\n        else if (!skip.contains(dir))\\n         stack.push(dir);\\n    }\\n    StringBuilder res = new StringBuilder();\\n    while(!stack.isEmpty()){\\n            res.insert(0,stack.pop()).insert(0,\"/\");\\n        }\\n    return res.isEmpty() ? \"/\" : res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nif(!dir.equals(\"..\") || !dir.equals(\".\") || !dir.equals(\"\"))\\n//instead did this\\nif(!skip.contains(dir))\\n```\n```\\nclass Solution {\\n   public String simplifyPath(String path) {\\n    Stack<String> stack = new Stack<>();\\n    Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n    for (String dir : path.split(\"/\")) {\\n        if (dir.equals(\"..\") && !stack.isEmpty())\\n         stack.pop();\\n        else if (!skip.contains(dir))\\n         stack.push(dir);\\n    }\\n    StringBuilder res = new StringBuilder();\\n    while(!stack.isEmpty()){\\n            res.insert(0,stack.pop()).insert(0,\"/\");\\n        }\\n    return res.isEmpty() ? \"/\" : res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847338,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Python**\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        for p in path.split(\"/\"):\\n            if p == \\'..\\' and len(stack) > 0:\\n                stack.pop()\\n            if p == \\'\\' or p == \\'.\\' or p ==\\'..\\':\\n                continue\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\\n**JavaScript**\\n```\\nvar simplifyPath = function(path) {\\n    path = path.split(\\'/\\');\\n    let stack = [];\\n    for(let p of path){\\n        if(p == \\'.\\' || p == \\'\\') continue;\\n        else if(p == \\'..\\')   stack.pop();\\n        else stack.push(p);\\n    }\\n    return \\'/\\' + stack.join(\\'/\\');\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !stack.isEmpty())    stack.pop();\\n            else if(!skip.contains(dir)) stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        stack = []\\n        for p in path.split(\"/\"):\\n            if p == \\'..\\' and len(stack) > 0:\\n                stack.pop()\\n            if p == \\'\\' or p == \\'.\\' or p ==\\'..\\':\\n                continue\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\n```\\nvar simplifyPath = function(path) {\\n    path = path.split(\\'/\\');\\n    let stack = [];\\n    for(let p of path){\\n        if(p == \\'.\\' || p == \\'\\') continue;\\n        else if(p == \\'..\\')   stack.pop();\\n        else stack.push(p);\\n    }\\n    return \\'/\\' + stack.join(\\'/\\');\\n};\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !stack.isEmpty())    stack.pop();\\n            else if(!skip.contains(dir)) stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739219,
                "title": "easy-c-solution-using-stl-with-detailed-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using STL functions.\\n- We took a stack to store all the paths. We\\u2019ll have 3 operations to find all the paths:\\n    - `if(temp == \"\" || temp == \".\") continue;` we\\u2019ll ignore all empty or \\u2018.\\u2019 indexs.\\n    - `if(temp != \"..\" ) s.push(temp);` if it\\u2019s not a \\u2018..\\u2019 means it indicates a path, simply push it to stack.\\n    - `else if(!s.empty()) s.pop();` and finally if it\\u2019s \\u2018..\\u2019 means we have to go previous directory, so pop the last path from stack.\\n- If we find the stack is empty that means we\\u2019re in the root directory, so `return \\u201C/\\u201D`.\\n- Now we\\u2019ll add all the paths with a \\u2018/\\u2019. But for stack the last element will be on top. So we need to reverse the stack.\\n- Here we used a trick & added the top element before the current ans, by this top element of the stack will go end every time.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        string ans, temp;\\n        int n = path.size();\\n        stringstream X(path);\\n        \\n        while(getline(X, temp, \\'/\\')){\\n            if(temp == \"\" || temp == \".\") continue;\\n            if(temp != \"..\" ) s.push(temp);\\n            else if(!s.empty()) s.pop();\\n        }\\n        if(s.empty()) return \"/\";\\n        \\n        while(!s.empty()){\\n            ans = \\'/\\' + s.top() + ans;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        string ans, temp;\\n        int n = path.size();\\n        stringstream X(path);\\n        \\n        while(getline(X, temp, \\'/\\')){\\n            if(temp == \"\" || temp == \".\") continue;\\n            if(temp != \"..\" ) s.push(temp);\\n            else if(!s.empty()) s.pop();\\n        }\\n        if(s.empty()) return \"/\";\\n        \\n        while(!s.empty()){\\n            ans = \\'/\\' + s.top() + ans;\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25794,
                "title": "python-easy-to-understand-solution-with-stack",
                "content": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        parts = path.split(\"/\")\\n        stack = []\\n        for p in parts:\\n            if p in [\\'\\', \\'.\\']:\\n                continue\\n            elif p == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        parts = path.split(\"/\")\\n        stack = []\\n        for p in parts:\\n            if p in [\\'\\', \\'.\\']:\\n                continue\\n            elif p == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847706,
                "title": "easy-java-solution-without-stack",
                "content": "```\\nclass Solution {\\n\\n    public String simplifyPath(String path) {\\n        String[] x = path.split(\"/\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = x.length - 1, sk = 0; i >= 0; i--) {\\n            if (x[i].equals(\".\") || x[i].length() == 0) continue;\\n            if (x[i].equals(\"..\")) sk++;  // increment skip count \\n            else if (sk > 0) sk--;  // skip it\\n            else sb.insert(0, \"/\" + x[i]);  // skip = 0? then add it.\\n        }\\n        if (sb.length() == 0) sb.append(\"/\");\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public String simplifyPath(String path) {\\n        String[] x = path.split(\"/\");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = x.length - 1, sk = 0; i >= 0; i--) {\\n            if (x[i].equals(\".\") || x[i].length() == 0) continue;\\n            if (x[i].equals(\"..\")) sk++;  // increment skip count \\n            else if (sk > 0) sk--;  // skip it\\n            else sb.insert(0, \"/\" + x[i]);  // skip = 0? then add it.\\n        }\\n        if (sb.length() == 0) sb.append(\"/\");\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050559,
                "title": "java-easy-to-read-easy-to-understand",
                "content": "```\\npublic String simplifyPath(String path) {\\n        String[] dirs = path.split(\"/\");\\n        Deque<String> stack = new ArrayDeque<>();\\n        for(String s: dirs) {\\n            if(s.equals(\"\")) continue;\\n            if(s.equals(\".\")) continue;\\n            if(s.equals(\"..\")) stack.pollLast();\\n            else stack.add(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] dirs = path.split(\"/\");\\n        Deque<String> stack = new ArrayDeque<>();\\n        for(String s: dirs) {\\n            if(s.equals(\"\")) continue;\\n            if(s.equals(\".\")) continue;\\n            if(s.equals(\"..\")) stack.pollLast();\\n            else stack.add(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915724,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of path.\\n    //   - space: O(n), where n is the length of path.\\n\\n    func simplifyPath(_ path: String) -> String {\\n        let paths = path.split(separator: \"/\")\\n        \\n        var stack = [String]()\\n        for path in paths {\\n            guard path != \".\", !path.isEmpty else { continue }\\n            \\n            if path == \"..\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                }\\n            } else {\\n                stack.append(String(path))\\n            }\\n        }\\n        \\n        return \"/\\\\(stack.joined(separator: \"/\"))\"\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of path.\\n    //   - space: O(n), where n is the length of path.\\n\\n    func simplifyPath(_ path: String) -> String {\\n        let paths = path.split(separator: \"/\")\\n        \\n        var stack = [String]()\\n        for path in paths {\\n            guard path != \".\", !path.isEmpty else { continue }\\n            \\n            if path == \"..\" {\\n                if !stack.isEmpty {\\n                    stack.removeLast()\\n                }\\n            } else {\\n                stack.append(String(path))\\n            }\\n        }\\n        \\n        return \"/\\\\(stack.joined(separator: \"/\"))\"\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550900,
                "title": "python-3-stack-2-solutions",
                "content": "```\\nclass Solution1:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i<len(path):\\n            while i< len(path) and path[i]==\\'/\\':\\n                i+=1\\n            start = i\\n            while i< len(path) and path[i]!=\\'/\\':\\n                i+=1\\n            strr = path[start:i]\\n            if strr == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            elif strr and strr != \\'.\\' :\\n                    stack.append(strr)\\n        if not stack:\\n            return \\'/\\'\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\\n\\n```\\nclass Solution2:\\n    def simplifyPath(self, path: str) -> str:\\n        strs = path.split(\\'/\\')\\n        res = []\\n        for s in strs:\\n            if s == \\'..\\':\\n                if res:\\n                    res.pop()\\n            elif s.isalpha() or (s and s!=\\'.\\'):\\n                res.append(s)\\n        return \\'/\\' + \\'/\\'.join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution1:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i<len(path):\\n            while i< len(path) and path[i]==\\'/\\':\\n                i+=1\\n            start = i\\n            while i< len(path) and path[i]!=\\'/\\':\\n                i+=1\\n            strr = path[start:i]\\n            if strr == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n            elif strr and strr != \\'.\\' :\\n                    stack.append(strr)\\n        if not stack:\\n            return \\'/\\'\\n        return \\'/\\' + \\'/\\'.join(stack)\\n```\n```\\nclass Solution2:\\n    def simplifyPath(self, path: str) -> str:\\n        strs = path.split(\\'/\\')\\n        res = []\\n        for s in strs:\\n            if s == \\'..\\':\\n                if res:\\n                    res.pop()\\n            elif s.isalpha() or (s and s!=\\'.\\'):\\n                res.append(s)\\n        return \\'/\\' + \\'/\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25725,
                "title": "accepted-solution-using-deque",
                "content": "I think using Deque is probably the most intuitive way to solve this problem.\\n\\n    /**\\n     * Deque of strings (directories).\\n     * iterate path:\\n     *  if \"/\", continue,\\n     *  if \".\", conitnue,\\n     *  if \"..\", poll last,\\n     *  else, add a new directory\\n     * in the end, build result from deque.\\n     */\\n    public String simplifyPath(String path) {\\n        Deque<String> deque = new LinkedList<String>();\\n        String[] splits = path.split(\"/\");\\n        for (String split : splits) {\\n            // CATCH: must use \"equals()\" instead of \"==\",\\n            // because 'split' is a variable!\\n            // Also, 'split' could be empty string.\\n            if (split.equals(\"\"))\\n                continue;\\n            else if (split.equals(\".\"))\\n                continue;\\n            else if (split.equals(\"..\"))\\n                deque.pollLast();\\n            else\\n                deque.addLast(split);\\n        }\\n        StringBuilder builder = new StringBuilder();\\n        while (!deque.isEmpty()) {\\n            String s = deque.pollFirst();\\n            builder.append(\"/\").append(s);\\n        }\\n        if (builder.length() == 0)\\n            return \"/\";\\n        return builder.toString();\\n    }",
                "solutionTags": [],
                "code": "I think using Deque is probably the most intuitive way to solve this problem.\\n\\n    /**\\n     * Deque of strings (directories).\\n     * iterate path:\\n     *  if \"/\", continue,\\n     *  if \".\", conitnue,\\n     *  if \"..\", poll last,\\n     *  else, add a new directory\\n     * in the end, build result from deque.\\n     */\\n    public String simplifyPath(String path) {\\n        Deque<String> deque = new LinkedList<String>();\\n        String[] splits = path.split(\"/\");\\n        for (String split : splits) {\\n            // CATCH: must use \"equals()\" instead of \"==\",\\n            // because 'split' is a variable!\\n            // Also, 'split' could be empty string.\\n            if (split.equals(\"\"))\\n                continue;\\n            else if (split.equals(\".\"))\\n                continue;\\n            else if (split.equals(\"..\"))\\n                deque.pollLast();\\n            else\\n                deque.addLast(split);\\n        }\\n        StringBuilder builder = new StringBuilder();\\n        while (!deque.isEmpty()) {\\n            String s = deque.pollFirst();\\n            builder.append(\"/\").append(s);\\n        }\\n        if (builder.length() == 0)\\n            return \"/\";\\n        return builder.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1847624,
                "title": "c-easy-to-understand-without-getline-or-split-simple-stack",
                "content": "**71. Simplify Path**\\n##### **APPROACH -**\\n*Use a **stack to store the directories**\\nCreate **curr to store the data between two forward slashes**\\nTraverse through the path maintaining the curr\\nWhenever / is encountered **push or pop the stack based upon curr**\\nFinally get the simplified path from the directories left in the stack*\\n\\n**Note: Initially add / to the end of the given path to ensure that the last curr is always considered**\\n\\n<br/>\\n\\n##### **COMPLEXITY -**\\n* **Time Complexity : O(N)**, where N = length of path\\n* **Space Complexity : O(M)**, where M = number of directories in path\\n\\n<br/>\\n\\n##### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string curr, simplifiedPath;\\n        stack<string> st;\\n        path.push_back(\\'/\\');\\n        \\n        for(char c : path) {\\n            if(c == \\'/\\') {\\n                if(curr.empty())    continue;\\n                else if(curr == \"..\") {\\n                    if(!st.empty())   st.pop();   // go to previous i.e. parent directory \\n                }\\n                else if(curr != \".\")    st.push(curr);   // add the new directory or file \\n                curr = \"\";\\n            }\\n            else\\n                curr.push_back(c);\\n        }\\n        \\n        while(!st.empty()) {\\n            simplifiedPath = \"/\" + st.top() + simplifiedPath;\\n            st.pop();\\n        }\\n        return simplifiedPath.empty() ? \"/\" : simplifiedPath;\\n    }\\n};\\n```\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string curr, simplifiedPath;\\n        stack<string> st;\\n        path.push_back(\\'/\\');\\n        \\n        for(char c : path) {\\n            if(c == \\'/\\') {\\n                if(curr.empty())    continue;\\n                else if(curr == \"..\") {\\n                    if(!st.empty())   st.pop();   // go to previous i.e. parent directory \\n                }\\n                else if(curr != \".\")    st.push(curr);   // add the new directory or file \\n                curr = \"\";\\n            }\\n            else\\n                curr.push_back(c);\\n        }\\n        \\n        while(!st.empty()) {\\n            simplifiedPath = \"/\" + st.top() + simplifiedPath;\\n            st.pop();\\n        }\\n        return simplifiedPath.empty() ? \"/\" : simplifiedPath;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407303,
                "title": "c-easy-solution-stack-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;   // Stack is going to store folders\\n        string ans=\"\";  // Answer path\\n        for(int i=0;i<path.length();i++){  // Traversing through string\\n            if(path[i] == \\'/\\'){  // We always going to ignore \\'/\\'\\n                continue;\\n            }\\n            string temp=\"\";  // We are gonna store folder names in temp\\n            while(i<path.length() && path[i] != \\'/\\'){  // To store names we use this while loop\\n                temp += path[i];\\n                i++;\\n            }\\n            if(temp == \".\") continue;  // If we get a single \\'.\\' then there is no need of pushing in stamp\\n            else if(temp == \"..\"){  // This means that we have to go up in path\\n                if(!st.empty()) st.pop();  // To go up we have to pop\\n            }\\n            else{\\n                st.push(temp);  // If we get no . or .. that means we got the name of the folder\\n            }           \\n        } \\n        if(st.empty())  ans = \\'/\\';  // If there is nothing in our stack then we just need to return /;\\n        while(!st.empty()){  // If we have something in stack then we have to give in this order \"/home/xyz/abc\" etc\\n            ans = \\'/\\' + st.top() + ans;  // For that I am using this \\n            st.pop();\\n        }       \\n        return ans;  // Returning the resulting string \\n    }\\n};\\n```\\n\\n`If you are still not able to understand and know hindi, then I\\'ll suggest to search \"CodeFreaks Simplify paths\" on Youtube`  \\n\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/d3f17c86-efa7-4873-bd1f-a2564dceb9e6_1681275250.3060498.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;   // Stack is going to store folders\\n        string ans=\"\";  // Answer path\\n        for(int i=0;i<path.length();i++){  // Traversing through string\\n            if(path[i] == \\'/\\'){  // We always going to ignore \\'/\\'\\n                continue;\\n            }\\n            string temp=\"\";  // We are gonna store folder names in temp\\n            while(i<path.length() && path[i] != \\'/\\'){  // To store names we use this while loop\\n                temp += path[i];\\n                i++;\\n            }\\n            if(temp == \".\") continue;  // If we get a single \\'.\\' then there is no need of pushing in stamp\\n            else if(temp == \"..\"){  // This means that we have to go up in path\\n                if(!st.empty()) st.pop();  // To go up we have to pop\\n            }\\n            else{\\n                st.push(temp);  // If we get no . or .. that means we got the name of the folder\\n            }           \\n        } \\n        if(st.empty())  ans = \\'/\\';  // If there is nothing in our stack then we just need to return /;\\n        while(!st.empty()){  // If we have something in stack then we have to give in this order \"/home/xyz/abc\" etc\\n            ans = \\'/\\' + st.top() + ans;  // For that I am using this \\n            st.pop();\\n        }       \\n        return ans;  // Returning the resulting string \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977070,
                "title": "line-by-line-explanation-beats-100-time-and-space-python",
                "content": "Here is Line by line code in \\n**Python :**\\n```\\ndef simplify_path(path):\\n    # Split path into a list of directory names\\n    dirs = path.split(\\'/\\')\\n    # Initialize the stack of directories\\n    stack = []\\n    # Iterate through the directories\\n    for d in dirs:\\n        # Ignore double slashes\\n        if d == \\'\\':\\n            continue\\n        # If it\\'s a double period, pop the top directory from the stack\\n        elif d == \\'..\\':\\n            if stack:\\n                stack.pop()\\n        # If it\\'s a single period or a regular directory name, add it to the stack\\n        elif d != \\'.\\':\\n            stack.append(d)\\n    # Construct the simplified canonical path\\n    simplified_path = \\'/\\' + \\'/\\'.join(stack)\\n    return simplified_path\\n```\\nUpvote if you find it useful",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef simplify_path(path):\\n    # Split path into a list of directory names\\n    dirs = path.split(\\'/\\')\\n    # Initialize the stack of directories\\n    stack = []\\n    # Iterate through the directories\\n    for d in dirs:\\n        # Ignore double slashes\\n        if d == \\'\\':\\n            continue\\n        # If it\\'s a double period, pop the top directory from the stack\\n        elif d == \\'..\\':\\n            if stack:\\n                stack.pop()\\n        # If it\\'s a single period or a regular directory name, add it to the stack\\n        elif d != \\'.\\':\\n            stack.append(d)\\n    # Construct the simplified canonical path\\n    simplified_path = \\'/\\' + \\'/\\'.join(stack)\\n    return simplified_path\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1847554,
                "title": "python-go-stack-array-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/GO] \\uD83C\\uDF1F Stack/Array Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n```A double period \\'..\\' refers to the directory up a level``` would definitely be a thing we need to solve. We can use stack to implement pop out to up a level\\n\\n**Algo**\\n1. Make path split by \"/\" into pathList\\n2. Iterate through pathList\\n\\t * If current directory == \"\" or directory ==\".\"  We do noops continue to next directory\\n\\t * If directory == \"..\", we have to pop out last member in stack, by doing this we can make path up a level\\n\\t * If it\\'s a directory, append it into stack\\n3. Iterate through stack and combine all directory into a output path\\n\\n**Note** : We implement we call *stack* by array, So we can pop out last element and still can iterate from begining to the end.\\n\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of string\\n* Space: O(N): Iterate through path.split(\\'/\\') take O(N) and Add up res in stack take O(N) => O(2N) = O(N)\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        dirList = []\\n        \\n        for directory in path.split(\\'/\\') :\\n            # Ignore\\n            if not directory or directory == \".\":\\n                continue\\n            # Directory up a level\\n            if directory == \"..\":\\n                if dirList:\\n                    dirList.pop()\\n            # Append it in dirList\\n            else:\\n                dirList.append(directory)\\n                \\n        res = \"/\"\\n        # Make all dir in dirList add in res\\n        for directory in dirList:\\n            res += directory\\n            res += \"/\"\\n        # If res == \"/\" return it else pop out last string\\n        return res[:-1] if res != \"/\" else \"/\"\\n```\\n**Go**\\n```go\\nfunc simplifyPath(path string) string {\\n    pathList := strings.Split(path, \"/\")\\n    dirList := make([]string, 0)\\n    \\n    for _ , dir := range pathList{\\n        // Ignore\\n        if dir == \"\" || dir == \".\"{\\n            continue\\n        }\\n        // Directory up a level\\n        if dir == \"..\"{\\n            if len(dirList) != 0{\\n                dirList = dirList[:len(dirList) - 1]\\n            }\\n        // Append it in dirList\\n        } else {\\n            dirList = append(dirList, dir)\\n        }\\n    }\\n    output := \"/\"\\n    // Make all dir in dirList add in res\\n    for _, dir := range dirList{\\n        output += dir\\n        output += \"/\"\\n    }\\n    // If res == \"/\" return it else pop out last string\\n    if output == \"/\"{\\n        return output\\n    }\\n\\n    return output[:len(output) - 1]\\n}\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```A double period \\'..\\' refers to the directory up a level```\n```python\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        dirList = []\\n        \\n        for directory in path.split(\\'/\\') :\\n            # Ignore\\n            if not directory or directory == \".\":\\n                continue\\n            # Directory up a level\\n            if directory == \"..\":\\n                if dirList:\\n                    dirList.pop()\\n            # Append it in dirList\\n            else:\\n                dirList.append(directory)\\n                \\n        res = \"/\"\\n        # Make all dir in dirList add in res\\n        for directory in dirList:\\n            res += directory\\n            res += \"/\"\\n        # If res == \"/\" return it else pop out last string\\n        return res[:-1] if res != \"/\" else \"/\"\\n```\n```go\\nfunc simplifyPath(path string) string {\\n    pathList := strings.Split(path, \"/\")\\n    dirList := make([]string, 0)\\n    \\n    for _ , dir := range pathList{\\n        // Ignore\\n        if dir == \"\" || dir == \".\"{\\n            continue\\n        }\\n        // Directory up a level\\n        if dir == \"..\"{\\n            if len(dirList) != 0{\\n                dirList = dirList[:len(dirList) - 1]\\n            }\\n        // Append it in dirList\\n        } else {\\n            dirList = append(dirList, dir)\\n        }\\n    }\\n    output := \"/\"\\n    // Make all dir in dirList add in res\\n    for _, dir := range dirList{\\n        output += dir\\n        output += \"/\"\\n    }\\n    // If res == \"/\" return it else pop out last string\\n    if output == \"/\"{\\n        return output\\n    }\\n\\n    return output[:len(output) - 1]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180786,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack <string> st;\\n        for(int i = 0;i<path.size();i++)\\n        {\\n            if(path[i] == \\'/\\')\\n                continue;\\n            string s;\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                s += path[i];\\n                i++;\\n            }\\n            if(s == \".\")\\n                continue;\\n            else if(s == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(s);\\n        }\\n        string res;\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        if(res.size() == 0)\\n            return \"/\";\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        stack <string> st;\\n        for(int i = 0;i<path.size();i++)\\n        {\\n            if(path[i] == \\'/\\')\\n                continue;\\n            string s;\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                s += path[i];\\n                i++;\\n            }\\n            if(s == \".\")\\n                continue;\\n            else if(s == \"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n                st.push(s);\\n        }\\n        string res;\\n        while(!st.empty())\\n        {\\n            res = \"/\" + st.top() + res;\\n            st.pop();\\n        }\\n        if(res.size() == 0)\\n            return \"/\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671723,
                "title": "rust",
                "content": "```rust\\n    pub fn simplify_path(path: String) -> String {\\n        format!(\\n            \"/{}\",\\n            path.split(\\'/\\')\\n                .filter(|&x| x != \"\" && x != \".\")\\n                .fold(vec![], |mut acc, item| {\\n                    if item == \"..\" { acc.pop(); } \\n                    else { acc.push(item); }\\n                    acc\\n                })\\n                .join(\"/\")\\n        )\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\n    pub fn simplify_path(path: String) -> String {\\n        format!(\\n            \"/{}\",\\n            path.split(\\'/\\')\\n                .filter(|&x| x != \"\" && x != \".\")\\n                .fold(vec![], |mut acc, item| {\\n                    if item == \"..\" { acc.pop(); } \\n                    else { acc.push(item); }\\n                    acc\\n                })\\n                .join(\"/\")\\n        )\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021358,
                "title": "some-people-really-like-to-complicate-things",
                "content": "# Intuition\\nDon\\'t overthink. Free your mind https://www.youtube.com/watch?v=5TyHTxANcPw\\n\\n# Approach\\n1. Split array by **/**\\n2. Filter empty elements (empty strings)\\n3. Then follow 2 simple rules\\n    **..** - means we go one directory up, in other words we pop element from the **res** array\\n    **.** - just skip it\\nEverything else push to the **res** array\\nAnd don\\'t forget **/** in the beginning of the response.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst simplifyPath = (path) => {\\n    const res = [];\\n    const arr = path.split(\\'/\\').filter(v => v);\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'..\\') {\\n            res.pop();\\n        } else if (arr[i] === \\'.\\') {\\n            continue;\\n        } else {\\n            res.push(arr[i])\\n        }\\n    }\\n\\n    return \\'/\\' + res.join(\\'/\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst simplifyPath = (path) => {\\n    const res = [];\\n    const arr = path.split(\\'/\\').filter(v => v);\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === \\'..\\') {\\n            res.pop();\\n        } else if (arr[i] === \\'.\\') {\\n            continue;\\n        } else {\\n            res.push(arr[i])\\n        }\\n    }\\n\\n    return \\'/\\' + res.join(\\'/\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702809,
                "title": "c-98-faster-tc-o-n-sc-o-1-no-stack-simple-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        string res; \\n        int n = s.size();\\n        \\n        // If the size is 1, return \\'/\\'\\n        if(n == 1) return \"/\";\\n        \\n        // There might be a case where the absolute path does not end with \\'/\\' , so Add \\'/\\' for simpler calculation\\n        if(s[n - 1] != \\'/\\') s.push_back(\\'/\\');\\n        \\n        // Take temporary string to check for \\'.\\' or \\'..\\' , you may also use temporary integer\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // There are two cases \\n            // 1) s[i] == \\'/\\'\\n            // 2) s[i] != \\'/\\'\\n            \\n            // We will do operation when ever we reached \\'/\\' except for i = 0\\n            \\n            if(s[i] != \\'/\\'){\\n                // Update the temp string and result string\\n                string t = \"\";\\n                t += s[i];\\n                res += t;\\n                temp += t;\\n                \\n            } else if (i != 0){\\n                // Since we cannot have continuous \\'/\\', if the result string ended with \\'/\\', then continue\\n                if(res.back() == \\'/\\') continue;\\n                \\n                if(temp == \".\"){\\n                    // If there is one \\'.\\', remove last two elements from the result\\n                    res.pop_back();\\n                    res.pop_back();\\n                    \\n                } else if(temp == \"..\"){\\n                    // If there is two \\'..\\', then remove until we remove two \\'/\\' from the result\\n                    int c = 0;\\n                    while(c < 2){\\n                        if(res.back() == \\'/\\') c++;\\n                        if(res.size() == 0) break;\\n                        res.pop_back();\\n                    }\\n                }\\n                // Make temp string as empty\\n                temp = \"\";\\n                res.push_back(\\'/\\');\\n            } else {\\n                // Case when i = 0\\n                res.push_back(s[i]);\\n            }\\n        }\\n        \\n        // Finally remove the last \\'/\\' in the result\\n        if(res.size() > 1) res.pop_back();\\n        return res;\\n    }\\n};\\n```\\n\\nIf you like the Solution , please do \"**UPVOTE**\"",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        string res; \\n        int n = s.size();\\n        \\n        // If the size is 1, return \\'/\\'\\n        if(n == 1) return \"/\";\\n        \\n        // There might be a case where the absolute path does not end with \\'/\\' , so Add \\'/\\' for simpler calculation\\n        if(s[n - 1] != \\'/\\') s.push_back(\\'/\\');\\n        \\n        // Take temporary string to check for \\'.\\' or \\'..\\' , you may also use temporary integer\\n        string temp = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // There are two cases \\n            // 1) s[i] == \\'/\\'\\n            // 2) s[i] != \\'/\\'\\n            \\n            // We will do operation when ever we reached \\'/\\' except for i = 0\\n            \\n            if(s[i] != \\'/\\'){\\n                // Update the temp string and result string\\n                string t = \"\";\\n                t += s[i];\\n                res += t;\\n                temp += t;\\n                \\n            } else if (i != 0){\\n                // Since we cannot have continuous \\'/\\', if the result string ended with \\'/\\', then continue\\n                if(res.back() == \\'/\\') continue;\\n                \\n                if(temp == \".\"){\\n                    // If there is one \\'.\\', remove last two elements from the result\\n                    res.pop_back();\\n                    res.pop_back();\\n                    \\n                } else if(temp == \"..\"){\\n                    // If there is two \\'..\\', then remove until we remove two \\'/\\' from the result\\n                    int c = 0;\\n                    while(c < 2){\\n                        if(res.back() == \\'/\\') c++;\\n                        if(res.size() == 0) break;\\n                        res.pop_back();\\n                    }\\n                }\\n                // Make temp string as empty\\n                temp = \"\";\\n                res.push_back(\\'/\\');\\n            } else {\\n                // Case when i = 0\\n                res.push_back(s[i]);\\n            }\\n        }\\n        \\n        // Finally remove the last \\'/\\' in the result\\n        if(res.size() > 1) res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051414,
                "title": "c-single-pass-solutions-compared-and-explained-100-time-75-space",
                "content": "Nice problem and the first one I did about parsing string(ified) input in a while.\\n\\nTo proceed with it, we will firsst of all declare 2 support variables:\\n* `res` is our accumulator variable, but, just to further optimise and squeeze even more efficiency, we will also use it to create temporary strings;\\n* `tmp` is a vector of strings we will use to store (or pop) our parsed strings as we go.\\n\\nWe will then parse the string character by character, other than the first one (that we know is always going to be `\\'\\\\\\'`, so no point in considering it).\\n\\nLooping from `i` from `1` to the last character (`lmt`), we will:\\n* assign the value of `path[i]` to `c`;\\n* deal with `c`, depending if:\\n\\t* `c != \\'/\\'`, we will append it to `res`;\\n\\t* in any other case and if `i == lmt` (ie: we are parsing the last character - and note that this might happen even if after we appended it to `res` above):\\n\\t* if `res == \"..\"` and we have at least one element in `tmp`, we will pop the last one from it;\\n\\t* if `res` is not empty and `!= \".\"`, we will add it to `tmp`;\\n\\t* reset `res` to be `\"\"`.\\n\\nOnce done, time to finally use `res` for its proper function: if `tmp` is not empty, we will set it to be `\"\"`, `\"/\"` otherwise.\\n\\nWe will then loop through all the strings `w` collected in `tmp` and append `\"/\" + w` to `res`.\\n\\nOnce done, we can return it.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res;\\n        vector<string> tmp;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (tmp.size()) tmp.pop_back();\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp.push_back(res);\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = tmp.size() ? \"\" : \"/\";\\n        for (string w: tmp) res += \"/\" + w;\\n        return res;\\n    }\\n};\\n```\\n\\nCould I be happy with it? Well, no: not a huge fan of stacks and whenever I can, I like to use arrays in their place, provided I can guesstimate their size, as I did with a bit of trial and error, setting `tmp` to be of size `100` with a bit of trial and error; `pos` is our pointer to write in it, initially set to `0` and all the logic is the same, with significantly better performance:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res, tmp[50];\\n        int pos = 0;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (pos) pos--;\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp[pos++] = res;\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = pos ? \"\" : \"/\";\\n        for (int i = 0; i < pos; i++) res += \"/\" + tmp[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res;\\n        vector<string> tmp;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (tmp.size()) tmp.pop_back();\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp.push_back(res);\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = tmp.size() ? \"\" : \"/\";\\n        for (string w: tmp) res += \"/\" + w;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // support variables\\n        string res, tmp[50];\\n        int pos = 0;\\n        // parsing path\\n        // for (int i = i, lmt = path.size(); i < lmt; i++) {\\n            // if (path[i] != \\'/\\') res.append(path[i]);\\n        for (int i = 1, c, lmt = path.size() - 1; i <= lmt; i++) {\\n            c = path[i];\\n            // case 1: c is part of a folder name\\n            if (c != \\'/\\') res.append(1, c);\\n            // case 2: end of a folder name\\n            if (c == \\'/\\' || i == lmt) {\\n                // sub-case 2-1: parent directory\\n                if (res == \"..\") {\\n                    if (pos) pos--;\\n                }\\n                // sub-case 2-2: res is valid and not the current directory\\n                else if (res.size() && res != \".\") tmp[pos++] = res;\\n                // resetting res\\n                res = \"\";\\n            }\\n        }\\n        // composing res\\n        res = pos ? \"\" : \"/\";\\n        for (int i = 0; i < pos; i++) res += \"/\" + tmp[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187271,
                "title": "easy-java-solution-using-stack",
                "content": "```\\npublic String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        Stack<String> st = new Stack<>();\\n        for(String s:paths){\\n            if(s.equals(\"\")) continue;\\n            else if(s.equals(\".\")) continue;\\n            else if(s.equals(\"..\")) \\n                if(!st.isEmpty()) st.pop();\\n                else continue;\\n            else st.add(s);\\n        }\\n        return \"/\"+String.join(\"/\", st);\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        Stack<String> st = new Stack<>();\\n        for(String s:paths){\\n            if(s.equals(\"\")) continue;\\n            else if(s.equals(\".\")) continue;\\n            else if(s.equals(\"..\")) \\n                if(!st.isEmpty()) st.pop();\\n                else continue;\\n            else st.add(s);\\n        }\\n        return \"/\"+String.join(\"/\", st);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847420,
                "title": "java-simple-java-code-explained-algorithm-stack",
                "content": "Sample case  2 Explain  ->   ![image](https://assets.leetcode.com/users/images/8cbf8af5-2ad5-4fa8-ba71-f8b077be63a2_1647222748.909183.jpeg)\\n\\n\\n![image](https://assets.leetcode.com/users/images/33223edb-ee01-4b32-ba7c-f3680384d4bd_1647222828.2566357.jpeg)\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        \\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        \\n        Stack<String> s = new Stack<>();\\n        StringBuilder res = new StringBuilder();\\n        String[] p =path.split(\"/\");\\n        \\n        for(int i=0;i<p.length;i++){\\n            if(!s.isEmpty()  && p[i].equals(\"..\")) s.pop();\\n            else if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\"))\\n                s.push(p[i]);\\n        }\\n        \\n        \\n        if(s.isEmpty()) return \"/\";\\n        while(!s.isEmpty()){\\n            res.insert(0,s.pop()).insert(0,\"/\");\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492803,
                "title": "c-76-ms-manipulate-string-array-from-split-or-80-ms-linkedlist",
                "content": "I originally used a Stack, but realized I had to reverse it, then I switched to a List, but deletions are slow, so I switched to a LinkedList and it is pretty quick and requires no reversal, then I realized you can just manipulate the array returned from the string.Split and keep track of how many tokens in the path.\\n\\n76 ms.\\n```\\n    public string SimplifyPath(string path) {\\n        \\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        int itemCount = 0;\\n        \\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(itemCount > 0) itemCount--;\\n                    break;\\n                default:\\n                    tokens[itemCount++] = tokens[i];\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', tokens, 0, itemCount);\\n    }\\n```\\n\\n80 ms. Linked List\\n\\n```\\n    public string SimplifyPath(string path) {\\n\\t\\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        var answerList = new LinkedList<string>();\\n\\t\\t\\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(answerList.Count > 0) answerList.RemoveLast();\\n                    break;\\n                default:\\n                    answerList.AddLast(tokens[i]);\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', answerList);\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public string SimplifyPath(string path) {\\n        \\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        int itemCount = 0;\\n        \\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(itemCount > 0) itemCount--;\\n                    break;\\n                default:\\n                    tokens[itemCount++] = tokens[i];\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', tokens, 0, itemCount);\\n    }\\n```\n```\\n    public string SimplifyPath(string path) {\\n\\t\\n        var tokens = path.Split(\\'/\\', StringSplitOptions.RemoveEmptyEntries);\\n        var answerList = new LinkedList<string>();\\n\\t\\t\\n        for(int i = 0; i < tokens.Length; i++){\\n            switch(tokens[i]){\\n                case \".\":\\n                    break;\\n                case \"..\":\\n                    if(answerList.Count > 0) answerList.RemoveLast();\\n                    break;\\n                default:\\n                    answerList.AddLast(tokens[i]);\\n                    break;\\n            }\\n        }\\n        \\n        return \"/\" + string.Join(\\'/\\', answerList);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455100,
                "title": "c-stack-solution",
                "content": "We use a stack to store each layer of the directory.\\nWe loop the path and parse each directory separating by `/`\\n\\n- If we get an empty directory or `.`, we do nothing\\n- If we get a `..`, we pop out the top element from the stack (if it is not empty)\\n- If we get anything else, we push the directory to the stack\\n\\nAt the end, we reconstruct the simplified path from the stack and return.\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        int i = 0;\\n        string cur = \"\";\\n        path += \\'/\\';\\n        // loop path and construct stack\\n        while (i < path.size()) {\\n            if (path[i] == \\'/\\') {\\n                if (!cur.empty()) {\\n                    if (cur == \".\") {\\n                        // do nothing\\n                    }\\n                    else if (cur == \"..\") {\\n                        // remove the last dir\\n                        if (!st.empty()) {\\n                            st.pop();\\n                        }\\n                    }\\n                    else {\\n                        // append the cur dir\\n                        st.push(cur);\\n                    }\\n                }\\n                cur.clear();\\n                i += 1;\\n            }\\n            else {\\n                cur += path[i];\\n                i += 1;\\n            }\\n        }\\n        // construct result string from stack\\n        string rst = \"\";\\n        while (!st.empty()) {\\n            rst = \"/\" + st.top() + rst;\\n            st.pop();\\n        }\\n        if (rst.empty()) rst += \\'/\\';\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        int i = 0;\\n        string cur = \"\";\\n        path += \\'/\\';\\n        // loop path and construct stack\\n        while (i < path.size()) {\\n            if (path[i] == \\'/\\') {\\n                if (!cur.empty()) {\\n                    if (cur == \".\") {\\n                        // do nothing\\n                    }\\n                    else if (cur == \"..\") {\\n                        // remove the last dir\\n                        if (!st.empty()) {\\n                            st.pop();\\n                        }\\n                    }\\n                    else {\\n                        // append the cur dir\\n                        st.push(cur);\\n                    }\\n                }\\n                cur.clear();\\n                i += 1;\\n            }\\n            else {\\n                cur += path[i];\\n                i += 1;\\n            }\\n        }\\n        // construct result string from stack\\n        string rst = \"\";\\n        while (!st.empty()) {\\n            rst = \"/\" + st.top() + rst;\\n            st.pop();\\n        }\\n        if (rst.empty()) rst += \\'/\\';\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379753,
                "title": "java-stack-explained-clean",
                "content": "Stack is superb for this problem - in case we go back (up) - just pop from stack. We can tokenize initial path using string.split.\\n\\n```\\n    public String simplifyPath(String path) {\\n        //parse string to initial tokens\\n        String[] vals = path.split(\"/\");\\n        //start iterating on path segments using stack to store results. Most tokens we can simply ignore\\n        Stack<String> s = new Stack();\\n        for (String p : vals) {\\n            //these cases refer to current dir and multiple \"/\"\\n            if (p.length() == 0 || p.equals(\".\"))\\n                continue;\\n            //in case we have to go back - just pop from stack\\n            else if (p.equals(\"..\")) {\\n                if (!s.isEmpty())\\n                    s.pop();\\n            }\\n            //all other cases - push to stack\\n            else\\n                s.push(p);\\n        }\\n        //no build the final path string\\n        String res = \"\";\\n        while (!s.isEmpty()) {\\n            res = \"/\" + s.pop() + res;\\n        }\\n        //in case we haven\\'t met any path segments - return just root folder\\n        return res.length() == 0 ? \"/\" : res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String simplifyPath(String path) {\\n        //parse string to initial tokens\\n        String[] vals = path.split(\"/\");\\n        //start iterating on path segments using stack to store results. Most tokens we can simply ignore\\n        Stack<String> s = new Stack();\\n        for (String p : vals) {\\n            //these cases refer to current dir and multiple \"/\"\\n            if (p.length() == 0 || p.equals(\".\"))\\n                continue;\\n            //in case we have to go back - just pop from stack\\n            else if (p.equals(\"..\")) {\\n                if (!s.isEmpty())\\n                    s.pop();\\n            }\\n            //all other cases - push to stack\\n            else\\n                s.push(p);\\n        }\\n        //no build the final path string\\n        String res = \"\";\\n        while (!s.isEmpty()) {\\n            res = \"/\" + s.pop() + res;\\n        }\\n        //in case we haven\\'t met any path segments - return just root folder\\n        return res.length() == 0 ? \"/\" : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181198,
                "title": "c-easy-to-understand-solution",
                "content": "```\\n    string simplifyPath(string path) {\\n        stack<string> dir;\\n        string res = \"\", val;\\n        istringstream ss(path);\\n        while(getline(ss, val, \\'/\\')){\\n            if(val.size() == 0 || val == \".\")\\n                continue;\\n            if(val == \"..\") {\\n                if(!dir.empty())\\n                    dir.pop();\\n            } else {\\n                dir.push(val);\\n            }\\n        }\\n        \\n        if(dir.empty())\\n            return \"/\";\\n        \\n        while(!dir.empty()){\\n            res = \"/\" + dir.top() + res;\\n            dir.pop();\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    string simplifyPath(string path) {\\n        stack<string> dir;\\n        string res = \"\", val;\\n        istringstream ss(path);\\n        while(getline(ss, val, \\'/\\')){\\n            if(val.size() == 0 || val == \".\")\\n                continue;\\n            if(val == \"..\") {\\n                if(!dir.empty())\\n                    dir.pop();\\n            } else {\\n                dir.push(val);\\n            }\\n        }\\n        \\n        if(dir.empty())\\n            return \"/\";\\n        \\n        while(!dir.empty()){\\n            res = \"/\" + dir.top() + res;\\n            dir.pop();\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 25820,
                "title": "ac-solution-in-java",
                "content": "    public class Solution {\\n        public String simplifyPath(String path) {\\n            Set<String> isSkip = new HashSet<>(Arrays.asList(\"\", \".\", \"..\"));\\n            Deque<String> stack = new ArrayDeque<>();\\n            for (String token : path.split(\"/\")) {\\n                if (token.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n                if (isSkip.contains(token)) continue;\\n                stack.push(token);\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            while (!stack.isEmpty()) {\\n                sb.append(\"/\" + stack.pollLast());\\n            }\\n            return sb.length() == 0 ? \"/\" : sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            Set<String> isSkip = new HashSet<>(Arrays.asList(\"\", \".\", \"..\"));\\n            Deque<String> stack = new ArrayDeque<>();\\n            for (String token : path.split(\"/\")) {\\n                if (token.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n                if (isSkip.contains(token)) continue;\\n                stack.push(token);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3406723,
                "title": "very-simple-and-concise-solution-with-explanation",
                "content": "## Approach \\n\\nIn a Unix-style file system, a period `.` refers to the current directory and a double period `..` refers to the directory up a level. For example, if we are in the directory /a/b/c/d and we want to go up one level, we can use `..` to get to /a/b/c.\\n\\nThe simplified canonical path should start with a single slash `/`, and any two directories should be separated by a single slash `/`. It should not end with a trailing slash `/`, and it should not contain any periods `.` or double periods `..`.\\n\\nTo achieve this, the given solution first creates an empty array called `simplifiedPath` to store the simplified path. It then splits the input `path` into individual directories using the forward slash `/` as a separator, and stores them in an array called `dirs`.\\n\\nThe function then goes through each directory in the `dirs` array using a `for...of` loop. If the directory is an empty string or a period `.`, it skips over it and moves to the next directory. If the directory is a double period `..`, it removes the last directory added to the `simplifiedPath` array using the `pop()` method, effectively moving up one level. If the directory is anything else, it adds it to the `simplifiedPath` array.\\n\\nFinally, the function joins all the directories in the `simplifiedPath` array using the forward slash `/` as a separator, and concatenates it with a single slash `/` at the beginning to create the simplified canonical path. The resulting path is then returned as a string.\\n\\n## JavaScript Solution\\n```\\nvar simplifyPath = function (path) {\\n  const simplifiedPath = [];\\n  const dirs = path.split(\"/\");\\n\\n  for (const dir of dirs) {\\n    if (dir === \"\" || dir === \".\") continue;\\n    dir === \"..\" ? simplifiedPath.pop() : simplifiedPath.push(dir);\\n  }\\n\\n  return \"/\" + simplifiedPath.join(\"/\");\\n};\\n\\n```\\n\\n## Go Solution\\n```go\\nimport \"strings\"\\n\\nfunc simplifyPath(path string) string {\\n\\tsimplifiedPath := make([]string, 0)\\n\\tdirs := strings.Split(path, \"/\")\\n\\n\\tfor _, dir := range dirs {\\n\\t\\tif dir == \"\" || dir == \".\" { continue }\\n\\t\\tif dir != \"..\" {\\n\\t\\t\\tsimplifiedPath = append(simplifiedPath, dir)\\n\\t\\t} else if len(simplifiedPath) > 0 {\\n\\t\\t\\tsimplifiedPath = simplifiedPath[:len(simplifiedPath)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn \"/\" + strings.Join(simplifiedPath, \"/\")\\n}\\n```\\n\\n## Rust Solution\\n```rust\\nimpl Solution {\\n    pub fn simplify_path(path: String) -> String {\\n        let mut simplified_path = vec![];\\n        for dir in path.split(\\'/\\') {\\n            match dir {\\n                \"\" | \".\" => continue,\\n                \"..\" => { simplified_path.pop(); }\\n                _ => simplified_path.push(dir),\\n            }\\n        }\\n\\n        \"/\".to_owned() + &simplified_path.join(\"/\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust",
                    "String",
                    "Stack"
                ],
                "code": "```\\nvar simplifyPath = function (path) {\\n  const simplifiedPath = [];\\n  const dirs = path.split(\"/\");\\n\\n  for (const dir of dirs) {\\n    if (dir === \"\" || dir === \".\") continue;\\n    dir === \"..\" ? simplifiedPath.pop() : simplifiedPath.push(dir);\\n  }\\n\\n  return \"/\" + simplifiedPath.join(\"/\");\\n};\\n\\n```\n```go\\nimport \"strings\"\\n\\nfunc simplifyPath(path string) string {\\n\\tsimplifiedPath := make([]string, 0)\\n\\tdirs := strings.Split(path, \"/\")\\n\\n\\tfor _, dir := range dirs {\\n\\t\\tif dir == \"\" || dir == \".\" { continue }\\n\\t\\tif dir != \"..\" {\\n\\t\\t\\tsimplifiedPath = append(simplifiedPath, dir)\\n\\t\\t} else if len(simplifiedPath) > 0 {\\n\\t\\t\\tsimplifiedPath = simplifiedPath[:len(simplifiedPath)-1]\\n\\t\\t}\\n\\t}\\n\\n\\treturn \"/\" + strings.Join(simplifiedPath, \"/\")\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn simplify_path(path: String) -> String {\\n        let mut simplified_path = vec![];\\n        for dir in path.split(\\'/\\') {\\n            match dir {\\n                \"\" | \".\" => continue,\\n                \"..\" => { simplified_path.pop(); }\\n                _ => simplified_path.push(dir),\\n            }\\n        }\\n\\n        \"/\".to_owned() + &simplified_path.join(\"/\")\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1848456,
                "title": "c-easy-to-understand-using-stack-daily-leetcoding-challenge-march-day-14",
                "content": "// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n\\n**Approach**\\n* Just store the **Folder** names in the stack (string between the 2 slashes) one by one\\n\\n* when we come across \\u201D . \\u201D we do nothing\\n\\n* When we find \\u201C..\\u201D in our path, we simply pop the topmost element as we have to jump back to parent\\u2019s directory according to given condition\\n\\n* When we see multiple \\u201C////\\u201D we just ignore them as they are equivalent to one single \\u201C/\\u201D\\n\\n* After iterating through the whole string the elements remaining in the stack is our answer\\n\\n**Time Complexity   : O(n)**\\n**Space Complexity : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string> st;                            // created the stack for stroing the Folder names\\n        string ans =\"\";                              // it will store the final ans\\n        \\n        for(int i=0;i<path.size();i++)               // iterate over the whole given string\\n        {\\n            // if it is a backslash then just ignore it because it is not the Folder name\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            // if it is not / then try to store our Folder name till we do not find next /\\n            // store the Folder name in temp string\\n            string temp = \"\";\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n            \\n            // after storing the Folder\\n            // just check the symbols \\n            \\n            // ignoring .\\n            if(temp==\".\")\\n                continue;\\n            \\n            // if it is \\'..\\' move to previous Folder \\n            else if(temp==\"..\")\\n            {\\n                // according to our given condition \\n                // if it is \\'..\\' move to previous Folder\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            \\n            else\\n            {\\n                // else store our all Folder names into the stack\\n                st.push(temp);\\n            }\\n        }\\n        \\n        // store the Folder names from stack to the ans string \\n        // in given firmat \"/Folder_name\"\\n        while(!st.empty())\\n        {\\n            ans = \"/\" + st.top() + ans;            // just following the format\\n            st.pop();\\n        }\\n        \\n        // if there is empty string \\n        if(ans.size() == 0)\\n            return \"/\";\\n        \\n        return ans;\\n    }\\n};\\n```\\n// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string> st;                            // created the stack for stroing the Folder names\\n        string ans =\"\";                              // it will store the final ans\\n        \\n        for(int i=0;i<path.size();i++)               // iterate over the whole given string\\n        {\\n            // if it is a backslash then just ignore it because it is not the Folder name\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            // if it is not / then try to store our Folder name till we do not find next /\\n            // store the Folder name in temp string\\n            string temp = \"\";\\n            while(i<path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n            \\n            // after storing the Folder\\n            // just check the symbols \\n            \\n            // ignoring .\\n            if(temp==\".\")\\n                continue;\\n            \\n            // if it is \\'..\\' move to previous Folder \\n            else if(temp==\"..\")\\n            {\\n                // according to our given condition \\n                // if it is \\'..\\' move to previous Folder\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            \\n            else\\n            {\\n                // else store our all Folder names into the stack\\n                st.push(temp);\\n            }\\n        }\\n        \\n        // store the Folder names from stack to the ans string \\n        // in given firmat \"/Folder_name\"\\n        while(!st.empty())\\n        {\\n            ans = \"/\" + st.top() + ans;            // just following the format\\n            st.pop();\\n        }\\n        \\n        // if there is empty string \\n        if(ans.size() == 0)\\n            return \"/\";\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050681,
                "title": "python-simple-short-6-line-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        \\n        for d in path.split(\"/\"):\\n            if d == \"..\": \\n                if stack: stack.pop(-1)\\n                    \\n            elif d and d != \".\": stack.append(d)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        \\n        for d in path.split(\"/\"):\\n            if d == \"..\": \\n                if stack: stack.pop(-1)\\n                    \\n            elif d and d != \".\": stack.append(d)\\n                \\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161111,
                "title": "java-string",
                "content": "We build the simplified path from scratch:\\n1. split path by \"/\"\\n2. backtrack if meets \"..\", do nothing if meets \".\" or \"\"\\n3. reconstruct the path by adding \"/\" in between (with heading \"/\")\\n\\n```\\n    public String simplifyPath(String path) {\\n        String[] dirNames = path.split(\"/\");\\n        \\n        // shortest (substitute . or ..)\\n        List<String> simplified = new ArrayList<>();\\n        for (String name : dirNames) {\\n            if (!name.isEmpty() && !name.equals(\".\")) {\\n                if (name.equals(\"..\")) {\\n                    if (!simplified.isEmpty()) {\\n                        simplified.remove(simplified.size() - 1);\\n                    }\\n                } else { \\n                    simplified.add(name);\\n                }\\n            } \\n        }\\n            \\n        // start with /, single / between two directory names\\n        StringBuilder simplifiedPath = new StringBuilder();\\n        for (String name : simplified) {\\n            simplifiedPath.append(\"/\").append(name);\\n        }\\n        \\n        return simplifiedPath.length() == 0 ? \"/\" : simplifiedPath.toString();   \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String simplifyPath(String path) {\\n        String[] dirNames = path.split(\"/\");\\n        \\n        // shortest (substitute . or ..)\\n        List<String> simplified = new ArrayList<>();\\n        for (String name : dirNames) {\\n            if (!name.isEmpty() && !name.equals(\".\")) {\\n                if (name.equals(\"..\")) {\\n                    if (!simplified.isEmpty()) {\\n                        simplified.remove(simplified.size() - 1);\\n                    }\\n                } else { \\n                    simplified.add(name);\\n                }\\n            } \\n        }\\n            \\n        // start with /, single / between two directory names\\n        StringBuilder simplifiedPath = new StringBuilder();\\n        for (String name : simplified) {\\n            simplifiedPath.append(\"/\").append(name);\\n        }\\n        \\n        return simplifiedPath.length() == 0 ? \"/\" : simplifiedPath.toString();   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25781,
                "title": "c-implementation",
                "content": "    class Solution {\\n    public:\\n        string simplifyPath(string path) {\\n            vector<string> st;\\n            vector<string> nodes;\\n            string result;\\n            split(path, '/', nodes);\\n            for(auto node : nodes) {\\n                //empty or only '.' path no change\\n                if(node == \"\" || node == \".\")  continue;\\n                //go back to the upper directory\\n                if(node == \"..\" && !st.empty())  st.pop_back();\\n                //push back the current directory\\n                else if(node != \"..\")  st.push_back(node);\\n            }\\n            for(auto it : st) result += \"/\" + it;\\n            return result.empty() ? \"/\" : result;\\n        }\\n        \\n        void split(string s, char delim, vector<string>& nodes) {\\n            string temp;\\n            stringstream ss(s);\\n            while(getline(ss, temp, delim)) {\\n                nodes.push_back(temp);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string simplifyPath(string path) {\\n            vector<string> st;\\n            vector<string> nodes;\\n            string result;\\n            split(path, '/', nodes);\\n            for(auto node : nodes) {\\n                //empty or only '.' path no change\\n                if(node == \"\" || node == \".\")  continue;\\n                //go back to the upper directory\\n                if(node == \"..\" && !st.empty())  st.pop_back();\\n                //push back the current directory\\n                else if(node != \"..\")  st.push_back(node);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3408365,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        return __import__(\\'os\\').path.abspath(path)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        return __import__(\\'os\\').path.abspath(path)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407238,
                "title": "python-simple-solution-using-stack",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n\\n        # different directories present in the string\\n        temp = path.split(\\'/\\') \\n\\n        for i in temp:\\n            if i != \\'.\\' and i != \\'\\' and i != \\'..\\':\\n                stack.append(i) # add if it is directory\\n\\n            # move to back directory if \\'..\\'\\n            elif i == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n        \\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n\\n        # different directories present in the string\\n        temp = path.split(\\'/\\') \\n\\n        for i in temp:\\n            if i != \\'.\\' and i != \\'\\' and i != \\'..\\':\\n                stack.append(i) # add if it is directory\\n\\n            # move to back directory if \\'..\\'\\n            elif i == \\'..\\':\\n                if stack:\\n                    stack.pop()\\n        \\n        return \\'/\\' + \\'/\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406774,
                "title": "java-easy-solution-using-split-method-beginner-friendly-98-faster-code-stringbuilder",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n     public String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        int left = -1, right = 0;\\n        while (right < paths.length) {\\n        \\tif (paths[right].equals(\"..\"))\\n        \\t\\tleft = left == -1 ? -1 : left - 1;\\n        \\telse if (!paths[right].equals(\".\") && !paths[right].equals(\"\"))\\n        \\t\\tpaths[++left] = paths[right];\\n        \\tright++;\\n        }\\n        if (left == -1)\\n        \\treturn \"/\";\\n        StringBuilder buf = new StringBuilder();\\n        for (int i = 0; i <= left; i++)\\n        \\tbuf.append(\\'/\\').append(paths[i]);\\n        return buf.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public String simplifyPath(String path) {\\n        String[] paths = path.split(\"/\");\\n        int left = -1, right = 0;\\n        while (right < paths.length) {\\n        \\tif (paths[right].equals(\"..\"))\\n        \\t\\tleft = left == -1 ? -1 : left - 1;\\n        \\telse if (!paths[right].equals(\".\") && !paths[right].equals(\"\"))\\n        \\t\\tpaths[++left] = paths[right];\\n        \\tright++;\\n        }\\n        if (left == -1)\\n        \\treturn \"/\";\\n        StringBuilder buf = new StringBuilder();\\n        for (int i = 0; i <= left; i++)\\n        \\tbuf.append(\\'/\\').append(paths[i]);\\n        return buf.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808626,
                "title": "c-easy-solution-stack",
                "content": "**If you like the solution please upvote it.**\\n\\n\\tstring simplifyPath(string path) {\\n        int n = path.size();\\n        if(path.back()!=\\'/\\') {\\n            path.push_back(\\'/\\');\\n            n++;\\n        }\\n        cout << path << \" \" << n << endl;\\n        string temp;\\n        stack<string> st;\\n        int i=1;\\n        while(i<n) {\\n            if(path[i] == \\'/\\') {\\n                if(temp==\"\" || temp==\".\") {\\n                    temp = \"\";\\n                }\\n                else if(temp==\"..\") {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else \\n                    st.push(temp);\\n                temp=\"\";\\n            }\\n            else {\\n                temp.push_back(path[i]);\\n            }\\n            i++;\\n        }\\n        string res=\"\";\\n        while(!st.empty()) {\\n            res = \"/\"+st.top()+res;\\n            st.pop();\\n        }\\n        if(res.length()==0)\\n            res.push_back(\\'/\\');\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "**If you like the solution please upvote it.**\\n\\n\\tstring simplifyPath(string path) {\\n        int n = path.size();\\n        if(path.back()!=\\'/\\') {\\n            path.push_back(\\'/\\');\\n            n++;\\n        }\\n        cout << path << \" \" << n << endl;\\n        string temp;\\n        stack<string> st;\\n        int i=1;\\n        while(i<n) {\\n            if(path[i] == \\'/\\') {\\n                if(temp==\"\" || temp==\".\") {\\n                    temp = \"\";\\n                }\\n                else if(temp==\"..\") {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else \\n                    st.push(temp);\\n                temp=\"\";\\n            }\\n            else {\\n                temp.push_back(path[i]);\\n            }\\n            i++;\\n        }\\n        string res=\"\";\\n        while(!st.empty()) {\\n            res = \"/\"+st.top()+res;\\n            st.pop();\\n        }\\n        if(res.length()==0)\\n            res.push_back(\\'/\\');\\n        return res;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1553245,
                "title": "stack-solution-easy-to-understand-tc-sc-o-n",
                "content": "**71. Simply Path - Solution**\\n\\nPseudo Code:\\nfunction simplyPath (string path)\\n1. Input : *path*\\n2. Declare a stack variable, *s*\\n3.  Declare string variables, *directory* & *result*\\n4.  Add \\'/\\' to path (why: to mark the end of the last directory if the *path* doesn\\'t end with \\'/\\' )\\n5.  Traverse through *path*\\n     a. Let current character be *curr*\\n\\t b.if *curr* is not \\'/\\' , then concatenate *curr* to *directory* (why: Assuming anything that is not \\'/\\' is going to be the directory name, and we handle \".\" , \"..\" accordingly)\\n\\t c. else\\n\\t     &nbsp;&nbsp;&nbsp; - if *directory* is empty or \".\" , then do nothing\\n\\t\\t &nbsp;&nbsp;&nbsp; - else if *directory* = \"..\" , then pop from stack, *s* (why: \"..\" represent directory up a level. so, the last encountered directory is not required)\\n\\t\\t &nbsp;&nbsp;&nbsp; - else push *directory* to the stack, *s* (why: anything non-null string other than \".\" , \"..\" represent a directory)\\n\\t\\t &nbsp;&nbsp;&nbsp; - end if\\n\\t\\t &nbsp;&nbsp;&nbsp; - clear *directory* value (why: to store next directory name)\\n\\t  d. end if\\n6. if stack, *s* is empty return \"/\"\\n7. end if\\n8. while stack, *s* is not empty\\n     a. Replace *result* with \\'/\\' + stack top + *result*\\n     b. pop from stack, *s*\\n9. end while\\n10. return *result*\\n\\n```\\nstring simplifyPath(string path) {\\n        stack<string> s; \\n        string directory, result;\\n        \\n        path+=\\'/\\';               \\n        \\n        for(int i=0;i<path.size();i++){\\n            if(path[i]!=\\'/\\')\\n                directory+=path[i];\\n            else {\\n                  if(directory.length()==0 || directory==\".\") {}\\n                  else if(directory==\"..\") {\\n                     if(!s.empty())\\n                        s.pop();\\n                  }\\n                  else               \\n                     s.push(directory);\\n                  directory=\"\";\\n            }            \\n        }\\n        \\n        if(s.size()==0)\\n            return \"/\";\\n        \\n        while(!s.empty()){\\n            result=\"/\"+s.top()+result;\\n            s.pop();\\n        }\\n        \\n        return result;\\n}\\n```\\nHope it helps!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring simplifyPath(string path) {\\n        stack<string> s; \\n        string directory, result;\\n        \\n        path+=\\'/\\';               \\n        \\n        for(int i=0;i<path.size();i++){\\n            if(path[i]!=\\'/\\')\\n                directory+=path[i];\\n            else {\\n                  if(directory.length()==0 || directory==\".\") {}\\n                  else if(directory==\"..\") {\\n                     if(!s.empty())\\n                        s.pop();\\n                  }\\n                  else               \\n                     s.push(directory);\\n                  directory=\"\";\\n            }            \\n        }\\n        \\n        if(s.size()==0)\\n            return \"/\";\\n        \\n        while(!s.empty()){\\n            result=\"/\"+s.top()+result;\\n            s.pop();\\n        }\\n        \\n        return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051451,
                "title": "go-stack-100-o-n-two-solutions-unit-test",
                "content": "The problem statement asks us to normalize a given path from notation having references to a  current `\".\"` and/or parent `\"..\"` directories to the canonical, absolute path. A given path is a list of directories separated by `\"/\"`, optionally having aforementioned references injected into it. To convert a path into canonical one we can split it by the separator `\"/\"` and normalize split list using _stack_ (basically, truncate split list) to manage references to parent directories `\"..\"` efficiently.\\n\\n    import (\\n    \\t\"strings\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\tstack := []string{}\\n    \\tchunks := strings.Split(path, \"/\")\\n    \\tfor _, chunk := range chunks {\\n    \\t\\tswitch chunk {\\n    \\t\\tcase \".\", \"\":\\n    \\t\\t\\tcontinue\\n    \\t\\tcase \"..\":\\n    \\t\\t\\tif len(stack) > 0 {\\n    \\t\\t\\t\\tstack = stack[:len(stack)-1]\\n    \\t\\t\\t}\\n    \\t\\tdefault:\\n    \\t\\t\\tstack = append(stack, chunk)\\n    \\t\\t}\\n    \\t}\\n    \\treturn \"/\" + strings.Join(stack, \"/\")\\n    }\\n\\n**Complexity:**\\n- Time: 0(n)\\n- Space: 0(n)\\n\\nAnother approach is to (cheat ;) and use standard library: \\n\\n    import (\\n    \\tp \"path\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\treturn p.Clean(path)\\n    }\\n\\nThe code of both approaches covered with unit test is available at the Go playground by the URL https://play.golang.org/p/d9gP8PI5mnj\\n\\nIf you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Go"
                ],
                "code": "The problem statement asks us to normalize a given path from notation having references to a  current `\".\"` and/or parent `\"..\"` directories to the canonical, absolute path. A given path is a list of directories separated by `\"/\"`, optionally having aforementioned references injected into it. To convert a path into canonical one we can split it by the separator `\"/\"` and normalize split list using _stack_ (basically, truncate split list) to manage references to parent directories `\"..\"` efficiently.\\n\\n    import (\\n    \\t\"strings\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\tstack := []string{}\\n    \\tchunks := strings.Split(path, \"/\")\\n    \\tfor _, chunk := range chunks {\\n    \\t\\tswitch chunk {\\n    \\t\\tcase \".\", \"\":\\n    \\t\\t\\tcontinue\\n    \\t\\tcase \"..\":\\n    \\t\\t\\tif len(stack) > 0 {\\n    \\t\\t\\t\\tstack = stack[:len(stack)-1]\\n    \\t\\t\\t}\\n    \\t\\tdefault:\\n    \\t\\t\\tstack = append(stack, chunk)\\n    \\t\\t}\\n    \\t}\\n    \\treturn \"/\" + strings.Join(stack, \"/\")\\n    }\\n\\n**Complexity:**\\n- Time: 0(n)\\n- Space: 0(n)\\n\\nAnother approach is to (cheat ;) and use standard library: \\n\\n    import (\\n    \\tp \"path\"\\n    )\\n    \\n    func simplifyPath(path string) string {\\n    \\treturn p.Clean(path)\\n    }\\n\\nThe code of both approaches covered with unit test is available at the Go playground by the URL https://play.golang.org/p/d9gP8PI5mnj\\n\\nIf you like solution and explanations, please **Upvote!**",
                "codeTag": "Python3"
            },
            {
                "id": 1051132,
                "title": "simplify-path-easy-python-solution",
                "content": "```\\ndef simplifyPath(self, path: str) -> str:\\n        \\n        stack = []\\n        \\n        path = path.split(\\'/\\')\\n        \\n        for p in path:\\n            if not p or p==\\'.\\':\\n                continue\\n            elif p==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n                \\n                \\n        root = \"/\"\\n        \\n        return root + \"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef simplifyPath(self, path: str) -> str:\\n        \\n        stack = []\\n        \\n        path = path.split(\\'/\\')\\n        \\n        for p in path:\\n            if not p or p==\\'.\\':\\n                continue\\n            elif p==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(p)\\n                \\n                \\n        root = \"/\"\\n        \\n        return root + \"/\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 225602,
                "title": "c-4ms-beats-100-simple-explanation",
                "content": "## Simplify Path\\n\\n### Approach: 4ms, beats 100%\\nThe approach for this question is really simple. The visited directories are kept track of using a stack. The following rules need to be taken care of:\\n1)Each non empty string between two consecutive \\'/\\' resemble a directory.\\n2)If this string is \\'.\\' then ignore it.\\n3)If this string is \\'..\\' then remove the last opened directory(present working directory) from the top of stack, if the stack is non empty.\\n4)Otherwise, the string resembles a new directory name and hence it is to be pushed into the stack.\\n\\nContinue the above procedure till the entire input path hasnt been traversed. In case the last character of the path is not \\'/\\', we have to check the string constituting the name of the last directory in the path and check if it is \\'.\\', \\'..\\' or something else and operate on it as in the above steps.\\n\\nPop the stack and store the strings in reserse order in the answer string seperated by using \\'/\\' as delimiter. If the answer string is empty then return \"/\", else return the answer string.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string s = \"\";\\n        stack<string> stck;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            char c = path[i];\\n            if(c==\\'/\\')\\n            {\\n                if(s==\"..\")\\n                {\\n                    if(!stck.empty())\\n                    {\\n                    stck.pop();\\n                    s=\"\";\\n                    }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n            s=\"\";\\n            continue;\\n            }\\n            s+=c;\\n        }\\n        if(path[path.size()-1]!=\\'/\\')\\n        {\\n            if(s==\"..\")\\n            {\\n                if(!stck.empty())\\n                {\\n                    stck.pop();\\n                }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n        }\\n        s = \"\";\\n        while(!stck.empty())\\n        {\\n            s = \"/\"+stck.top()+s;\\n            stck.pop();\\n        }\\n        if(s==\"\")\\n        {\\n            return \"/\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string s = \"\";\\n        stack<string> stck;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            char c = path[i];\\n            if(c==\\'/\\')\\n            {\\n                if(s==\"..\")\\n                {\\n                    if(!stck.empty())\\n                    {\\n                    stck.pop();\\n                    s=\"\";\\n                    }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n            s=\"\";\\n            continue;\\n            }\\n            s+=c;\\n        }\\n        if(path[path.size()-1]!=\\'/\\')\\n        {\\n            if(s==\"..\")\\n            {\\n                if(!stck.empty())\\n                {\\n                    stck.pop();\\n                }\\n            }\\n            else if(s!=\"\" && s!=\".\")\\n            {\\n                stck.push(s);\\n            }\\n        }\\n        s = \"\";\\n        while(!stck.empty())\\n        {\\n            s = \"/\"+stck.top()+s;\\n            stck.pop();\\n        }\\n        if(s==\"\")\\n        {\\n            return \"/\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25756,
                "title": "my-5ms-java-solution-without-stack-and-deque-beats-98-of-solutions",
                "content": "First to first, there is no stack or deque used in my solution. The only thing I did is just to transfer original string into char array.\\n\\nMy idea is:\\n Key: Use a counter to count how many times \"..\" appears before we handle a normal string of part of the path.\\n\\n1. go through the char array from end to start\\n2. ignore all '/' characters\\n3. get string between '/'\\n4. handle this string in 4 branches:\\n4.a if it is empty or equals to \".\", do nothing\\n4.b if it is equals to \"..\", counter++\\n4.c if the counter is greater than 0, then counter--\\n4.d else ( counter == 0) do concatenation of result with current part of path.\\n\\nMy code: \\n```\\npublic String simplifyPath(String path) {\\n        String ans = \"\";\\n        char[] chars = path.toCharArray();\\n        int i = chars.length - 1;\\n        // a counter to count how many times \"..\" shows up\\n        int count = 0;  \\n        while ( i >=0) {\\n            int j = i;\\n            while( j >= 0 && chars[j] == '/')\\n                j--;\\n            int k = j;\\n            while(k >=0 && chars[k] != '/')\\n                k--;\\n            String part = String.valueOf(chars, k+1, j-k);\\n            if (part.isEmpty() || part.equals(\".\")){\\n                // do nothing\\n            }\\n            // count appearence of \"..\"\\n            else if(part.equals(\"..\")) \\n                count++;\\n           // ignore current part, \\n           //because there is \"..\" after it\\n           else if (count > 0) \\n                count--;\\n           // count == 0, no need to ignore current part \\n           // and do result concatenation\\n            else\\n                ans = \"/\" + part + ans;\\n            i = k;\\n        }\\n        return ans.isEmpty()? \"/\" : ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "First to first, there is no stack or deque used in my solution. The only thing I did is just to transfer original string into char array.\\n\\nMy idea is:\\n Key: Use a counter to count how many times \"..\" appears before we handle a normal string of part of the path.\\n\\n1. go through the char array from end to start\\n2. ignore all '/' characters\\n3. get string between '/'\\n4. handle this string in 4 branches:\\n4.a if it is empty or equals to \".\", do nothing\\n4.b if it is equals to \"..\", counter++\\n4.c if the counter is greater than 0, then counter--\\n4.d else ( counter == 0) do concatenation of result with current part of path.\\n\\nMy code: \\n```\\npublic String simplifyPath(String path) {\\n        String ans = \"\";\\n        char[] chars = path.toCharArray();\\n        int i = chars.length - 1;\\n        // a counter to count how many times \"..\" shows up\\n        int count = 0;  \\n        while ( i >=0) {\\n            int j = i;\\n            while( j >= 0 && chars[j] == '/')\\n                j--;\\n            int k = j;\\n            while(k >=0 && chars[k] != '/')\\n                k--;\\n            String part = String.valueOf(chars, k+1, j-k);\\n            if (part.isEmpty() || part.equals(\".\")){\\n                // do nothing\\n            }\\n            // count appearence of \"..\"\\n            else if(part.equals(\"..\")) \\n                count++;\\n           // ignore current part, \\n           //because there is \"..\" after it\\n           else if (count > 0) \\n                count--;\\n           // count == 0, no need to ignore current part \\n           // and do result concatenation\\n            else\\n                ans = \"/\" + part + ans;\\n            i = k;\\n        }\\n        return ans.isEmpty()? \"/\" : ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25766,
                "title": "java-solution-without-using-build-in-split-function-beats-over-91",
                "content": "When we encounter \"/\", we try to find the next \"/\" and get the string between them. If it equals \"..\" and the stack is not empty, then we pop one element. If it does not equal \".\" and is not empty, then we can push it into the stack.\\n\\n    public class Solution {\\n        public String simplifyPath(String path) {\\n            StringBuilder sb = new StringBuilder();\\n            Stack<String> stack = new Stack<>();\\n            int i = 0, len = path.length();\\n            while (i < len) {\\n                if (path.charAt(i) == '/') {\\n                    int j = i+1;\\n                    while (j < len && path.charAt(j) != '/') {\\n                        j++;\\n                    }\\n                    String current = path.substring(i+1, j);\\n                    if (current.equals(\"..\")) {\\n                        if (!stack.isEmpty()) {\\n                            stack.pop();\\n                        }\\n                    } else {\\n                        if (!current.equals(\".\") && !current.equals(\"\")) {\\n                            stack.push(current);\\n                        }\\n                    }\\n                    i = j;\\n                }\\n            }\\n            for (String s : stack) {\\n                sb.append(\"/\"+s);\\n            }\\n            return sb.length() == 0 ? \"/\" : sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            StringBuilder sb = new StringBuilder();\\n            Stack<String> stack = new Stack<>();\\n            int i = 0, len = path.length();\\n            while (i < len) {\\n                if (path.charAt(i) == '/') {\\n                    int j = i+1;\\n                    while (j < len && path.charAt(j) != '/') {\\n                        j++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3408403,
                "title": "c-solution-with-approach",
                "content": "# \\u2B06\\uFE0FLike|\\uD83C\\uDFAFShare|\\u2B50Favourite\\n\\n# Approach\\n1. Split the path into parts using \\'/\\' as the delimiter.\\n2. Iterate through the parts and push the parts into a stack.\\n3. If the part is \"..\" then pop the stack.\\n4. If the part is \".\" or \"\" then do nothing.\\n5. If the part is anything else then push it into the stack.\\n6. Iterate through the stack and build the result string.\\n7. Return the result string.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of the path.\\n\\n- Space complexity:\\nO(n) where n is the length of the path.\\n\\n# C# Code\\n```\\npublic class Solution \\n{\\n    public string SimplifyPath(string path)\\n    {\\n        var stack = new Stack<string>();\\n        var parts = path.Split(\\'/\\');\\n        foreach (var part in parts)\\n        {\\n            if (part == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    stack.Pop();\\n                }\\n            }\\n            else if (part != \".\" && part != \"\")\\n            {\\n                stack.Push(part);\\n            }\\n        }\\n        var result = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            result.Insert(0, stack.Pop());\\n            result.Insert(0, \"/\");\\n        }\\n        return result.Length == 0 ? \"/\" : result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string SimplifyPath(string path)\\n    {\\n        var stack = new Stack<string>();\\n        var parts = path.Split(\\'/\\');\\n        foreach (var part in parts)\\n        {\\n            if (part == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                {\\n                    stack.Pop();\\n                }\\n            }\\n            else if (part != \".\" && part != \"\")\\n            {\\n                stack.Push(part);\\n            }\\n        }\\n        var result = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            result.Insert(0, stack.Pop());\\n            result.Insert(0, \"/\");\\n        }\\n        return result.Length == 0 ? \"/\" : result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407220,
                "title": "easy-commented-code-in-c-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n      stack<string> st;\\n        string res = \"\";\\n        for(int i = 0;  i < path.length() ; i++)\\n        {\\n            if(path[i] == \\'/\\') continue; // skip it\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i]; // add the current path\\n                i++;\\n            }\\n            if(temp == \".\") continue; // skip again\\n            else if(temp == \"..\") {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n\\n        while(!st.empty()) {\\n            res = \"/\" + st.top() + res; // adding this way, helps us, that we don\\'t need to reverse the string after that\\n            st.pop();\\n        }\\n        \\n        if(res.size() == 0)  return \"/\"; // if no directory is there \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n      stack<string> st;\\n        string res = \"\";\\n        for(int i = 0;  i < path.length() ; i++)\\n        {\\n            if(path[i] == \\'/\\') continue; // skip it\\n            string temp;\\n\\t\\t\\t// iterate till we doesn\\'t traverse the whole string and doesn\\'t encounter the last\\n            while(i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i]; // add the current path\\n                i++;\\n            }\\n            if(temp == \".\") continue; // skip again\\n            else if(temp == \"..\") {\\n                if(!st.empty())\\n                    st.pop();\\n            }\\n            else\\n\\t\\t\\t// push the directory file name to stack\\n                st.push(temp);\\n        }\\n\\n        while(!st.empty()) {\\n            res = \"/\" + st.top() + res; // adding this way, helps us, that we don\\'t need to reverse the string after that\\n            st.pop();\\n        }\\n        \\n        if(res.size() == 0)  return \"/\"; // if no directory is there \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407036,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n    \\n        stack=[]\\n        for a in path.split(\\'/\\'):\\n            if a==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n\\n            elif a not in (\\'\\',\\'.\\'):\\n                stack.append(a)\\n\\n\\n        return \"/\"+\"/\".join(stack)                   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n    \\n        stack=[]\\n        for a in path.split(\\'/\\'):\\n            if a==\\'..\\':\\n                if stack:\\n                    stack.pop()\\n\\n            elif a not in (\\'\\',\\'.\\'):\\n                stack.append(a)\\n\\n\\n        return \"/\"+\"/\".join(stack)                   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406942,
                "title": "advance-string-manipulations-split-and-iterate-java",
                "content": "# Intuition\\nThe things you need to keep in mind:\\n- The path will be a valid Unix command. Yes you read that right. Unix path command.\\n- Entering \"../\" will change the current directory to it\\'s parent directory.\\n- Entering \"./\" will stay in the same current directory.\\n- Entering \"x\" will visit the child directory named **x**.\\n\\nNow for the output your result must ensure the following things:\\n- The path starts with a single slash \\'/\\'.\\n- Any two directories are separated by a single slash \\'/\\'.\\n- The path does not end with a trailing \\'/\\'.\\n- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \\'.\\' or double period \\'..\\')\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## The main idea of this solution is to use a stack. How you decide to process the input string is a personal choice.\\n\\nYour mind is telling you to split the path according to **\"/\"**. So, what are you waiting for? Split it!\\nNow the arrays you found. This array will contain paths. Some of them are simple \"xyz\". Some are **\".\"** . Some are **\"..\"** and some are empty **\"\"**. So, based on these elements we will insert the values in an arraylist.\\n- If we encounter \"..\" we pop the last element from the arraylist.\\n- If we encounter \".\", we do nothing.\\n- In other cases, we insert in the arraylist.\\n\\n# Complexity\\n- Time Complexity: $$O(N)$$ if there are $$N$$ characters in the `path` variable. First, we spend $$O(N)$$ trying to split the input path into components and then we process each component one by one which is again an $$O(N)$$ operation.\\n\\n- Space Complexity: $$O(N)$$. Actually, it\\'s $$2N$$ because we have the array that contains the split components and then we have the arraylist stack.\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        // I didn\\'t know yesterday that we could use vars like this!\\n        var dirs = new ArrayList<String>();\\n        for(var dir : path.split(\"/\")) {\\n            if(dir.isEmpty() || dir.equals(\".\")){\\n                continue;\\n            }\\n            if(dir.equals(\"..\")) {\\n                if(!dirs.isEmpty()){\\n                    dirs.remove(dirs.size()-1);\\n                }\\n            }\\n            else {\\n                dirs.add(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", dirs);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        // I didn\\'t know yesterday that we could use vars like this!\\n        var dirs = new ArrayList<String>();\\n        for(var dir : path.split(\"/\")) {\\n            if(dir.isEmpty() || dir.equals(\".\")){\\n                continue;\\n            }\\n            if(dir.equals(\"..\")) {\\n                if(!dirs.isEmpty()){\\n                    dirs.remove(dirs.size()-1);\\n                }\\n            }\\n            else {\\n                dirs.add(dir);\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", dirs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406744,
                "title": "easy-to-understand-code-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path)\\n    {\\n        //\\'/\\' is used as a marker for end of the previous directory\\n        path.push_back(\\'/\\'); \\n        stack<string>st;\\n        //===============================================================================================\\n        string directory = \"\";\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            if (path[i] == \\'/\\') //for every \\'/\\' try to consider the recorded \"directory\"\\n            {\\n                //==========================================================\\n                if (directory == \"..\") //go  back one directory\\n                {\\n                    if (!st.empty()) st.pop();\\n                }\\n                else if (directory != \".\" && directory != \"\")  //if directory is valid string\\n                    st.push(directory);\\n                //==========================================================\\n                //else if (directory == \".\") => do Nothing [stay in curr directory]\\n                //else if (directory == \"/\") => this will occur when there are consecutive \\'/\\' => doNothing\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);\\n        }\\n        //=============================================================================================\\n        string ans = \"\";\\n        while(!st.empty()) \\n        { \\n            ans = \"/\" + st.top() + ans; \\n            st.pop(); \\n        }\\n        //==============================================================================================\\n        return (ans == \"\" ? \"/\" : ans);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path)\\n    {\\n        //\\'/\\' is used as a marker for end of the previous directory\\n        path.push_back(\\'/\\'); \\n        stack<string>st;\\n        //===============================================================================================\\n        string directory = \"\";\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            if (path[i] == \\'/\\') //for every \\'/\\' try to consider the recorded \"directory\"\\n            {\\n                //==========================================================\\n                if (directory == \"..\") //go  back one directory\\n                {\\n                    if (!st.empty()) st.pop();\\n                }\\n                else if (directory != \".\" && directory != \"\")  //if directory is valid string\\n                    st.push(directory);\\n                //==========================================================\\n                //else if (directory == \".\") => do Nothing [stay in curr directory]\\n                //else if (directory == \"/\") => this will occur when there are consecutive \\'/\\' => doNothing\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);\\n        }\\n        //=============================================================================================\\n        string ans = \"\";\\n        while(!st.empty()) \\n        { \\n            ans = \"/\" + st.top() + ans; \\n            st.pop(); \\n        }\\n        //==============================================================================================\\n        return (ans == \"\" ? \"/\" : ans);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847723,
                "title": "c-very-easy-logic-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        path.push_back(\\'/\\');   // to handle cases like \"/...\"\\n        \\n        stack<string> st;   // to hold directories\\n        \\n        string directory = \"\";\\n        for(int i=0; i<path.size(); i++) {\\n            \\n            if( path[i] == \\'/\\' ) {      // push valid directories to stack\\n                if( directory == \"..\" && !st.empty() ) st.pop();\\n                else if( directory != \"\" && directory != \".\" && directory != \"..\") st.push(directory);\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);  // adding chars to directory name until finds any \\'/\\' slash\\n        }\\n        \\n        \\n        // now construct the canonical directory\\n        string result = \"\";\\n        while(!st.empty()) {\\n            result = \"/\"+st.top()+result;\\n            st.pop();\\n        }\\n        \\n        if(result==\"\") return \"/\";\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        path.push_back(\\'/\\');   // to handle cases like \"/...\"\\n        \\n        stack<string> st;   // to hold directories\\n        \\n        string directory = \"\";\\n        for(int i=0; i<path.size(); i++) {\\n            \\n            if( path[i] == \\'/\\' ) {      // push valid directories to stack\\n                if( directory == \"..\" && !st.empty() ) st.pop();\\n                else if( directory != \"\" && directory != \".\" && directory != \"..\") st.push(directory);\\n                directory = \"\";\\n            }\\n            else directory.push_back(path[i]);  // adding chars to directory name until finds any \\'/\\' slash\\n        }\\n        \\n        \\n        // now construct the canonical directory\\n        string result = \"\";\\n        while(!st.empty()) {\\n            result = \"/\"+st.top()+result;\\n            st.pop();\\n        }\\n        \\n        if(result==\"\") return \"/\";\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050588,
                "title": "python-stack",
                "content": "The idea is that when we see a `..` we are going up, so the last element should be removed (if it exists), which is implemented by stack.\\n\\n```python\\nclass Solution:\\n    def simplifyPath(self, path):\\n        s = []\\n        for x in path.split(\\'/\\'):\\n            if not x: \\n                continue\\n            elif x == \\'.\\':\\n                continue\\n            elif x == \\'..\\':\\n                if s:\\n                    s.pop()\\n            else:\\n                s.append(x)\\n        return \\'/\\' + \\'/\\'.join(s)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def simplifyPath(self, path):\\n        s = []\\n        for x in path.split(\\'/\\'):\\n            if not x: \\n                continue\\n            elif x == \\'.\\':\\n                continue\\n            elif x == \\'..\\':\\n                if s:\\n                    s.pop()\\n            else:\\n                s.append(x)\\n        return \\'/\\' + \\'/\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200362,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        istringstream ss(path);\\n        string tempPath;\\n        vector<string> stack;\\n        while(getline(ss,tempPath,\\'/\\')){\\n            if(tempPath == \".\" || tempPath.empty()){\\n                continue;\\n            }else if(tempPath == \"..\"){\\n                if(stack.empty() == false)\\n                    stack.pop_back();\\n            }else{\\n                stack.push_back(tempPath);\\n            }\\n        }\\n        \\n        string result;\\n        for(auto &s : stack){\\n            result += \"/\" + s;\\n        }\\n        \\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        istringstream ss(path);\\n        string tempPath;\\n        vector<string> stack;\\n        while(getline(ss,tempPath,\\'/\\')){\\n            if(tempPath == \".\" || tempPath.empty()){\\n                continue;\\n            }else if(tempPath == \"..\"){\\n                if(stack.empty() == false)\\n                    stack.pop_back();\\n            }else{\\n                stack.push_back(tempPath);\\n            }\\n        }\\n        \\n        string result;\\n        for(auto &s : stack){\\n            result += \"/\" + s;\\n        }\\n        \\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25697,
                "title": "3-lines-javascript-don-t-do-this-in-interviews",
                "content": "Standard stack-based solution, compressed just to make it into 3 lines. Don't do this in interviews.\\n```\\nvar simplifyPath = function(path) {\\n    const stack = [], tokens = path.split('/').filter(t => !['/', '', '.'].includes(t));\\n    tokens.forEach(t => t === '..' ? stack.pop() : stack.push(t));\\n    return '/' + stack.join('/');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar simplifyPath = function(path) {\\n    const stack = [], tokens = path.split('/').filter(t => !['/', '', '.'].includes(t));\\n    tokens.forEach(t => t === '..' ? stack.pop() : stack.push(t));\\n    return '/' + stack.join('/');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25814,
                "title": "java-solution-with-one-stack",
                "content": "General idea: Split the string by slash first and then, using a stack to store the name of directory. There are totally 5 situations when looping through the array:\\n\\n - If elem is empty string, then it means we either meet multiple slashes (\"//\", \"///\"...) or it is the start point. For this case, simply ignore and continue;\\n - If elem is \".\", then we have to stay in current directory, as the same as case 1), do nothing and continue;\\n - If elem is \"..\" and stack is not empty, then we have to go back to parent directory. For this case, simply pop the top element from stack;\\n - If elem has a name (\"home\", \"desktop\"...), push it to stack.\\n - For all other cases, do nothing and continue.\\n\\nWhen pop up elem from stack to get result, there is a special case: If stack is empty, then it means input string is \"/../\" or \"/\", or others which lead us staying in current directory. For this case, simply return \"/\".\\n\\n    public class Solution {\\n        public String simplifyPath(String path) {\\n            String[] arr = path.split(\"/\");\\n            Stack<String> stack = new Stack<>();\\n            for (int i = 0; i < arr.length; i++) {\\n                if (\"\".equals(arr[i]) || \".\".equals(arr[i])) continue;\\n                if (\"..\".equals(arr[i]) && !stack.isEmpty()) stack.pop();\\n                else if (!\"..\".equals(arr[i])) stack.push(arr[i]);\\n            }\\n            if (stack.isEmpty()) return \"/\";\\n            String result = \"\";\\n            while (!stack.isEmpty()) result = \"/\" + stack.pop() + result;\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n        public String simplifyPath(String path) {\\n            String[] arr = path.split(\"/\");\\n            Stack<String> stack = new Stack<>();\\n            for (int i = 0; i < arr.length; i++) {\\n                if (\"\".equals(arr[i]) || \".\".equals(arr[i])) continue;\\n                if (\"..\".equals(arr[i]) && !stack.isEmpty()) stack.pop();\\n                else if (!\"..\".equals(arr[i])) stack.push(arr[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25816,
                "title": "my-simple-c-code",
                "content": "    string simplifyPath(string path) {\\n            const char* p = path.c_str();\\n            string res = \"/\";\\n            vector<string> full_path;\\n            char* addr = strtok((char*)p, \"/\");\\n            int cur = 0, size = 0;\\n            while(addr) {\\n                if(strcmp(addr, \".\") == 0) {\\n                }       \\n                else if(strcmp(addr, \"..\") == 0) {\\n                    cur > 0 ? cur-- : cur;\\n                }    \\n                else {\\n                    if(cur == size) {\\n                        full_path.push_back(addr);\\n                        cur++;\\n                        size++;\\n                    }\\n                    else {\\n                        full_path[cur++] = addr;\\n                    }\\n                }     \\n                addr = strtok(NULL, \"/\");\\n            }\\n            for(int i=0; i<cur; i++) {\\n                res = res + full_path[i] + \"/\";\\n            }\\n            return res.size() == 1 ? res : res.substr(0, res.size() - 1);\\n    }",
                "solutionTags": [],
                "code": "    string simplifyPath(string path) {\\n            const char* p = path.c_str();\\n            string res = \"/\";\\n            vector<string> full_path;\\n            char* addr = strtok((char*)p, \"/\");\\n            int cur = 0, size = 0;\\n            while(addr) {\\n                if(strcmp(addr, \".\") == 0) {\\n                }       \\n                else if(strcmp(addr, \"..\") == 0) {\\n                    cur > 0 ? cur-- : cur;\\n                }    \\n                else {\\n                    if(cur == size) {\\n                        full_path.push_back(addr);\\n                        cur++;\\n                        size++;\\n                    }\\n                    else {\\n                        full_path[cur++] = addr;\\n                    }\\n                }     \\n                addr = strtok(NULL, \"/\");\\n            }\\n            for(int i=0; i<cur; i++) {\\n                res = res + full_path[i] + \"/\";\\n            }\\n            return res.size() == 1 ? res : res.substr(0, res.size() - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3767647,
                "title": "java-easy-solution-using-stack",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n      Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories) { \\n            if (dir.equals(\".\") || dir.isEmpty()) continue;\\n            else if (dir.equals(\"..\")) { \\n                if (!stack.isEmpty())\\n                    stack.pop();\\n            }\\n            else\\n                stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);   \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n      Stack<String> stack = new Stack<>();    \\n        String[] directories = path.split(\"/\"); \\n        for (String dir : directories) { \\n            if (dir.equals(\".\") || dir.isEmpty()) continue;\\n            else if (dir.equals(\"..\")) { \\n                if (!stack.isEmpty())\\n                    stack.pop();\\n            }\\n            else\\n                stack.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", stack);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409586,
                "title": "most-optimal-solution-using-stack-complete-approach-explained",
                "content": "\\n\\n# Approach\\nThe solution first initializes an empty stack to keep track of the directories on the simplified path. It then uses a stringstream to split the input path into individual directory names, and iterates over them one by one.\\n\\nIf the directory name is empty (which can happen due to consecutive slashes in the input path) or equal to \".\", we can skip it and move on to the next directory.\\n\\nIf the directory name is \"..\", we need to move up one level in the directory hierarchy. To do this, we simply pop the last directory from the stack (if it\\'s not empty).\\n\\nIf the directory name is any other valid directory name, we push it onto the stack.\\n\\nOnce we\\'ve processed all the directories on the input path, we need to construct the simplified path by popping the directories from the stack in reverse order and concatenating them with a slash separator. We also need to add a leading slash to the simplified path.\\n\\nIf the stack is empty (which can happen if the input path only contains \".\" or \"..\" directories), we simply return a single slash as the simplified path.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string directory, result;\\n        while (getline(ss, directory, \\'/\\')) {\\n            if (directory == \"\" || directory == \".\") {\\n                continue;\\n            } else if (directory == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(directory);\\n            }\\n        }\\n        while (!s.empty()) {\\n            result = \"/\" + s.top() + result;\\n            s.pop();\\n        }\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        stringstream ss(path);\\n        string directory, result;\\n        while (getline(ss, directory, \\'/\\')) {\\n            if (directory == \"\" || directory == \".\") {\\n                continue;\\n            } else if (directory == \"..\") {\\n                if (!s.empty()) {\\n                    s.pop();\\n                }\\n            } else {\\n                s.push(directory);\\n            }\\n        }\\n        while (!s.empty()) {\\n            result = \"/\" + s.top() + result;\\n            s.pop();\\n        }\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409341,
                "title": "easy-python-solution-98-runtime",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path=[i for i in path if i and i!=\"/\" and i!=\".\"]\\n        for i in path:\\n            if i==\"..\" and stack:\\n                stack.pop()\\n            elif i!=\"..\":\\n                stack.append(i)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path=[i for i in path if i and i!=\"/\" and i!=\".\"]\\n        for i in path:\\n            if i==\"..\" and stack:\\n                stack.pop()\\n            elif i!=\"..\":\\n                stack.append(i)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409173,
                "title": "java-stack-simplify-path",
                "content": "\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        while (end < path.length())\\n        {\\n            start = end;\\n            if (path.charAt(end) == \\'.\\') {\\n                start = end;\\n                while (end < path.length() && path.charAt(end) == \\'.\\')\\n                    end++;\\n                if (end - start == 1 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else if (end - start == 2 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    stack.remove(stack.size() - 1);\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else\\n                {\\n                    while (end < path.length() && path.charAt(end) != \\'/\\')\\n                        end++;\\n                    stack.add(path.substring(start,end));\\n                }\\n\\n            }\\n            else if (path.charAt(end) == \\'/\\')\\n            {\\n                if (stack.isEmpty() || !stack.get(stack.size() - 1).equals(\"/\") && end != path.length() - 1)\\n                    stack.add(path.substring(start,end + 1));\\n                end++;\\n            }\\n            else\\n            {\\n                start = end;\\n                while (end < path.length() &&  path.charAt(end) != \\'/\\')\\n                    end++;\\n                if (start != end) stack.add(path.substring(start,end));\\n            }\\n        }\\n        if (stack.isEmpty()) return \"/\";\\n        else if (stack.size() > 1 && stack.get(stack.size() - 1).equals(\"/\")) stack.remove(stack.size() - 1);\\n        StringBuilder srr = new StringBuilder();\\n        for (String d : stack)\\n            srr.append(d);\\n        return srr.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        ArrayList<String> stack = new ArrayList<>();\\n        int start = 0;\\n        int end = 0;\\n        while (end < path.length())\\n        {\\n            start = end;\\n            if (path.charAt(end) == \\'.\\') {\\n                start = end;\\n                while (end < path.length() && path.charAt(end) == \\'.\\')\\n                    end++;\\n                if (end - start == 1 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else if (end - start == 2 && (end < path.length() && path.charAt(end) == \\'/\\' || end == path.length())) {\\n                    stack.remove(stack.size() - 1);\\n                    if (!stack.isEmpty()) stack.remove(stack.size() - 1);\\n                }\\n                else\\n                {\\n                    while (end < path.length() && path.charAt(end) != \\'/\\')\\n                        end++;\\n                    stack.add(path.substring(start,end));\\n                }\\n\\n            }\\n            else if (path.charAt(end) == \\'/\\')\\n            {\\n                if (stack.isEmpty() || !stack.get(stack.size() - 1).equals(\"/\") && end != path.length() - 1)\\n                    stack.add(path.substring(start,end + 1));\\n                end++;\\n            }\\n            else\\n            {\\n                start = end;\\n                while (end < path.length() &&  path.charAt(end) != \\'/\\')\\n                    end++;\\n                if (start != end) stack.add(path.substring(start,end));\\n            }\\n        }\\n        if (stack.isEmpty()) return \"/\";\\n        else if (stack.size() > 1 && stack.get(stack.size() - 1).equals(\"/\")) stack.remove(stack.size() - 1);\\n        StringBuilder srr = new StringBuilder();\\n        for (String d : stack)\\n            srr.append(d);\\n        return srr.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407225,
                "title": "easy-python-solution-using-stacks-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: $$ O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        paths = path.split(\\'/\\')\\n        st = []\\n        for path in paths:\\n            if path != \"\" and path != \"..\" and path !=\".\":\\n                st.append(path)\\n            if path == \"..\" and len(st) > 0:\\n                st.pop()\\n        print(st)\\n        return \"/\"+\"/\".join(st)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        paths = path.split(\\'/\\')\\n        st = []\\n        for path in paths:\\n            if path != \"\" and path != \"..\" and path !=\".\":\\n                st.append(path)\\n            if path == \"..\" and len(st) > 0:\\n                st.pop()\\n        print(st)\\n        return \"/\"+\"/\".join(st)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406726,
                "title": "java-stack-8-lines-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public String simplifyPath(String path) {\\n    var stack = new Stack<String>();\\n\\n    for (var s : path.split(\"/\")) {\\n      if (s.equals(\"..\")) {\\n        if (!stack.empty())\\n          stack.pop();\\n      } else if (!s.equals(\".\") && !s.equals(\"\")) {\\n        stack.push(s);\\n      }\\n    }\\n    return \"/\" + String.join(\"/\", stack);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n  public String simplifyPath(String path) {\\n    var stack = new Stack<String>();\\n\\n    for (var s : path.split(\"/\")) {\\n      if (s.equals(\"..\")) {\\n        if (!stack.empty())\\n          stack.pop();\\n      } else if (!s.equals(\".\") && !s.equals(\"\")) {\\n        stack.push(s);\\n      }\\n    }\\n    return \"/\" + String.join(\"/\", stack);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406716,
                "title": "one-liner-two-solutions-14-ms-98-77-easy-to-understand",
                "content": "# Seven-liner\\n\\n14 ms 98.77%\\n\\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").reduce(into: [Substring]()) {\\n        switch $1 {\\n        case \".\": return\\n        case \"..\": _ = $0.popLast()\\n        default: $0.append($1)\\n        }\\n    }.joined(separator: \"/\")\\n}\\n```\\n\\n# One-liner\\n\\n14 ms 98.77%\\n\\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").filter { $0 != \".\" }.reduce(into: [Substring]()) { if $1 == \"..\" { _ = $0.popLast() } else { $0.append($1) } }.joined(separator: \"/\")\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").reduce(into: [Substring]()) {\\n        switch $1 {\\n        case \".\": return\\n        case \"..\": _ = $0.popLast()\\n        default: $0.append($1)\\n        }\\n    }.joined(separator: \"/\")\\n}\\n```\n```swift\\nfunc simplifyPath(_ path: String) -> String {\\n    \"/\" + path.split(separator: \"/\").filter { $0 != \".\" }.reduce(into: [Substring]()) { if $1 == \"..\" { _ = $0.popLast() } else { $0.append($1) } }.joined(separator: \"/\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406710,
                "title": "10-lines-code-using-stringstream",
                "content": "# **Please Upvote Me \\uD83E\\uDD79**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // creating answer string to store the final ans\\n        string result=\"\", token;\\n\\n        // using stringstream\\n        // << : using to add into the string\\n        // >> : used to read from the string\\n        stringstream ss(path);\\n        vector<string> tokens;\\n\\n        while(getline(ss, token, \\'/\\')){\\n            if(token==\".\" || token==\"\") \\n                continue;\\n            else if(token==\"..\"){\\n                if(tokens.size()!=0)  tokens.pop_back();\\n            }\\n            else{\\n                tokens.push_back(token);\\n            }\\n        }\\n\\n        if(tokens.size()==0) \\n            return \"/\";\\n\\n        for(int i=0; i<tokens.size(); ++i)\\n            result=result+\\'/\\'+tokens[i];\\n            \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        // creating answer string to store the final ans\\n        string result=\"\", token;\\n\\n        // using stringstream\\n        // << : using to add into the string\\n        // >> : used to read from the string\\n        stringstream ss(path);\\n        vector<string> tokens;\\n\\n        while(getline(ss, token, \\'/\\')){\\n            if(token==\".\" || token==\"\") \\n                continue;\\n            else if(token==\"..\"){\\n                if(tokens.size()!=0)  tokens.pop_back();\\n            }\\n            else{\\n                tokens.push_back(token);\\n            }\\n        }\\n\\n        if(tokens.size()==0) \\n            return \"/\";\\n\\n        for(int i=0; i<tokens.size(); ++i)\\n            result=result+\\'/\\'+tokens[i];\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225748,
                "title": "simplifying-unix-style-absolute-paths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we need to construct the simplified canonical path from the input path string. We can use a stack to keep track of the directories on the canonical path as we process the input path string. For each directory name, we need to handle three cases: \".\" (current directory), \"..\" (parent directory), and other directory names.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by initializing an empty stack to store the directories on the canonical path. Then, we split the input path string by slashes (\"/\") to get the individual directory names. For each directory name, we do the following:\\n\\n- If the directory name is \".\", we simply skip it (as it refers to the current directory).\\n- If the directory name is \"..\", we pop the top directory from the stack (as it refers to the parent directory).\\n- Otherwise, we push the directory name onto the stack.\\nAt the end, we can construct the simplified canonical path by joining the directories in the stack with slashes and adding a leading slash.\\n# Complexity\\n- Time complexity: The time complexity of the solution is $$O(n)$$, where n is the length of the input path string, since we need to process each directory name in the path string once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the solution is $$O(n)$$, where n is the length of the input path string, since we need to store the directories on the canonical path in the stack. In the worst case, when all directories in the path string are valid directory names (i.e., no \".\" or \"..\"), the stack can have a maximum size of n/2 (when the input path string has alternating directory names and slashes).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        for directory in path.split(\"/\"):\\n            if directory == \"\" or directory == \".\":\\n                continue\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        for directory in path.split(\"/\"):\\n            if directory == \"\" or directory == \".\":\\n                continue\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n        return \"/\" + \"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171817,
                "title": "c-easy-dequeue-o-n-0ms-beats-100-with-explanation",
                "content": "# Approach\\nWe can iterate over the given string and store the string between two `\\'/\\'` inside a dequeue. This stored string can be one of the 3 possible nature.\\n\\n    1) It can be a normal file or folder name.\\n       In this can we will push it at the back of our dequeue. \\n    2) It can be a \".\"\\n       In this can we will just ignore it.\\n    3) It can be \"..\"\\n       In this can we will pop the latest element from the back of our dequeue if it is not empty.\\n\\n\\nIf after `\\'/\\'` we encounter another `\\'/\\'` we can ignore it. \\n\\nThen, after the iteration of whole string is complete, we will run a while loop till the `dequeue` is not empty to store the string present at the front of our `dequeue` to our answer and then pop that front string from our `dequeue`.\\nAfter each addition of string we will seperate the next one by adding `\\'/\\'`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        deque<string> s;\\n        int i = 0;\\n\\n        while(i<path.size())\\n        {\\n            if(path[i] == \\'/\\')i++;\\n            else\\n            {\\n                string str = \"\";\\n                while(i<path.size() && path[i] != \\'/\\')\\n                {\\n                    str += path[i];i++;\\n                }\\n                if(str == \"..\")\\n                {\\n                    if(!s.empty())s.pop_back();\\n                }\\n                else if(str != \".\") s.push_back(str);\\n            }\\n        }\\n\\n        string ans = \"/\";\\n        while(!s.empty())\\n        {\\n            ans += s.front();\\n            ans += \\'/\\';\\n            s.pop_front();\\n        }\\n        if(ans.size()>1)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        deque<string> s;\\n        int i = 0;\\n\\n        while(i<path.size())\\n        {\\n            if(path[i] == \\'/\\')i++;\\n            else\\n            {\\n                string str = \"\";\\n                while(i<path.size() && path[i] != \\'/\\')\\n                {\\n                    str += path[i];i++;\\n                }\\n                if(str == \"..\")\\n                {\\n                    if(!s.empty())s.pop_back();\\n                }\\n                else if(str != \".\") s.push_back(str);\\n            }\\n        }\\n\\n        string ans = \"/\";\\n        while(!s.empty())\\n        {\\n            ans += s.front();\\n            ans += \\'/\\';\\n            s.pop_front();\\n        }\\n        if(ans.size()>1)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673403,
                "title": "python3-easy-to-understand-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(path):\\n            cur = path[i]\\n            i += 1\\n            if cur == \\'/\\':\\n                while i < len(path) and path[i] == \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n            else:\\n                while i < len(path) and path[i] != \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n                    \\n            if cur == \\'..\\': \\n                if stack: stack.pop()\\n            elif cur[0] != \\'/\\' and cur != \\'.\\': \\n                stack.append(cur)\\n        \\n        res = \\'\\'\\n        for s in stack: res += \\'/\\' + s\\n            \\n        return res if res else \\'/\\'\\n\\n    \\n    \\n    \\n\\'\\'\\'Test Cases:\\n\\n\"/home/\"\\n\"/../\"\\n\"/home//foo/\"\\n\"/a/./b/../../c/\"\\n\"/a//b////c/d//././/..\"\\n\"/...\"\\n\"/..hidden\"\\n\"/a/../../b/../c//.//\"\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack = []\\n        i = 0\\n        while i < len(path):\\n            cur = path[i]\\n            i += 1\\n            if cur == \\'/\\':\\n                while i < len(path) and path[i] == \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n            else:\\n                while i < len(path) and path[i] != \\'/\\':\\n                    cur += path[i]\\n                    i += 1\\n                    \\n            if cur == \\'..\\': \\n                if stack: stack.pop()\\n            elif cur[0] != \\'/\\' and cur != \\'.\\': \\n                stack.append(cur)\\n        \\n        res = \\'\\'\\n        for s in stack: res += \\'/\\' + s\\n            \\n        return res if res else \\'/\\'\\n\\n    \\n    \\n    \\n\\'\\'\\'Test Cases:\\n\\n\"/home/\"\\n\"/../\"\\n\"/home//foo/\"\\n\"/a/./b/../../c/\"\\n\"/a//b////c/d//././/..\"\\n\"/...\"\\n\"/..hidden\"\\n\"/a/../../b/../c//.//\"\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540337,
                "title": "java-stack-simple",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> st = new Stack();\\n        boolean period = false;\\n        \\n        String[] s = path.split(\"/\");\\n        \\n        for(String str : s){\\n            \\n            if(str.equals(\".\") || str.equals(\"\") || str.equals(\" \"))continue;\\n            \\n            else if(str.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(\"/\" + str);\\n            }\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            \\n            ans = st.pop() + ans;\\n        }\\n       \\n        if(ans.equals(\"\"))return \"/\";\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> st = new Stack();\\n        boolean period = false;\\n        \\n        String[] s = path.split(\"/\");\\n        \\n        for(String str : s){\\n            \\n            if(str.equals(\".\") || str.equals(\"\") || str.equals(\" \"))continue;\\n            \\n            else if(str.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(\"/\" + str);\\n            }\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            \\n            ans = st.pop() + ans;\\n        }\\n       \\n        if(ans.equals(\"\"))return \"/\";\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462799,
                "title": "c-easy-solution-using-stack",
                "content": "**Approach:- \\n1. Iterate over the string .\\n2. if we got \"/\" , continue .\\n3. Now we need a temp string to store the character between  the two \"/\" , so do store in tmp while we didn\\'t get \"/\".\\n4. If we got temp as only single dot(.) , we need to contiue , it can\\'t be included in our answer.\\n5. If we go temp as double dot , in this case we need to pop from the stack if it is not empty  as double dot means a level up for that .\\n6. At last ,if above two conditions doesn\\'t meant , it means we got tmp , it will be included in our answer , so now push into the stack.****\\n\\nIn the stack , we got those string which are in the  path i.e,\\nAs In stack , elements follow LIFO method , but our answer should have value from the starting . \\nNow , we have anyhow need to put in answer from starting..\\nso we will put answer as answer = \"/\" + st.top()+ answer.\\nIt will take O(N+ N) time for resulting string to be return by popping out elements from stack.\\n\\n\\n**Please UPVOTE if find helpful.**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        stack<string>st;\\n        string ans;\\n        int n=s.size();\\n        // Iterating through the string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'/\\') continue;\\n            string tmp;\\n            while(i<n && s[i]!=\\'/\\') \\n\\t\\t\\t  tmp+=s[i++];            \\n            if(tmp==\".\") continue;\\n            else if(tmp==\"..\"){\\n                  if(!st.empty()) \\n                      st.pop();\\n            }\\n            else\\n               st.push(tmp);\\n            }\\n        while(!st.empty()){\\n            ans=\"/\"+ st.top()+ans;\\n            st.pop();\\n        }\\n        \\n         if(ans.size()==0)return \"/\";\\n        \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        stack<string>st;\\n        string ans;\\n        int n=s.size();\\n        // Iterating through the string s\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'/\\') continue;\\n            string tmp;\\n            while(i<n && s[i]!=\\'/\\') \\n\\t\\t\\t  tmp+=s[i++];            \\n            if(tmp==\".\") continue;\\n            else if(tmp==\"..\"){\\n                  if(!st.empty()) \\n                      st.pop();\\n            }\\n            else\\n               st.push(tmp);\\n            }\\n        while(!st.empty()){\\n            ans=\"/\"+ st.top()+ans;\\n            st.pop();\\n        }\\n        \\n         if(ans.size()==0)return \"/\";\\n        \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285456,
                "title": "71-simplify-path-c-with-comments-and-explanation",
                "content": "\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring simplifyPath(string path) {\\n\\t\\t\\tstring canonicalPath = \"\"; //for creating the final path / answer\\n\\t\\t\\tstring curr = \"\"; //to build the current directory\\n\\t\\t\\tstack<string> s; //for implementing \"..\" -> POP feature (to go to the directory up a level)\\n\\t\\t\\tpath += \"/\"; //(**IMP) we add this so that the last directory gets added in case the input doesn\\'t end with \"/\"\\n\\t\\t\\t//example for the above case - \"/a//b////c/d//././/..\"\\n\\t\\t\\tfor(int i=0;i<path.length();i++){\\n\\t\\t\\t\\tif(path[i] == \\'/\\'){ //we have some cases when we find \"/\" \\n\\t\\t\\t\\t\\tif(curr == \"..\"){ //here we have to implement pop to to the directory up a level\\n\\t\\t\\t\\t\\t\\tif(!s.empty()) s.pop(); //check if the stack is already empty , in that case no need to do anything\\n\\t\\t\\t\\t\\t} else if(curr != \".\" and curr!= \"\"){ //we do nothing if curr directory which we built is \".\" or is empty\\n\\t\\t\\t\\t\\t\\ts.push(curr); //push the directory into the stack\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr = \"\"; //resetting the curr string after a directory is successfully added into the stack in order to build a new directory\\n\\t\\t\\t\\t} else { //keep building the current string / directory\\n\\t\\t\\t\\t\\tcurr += path[i]; //add the character to build the current directory\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//by here : - Example : IP - \"/home//foo/\" \\n\\t\\t\\t//our stack now contains - |foo | or \"fool\",\"home\" top to down \\n\\t\\t\\t//                         |home|\\n\\t\\t\\t//now we have to start building our final answer , i.e string canonicalPath\\n\\t\\t\\twhile(!s.empty()){\\n\\t\\t\\t\\tcanonicalPath = \"/\"+s.top()+canonicalPath;\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//incase our final answer is empty, then we add a condition to return \"/\" as the path always starts with a single slash \"/\"\\n\\t\\t\\tif(canonicalPath.length() == 0){\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t} else { //return our final answer\\n\\t\\t\\t\\treturn canonicalPath;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring simplifyPath(string path) {\\n\\t\\t\\tstring canonicalPath = \"\"; //for creating the final path / answer\\n\\t\\t\\tstring curr = \"\"; //to build the current directory\\n\\t\\t\\tstack<string> s; //for implementing \"..\" -> POP feature (to go to the directory up a level)\\n\\t\\t\\tpath += \"/\"; //(**IMP) we add this so that the last directory gets added in case the input doesn\\'t end with \"/\"\\n\\t\\t\\t//example for the above case - \"/a//b////c/d//././/..\"\\n\\t\\t\\tfor(int i=0;i<path.length();i++){\\n\\t\\t\\t\\tif(path[i] == \\'/\\'){ //we have some cases when we find \"/\" \\n\\t\\t\\t\\t\\tif(curr == \"..\"){ //here we have to implement pop to to the directory up a level\\n\\t\\t\\t\\t\\t\\tif(!s.empty()) s.pop(); //check if the stack is already empty , in that case no need to do anything\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2100643,
                "title": "java-solution-using-stack-explanation",
                "content": "let\\'s assume that the given string is \"/home/foo/./java/../bar/\"\\nfirstly we will go to directory home so i push home to stack \\n<img src = \"https://assets.leetcode.com/users/images/6f8513dc-8d89-44f2-84b8-4b2d28a3587c_1654142299.084013.png\" width = \"600\">\\n\\nthen next i will go to directory foo(inside home) to stack\\n<img src=\"https://assets.leetcode.com/users/images/6ae56263-ff30-4628-a7bc-f06f41b6c2ed_1654142398.4118161.png\" width = \"600\">\\n\\n after that i have \".\" in the string so i simply ignore that and proceed to go to java directory \\n<img src=\"https://assets.leetcode.com/users/images/8efc44e9-5206-4f34-b3f7-4b444bb88f11_1654142455.4679081.png\" width =\"600\" >\\n\\nafter that i see\"..\" which means go 1 step back so i pop out last directory entered\\n<img src=\"https://assets.leetcode.com/users/images/b1af2191-6293-4c21-8935-0a3c927b1acc_1654142508.964751.png\" width = \"600\">\\n\\nfinally i go to bar directory and push it\\n<img src=\"https://assets.leetcode.com/users/images/50406caa-7ae0-457e-bd55-a90ff56c8631_1654142572.1674197.png\" width = \"600\">\\n\\nso in the end i have to pop all the enteries in the stack and the top item should be there at the end of string \\n\\nProcedure - \\n- first get all the substrings within \"/\" \\n- if the substring is \".\" then ignore and if it is \"..\" then pop the last element of stack if stack is not empty!\\n- if the above condition not satisfy then simply push the value into stack\\n- finally pop out last value and add it to answer string as -> ``` answer = \"/\" + top value of stack + answer``` \\n- one cornor case when we haven\\'t pushed anthing into stack then simply return \"/\"\\n\\n**If you find this useful then please upvote**\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stk = new Stack<>();\\n        String ans = \"\";\\n        int record = 0;\\n        for(int i = 0 ; i < path.length(); ++i){\\n            if(path.charAt(i) == \\'/\\')\\n                continue;\\n            String temp = \"\"; // make temp string = 0 everytime\\n            while(i<path.length() && path.charAt(i) != \\'/\\'){\\n                temp += path.charAt(i);\\n                ++i;\\n            }\\n            switch(temp){\\n                case \".\":\\n                    // ++i;\\n                    break;\\n                case \"..\":\\n                    if(!stk.isEmpty()) stk.pop();\\n                    break;\\n                default:\\n                    stk.push(temp);\\n            }\\n        }\\n            \\n        while(!stk.isEmpty()){\\n            ans = \"/\"+ stk.pop() + ans ;\\n        }\\n        return (ans.length() == 0 ) ? \"/\" : ans;\\n    }\\n}\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "``` answer = \"/\" + top value of stack + answer```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stk = new Stack<>();\\n        String ans = \"\";\\n        int record = 0;\\n        for(int i = 0 ; i < path.length(); ++i){\\n            if(path.charAt(i) == \\'/\\')\\n                continue;\\n            String temp = \"\"; // make temp string = 0 everytime\\n            while(i<path.length() && path.charAt(i) != \\'/\\'){\\n                temp += path.charAt(i);\\n                ++i;\\n            }\\n            switch(temp){\\n                case \".\":\\n                    // ++i;\\n                    break;\\n                case \"..\":\\n                    if(!stk.isEmpty()) stk.pop();\\n                    break;\\n                default:\\n                    stk.push(temp);\\n            }\\n        }\\n            \\n        while(!stk.isEmpty()){\\n            ans = \"/\"+ stk.pop() + ans ;\\n        }\\n        return (ans.length() == 0 ) ? \"/\" : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850695,
                "title": "c-superfast-100-faster-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string>s;\\n        int n=path.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            string ch=\"\";\\n            bool flag=false;\\n            int c=0;\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                if(path[i]>=\\'a\\' && path[i]<=\\'z\\' || path[i]>=\\'A\\' && path[i]<=\\'Z\\')\\n                {\\n                    flag=true;\\n                }else if(path[i]==\\'.\\')\\n                {\\n                    c++;\\n                }\\n                ch+=path[i];\\n                i++;\\n                // cout<<ch<<endl;\\n            }\\n            if(c==2 && !s.empty())\\n            {\\n                s.pop();\\n            }else if(c>2 || flag)\\n            {\\n                s.push(ch);\\n            }\\n            // i--;\\n        }\\n        if(s.empty())return \"/\";\\n        \\n        string ans=\"\";\\n        stack<string>st;\\n        while(!s.empty())\\n        {\\n            st.push(s.top());\\n            s.pop();\\n        }\\n\\t\\t//make another stack \\n        while(!st.empty())\\n        {\\n            ans+=\\'/\\';\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) \\n    {\\n        stack<string>s;\\n        int n=path.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            string ch=\"\";\\n            bool flag=false;\\n            int c=0;\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                if(path[i]>=\\'a\\' && path[i]<=\\'z\\' || path[i]>=\\'A\\' && path[i]<=\\'Z\\')\\n                {\\n                    flag=true;\\n                }else if(path[i]==\\'.\\')\\n                {\\n                    c++;\\n                }\\n                ch+=path[i];\\n                i++;\\n                // cout<<ch<<endl;\\n            }\\n            if(c==2 && !s.empty())\\n            {\\n                s.pop();\\n            }else if(c>2 || flag)\\n            {\\n                s.push(ch);\\n            }\\n            // i--;\\n        }\\n        if(s.empty())return \"/\";\\n        \\n        string ans=\"\";\\n        stack<string>st;\\n        while(!s.empty())\\n        {\\n            st.push(s.top());\\n            s.pop();\\n        }\\n\\t\\t//make another stack \\n        while(!st.empty())\\n        {\\n            ans+=\\'/\\';\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1848608,
                "title": "stack-solution-with-easy-detailed-explanation",
                "content": "[Leetcode](https://leetcode.com/) [71. Simplify Path](https://leetcode.com/problems/simplify-path/).\\n\\n***By Frank Luo***\\n\\n# Intuition  \\n\\nWe can just **simulate** the process from the begin to end.\\n\\nFirst we split the given string $\\\\textit{path}$ into a list of strings by the slash $/$, denoted as `names`. According to the **canonical path** in the problem description, the strings contained in `names` can only be the following:\\n\\n1. empty string;\\n2. a dot `.`;\\n3. two dots `..`;\\n4. a directory name containing only English letters, numbers, or `_`.\\n\\nIf we meet empty string or `.`, we can ignore them because empty string means nothing, and `.` means the current directory itself, so we don\\'t need to change directories.\\n\\nIf we meet `..` or \"directory names\", we can use a **Stack** to maintain each directory name in the path. When we encounter \"two dots\", we need to change the directory to the parent directory. As the stack is not empty, we pop the directory of the stack. When we encounter a \"directory\", we put it to the stack.\\n\\nFinally we need to iterate each string in `names` and do the above. After all operations are completed, we connect the strings from the bottom of the stack to the top of the stack with `/`, and then add `/` at the top to indicate the root directory, and we can get the simplified Canonical path.\\n\\n\\n```java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null || path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        Stack<String> pathStack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        path = path.replaceAll(\"\\\\\\\\/\\\\\\\\/\", \"/\");\\n        String[] folders = path.split(\"\\\\\\\\/\");\\n        int len = folders.length;\\n        for (int i = 0; i < len; i++) {\\n            String folder = folders[i];\\n            if (folder.equalsIgnoreCase(\".\")) {\\n                continue;\\n            } else if (folder.equalsIgnoreCase(\"..\")) {\\n                if (!pathStack.empty()) {\\n                    pathStack.pop();\\n                }\\n            } else if (folder.length() > 0) {\\n                pathStack.push(folder);\\n            }\\n        }\\n\\n        ans.append(\\'/\\');\\n        List<String> res = new ArrayList<>();\\n        while (!pathStack.empty()) {\\n            res.add(pathStack.pop());\\n        }\\n\\n        for (int i = res.size() - 1; i >= 0; i--) {\\n            ans.append(res.get(i));\\n            ans.append(\"/\");\\n        }\\n\\n        if (ans.length() > 1 && ans.charAt(ans.length() - 1) == \\'/\\') {\\n            ans.deleteCharAt(ans.length() - 1);\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```\\n\\n\\n```python []\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        ans = []\\n        for p in path.split(\"/\"):\\n            if p == \"..\" and ans:\\n                ans.pop()\\n            elif p not in \"..\":\\n                ans.append(p)\\n        return \"/\" + \"/\".join(ans)\\n```\\n\\n\\n```go []\\nfunc simplifyPath(path string) string {\\n    ans := []string{}\\n    for _, s := range strings.Split(path, \"/\") {\\n        if s != \"\" && s != \".\" && s != \"..\"{\\n            ans = append(ans, s)\\n        } else if s == \"..\" && len(ans) > 0{\\n            ans = ans[:len(ans) - 1]\\n        }\\n    }\\n    return \"/\" + strings.Join(ans, \"/\")\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(N)$.\\n- **Space Complexity**: $O(N)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```java []\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        if (path == null || path.length() <= 1) {\\n            return \"/\";\\n        }\\n\\n        Stack<String> pathStack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        path = path.replaceAll(\"\\\\\\\\/\\\\\\\\/\", \"/\");\\n        String[] folders = path.split(\"\\\\\\\\/\");\\n        int len = folders.length;\\n        for (int i = 0; i < len; i++) {\\n            String folder = folders[i];\\n            if (folder.equalsIgnoreCase(\".\")) {\\n                continue;\\n            } else if (folder.equalsIgnoreCase(\"..\")) {\\n                if (!pathStack.empty()) {\\n                    pathStack.pop();\\n                }\\n            } else if (folder.length() > 0) {\\n                pathStack.push(folder);\\n            }\\n        }\\n\\n        ans.append(\\'/\\');\\n        List<String> res = new ArrayList<>();\\n        while (!pathStack.empty()) {\\n            res.add(pathStack.pop());\\n        }\\n\\n        for (int i = res.size() - 1; i >= 0; i--) {\\n            ans.append(res.get(i));\\n            ans.append(\"/\");\\n        }\\n\\n        if (ans.length() > 1 && ans.charAt(ans.length() - 1) == \\'/\\') {\\n            ans.deleteCharAt(ans.length() - 1);\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        ans = []\\n        for p in path.split(\"/\"):\\n            if p == \"..\" and ans:\\n                ans.pop()\\n            elif p not in \"..\":\\n                ans.append(p)\\n        return \"/\" + \"/\".join(ans)\\n```\n```go []\\nfunc simplifyPath(path string) string {\\n    ans := []string{}\\n    for _, s := range strings.Split(path, \"/\") {\\n        if s != \"\" && s != \".\" && s != \"..\"{\\n            ans = append(ans, s)\\n        } else if s == \"..\" && len(ans) > 0{\\n            ans = ans[:len(ans) - 1]\\n        }\\n    }\\n    return \"/\" + strings.Join(ans, \"/\")\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848443,
                "title": "c-strtok",
                "content": "```\\nchar * simplifyPath(char * path){\\n    int len = strlen(path) + 1;\\n    char** pathArray = (char**)calloc(len,sizeof(char*)); ;\\n    int idx = 0;\\n    char* p;\\n    p = strtok(path, \"/\");\\n    while (p != NULL) {\\n        if(strcmp(p, \"..\") == 0){\\n            if(idx-1 >= 0) idx -= 1;\\n        }\\n        else if(strcmp(p, \".\") != 0){\\n            pathArray[idx] = (char*)calloc(strlen(p) + 1,sizeof(char)); \\n            strcpy(pathArray[idx], p);\\n            idx += 1;\\n        }\\n        p = strtok(NULL, \"/\");\\t\\t   \\n    }\\n    char* result = (char*)calloc(len,sizeof(char)); \\n    for(int i=0; i<idx; i++){\\n        strcat(result,\"/\");\\n        strcat(result,pathArray[i]);\\n    }\\n    if(idx==0) strcat(result,\"/\");\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * simplifyPath(char * path){\\n    int len = strlen(path) + 1;\\n    char** pathArray = (char**)calloc(len,sizeof(char*)); ;\\n    int idx = 0;\\n    char* p;\\n    p = strtok(path, \"/\");\\n    while (p != NULL) {\\n        if(strcmp(p, \"..\") == 0){\\n            if(idx-1 >= 0) idx -= 1;\\n        }\\n        else if(strcmp(p, \".\") != 0){\\n            pathArray[idx] = (char*)calloc(strlen(p) + 1,sizeof(char)); \\n            strcpy(pathArray[idx], p);\\n            idx += 1;\\n        }\\n        p = strtok(NULL, \"/\");\\t\\t   \\n    }\\n    char* result = (char*)calloc(len,sizeof(char)); \\n    for(int i=0; i<idx; i++){\\n        strcat(result,\"/\");\\n        strcat(result,pathArray[i]);\\n    }\\n    if(idx==0) strcat(result,\"/\");\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848420,
                "title": "faster-than-99-submission",
                "content": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = []\\n    let pathToProcess = path.split(\\'/\\')\\n    for(let path of pathToProcess){\\n        if(path === \\'.\\' || path === \\'\\'){\\n            continue\\n        }\\n        if(path === \\'..\\'){\\n            stack.pop()\\n            continue\\n        }\\n        // console.log(path)\\n        stack.push(path)\\n        \\n    }\\n    return \\'/\\'+stack.join(\\'/\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    let stack = []\\n    let pathToProcess = path.split(\\'/\\')\\n    for(let path of pathToProcess){\\n        if(path === \\'.\\' || path === \\'\\'){\\n            continue\\n        }\\n        if(path === \\'..\\'){\\n            stack.pop()\\n            continue\\n        }\\n        // console.log(path)\\n        stack.push(path)\\n        \\n    }\\n    return \\'/\\'+stack.join(\\'/\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848281,
                "title": "solution-swift-simplify-path",
                "content": "```swift\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        var stack: [Substring] = []\\n        \\n        for p in path.split(separator: \"/\") {\\n            if p == \"..\" { stack.popLast() }\\n            else\\n                if p != \".\" { stack.append(p) }\\n        }\\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Note that there is no trailing slash after the last directory name.\\n    func test0() {\\n        let value = solution.simplifyPath(\"/home/\")\\n        XCTAssertEqual(value, \"/home\")\\n    }\\n    \\n    // Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\\n    func test1() {\\n        let value = solution.simplifyPath(\"/../\")\\n        XCTAssertEqual(value, \"/\")\\n    }\\n    \\n    // In the canonical path, multiple consecutive slashes are replaced by a single one.\\n    func test2() {\\n        let value = solution.simplifyPath(\"/home//foo/\")\\n        XCTAssertEqual(value, \"/home/foo\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```swift\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        var stack: [Substring] = []\\n        \\n        for p in path.split(separator: \"/\") {\\n            if p == \"..\" { stack.popLast() }\\n            else\\n                if p != \".\" { stack.append(p) }\\n        }\\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Note that there is no trailing slash after the last directory name.\\n    func test0() {\\n        let value = solution.simplifyPath(\"/home/\")\\n        XCTAssertEqual(value, \"/home\")\\n    }\\n    \\n    // Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\\n    func test1() {\\n        let value = solution.simplifyPath(\"/../\")\\n        XCTAssertEqual(value, \"/\")\\n    }\\n    \\n    // In the canonical path, multiple consecutive slashes are replaced by a single one.\\n    func test2() {\\n        let value = solution.simplifyPath(\"/home//foo/\")\\n        XCTAssertEqual(value, \"/home/foo\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847792,
                "title": "using-vector-of-strings-clean-and-concise-beginners-level",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> ans;\\n        int n = path.size();\\n        int i =0;\\n        while(i < n){\\n            \\n            string tmp = \"\";\\n            if(path[i] == \\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            while(i < n and path[i] != \\'/\\'){\\n                tmp.push_back(path[i]);\\n                i++;\\n            }\\n            if(tmp == \".\"){\\n                continue;\\n            }else if(tmp == \"..\"){\\n                if(ans.size() > 0) ans.pop_back();\\n            }else{\\n                ans.push_back(tmp);\\n            }\\n        }\\n        string rans=\"\";\\n        if(ans.size() == 0) return \"/\";\\n        for(auto x : ans){\\n            rans = rans + \"/\" + x;\\n        }\\n        return rans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> ans;\\n        int n = path.size();\\n        int i =0;\\n        while(i < n){\\n            \\n            string tmp = \"\";\\n            if(path[i] == \\'/\\'){\\n                i++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1847645,
                "title": "java-using-linkedlist-string-very-easy",
                "content": "The algorithm is simple. \\n* First split the given path with slash (/)\\n* Then itterate over the parts of the string\\n* If the part is not empty or is not dot(\".\") then -\\n\\t* If the part is \"..\" then pop last element from LinkedList\\n\\t* Else add the part into the LinkedList\\n* Join the elements in the LinkedList\\n```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        var parts = path.split(\"/\");\\n        var list = new LinkedList<String>();\\n        for (var part : parts) {\\n            if (part != null && !part.isEmpty() && !\".\".equals(part)) {\\n                if (\"..\".equals(part)) {\\n                    list.pollLast();\\n                } else {\\n                    list.add(part);\\n                }\\n            }\\n        }\\n        return \"/\" + String.join(\"/\", list);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String simplifyPath(String path) {\\n        var parts = path.split(\"/\");\\n        var list = new LinkedList<String>();\\n        for (var part : parts) {\\n            if (part != null && !part.isEmpty() && !\".\".equals(part)) {\\n                if (\"..\".equals(part)) {\\n                    list.pollLast();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1847303,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> q = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !q.isEmpty())    q.pop();\\n            else if(!skip.contains(dir)) q.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", q);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> q = new Stack();\\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\", \".\", \"\"));\\n        for(String dir : path.split(\"/\")){\\n            if(dir.equals(\"..\") && !q.isEmpty())    q.pop();\\n            else if(!skip.contains(dir)) q.push(dir);\\n        }\\n        return \"/\" + String.join(\"/\", q);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721754,
                "title": "c-solution-using-stack",
                "content": "\\n\\tstring simplifyPath(string path) {\\n        stack<string> st;\\n        string word=\"\";\\n        if(path[path.size()-1] !=\\'/\\')\\n            path+=\\'/\\';\\n        for(int i=0;i<path.size();i++)\\n        {\\n            if(path[i]==\\'/\\')\\n            {\\n                if(word==\"\" || word==\".\")\\n                {}\\n                else if(word==\"..\")\\n                {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else{\\n                //std::cout<<word;\\n                st.push(word);\\n                }\\n                 word=\"\";\\n            }\\n            else\\n                word+=path[i];\\n        }\\n        if(word.size()>0)\\n            st.push(word);\\n        int n=st.size();\\n        stack<string> st2;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=st.top();\\n            st.pop();\\n            st2.push(temp);\\n        }\\n        string ans=\"\";\\n        while (!st2.empty())\\n        {\\n            ans+=(\"/\"+st2.top());\\n            //std::cout<<st.top();\\n            st2.pop();\\n        }\\n        if(ans.size()==0)\\n        {ans+=\"/\";\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\nPlease upvote if you find it useful.\\nThanks :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "\\n\\tstring simplifyPath(string path) {\\n        stack<string> st;\\n        string word=\"\";\\n        if(path[path.size()-1] !=\\'/\\')\\n            path+=\\'/\\';\\n        for(int i=0;i<path.size();i++)\\n        {\\n            if(path[i]==\\'/\\')\\n            {\\n                if(word==\"\" || word==\".\")\\n                {}\\n                else if(word==\"..\")\\n                {\\n                    if(!st.empty())\\n                        st.pop();\\n                }\\n                else{\\n                //std::cout<<word;\\n                st.push(word);\\n                }\\n                 word=\"\";\\n            }\\n            else\\n                word+=path[i];\\n        }\\n        if(word.size()>0)\\n            st.push(word);\\n        int n=st.size();\\n        stack<string> st2;\\n        for(int i=0;i<n;i++)\\n        {\\n            string temp=st.top();\\n            st.pop();\\n            st2.push(temp);\\n        }\\n        string ans=\"\";\\n        while (!st2.empty())\\n        {\\n            ans+=(\"/\"+st2.top());\\n            //std::cout<<st.top();\\n            st2.pop();\\n        }\\n        if(ans.size()==0)\\n        {ans+=\"/\";\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\nPlease upvote if you find it useful.\\nThanks :)",
                "codeTag": "C++"
            },
            {
                "id": 1457918,
                "title": "simple-clean-easy-to-understand-cpp-solution",
                "content": "\\nThe CPP implementation of the approach is given below with the help of stack:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string word=\"\";\\n        stack<string>st;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            while(i<path.size()&&path[i]==\\'/\\')i++;\\n            while(i<path.size()&&path[i]!=\\'/\\')word=word+path[i],i++;\\n           \\n            if(word.size()){\\n            if(word==\".\"){word=\"\";continue;}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n            word=\"\";\\n            }\\n        }\\n        if(word.size()){\\n        if(word==\".\"){word=\"\";}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n        }\\n        string ans=\"\";\\n        while(st.size()){\\n            string ab=st.top();\\n            st.pop();\\n       ans=\"/\"+ab+ans;\\n        }\\n        \\n       \\n         return ans.size()==0?\"/\":ans;   \\n    }\\n};\\n```\\n\\n* If you find my solution easy to understand do Upvote it :)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        string word=\"\";\\n        stack<string>st;\\n        for(int i=0;i<path.size();i++)\\n        {\\n            while(i<path.size()&&path[i]==\\'/\\')i++;\\n            while(i<path.size()&&path[i]!=\\'/\\')word=word+path[i],i++;\\n           \\n            if(word.size()){\\n            if(word==\".\"){word=\"\";continue;}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n            word=\"\";\\n            }\\n        }\\n        if(word.size()){\\n        if(word==\".\"){word=\"\";}\\n            else if(word==\"..\"){\\n                word=\"\";\\n                if(st.size())\\n                st.pop();\\n            }\\n            else\\n            st.push(word);\\n        }\\n        string ans=\"\";\\n        while(st.size()){\\n            string ab=st.top();\\n            st.pop();\\n       ans=\"/\"+ab+ans;\\n        }\\n        \\n       \\n         return ans.size()==0?\"/\":ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313778,
                "title": "python-solution-71-simplified-path",
                "content": "```\\n#Upvote if you find it useful!\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        for x in path.split(\"/\"):\\n            if x==\"..\":\\n                if stack:\\n                    stack.pop()\\n            elif x==\\'.\\' or not x:\\n                continue\\n            else:\\n                stack.append(x)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n#Upvote if you find it useful!\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        for x in path.split(\"/\"):\\n            if x==\"..\":\\n                if stack:\\n                    stack.pop()\\n            elif x==\\'.\\' or not x:\\n                continue\\n            else:\\n                stack.append(x)\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306297,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        \\n        int l=0;\\n        int len=path.length();\\n        while(l<len){\\n            \\n            while(l<len and path[l]==\\'/\\')\\n                l++;\\n            string tmp;\\n            while(l<len and path[l]!=\\'/\\')\\n                tmp.push_back(path[l++]);\\n            if(tmp==\".\")\\n                continue;\\n            else if(tmp==\"..\")\\n            {\\n                if(!s.empty())\\n                    s.pop();\\n            }\\n            else if(tmp.length())\\n                s.push(tmp);\\n\\n        }\\n        vector<string> v;\\n    \\n        while(!s.empty())\\n        {\\n            v.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        int sz=v.size();\\n        string ans;\\n\\n        while(sz--)\\n        {\\n            ans+=\"/\";\\n            ans+=v[sz];\\n        }\\n        if(ans.length()==0)\\n            return \"/\";\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> s;\\n        \\n        int l=0;\\n        int len=path.length();\\n        while(l<len){\\n            \\n            while(l<len and path[l]==\\'/\\')\\n                l++;\\n            string tmp;\\n            while(l<len and path[l]!=\\'/\\')\\n                tmp.push_back(path[l++]);\\n            if(tmp==\".\")\\n                continue;\\n            else if(tmp==\"..\")\\n            {\\n                if(!s.empty())\\n                    s.pop();\\n            }\\n            else if(tmp.length())\\n                s.push(tmp);\\n\\n        }\\n        vector<string> v;\\n    \\n        while(!s.empty())\\n        {\\n            v.push_back(s.top());\\n            s.pop();\\n        }\\n\\n        int sz=v.size();\\n        string ans;\\n\\n        while(sz--)\\n        {\\n            ans+=\"/\";\\n            ans+=v[sz];\\n        }\\n        if(ans.length()==0)\\n            return \"/\";\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1258987,
                "title": "c-4-ms-solution-using-stack-with-explanation",
                "content": "```\\nHere we have to insert \\'/\\' at the end of the string if not present because we are going to complete a string when we will find a \\'/ \\'.\\n```class Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string>st;\\n        string s1,s2;\\n        int n=path.size();\\n        if(path[n-1]!=\\'/\\')\\n            path.insert(n,\"/\");\\n        for(int i=1;i<path.size();i++)\\n        {\\n\\t\\t// checking if \\'/ \\' present or not because it will be the end of string.\\n            if(path[i]!=\\'/\\')\\n            {\\n                s1.push_back(path[i]);\\n            }\\n            else\\n            {\\n                if(s1.size()>0)\\n                st.push(s1);\\n                if(s1==\"..\")\\n                {\\n\\t\\t\\t\\t// suppose you have only \"..\" in stack then stack size will be 1 and two times poping will give runtime error\\n\\t\\t\\t\\t//because we have to pop \"..\" and one more top item from stack to go to it`s parent\\n                    if(st.size()>=2)\\n                    {\\n                            st.pop();\\n                            st.pop();\\n                    }\\n                    else\\n                        st.pop();\\n                }\\n                if(s1==\".\")\\n                {\\n                    st.pop();\\n                }\\n                s1.clear();\\n            }\\n        }\\n         if(st.empty())\\n             return \"/\";\\n        while(st.size()>0)\\n        {\\n            s2.insert(0,st.top());\\n            s2.insert(0,\"/\");\\n            st.pop();\\n        }\\n        return s2;\\n    }\\n};\\n# *if you find this solution useful, please upvote*\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nHere we have to insert \\'/\\' at the end of the string if not present because we are going to complete a string when we will find a \\'/ \\'.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185521,
                "title": "short-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string>st;\\n        int i=0, n=path.length();\\n        while(i<n){\\n            string temp;\\n            while(path[i]==\\'/\\' && i<n) i++;\\n            while(path[i]!=\\'/\\' && i<n) temp+=path[i++];\\n            if(temp==\"..\" && !st.empty()) st.pop_back();\\n            else if(temp==\".\" || temp==\"\") continue;\\n            else if(temp!=\"..\") st.push_back(temp);               \\n        }\\n        string res;\\n        for(string s:st) res+= \"/\" + s;\\n        return res.empty() ? \"/\":res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string>st;\\n        int i=0, n=path.length();\\n        while(i<n){\\n            string temp;\\n            while(path[i]==\\'/\\' && i<n) i++;\\n            while(path[i]!=\\'/\\' && i<n) temp+=path[i++];\\n            if(temp==\"..\" && !st.empty()) st.pop_back();\\n            else if(temp==\".\" || temp==\"\") continue;\\n            else if(temp!=\"..\") st.push_back(temp);               \\n        }\\n        string res;\\n        for(string s:st) res+= \"/\" + s;\\n        return res.empty() ? \"/\":res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179620,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        String[] splitString=path.split(\"/+\");\\n        Stack<String> st= new Stack<>();\\n        \\n        for(String s:splitString){\\n            if(st.size()>0 &&  \"..\".equals(s)){\\n                st.pop();\\n            }else if(!Arrays.asList(\"\",\".\",\"..\").contains(s)){ \\n// A list contain [ \" \",\".\",\"..\"] and if a string(s) contain any list element than continue else put into stack..\\n                //  I strongly recommended please dry run this once to know better how it work \\n                st.push(s);\\n            }            \\n            \\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();      \\n                   \\n        for(String s1: st){\\n            sb.append(\"/\").append(s1);\\n        }\\n        \\n        return sb.length()==0 ? \"/\":sb.toString();\\n        \\n        \\n    // In place of line  16 to 22 we can also  use. .... \\n    //    return \"/\" + String.join(\"/\"+st);     \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        String[] splitString=path.split(\"/+\");\\n        Stack<String> st= new Stack<>();\\n        \\n        for(String s:splitString){\\n            if(st.size()>0 &&  \"..\".equals(s)){\\n                st.pop();\\n            }else if(!Arrays.asList(\"\",\".\",\"..\").contains(s)){ \\n// A list contain [ \" \",\".\",\"..\"] and if a string(s) contain any list element than continue else put into stack..\\n                //  I strongly recommended please dry run this once to know better how it work \\n                st.push(s);\\n            }            \\n            \\n        }\\n        \\n        \\n        StringBuilder sb = new StringBuilder();      \\n                   \\n        for(String s1: st){\\n            sb.append(\"/\").append(s1);\\n        }\\n        \\n        return sb.length()==0 ? \"/\":sb.toString();\\n        \\n        \\n    // In place of line  16 to 22 we can also  use. .... \\n    //    return \"/\" + String.join(\"/\"+st);     \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130045,
                "title": "c-100-faster-two-pointers-no-stack",
                "content": "// Two pointers\\n   \\n\\t\\tstring simplifyPath(string path)\\n\\t\\t{\\n\\t\\t\\tstring result;\\n\\n\\t\\t\\tsize_t front = 0;\\n\\t\\t\\tsize_t rear = 0;\\n\\n\\t\\t\\twhile (front < path.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trear = path.find(\\'/\\', front + 1);\\n\\n\\t\\t\\t\\tif (rear == path.npos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trear = path.length();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Skip \"//\"\\n\\t\\t\\t\\tif (rear - front > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring s = path.substr(front + 1, rear - front - 1);\\n\\n\\t\\t\\t\\t\\t// Skip \".\"\\n\\t\\t\\t\\t\\tif (!s.empty() && s != \".\")\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t// Handle \"..\"\\n\\t\\t\\t\\t\\t\\tif (s == \"..\")\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (!result.empty())\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresult.erase(result.find_last_of(\\'/\\'));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tresult += \"/\" + s;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfront = rear;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (result.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "// Two pointers\\n   \\n\\t\\tstring simplifyPath(string path)\\n\\t\\t{\\n\\t\\t\\tstring result;\\n\\n\\t\\t\\tsize_t front = 0;\\n\\t\\t\\tsize_t rear = 0;\\n\\n\\t\\t\\twhile (front < path.length() - 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\trear = path.find(\\'/\\', front + 1);\\n\\n\\t\\t\\t\\tif (rear == path.npos)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trear = path.length();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Skip \"//\"\\n\\t\\t\\t\\tif (rear - front > 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring s = path.substr(front + 1, rear - front - 1);\\n\\n\\t\\t\\t\\t\\t// Skip \".\"\\n\\t\\t\\t\\t\\tif (!s.empty() && s != \".\")\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t// Handle \"..\"\\n\\t\\t\\t\\t\\t\\tif (s == \"..\")\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif (!result.empty())\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tresult.erase(result.find_last_of(\\'/\\'));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tresult += \"/\" + s;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfront = rear;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (result.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn \"/\";\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1055024,
                "title": "c-solution",
                "content": "```\\nstring simplifyPath(string path) {\\n\\tvector<string> parts {};\\n\\tint i = 0;\\n\\twhile (i < path.size()) {\\n\\t\\tif (path[i] != \\'/\\') {\\n\\t\\t\\tstring cur = \"\";\\n\\t\\t\\twhile (i < path.size() && path[i] != \\'/\\')\\n\\t\\t\\t\\tcur += path[i++];\\n\\t\\t\\tif (cur == \"..\") {\\n\\t\\t\\t\\tif (!parts.empty())\\n\\t\\t\\t\\t\\tparts.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\telse if (cur != \".\")\\n\\t\\t\\t\\tparts.push_back(cur);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n\\tstring result = \"\";\\n\\tfor (string s : parts)\\n\\t\\tresult += \"/\" + s;\\n\\treturn result.empty() ? \"/\" : result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring simplifyPath(string path) {\\n\\tvector<string> parts {};\\n\\tint i = 0;\\n\\twhile (i < path.size()) {\\n\\t\\tif (path[i] != \\'/\\') {\\n\\t\\t\\tstring cur = \"\";\\n\\t\\t\\twhile (i < path.size() && path[i] != \\'/\\')\\n\\t\\t\\t\\tcur += path[i++];\\n\\t\\t\\tif (cur == \"..\") {\\n\\t\\t\\t\\tif (!parts.empty())\\n\\t\\t\\t\\t\\tparts.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\telse if (cur != \".\")\\n\\t\\t\\t\\tparts.push_back(cur);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ti++;\\n\\t}\\n\\tstring result = \"\";\\n\\tfor (string s : parts)\\n\\t\\tresult += \"/\" + s;\\n\\treturn result.empty() ? \"/\" : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051006,
                "title": "python-3-two-pointers-o-n",
                "content": "- Split ```path``` by the separator ```/```. Note ```path``` is starting with the separator. So first element of the list is empty string.\\n- Iteratively move fast pointer forward. Slow pointer can be incremented (general case), decremented (```..```) or unchanged (``` ```, ```.```). If it is incremented then copy value from the fast pointer.\\n- Delete unnecessary tail from the list and join all items of the list into a string. \\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        arr = path.split(\\'/\\'); j = 1\\n        for a in arr:\\n            if a == \\'..\\':\\n                j = max(1, j-1)\\n            elif a and a != \\'.\\':\\n                arr[j] = a; j += 1\\n        del arr[j:]\\n        \\n        return \\'/\\'.join(arr) or \\'/\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```path```\n```/```\n```path```\n```..```\n``` ```\n```.```\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        arr = path.split(\\'/\\'); j = 1\\n        for a in arr:\\n            if a == \\'..\\':\\n                j = max(1, j-1)\\n            elif a and a != \\'.\\':\\n                arr[j] = a; j += 1\\n        del arr[j:]\\n        \\n        return \\'/\\'.join(arr) or \\'/\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050624,
                "title": "python-by-stack-w-comment",
                "content": "Python by stack\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n\\n        # stack to store directory name\\n        stack = []\\n        \\n        # check each directory name in given path, split by \\'/\\'\\n        for dir_name in path.split(\\'/\\'):\\n            \\n            # do nothing if directory name is either empty string or \\'.\\'\\n            if dir_name == \\'\\' or dir_name == \\'.\\':\\n                continue\\n\\n            # go back to parnet level and pop stack if stack is not empty    \\n            elif dir_name == \\'..\\':    \\n                stack and stack.pop()\\n\\n            # push current directory name into stack                    \\n            else:\\n                stack.append( dir_name )\\n                \\n        return \\'/\\' + \\'/\\'.join( stack )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about stack operation](https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks)\\n\\n[2] [Python official docs about str.split( ... )](https://docs.python.org/3/library/stdtypes.html?highlight=str%20split#str.split)\\n\\n[3] [Python official docs about str.join( ... )](https://docs.python.org/3/library/stdtypes.html?highlight=str%20split#str.split)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n\\n        # stack to store directory name\\n        stack = []\\n        \\n        # check each directory name in given path, split by \\'/\\'\\n        for dir_name in path.split(\\'/\\'):\\n            \\n            # do nothing if directory name is either empty string or \\'.\\'\\n            if dir_name == \\'\\' or dir_name == \\'.\\':\\n                continue\\n\\n            # go back to parnet level and pop stack if stack is not empty    \\n            elif dir_name == \\'..\\':    \\n                stack and stack.pop()\\n\\n            # push current directory name into stack                    \\n            else:\\n                stack.append( dir_name )\\n                \\n        return \\'/\\' + \\'/\\'.join( stack )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750394,
                "title": "simple-c-solution-easy-to-understand-stack-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        path+=\"/\";\\n        string temp=\"\";\\n        for(int i=0;i<path.length();i++){\\n            if(path[i]==\\'/\\'){\\n                if(temp==\"\"||temp==\".\"){\\n                    temp=\"\";\\n                    continue;\\n                }else if(temp==\"..\"){\\n                    if(st.size()){\\n                        st.pop();\\n                    }\\n                    \\n                    temp=\"\";\\n                }else{\\n                    st.push(temp);\\n                    temp=\"\";\\n                }\\n            }else{\\n                temp+=path[i];\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(st.size()){\\n            ans=st.top()+\"/\"+ans;\\n            st.pop();\\n        }\\n        if(ans!=\"\"){\\n            ans.pop_back();\\n        }\\n        ans=\"/\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        path+=\"/\";\\n        string temp=\"\";\\n        for(int i=0;i<path.length();i++){\\n            if(path[i]==\\'/\\'){\\n                if(temp==\"\"||temp==\".\"){\\n                    temp=\"\";\\n                    continue;\\n                }else if(temp==\"..\"){\\n                    if(st.size()){\\n                        st.pop();\\n                    }\\n                    \\n                    temp=\"\";\\n                }else{\\n                    st.push(temp);\\n                    temp=\"\";\\n                }\\n            }else{\\n                temp+=path[i];\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(st.size()){\\n            ans=st.top()+\"/\"+ans;\\n            st.pop();\\n        }\\n        if(ans!=\"\"){\\n            ans.pop_back();\\n        }\\n        ans=\"/\"+ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695975,
                "title": "simple-java-solution-with-list",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        List<String> paths = new ArrayList<>(path.length());\\n        int i = -1;\\n        for(String folder : path.split(\"/\")){\\n            if(folder.equals(\"..\")){\\n                if(!paths.isEmpty()){\\n                    paths.remove(i);\\n                    i --;   \\n                }\\n            }else if(!folder.isEmpty() && !folder.equals(\".\")){\\n                paths.add(folder);\\n                i++;\\n            }\\n            \\n        }\\n        return \"/\"+String.join(\"/\", paths);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        List<String> paths = new ArrayList<>(path.length());\\n        int i = -1;\\n        for(String folder : path.split(\"/\")){\\n            if(folder.equals(\"..\")){\\n                if(!paths.isEmpty()){\\n                    paths.remove(i);\\n                    i --;   \\n                }\\n            }else if(!folder.isEmpty() && !folder.equals(\".\")){\\n                paths.add(folder);\\n                i++;\\n            }\\n            \\n        }\\n        return \"/\"+String.join(\"/\", paths);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601469,
                "title": "easy-to-understand-c-code-using-stack",
                "content": "If there is \\'/\\' then continue no need to push or pop anything. Otherwise make a string until another \\'/\\'.\\n1. If string is \".\" the continue\\n2. If string is \"..\" then pop stack if not empty and continue\\n3. Push the string to the stack\\n\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        \\n        int n=path.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            string s=\"\";\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                s=s+path[i];\\n                i++;\\n            }\\n            i--;\\n            \\n            if(s==\".\")\\n                continue;\\n            if(s==\"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                continue;\\n            }\\n            st.push(s);\\n        }\\n        \\n        if(st.empty())\\n            return \"/\";\\n        \\n        string result=\"\";\\n        while(!st.empty())\\n        {\\n            result=\"/\" + st.top() + result;\\n            cout<<st.top()<<\"/\";\\n            st.pop();\\n        }\\n        cout<<endl;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        \\n        int n=path.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(path[i]==\\'/\\')\\n                continue;\\n            \\n            string s=\"\";\\n            while(i<n && path[i]!=\\'/\\')\\n            {\\n                s=s+path[i];\\n                i++;\\n            }\\n            i--;\\n            \\n            if(s==\".\")\\n                continue;\\n            if(s==\"..\")\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                continue;\\n            }\\n            st.push(s);\\n        }\\n        \\n        if(st.empty())\\n            return \"/\";\\n        \\n        string result=\"\";\\n        while(!st.empty())\\n        {\\n            result=\"/\" + st.top() + result;\\n            cout<<st.top()<<\"/\";\\n            st.pop();\\n        }\\n        cout<<endl;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 500999,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n        Stack<String> segmentStack = new Stack<>();\\n        for (String segment : path.split(\"/\")) {\\n            if (!segment.isEmpty() && !segment.equals(\".\")) {\\n                if (segment.equals(\"..\")) {\\n                    if (!segmentStack.isEmpty()) {\\n                        segmentStack.pop();\\n                    }\\n                } else {\\n                    segmentStack.push(segment);\\n                }\\n            }\\n        }\\n\\n        if (segmentStack.isEmpty()) {\\n            return \"/\";\\n        }\\n        \\n        Stack<String> reversedStack = new Stack<>();\\n        while (!segmentStack.isEmpty()) {\\n            reversedStack.push(segmentStack.pop());\\n        }\\n        \\n        StringBuilder outputBuilder = new StringBuilder();\\n        while (!reversedStack.isEmpty()) {\\n            outputBuilder.append(\"/\");\\n            outputBuilder.append(reversedStack.pop());\\n        }\\n        \\n        return outputBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n        Stack<String> segmentStack = new Stack<>();\\n        for (String segment : path.split(\"/\")) {\\n            if (!segment.isEmpty() && !segment.equals(\".\")) {\\n                if (segment.equals(\"..\")) {\\n                    if (!segmentStack.isEmpty()) {\\n                        segmentStack.pop();\\n                    }\\n                } else {\\n                    segmentStack.push(segment);\\n                }\\n            }\\n        }\\n\\n        if (segmentStack.isEmpty()) {\\n            return \"/\";\\n        }\\n        \\n        Stack<String> reversedStack = new Stack<>();\\n        while (!segmentStack.isEmpty()) {\\n            reversedStack.push(segmentStack.pop());\\n        }\\n        \\n        StringBuilder outputBuilder = new StringBuilder();\\n        while (!reversedStack.isEmpty()) {\\n            outputBuilder.append(\"/\");\\n            outputBuilder.append(reversedStack.pop());\\n        }\\n        \\n        return outputBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472288,
                "title": "accepted-c-stack-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public string SimplifyPath(string path) \\n    {\\n        string[] pathDir = path.Split(new [] { \\'/\\' });\\n        Stack<string> stack = new Stack<string>();\\n        foreach (string dir in pathDir)\\n        {\\n            if (dir == \".\" || dir.Length == 0) continue;\\n            if (dir == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                    stack.Pop();\\n                continue;\\n            }\\n            stack.Push(dir);\\n        }\\n        \\n        var res = new StringBuilder();\\n        while (stack.Count > 0)\\n            res.Insert(0, \"/\" + stack.Pop());\\n        return res.Length == 0 ? \"/\" : res.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string SimplifyPath(string path) \\n    {\\n        string[] pathDir = path.Split(new [] { \\'/\\' });\\n        Stack<string> stack = new Stack<string>();\\n        foreach (string dir in pathDir)\\n        {\\n            if (dir == \".\" || dir.Length == 0) continue;\\n            if (dir == \"..\")\\n            {\\n                if (stack.Count > 0)\\n                    stack.Pop();\\n                continue;\\n            }\\n            stack.Push(dir);\\n        }\\n        \\n        var res = new StringBuilder();\\n        while (stack.Count > 0)\\n            res.Insert(0, \"/\" + stack.Pop());\\n        return res.Length == 0 ? \"/\" : res.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313909,
                "title": "c-99-beat-iterative-stack-solution-pretty-basic-judge-4-urself",
                "content": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        vector <string> aList;\\n        \\n        int aPrevIndex = 0;\\n        for (int i=0;i<path.size();i++) {\\n            if (path[i] == \\'/\\') {\\n                if (i > aPrevIndex) {\\n                    aList.push_back(path.substr(aPrevIndex, i - aPrevIndex));\\n                }\\n                aPrevIndex = i + 1;\\n            }\\n        }\\n        \\n        if (path.size() > aPrevIndex) {\\n            aList.push_back(path.substr(aPrevIndex, path.size() - aPrevIndex));\\n        }\\n        \\n        vector <string> aStack;\\n        for (int i=0;i<aList.size();i++) {\\n            if (aList[i] == \".\") { continue; }\\n            if (aList[i] == \"..\") { \\n                if (aStack.empty() == false) {\\n                    aStack.pop_back();\\n                }\\n                continue;\\n            }\\n            if (aList[i].size() > 0) {\\n                aStack.push_back(aList[i]);\\n            }\\n        }\\n        \\n        string aResult = \"/\";\\n        for (int i=0;i<aStack.size();i++) {\\n            aResult += aStack[i];\\n            if (i < (aStack.size() - 1)) {\\n                aResult += \"/\";\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nKaboom, easy solutions. Now you\\'re on the payroll. Lucky ducky.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n        vector <string> aList;\\n        \\n        int aPrevIndex = 0;\\n        for (int i=0;i<path.size();i++) {\\n            if (path[i] == \\'/\\') {\\n                if (i > aPrevIndex) {\\n                    aList.push_back(path.substr(aPrevIndex, i - aPrevIndex));\\n                }\\n                aPrevIndex = i + 1;\\n            }\\n        }\\n        \\n        if (path.size() > aPrevIndex) {\\n            aList.push_back(path.substr(aPrevIndex, path.size() - aPrevIndex));\\n        }\\n        \\n        vector <string> aStack;\\n        for (int i=0;i<aList.size();i++) {\\n            if (aList[i] == \".\") { continue; }\\n            if (aList[i] == \"..\") { \\n                if (aStack.empty() == false) {\\n                    aStack.pop_back();\\n                }\\n                continue;\\n            }\\n            if (aList[i].size() > 0) {\\n                aStack.push_back(aList[i]);\\n            }\\n        }\\n        \\n        string aResult = \"/\";\\n        for (int i=0;i<aStack.size();i++) {\\n            aResult += aStack[i];\\n            if (i < (aStack.size() - 1)) {\\n                aResult += \"/\";\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313904,
                "title": "swift-simple-stack-solution-using-all-arrays-o-n-good-speed",
                "content": "```\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        \\n        var list = path.split(separator: \"/\")\\n        print(list)\\n        \\n        var stack = [String]()\\n        \\n        for component in list {\\n            \\n            if component == \".\" { continue }\\n            if component == \"..\" {\\n                if stack.count > 0 { stack.removeLast() }\\n                continue\\n            }\\n            \\n            if component.count > 0 { stack.append(String(component)) }\\n        }\\n        \\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```\\n\\nKaboom, G, you\\'re on the pAyRoLl now BOIIIIIII",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func simplifyPath(_ path: String) -> String {\\n        \\n        var list = path.split(separator: \"/\")\\n        print(list)\\n        \\n        var stack = [String]()\\n        \\n        for component in list {\\n            \\n            if component == \".\" { continue }\\n            if component == \"..\" {\\n                if stack.count > 0 { stack.removeLast() }\\n                continue\\n            }\\n            \\n            if component.count > 0 { stack.append(String(component)) }\\n        }\\n        \\n        return \"/\" + stack.joined(separator: \"/\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307383,
                "title": "short-python-o-n-with-explanation",
                "content": "O(n) - every character in path \\nSpace: O(n) - might just have a long directory name piling on to the stack\\nAlgorithm: Keep a stack tracking the directory level, skip over the . and only append directories which are not the . or ..\\nWhen an .. is encountered pop from the stack (go up a level in the hierarchy) only if you have something in the stack, otherwise do nothing (empty stack encountering ..).\\n\\n```\\ndef simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"        \\n        # Splitting is O(n*m) - where m is the length of the character to split, here this is O(n)\\n        plist = path.split(\\'/\\')\\n        stack = []\\n        for directory in plist:\\n            if directory == \".\" or not directory:\\n                continue\\n            # Need this condition nested for case of /../a\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n                \\n        return \"/\" + \"/\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "O(n) - every character in path \\nSpace: O(n) - might just have a long directory name piling on to the stack\\nAlgorithm: Keep a stack tracking the directory level, skip over the . and only append directories which are not the . or ..\\nWhen an .. is encountered pop from the stack (go up a level in the hierarchy) only if you have something in the stack, otherwise do nothing (empty stack encountering ..).\\n\\n```\\ndef simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"        \\n        # Splitting is O(n*m) - where m is the length of the character to split, here this is O(n)\\n        plist = path.split(\\'/\\')\\n        stack = []\\n        for directory in plist:\\n            if directory == \".\" or not directory:\\n                continue\\n            # Need this condition nested for case of /../a\\n            elif directory == \"..\":\\n                if stack:\\n                    stack.pop()\\n            else:\\n                stack.append(directory)\\n                \\n        return \"/\" + \"/\".join(stack)",
                "codeTag": "Python3"
            },
            {
                "id": 175951,
                "title": "one-line-golang-solution-for-fun",
                "content": "```\\nfunc simplifyPath(path string) string {\\n    return filepath.Clean(path);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc simplifyPath(path string) string {\\n    return filepath.Clean(path);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154576,
                "title": "easy-and-clean-to-understand-no-stack-java",
                "content": "Start from the right most directory. If we encounter \\'..\\' we have to skip one directory. As, in linux \\'..\\' is to go one directory up.\\n\\t\\t\\n```\\npublic String simplifyPath(String path) {\\n        String[] temp = path.split(\"/\");\\n        int skip = 0;\\n        String ans = \"\";\\n        \\n        for(int i = temp.length - 1; i >= 0; i-- ){\\n            if(temp[i].equals(\".\") || temp[i].equals(\"\"))\\n                continue;\\n            else if(temp[i].equals(\"..\"))\\n                skip++;\\n            else if(skip > 0)\\n                skip--;\\n            else\\n                ans =  \"/\" + temp[i]  + ans;\\n        }\\n        return ans == \"\" ? \"/\" : ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic String simplifyPath(String path) {\\n        String[] temp = path.split(\"/\");\\n        int skip = 0;\\n        String ans = \"\";\\n        \\n        for(int i = temp.length - 1; i >= 0; i-- ){\\n            if(temp[i].equals(\".\") || temp[i].equals(\"\"))\\n                continue;\\n            else if(temp[i].equals(\"..\"))\\n                skip++;\\n            else if(skip > 0)\\n                skip--;\\n            else\\n                ans =  \"/\" + temp[i]  + ans;\\n        }\\n        return ans == \"\" ? \"/\" : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25750,
                "title": "5-line-js-solution",
                "content": "```js\\nfunction simplifyPath(path) {\\n    const stack = [];\\n    \\n    for (let p of path.split('/').filter(p => p && p !== '.')) {\\n        p === '..' ? stack.pop() : stack.push(p);\\n    }\\n    \\n    return '/' + stack.join('/');\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction simplifyPath(path) {\\n    const stack = [];\\n    \\n    for (let p of path.split('/').filter(p => p && p !== '.')) {\\n        p === '..' ? stack.pop() : stack.push(p);\\n    }\\n    \\n    return '/' + stack.join('/');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25765,
                "title": "5ms-java-implementation-using-stack-beats-99-63",
                "content": "    public String simplifyPath(String path) {\\n        int len = path.length();\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < len; ) {\\n            char c = path.charAt(i);\\n            if (c == '/') { ++i; }  // skip the separator '/'\\n            else if (c == '.') {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                if (j - i == 2 && path.charAt(i + 1) == '.' && !stack.isEmpty()) {  // go up to parent directory\\n                    stack.removeLast();\\n                } else if (j - i > 2) {\\n                    stack.addLast(path.substring(i, j));  // go down to child directory\\n                }\\n                i = j;\\n            } else {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                stack.addLast(path.substring(i, j));  // go down to child directory\\n                i = j;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for (String dir: stack) { ans.append('/').append(dir); }\\n        if (ans.length() == 0) { return \"/\"; }\\n        return ans.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String simplifyPath(String path) {\\n        int len = path.length();\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < len; ) {\\n            char c = path.charAt(i);\\n            if (c == '/') { ++i; }  // skip the separator '/'\\n            else if (c == '.') {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                if (j - i == 2 && path.charAt(i + 1) == '.' && !stack.isEmpty()) {  // go up to parent directory\\n                    stack.removeLast();\\n                } else if (j - i > 2) {\\n                    stack.addLast(path.substring(i, j));  // go down to child directory\\n                }\\n                i = j;\\n            } else {\\n                int j = i + 1;\\n                while (j < len && path.charAt(j) != '/') { ++j; }\\n                stack.addLast(path.substring(i, j));  // go down to child directory\\n                i = j;\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        for (String dir: stack) { ans.append('/').append(dir); }\\n        if (ans.length() == 0) { return \"/\"; }\\n        return ans.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25793,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static String simplifyPath(String path) {\\n\\t\\tif (path == null || path.length() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tString[] parts = path.split(\"/\");\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tfor (int i = 0; i < parts.length; i++) {\\n\\t\\t\\tif (parts[i].equals(\".\")||parts[i].equals(\"\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if (parts[i].equals(\"..\")) {\\n\\t\\t\\t\\tif (!stack.isEmpty())\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tstack.push(parts[i]);\\n\\t\\t}\\n\\t\\tif (stack.isEmpty())\\n\\t\\t\\treturn \"/\";\\n\\t\\tString result = \"\";\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tresult = \"/\" + stack.pop() + result;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static String simplifyPath(String path) {\\n\\t\\tif (path == null || path.length() == 0)\\n\\t\\t\\treturn null;\\n\\t\\tString[] parts = path.split(\"/\");\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tfor (int i = 0; i < parts.length; i++) {\\n\\t\\t\\tif (parts[i].equals(\".\")||parts[i].equals(\"\"))\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\telse if (parts[i].equals(\"..\")) {\\n\\t\\t\\t\\tif (!stack.isEmpty())\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tstack.push(parts[i]);\\n\\t\\t}\\n\\t\\tif (stack.isEmpty())\\n\\t\\t\\treturn \"/\";\\n\\t\\tString result = \"\";\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tresult = \"/\" + stack.pop() + result;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 25824,
                "title": "2ms-solution-in-c",
                "content": "    #include<stdlib.h>\\n\\n    char* simplifyPath(char* path) \\n    {\\n        int top = -1;\\n        int i;\\n        int j;\\n    \\n        for(i = 0; path[i] != '\\\\0'; ++i)\\n        {\\n            path[++top] = path[i]; \\n            if(top >= 1 && path[top - 1] == '/' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                top -= 2;\\n            }\\n            else if(top >= 2 && path[top - 2] == '/' && path[top - 1] == '.' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                for(j = top - 3; j >= 0; --j)\\n                {\\n                    if(path[j] == '/') break;\\n                }\\n                if(j < 0)\\n                {\\n                    top = -1;\\n                }\\n                else\\n                {\\n                    top = j - 1;\\n                }\\n            }\\n            else if(path[top] == '/' && path[i + 1] == '/') --top;\\n        }\\n        if(top > 0) \\n        {\\n            if(path[top] == '/') path[top] = '\\\\0';\\n            else path[top + 1] = '\\\\0';\\n        }\\n        else if(top == 0) path[top + 1] = '\\\\0';\\n        else \\n        {\\n            path[0] = '/'; \\n            path[1] = '\\\\0';\\n        }\\n        return path;\\n    }",
                "solutionTags": [],
                "code": "    #include<stdlib.h>\\n\\n    char* simplifyPath(char* path) \\n    {\\n        int top = -1;\\n        int i;\\n        int j;\\n    \\n        for(i = 0; path[i] != '\\\\0'; ++i)\\n        {\\n            path[++top] = path[i]; \\n            if(top >= 1 && path[top - 1] == '/' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                top -= 2;\\n            }\\n            else if(top >= 2 && path[top - 2] == '/' && path[top - 1] == '.' && path[top] == '.' && (path[i + 1] == '/' || path[i + 1] == '\\\\0'))\\n            {\\n                for(j = top - 3; j >= 0; --j)\\n                {\\n                    if(path[j] == '/') break;\\n                }\\n                if(j < 0)\\n                {\\n                    top = -1;\\n                }\\n                else\\n                {\\n                    top = j - 1;\\n                }\\n            }\\n            else if(path[top] == '/' && path[i + 1] == '/') --top;\\n        }\\n        if(top > 0) \\n        {\\n            if(path[top] == '/') path[top] = '\\\\0';\\n            else path[top + 1] = '\\\\0';\\n        }\\n        else if(top == 0) path[top + 1] = '\\\\0';\\n        else \\n        {\\n            path[0] = '/'; \\n            path[1] = '\\\\0';\\n        }\\n        return path;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 25826,
                "title": "java-already-has-the-method-string-join",
                "content": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<String>();\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty())\\n                stack.pop();\\n            else if (!s.equals(\".\") && !s.equals(\"..\") && !s.equals(\"\"))\\n                stack.push(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }",
                "solutionTags": [],
                "code": "    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<String>();\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty())\\n                stack.pop();\\n            else if (!s.equals(\".\") && !s.equals(\"..\") && !s.equals(\"\"))\\n                stack.push(s);\\n        }\\n        return \"/\" + String.join(\"/\", stack);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25741,
                "title": "simple-python-ac-code",
                "content": "    class Solution:\\n    # @param path, a string\\n    # @return a string\\n    def simplifyPath(self, path):\\n        result = []\\n        pathList = path.split('/')\\n        for content in pathList:\\n            if content:\\n                if content == '..':\\n                    try:\\n                        result.pop()\\n                    except:\\n                        result = []\\n                elif content != '.':\\n                    result.append(content)\\n        return '/'+'/'.join(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param path, a string\\n    # @return a string\\n    def simplifyPath(self, path):\\n        result = []\\n        pathList = path.split('/')\\n        for content in pathList:\\n            if content:\\n                if content == '..':\\n                    try:\\n                        result.pop()\\n                    except:\\n                        result = []\\n                elif content != '.':\\n                    result.append(content)\\n        return '/'+'/'.join(result)",
                "codeTag": "Java"
            },
            {
                "id": 4050586,
                "title": "simplify-path-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803142,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    std::string simplifyPath(std::string path)\\n    {\\n        if (path.size() == 1)\\n        {\\n            return path;\\n        }\\n        std::string result;\\n        std::stack<std::string> stk;\\n        std::string temp;\\n        for (int i = 0; i < path.size(); i++)\\n        {\\n            temp.clear();\\n\\n            while (path[i] == \\'/\\')\\n            {\\n                i++;\\n            }\\n\\n            while (i < path.size() && path[i] != \\'/\\')\\n            {\\n                temp += path[i];\\n                i++;\\n            }\\n\\n            if (temp == \"..\")\\n            {\\n                if (!stk.empty())\\n                {\\n                    stk.pop();\\n                }\\n            }\\n            else\\n            {\\n                if (temp != \".\" && temp != \"\")\\n                {\\n                    stk.push(temp);\\n                }\\n            }\\n        }\\n        std::stack<std::string> reverse;\\n        while (!stk.empty())\\n        {\\n            reverse.push(stk.top());\\n            stk.pop();\\n        }\\n\\n        while (!reverse.empty())\\n        {\\n            result += \"/\" + reverse.top();\\n            reverse.pop();\\n        }\\n\\n        return result.empty() ? \"/\" : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415113,
                "title": "o-n-solution-golang",
                "content": "# Intuition\\nWhen thinking of unix path, first data structure comes to mind is `stack` because we can simply push each directory in our stack when we found \"/\" and also pop the directory on \"..\"\\n\\n# Approach\\nFirst of all, we need to implement the `stack` data structure. The simplest way is using Go struct with property `a` type of []string.\\n\\n```go\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n    // implementation here\\n}\\n\\nfunc (st *stack) peek() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) pop() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n    // implementation here\\n}\\n```\\n\\nThen, we implement a special method, `constructAbsolutePath` which joins every string in our stack with `\"/\"`. This is not too difficult to understand right?\\n\\n```go\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n```\\n\\nAfter implementing stack data structure, we are now ready to solve this problem!\\n\\nThe approach is to checking every single charactor in our string, At this point, we have some special charactors the handle.\\n\\nIf we found \"/\", we know that this is the end of directory name. Therefore, we have to push something into out stack. However we **CANNOT** push everything without more check.\\n\\n1. \".\" and \"\"\\n\\n    If the directory to push is \".\" or \"\". That mean nothing to push because \".\" is the current directory and \"\" is a special handle for those absolute path input leading with \"/\".\\n\\n2. \"..\"\\n\\n    \"..\" means you are going back one level from currect directory. This means you have to pop the directory from out stack but only in case stack is **NOT** empty. (you are not going to pop the empty stack)\\n\\nWhen we finish looping through the input string, then we just call the method we have implemented `constructAbsolutePath`.\\n\\nThat\\'s all! Thanks for reading my approach.\\n\\n\\n# Complexity\\n- Time complexity: O(n) where n is the length of input string `path`.\\n\\n- Space complexity: Also O(n).\\n\\n# Code\\n```\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n\\tst.a = append(st.a, x)\\n}\\n\\nfunc (st *stack) peek() string {\\n\\treturn st.a[len(st.a)-1]\\n}\\n\\nfunc (st *stack) pop() string {\\n\\tret := st.peek()\\n\\tst.a = st.a[:len(st.a)-1]\\n\\treturn ret\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n\\treturn len(st.a) == 0\\n}\\n\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n\\nfunc simplifyPath(path string) string {\\n\\t// ensure slash at ending\\n\\tpath += \"/\"\\n\\n\\tst := stack{}\\n\\n\\tchars := strings.Split(path, \"\")\\n\\tdir := \"\"\\n\\tfor _, char := range chars {\\n\\t\\tswitch {\\n\\t\\tcase char == \"/\":\\n\\t\\t\\tswitch dir {\\n\\t\\t\\tcase \".\", \"\":\\n\\t\\t\\t\\t// do nothing\\n\\t\\t\\tcase \"..\":\\n\\t\\t\\t\\tif !st.isEmpty() {\\n\\t\\t\\t\\t\\tst.pop()\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tst.push(dir)\\n\\t\\t\\t}\\n\\t\\t\\tdir = \"\"\\n\\n\\t\\tdefault:\\n\\t\\t\\tdir += char\\n\\t\\t}\\n\\t}\\n\\n\\treturn st.constructAbsolutePath()\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n    // implementation here\\n}\\n\\nfunc (st *stack) peek() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) pop() string {\\n    // implementation here\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n    // implementation here\\n}\\n```\n```go\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n```\n```\\ntype stack struct {\\n\\ta []string\\n}\\n\\nfunc (st *stack) push(x string) {\\n\\tst.a = append(st.a, x)\\n}\\n\\nfunc (st *stack) peek() string {\\n\\treturn st.a[len(st.a)-1]\\n}\\n\\nfunc (st *stack) pop() string {\\n\\tret := st.peek()\\n\\tst.a = st.a[:len(st.a)-1]\\n\\treturn ret\\n}\\n\\nfunc (st *stack) isEmpty() bool {\\n\\treturn len(st.a) == 0\\n}\\n\\nfunc (st *stack) constructAbsolutePath() string {\\n\\tpaths := strings.Join(st.a, \"/\")\\n\\treturn \"/\" + paths\\n}\\n\\nfunc simplifyPath(path string) string {\\n\\t// ensure slash at ending\\n\\tpath += \"/\"\\n\\n\\tst := stack{}\\n\\n\\tchars := strings.Split(path, \"\")\\n\\tdir := \"\"\\n\\tfor _, char := range chars {\\n\\t\\tswitch {\\n\\t\\tcase char == \"/\":\\n\\t\\t\\tswitch dir {\\n\\t\\t\\tcase \".\", \"\":\\n\\t\\t\\t\\t// do nothing\\n\\t\\t\\tcase \"..\":\\n\\t\\t\\t\\tif !st.isEmpty() {\\n\\t\\t\\t\\t\\tst.pop()\\n\\t\\t\\t\\t}\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tst.push(dir)\\n\\t\\t\\t}\\n\\t\\t\\tdir = \"\"\\n\\n\\t\\tdefault:\\n\\t\\t\\tdir += char\\n\\t\\t}\\n\\t}\\n\\n\\treturn st.constructAbsolutePath()\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3412890,
                "title": "easy-solution-with-explanation-in-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const res = [];\\n    const arr = path.split(\"/\");\\n    for(let str of arr) {\\n        // when you see .. symbol\\n        // check result array and if it\\'s not empty\\n        // pop the last element\\n        if(str === \"..\") {\\n            if(res.length !== 0) {\\n                res.pop();\\n            }\\n        } \\n        // if you split \"a//b\" the result [\\'a\\',\\'\\',\\'b\\']\\n        // So check the length>=1 and ignore the period\\n        else if(str.length>=1 && str!==\".\") {\\n            res.push(str);\\n        } \\n    }\\n    return \"/\"+res.join(\"/\");\\n};\\n```\\n# If You Like, Please, Upvote!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n    const res = [];\\n    const arr = path.split(\"/\");\\n    for(let str of arr) {\\n        // when you see .. symbol\\n        // check result array and if it\\'s not empty\\n        // pop the last element\\n        if(str === \"..\") {\\n            if(res.length !== 0) {\\n                res.pop();\\n            }\\n        } \\n        // if you split \"a//b\" the result [\\'a\\',\\'\\',\\'b\\']\\n        // So check the length>=1 and ignore the period\\n        else if(str.length>=1 && str!==\".\") {\\n            res.push(str);\\n        } \\n    }\\n    return \"/\"+res.join(\"/\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3411390,
                "title": "easy-to-understand-c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n     stack<string> st;\\n        for(int i = 0; i < path.size(); ++i) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp;\\n            while(i < path.size() && path[i] != \\'/\\') {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n            }\\n            else st.push(temp);\\n        }\\n        path = \"\";\\n        while(!st.empty()) {\\n            path = \"/\" + st.top() + path;\\n            st.pop();\\n        }\\n        if(path.size() == 0) return \"/\";\\n        return path;}\\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n     stack<string> st;\\n        for(int i = 0; i < path.size(); ++i) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp;\\n            while(i < path.size() && path[i] != \\'/\\') {\\n                temp += path[i];\\n                ++i;\\n            }\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n            }\\n            else st.push(temp);\\n        }\\n        path = \"\";\\n        while(!st.empty()) {\\n            path = \"/\" + st.top() + path;\\n            st.pop();\\n        }\\n        if(path.size() == 0) return \"/\";\\n        return path;}\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410455,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int len = path.length();\\n        stack<string> st;\\n        string ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp = \"\";\\n            while(i < len && path[i] != \\'/\\') temp += path[i++];\\n            if(temp == \".\") continue;\\n            if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n                continue;\\n            }\\n            st.push(temp);\\n        }\\n        while(!st.empty()) {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.size()) return ans;\\n        else return \"/\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int len = path.length();\\n        stack<string> st;\\n        string ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(path[i] == \\'/\\') continue;\\n            string temp = \"\";\\n            while(i < len && path[i] != \\'/\\') temp += path[i++];\\n            if(temp == \".\") continue;\\n            if(temp == \"..\") {\\n                if(!st.empty()) st.pop();\\n                continue;\\n            }\\n            st.push(temp);\\n        }\\n        while(!st.empty()) {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.size()) return ans;\\n        else return \"/\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409893,
                "title": "simplify-path-best-solution-in-c-using-stack",
                "content": "##  PLEASE UPVOTE  \\uD83D\\uDC4D IF SOLUTION HELPED IN ANYWAY\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n\\n        stack<string> st;\\n        int i=0, j=0;\\n        while(i<path.length())  {\\n            if(path[i] == \\'/\\')  {i++;continue;}\\n            string temp = \"\";\\n            j=i;\\n            while(j<path.length() && path[j] != \\'/\\')   {\\n                temp.push_back(path[j]);\\n                j++;\\n            }\\n            i=j;\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\" && st.empty())   continue;\\n            else if(temp == \"..\" && !st.empty())   st.pop();\\n            else st.push(temp);\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty())  {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.length() == 0)   return \"/\";\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        \\n\\n        stack<string> st;\\n        int i=0, j=0;\\n        while(i<path.length())  {\\n            if(path[i] == \\'/\\')  {i++;continue;}\\n            string temp = \"\";\\n            j=i;\\n            while(j<path.length() && path[j] != \\'/\\')   {\\n                temp.push_back(path[j]);\\n                j++;\\n            }\\n            i=j;\\n            if(temp == \".\") continue;\\n            else if(temp == \"..\" && st.empty())   continue;\\n            else if(temp == \"..\" && !st.empty())   st.pop();\\n            else st.push(temp);\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty())  {\\n            ans = \"/\" + st.top() + ans;\\n            st.pop();\\n        }\\n        if(ans.length() == 0)   return \"/\";\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409788,
                "title": "clever-and-easy-with-stringstream-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stringstream ss(path);\\n        vector<string> stack;\\n        string word;\\n\\n        while(getline(ss, word, \\'/\\')){\\n            if(word.empty() || word == \".\") continue;\\n            if(word == \"..\"){\\n                if(stack.size()) stack.pop_back();\\n                continue;\\n            }\\n            stack.push_back(word);\\n        }\\n\\n        word = \"/\";\\n        for(auto &i: stack) word += i + \"/\";\\n        if(word.size() > 1) word = word.substr(0, word.size() - 1);\\n        return word;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stringstream ss(path);\\n        vector<string> stack;\\n        string word;\\n\\n        while(getline(ss, word, \\'/\\')){\\n            if(word.empty() || word == \".\") continue;\\n            if(word == \"..\"){\\n                if(stack.size()) stack.pop_back();\\n                continue;\\n            }\\n            stack.push_back(word);\\n        }\\n\\n        word = \"/\";\\n        for(auto &i: stack) word += i + \"/\";\\n        if(word.size() > 1) word = word.substr(0, word.size() - 1);\\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409752,
                "title": "java-solution-with-simple-explanation",
                "content": "### Stack\\n\\nIdea: First, split array using `/`. Second, iterate array and pop the stack if the path is `..`, push the string while the path is not empty and `.`. Finally, generate result path using string builder.\\n\\n```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] pathArray = path.split(\"/\");\\n\\n        for (String s : pathArray) {\\n            if (s.equals(\"..\")) {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n            } else if (s.length() != 0 && !s.equals(\".\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            res.insert(0, \"/\" + stack.pop());\\n        }\\n\\n        return res.toString().length() > 0 ? res.toString() : \"/\";\\n    }\\n}\\n```\\n\\nComplexity Analysis:\\n\\n- Time Complexity: $O(n)$. $n$ is the length of path.\\n- Space Complexity: $O(n)$. Stack costs $O(n)$ space complexity.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] pathArray = path.split(\"/\");\\n\\n        for (String s : pathArray) {\\n            if (s.equals(\"..\")) {\\n                if (!stack.isEmpty()) {\\n                    stack.pop();\\n                }\\n            } else if (s.length() != 0 && !s.equals(\".\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        StringBuilder res = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            res.insert(0, \"/\" + stack.pop());\\n        }\\n\\n        return res.toString().length() > 0 ? res.toString() : \"/\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409708,
                "title": "simple-solution",
                "content": "# Approach\\nThis problem can be solved using only one loop. Firstly, one needs to identify that we need to get directories first and store them in an array so that we can generate our path using it. \\n1) Spliting the path and converting into array using simple .split method will return all the directories in the path including `.` and `..`\\n2) Store your generated path in a stack, so that if a special command e.g `..` is entered we simple remove the last directory from the stack or stay on the same directory for `.` and loop over \\n3) for directory name simple keep pushing it in stack\\n\\n# Code\\n```\\n# @param {String} path\\n# @return {String}\\ndef simplify_path(path)\\n    result = []\\n    directories = path.split(\\'/\\') \\n    directories.each_with_index do |dir, index|\\n        if dir.eql?(\\'.\\') or dir.eql?(\\'\\')\\n            next\\n        elsif dir.eql?(\\'..\\')\\n            result.pop() if result.length > 0\\n        else\\n            result << dir\\n        end\\n    end\\n    \\'/\\' + result.join(\\'/\\')\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} path\\n# @return {String}\\ndef simplify_path(path)\\n    result = []\\n    directories = path.split(\\'/\\') \\n    directories.each_with_index do |dir, index|\\n        if dir.eql?(\\'.\\') or dir.eql?(\\'\\')\\n            next\\n        elsif dir.eql?(\\'..\\')\\n            result.pop() if result.length > 0\\n        else\\n            result << dir\\n        end\\n    end\\n    \\'/\\' + result.join(\\'/\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3409583,
                "title": "beats-100-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        stack<string>st;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            if(temp == \"\" || temp == \".\"){\\n                // continue;\\n            }\\n            else if(temp == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n            i = id;\\n        }\\n        stack<string>st2;\\n        while(!st.empty()){\\n            st2.push(st.top());\\n            st.pop();\\n        }\\n\\n        string ans = \"\";\\n        while(!st2.empty()){\\n            ans+=\"/\";\\n            ans+=st2.top();\\n            st2.pop();\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        stack<string>st;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            if(temp == \"\" || temp == \".\"){\\n                // continue;\\n            }\\n            else if(temp == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n            i = id;\\n        }\\n        stack<string>st2;\\n        while(!st.empty()){\\n            st2.push(st.top());\\n            st.pop();\\n        }\\n\\n        string ans = \"\";\\n        while(!st2.empty()){\\n            ans+=\"/\";\\n            ans+=st2.top();\\n            st2.pop();\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409428,
                "title": "easy-to-understand-c-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        vector<string>v;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            v.push_back(temp);\\n            i = id;\\n        }\\n        stack<string>st;\\n        int sz = v.size();\\n        for(int i=0; i<sz; i++){\\n            if(v[i] == \"\" || v[i] == \".\"){\\n                continue;\\n            }\\n            else if(v[i] == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(v[i]);\\n            }\\n        }\\n        v.clear();\\n        string ans = \"\";\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        sz = v.size();\\n        for(int i=sz-1; i>=0; i--){\\n            ans += \"/\";\\n            ans += v[i];\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string s) {\\n        int n = s.length();\\n        vector<string>v;\\n        for(int i=0; i<n;){\\n            int id = i+1;\\n            string temp = \"\";\\n            while(id<n && s[id] != \\'/\\'){\\n                temp += s[id];\\n                id++;\\n            }\\n            v.push_back(temp);\\n            i = id;\\n        }\\n        stack<string>st;\\n        int sz = v.size();\\n        for(int i=0; i<sz; i++){\\n            if(v[i] == \"\" || v[i] == \".\"){\\n                continue;\\n            }\\n            else if(v[i] == \"..\"){\\n                if(!st.empty()) st.pop();\\n            }\\n            else{\\n                st.push(v[i]);\\n            }\\n        }\\n        v.clear();\\n        string ans = \"\";\\n        while(!st.empty()){\\n            v.push_back(st.top());\\n            st.pop();\\n        }\\n        sz = v.size();\\n        for(int i=sz-1; i>=0; i--){\\n            ans += \"/\";\\n            ans += v[i];\\n        }\\n        if(ans.length() == 0) return \"/\";\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409393,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconvert the string to array for easy manulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n\\n    // Split on slash\\n    let s = path.split(\\'/\\');\\n    \\n    // Filter out empty strings\\n    s = s.filter((el)=>el!==\\'\\');\\n    \\n    const answer = [];\\n    \\n    for(const el of s){        \\n        if(el === \\'.\\'){\\n            // do nothing\\n        }else if(el === \\'..\\'){\\n            answer.pop(); // In JavaScript no need to check whether the array is empty or not before popping\\n        }else{\\n            answer.push(el);\\n        }\\n    }\\n    \\n    return \\'/\\' + answer.join(\\'/\\');\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} path\\n * @return {string}\\n */\\nvar simplifyPath = function(path) {\\n\\n    // Split on slash\\n    let s = path.split(\\'/\\');\\n    \\n    // Filter out empty strings\\n    s = s.filter((el)=>el!==\\'\\');\\n    \\n    const answer = [];\\n    \\n    for(const el of s){        \\n        if(el === \\'.\\'){\\n            // do nothing\\n        }else if(el === \\'..\\'){\\n            answer.pop(); // In JavaScript no need to check whether the array is empty or not before popping\\n        }else{\\n            answer.push(el);\\n        }\\n    }\\n    \\n    return \\'/\\' + answer.join(\\'/\\');\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409347,
                "title": "very-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String>st=new Stack<>();\\n        \\n        for(int i=0;i<path.length();i++){\\n            if(path.charAt(i)==\\'/\\') continue;\\n\\n            String temp=\"\";\\n            while(i<path.length() && path.charAt(i)!=\\'/\\'){\\n                temp+=path.charAt(i);\\n                i++;\\n            }\\n\\n            if(temp.equals(\".\")) continue;\\n            else if(temp.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n        }\\n        \\n        String ans=\"\";\\n        while(!st.isEmpty()){\\n            ans=\"/\"+st.pop()+ans;\\n        }\\n        if(ans.length()==0) return \"/\";\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String>st=new Stack<>();\\n        \\n        for(int i=0;i<path.length();i++){\\n            if(path.charAt(i)==\\'/\\') continue;\\n\\n            String temp=\"\";\\n            while(i<path.length() && path.charAt(i)!=\\'/\\'){\\n                temp+=path.charAt(i);\\n                i++;\\n            }\\n\\n            if(temp.equals(\".\")) continue;\\n            else if(temp.equals(\"..\")){\\n                if(!st.isEmpty()){\\n                    st.pop();\\n                }\\n\\n            }\\n            else{\\n                st.push(temp);\\n            }\\n        }\\n        \\n        String ans=\"\";\\n        while(!st.isEmpty()){\\n            ans=\"/\"+st.pop()+ans;\\n        }\\n        if(ans.length()==0) return \"/\";\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409328,
                "title": "java-easy-solutions-99-faster-3-approaches-without-stack-and-using-stack",
                "content": "**PLEASE UPVOTE IF YOU FIND IT USEFUL**\\n\\n# Approach 1\\nUsing Stack and String Split funtion.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 4ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n       Stack<String> stack=new Stack<>();\\n       String []str=path.split(\"/\");\\n       for(String s: str){\\n           //System.out.println(s);\\n           if(s.equals(\".\") || s.equals(\"\"))continue;\\n           else if(s.equals(\"..\")){if(!stack.isEmpty()) stack.pop();}\\n           else stack.push(s);\\n       }\\n       //System.out.println(stack);\\n       Collections.reverse(stack);\\n       StringBuilder sb=new StringBuilder();\\n       while(!stack.isEmpty()){\\n           sb.append(\"/\");\\n           sb.append(stack.pop());\\n       }\\n       if(sb.length()==0) return \"/\";\\n       return sb.toString();\\n    }\\n}\\n```\\n\\n# Approach 2\\nWithout using Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 2ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        char []stack=new char[len];\\n        int i=0;\\n\\t\\t    int j=-1;\\n        while(i<len){\\n            if(j>=0 && (stack[j] == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack[j] == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(j>=0 && dot>0){\\n                    if(stack[j--]==\\'/\\')dot--;\\n                    }\\n                    if(j==-1) j=0;\\n                }\\n            }\\n            else{\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                } \\n        }\\n        if(stack[j]==\\'/\\'&& j>1) j--;\\n\\n        return String.valueOf(stack,0,j+1);\\n  }\\n}\\n```\\n# Approach 3\\nUsing Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N) 12ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        Stack<Character> stack=new Stack<>();\\n        int i=0;\\n        while(i<len){\\n            if(!stack.isEmpty() && (stack.peek() == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack.peek() == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(!stack.isEmpty() && dot>0){\\n                    if(stack.pop()==\\'/\\')dot--;\\n                    }\\n                    if(stack.isEmpty()) stack.push(\\'/\\');\\n                }\\n            }\\n            else{\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                } \\n        }\\n         StringBuilder sb=new StringBuilder();\\n         if(stack.peek()==\\'/\\'&& stack.size()>1) stack.pop();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n\\n        return sb.reverse().toString();\\n}\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n       Stack<String> stack=new Stack<>();\\n       String []str=path.split(\"/\");\\n       for(String s: str){\\n           //System.out.println(s);\\n           if(s.equals(\".\") || s.equals(\"\"))continue;\\n           else if(s.equals(\"..\")){if(!stack.isEmpty()) stack.pop();}\\n           else stack.push(s);\\n       }\\n       //System.out.println(stack);\\n       Collections.reverse(stack);\\n       StringBuilder sb=new StringBuilder();\\n       while(!stack.isEmpty()){\\n           sb.append(\"/\");\\n           sb.append(stack.pop());\\n       }\\n       if(sb.length()==0) return \"/\";\\n       return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        char []stack=new char[len];\\n        int i=0;\\n\\t\\t    int j=-1;\\n        while(i<len){\\n            if(j>=0 && (stack[j] == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack[j] == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(j>=0 && dot>0){\\n                    if(stack[j--]==\\'/\\')dot--;\\n                    }\\n                    if(j==-1) j=0;\\n                }\\n            }\\n            else{\\n                    stack[++j]=path.charAt(i);\\n                    i++;\\n                } \\n        }\\n        if(stack[j]==\\'/\\'&& j>1) j--;\\n\\n        return String.valueOf(stack,0,j+1);\\n  }\\n}\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        int len=path.length();\\n        Stack<Character> stack=new Stack<>();\\n        int i=0;\\n        while(i<len){\\n            if(!stack.isEmpty() && (stack.peek() == \\'/\\' || i==len-1) && path.charAt(i)==\\'/\\') {\\n                i++;\\n                continue;\\n            }\\n            if(path.charAt(i)==\\'.\\' && stack.peek() == \\'/\\' ){\\n                int dot=0;\\n                while(i<len && path.charAt(i)!=\\'/\\'){\\n                    dot++;\\n                    if(path.charAt(i)!=\\'.\\'){\\n                        dot+=5;\\n                        break;\\n                    }\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                }\\n                if(dot<3){\\n                     while(!stack.isEmpty() && dot>0){\\n                    if(stack.pop()==\\'/\\')dot--;\\n                    }\\n                    if(stack.isEmpty()) stack.push(\\'/\\');\\n                }\\n            }\\n            else{\\n                    stack.push(path.charAt(i));\\n                    i++;\\n                } \\n        }\\n         StringBuilder sb=new StringBuilder();\\n         if(stack.peek()==\\'/\\'&& stack.size()>1) stack.pop();\\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n\\n        return sb.reverse().toString();\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408323,
                "title": "java-solution-beginer-level-can-understand-upvote-plz",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery java beginer Can understand this intuition..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBeginner Level Approch..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n    Stack<String>stack = new Stack<>();\\n    String res =\"\";\\nfor(int i=0;i<path.length();i++){\\n    if(path.charAt(i)==\\'/\\'){\\n        continue;\\n    }\\n    String temp =\"\";\\n    while(i<path.length() && path.charAt(i) != \\'/\\'){\\n        temp +=path.charAt(i);\\n        ++i;\\n    }\\n       \\n           if(temp.equals(\".\")){\\n               continue;\\n           }else if(temp.equals(\"..\")){\\n               if(!stack.isEmpty())\\n               stack.pop();\\n           }else{\\n               stack.push(temp);\\n           }\\n\\n         }\\n        \\n         while(!stack.isEmpty()){\\n             res = \"/\"+stack.peek()+res;\\n             stack.pop();\\n         }\\n         if(res.length()==0){\\n             return \"/\";\\n         }\\n    return res;\\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n\\n    Stack<String>stack = new Stack<>();\\n    String res =\"\";\\nfor(int i=0;i<path.length();i++){\\n    if(path.charAt(i)==\\'/\\'){\\n        continue;\\n    }\\n    String temp =\"\";\\n    while(i<path.length() && path.charAt(i) != \\'/\\'){\\n        temp +=path.charAt(i);\\n        ++i;\\n    }\\n       \\n           if(temp.equals(\".\")){\\n               continue;\\n           }else if(temp.equals(\"..\")){\\n               if(!stack.isEmpty())\\n               stack.pop();\\n           }else{\\n               stack.push(temp);\\n           }\\n\\n         }\\n        \\n         while(!stack.isEmpty()){\\n             res = \"/\"+stack.peek()+res;\\n             stack.pop();\\n         }\\n         if(res.length()==0){\\n             return \"/\";\\n         }\\n    return res;\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408035,
                "title": "python-elegant-short-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n```\\nclass Solution:\\n\\n    SEP = \\'/\\'\\n    CURRENT_DIR = \\'.\\'\\n    PARENT_DIR = \\'..\\'\\n\\n    def simplifyPath(self, path: str) -> str:\\n        simplified = []\\n\\n        for directory in path.split(self.SEP):\\n            if not directory or directory == self.CURRENT_DIR:\\n                continue\\n\\n            if directory == self.PARENT_DIR:\\n                if simplified:\\n                    simplified.pop()\\n            else:\\n                simplified.append(directory)\\n\\n        return self.SEP + self.SEP.join(simplified)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    SEP = \\'/\\'\\n    CURRENT_DIR = \\'.\\'\\n    PARENT_DIR = \\'..\\'\\n\\n    def simplifyPath(self, path: str) -> str:\\n        simplified = []\\n\\n        for directory in path.split(self.SEP):\\n            if not directory or directory == self.CURRENT_DIR:\\n                continue\\n\\n            if directory == self.PARENT_DIR:\\n                if simplified:\\n                    simplified.pop()\\n            else:\\n                simplified.append(directory)\\n\\n        return self.SEP + self.SEP.join(simplified)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407966,
                "title": "unlimited-logic-with-stack",
                "content": "\\n\\n# Python Solution With Python\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        res=\"\"\\n        for c in path+\\'/\\':\\n            if c==\\'/\\':\\n                if res==\"..\":\\n                    if stack: stack.pop()\\n                elif res!=\"\" and res!=\\'.\\':\\n                    stack.append(res)\\n                res=\"\"\\n            else:\\n                res+=c\\n        return \"/\"+\"/\".join(stack)\\n```\\n# \\'/\\' is added due to the edges of like \"a/b/c/d///././..\"-->this test case has last two string are \"..\" which removes one element from stack then output gives \"a/b/c\" so we can solve that test case by adding \\'/\\' then output is \"a/b/c/d\"\\n\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        stack=[]\\n        res=\"\"\\n        for c in path+\\'/\\':\\n            if c==\\'/\\':\\n                if res==\"..\":\\n                    if stack: stack.pop()\\n                elif res!=\"\" and res!=\\'.\\':\\n                    stack.append(res)\\n                res=\"\"\\n            else:\\n                res+=c\\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407042,
                "title": "c-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        string ans=\"\";\\n        for(int i=0;i<path.size();i++){\\n            if(path[i]==\\'/\\'){\\n                continue;\\n            }\\n            string temp;\\n            while(i<path.size() && path[i]!=\\'/\\'){\\n                temp+=path[i];\\n                i++;\\n            }\\n            if(temp==\".\"){\\n                continue;\\n            }else if(temp==\"..\"){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=\\'/\\'+st.top()+ans;\\n            st.pop();\\n        }\\n        if(ans.size()==0){\\n            return \"/\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        stack<string> st;\\n        string ans=\"\";\\n        for(int i=0;i<path.size();i++){\\n            if(path[i]==\\'/\\'){\\n                continue;\\n            }\\n            string temp;\\n            while(i<path.size() && path[i]!=\\'/\\'){\\n                temp+=path[i];\\n                i++;\\n            }\\n            if(temp==\".\"){\\n                continue;\\n            }else if(temp==\"..\"){\\n                if(!st.empty()){\\n                    st.pop();\\n                }\\n            }else{\\n                st.push(temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=\\'/\\'+st.top()+ans;\\n            st.pop();\\n        }\\n        if(ans.size()==0){\\n            return \"/\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406981,
                "title": "java-stack",
                "content": "# Intuition\\nBetter use \"split\" to make the logic cleaner. My first trial didn\\'t used \"split\" and turnout my logic was messy.\\n\\n# Approach\\nstack\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) -> because of stack\\n\\n# Code\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!(s.equals(\"\") || s.equals(\".\") || s.equals(\"..\"))) stack.add(s);\\n        }\\n\\n        String ans = \"\";\\n        for (String i : stack) {\\n            ans += \"/\" + i;\\n        }\\n        return ans.isEmpty() ? \"/\" : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n\\n        for (String s : path.split(\"/\")) {\\n            if (s.equals(\"..\") && !stack.isEmpty()) stack.pop();\\n            else if (!(s.equals(\"\") || s.equals(\".\") || s.equals(\"..\"))) stack.add(s);\\n        }\\n\\n        String ans = \"\";\\n        for (String i : stack) {\\n            ans += \"/\" + i;\\n        }\\n        return ans.isEmpty() ? \"/\" : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406944,
                "title": "stack-python-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstack problem \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsplit path and iterate through it \\nhanlding 3 cases \\n1- if cur_val is \"..\" and stack is empty of cur_val is \".\" do nothing and contniue \\n2 - if cur_val is \"..\" and stack , pop last ele from stack\\n3 - otherwise , append val to stack\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path =[p for p in path if p ]\\n        for p in path:\\n            if (len(stack)==0 and p==\"..\") or p ==\".\":\\n                continue \\n            elif p==\"..\" and stack:\\n                stack.pop()\\n            else:\\n                stack.append(p)\\n        return \"/\" + \"/\".join(stack)\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution(object):\\n    def simplifyPath(self, path):\\n        \"\"\"\\n        :type path: str\\n        :rtype: str\\n        \"\"\"\\n        stack=[]\\n        path=path.split(\"/\")\\n        path =[p for p in path if p ]\\n        for p in path:\\n            if (len(stack)==0 and p==\"..\") or p ==\".\":\\n                continue \\n            elif p==\"..\" and stack:\\n                stack.pop()\\n            else:\\n                stack.append(p)\\n        return \"/\" + \"/\".join(stack)\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406773,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def simplifyPath(path: String): String = \\n        path.split(\"/+\").foldLeft(List[String]())((acc, cur) => cur match {\\n            case \"..\" => scala.util.Try(acc.tail).getOrElse(List[String]())\\n            case \".\" | \"\" => acc\\n            case _ => cur +: acc\\n        }).reverse.mkString(\"/\", \"/\", \"\")\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def simplifyPath(path: String): String = \\n        path.split(\"/+\").foldLeft(List[String]())((acc, cur) => cur match {\\n            case \"..\" => scala.util.Try(acc.tail).getOrElse(List[String]())\\n            case \".\" | \"\" => acc\\n            case _ => cur +: acc\\n        }).reverse.mkString(\"/\", \"/\", \"\")\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3406669,
                "title": "daily-leetcoding-challenge-april-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3181590,
                "title": "71-simplify-path-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Split the input string path into a list of directories using .split(\\'/\\').\\n2. Initialize an empty list stack to store the directories.\\n3. Loop through the list of directories.\\n4. If the directory is an empty string or a single period, skip it.\\n5. If the directory is .., pop the last directory from the stack.\\n6. If the directory is a regular directory name, push it to the stack.\\n7. Join the directories in the stack using /.join and add a leading slash.\\n8. Return the simplified path.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        # split the path into a list of directories\\n        dirs = path.split(\\'/\\')\\n        # initialize a stack to store the directories\\n        stack = []\\n        for dir in dirs:\\n            if dir == \\'\\' or dir == \\'.\\':\\n                continue\\n            elif dir == \\'..\\':\\n                if len(stack) > 0:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        # join the directories in the stack and add a leading slash\\n        return \\'/\\' + \\'/\\'.join(stack)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        # split the path into a list of directories\\n        dirs = path.split(\\'/\\')\\n        # initialize a stack to store the directories\\n        stack = []\\n        for dir in dirs:\\n            if dir == \\'\\' or dir == \\'.\\':\\n                continue\\n            elif dir == \\'..\\':\\n                if len(stack) > 0:\\n                    stack.pop()\\n            else:\\n                stack.append(dir)\\n        # join the directories in the stack and add a leading slash\\n        return \\'/\\' + \\'/\\'.join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178616,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity: Given `n = len(path)` then complexity is `O(n)`\\n\\n- Space complexity: Given `n = len(path)` then complexity is `O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        levels, stack = path.split(\"/\"), []\\n\\n        for l in levels:\\n            if len(l)>0 and l != \\'.\\':\\n                if l == \\'..\\' and stack:\\n                    stack.pop()\\n                else if != \\'..\\':\\n                    stack.append(l)\\n        \\n        return \"/\"+\"/\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def simplifyPath(self, path: str) -> str:\\n        levels, stack = path.split(\"/\"), []\\n\\n        for l in levels:\\n            if len(l)>0 and l != \\'.\\':\\n                if l == \\'..\\' and stack:\\n                    stack.pop()\\n                else if != \\'..\\':\\n                    stack.append(l)\\n        \\n        return \"/\"+\"/\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824793,
                "title": "java-stack-deque",
                "content": "### **Please Upvote** :D\\n##### 1. Using Stack:\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!stack.isEmpty() && s.equals(\"..\")) {\\n                stack.pop();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        if (stack.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : stack) {\\n            sb.append(\\'/\\').append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. Using Deque:\\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dq = new LinkedList<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!dq.isEmpty() && s.equals(\"..\")) {\\n                dq.poll();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                dq.push(s);\\n            }\\n        }\\n\\n        if (dq.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!dq.isEmpty()) {\\n            sb.append(\\'/\\').append(dq.pollLast());\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Stack<String> stack = new Stack<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!stack.isEmpty() && s.equals(\"..\")) {\\n                stack.pop();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                stack.push(s);\\n            }\\n        }\\n\\n        if (stack.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : stack) {\\n            sb.append(\\'/\\').append(s);\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public String simplifyPath(String path) {\\n        Deque<String> dq = new LinkedList<>();\\n        String[] p = path.split(\"/\");\\n        for (String s : p) {\\n            if (!dq.isEmpty() && s.equals(\"..\")) {\\n                dq.poll();\\n            } else if (!s.equals(\"\") && !s.equals(\".\") && !s.equals(\"..\")) {\\n                dq.push(s);\\n            }\\n        }\\n\\n        if (dq.isEmpty()) {\\n            return \"/\";\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!dq.isEmpty()) {\\n            sb.append(\\'/\\').append(dq.pollLast());\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725073,
                "title": "java-simple-two-approaches",
                "content": "# Two Approaches \\n\\n**1. Using Stack**\\nTC O(N) & SC O(N)\\n\\n```\\nclass Solution{\\n  public String simplifyPath(String path) {\\n       Stack<String> s=new Stack<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.pop();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.insert(0,s.pop()).insert(0,\"/\");\\n       }\\n       return res.toString();\\n    }\\n}\\n```\\n\\n**2. Using Deque**\\nTC O(N) & SC O(N)\\n\\n```\\nclass Solution{\\n  public static String simplifyPath(String path) {\\n      Deque<String> s=new LinkedList<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.poll();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.append(\"/\").append(s.pollLast());  //pollLast will give u the first element from Dq\\n       }\\n       return res.toString();  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n  public String simplifyPath(String path) {\\n       Stack<String> s=new Stack<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.pop();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.insert(0,s.pop()).insert(0,\"/\");\\n       }\\n       return res.toString();\\n    }\\n}\\n```\n```\\nclass Solution{\\n  public static String simplifyPath(String path) {\\n      Deque<String> s=new LinkedList<>();\\n       StringBuilder res=new StringBuilder();\\n       String[] p=path.split(\"/\");\\n       \\n       for(int i=0;i<p.length;i++){\\n         if(!s.isEmpty() && p[i].equals(\"..\")) s.poll();\\n         if(!p[i].equals(\"\") && !p[i].equals(\".\") && !p[i].equals(\"..\")){\\n           s.push(p[i]);\\n         }\\n       }\\n       \\n       if(s.isEmpty()) return \"/\";\\n       while(!s.isEmpty()){\\n         res.append(\"/\").append(s.pollLast());  //pollLast will give u the first element from Dq\\n       }\\n       return res.toString();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715470,
                "title": "made-it-simple-stacks-sliding-window-based-on-hi-malik-solution-c-version",
                "content": "**The Entire idea is**\\n* We have the path\\n* We can split based on / slashes\\n* /a//b/../c/d/ -> a, b, .. , c, d = > We get the directories\\n* Then we need to do only ONE THING\\n* Put things onto stack. \\n* we need to go back that is POP when we see ..\\n* So at last we have the PATH IN STACK.\\n* When we POP And CONTRUCT THE ANS. We need to do in reverse manner.\\n* PATH = / DIRECTORY + OLD PATH\\n\\nHOW WE SPLIT?\\n* We could have used string stream or any other.\\n* But we did manually with sliding window.\\n* i always points to start of string and j points to the end.\\n* whenever u see \\'/\\' its time to enter the directory. Then move to next non slash place.\\n\\n```\\n//TIME : O(N)\\n//SPACE: O(N)\\n\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> arr;\\n        int N = path.size();\\n        int i = 1;\\n        int j = 1;\\n        while(j < N){\\n            if(path[j] == \\'/\\'){\\n                arr.push_back(path.substr(i,j-i));\\n                //now point j to a non /\\n                while(path[j]==\\'/\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n            //else its not / \\n            j++;\\n        }\\n        \\n        if(i<N){\\n            //Edge case = when there is no last back slash\\n            arr.push_back(path.substr(i,j-i));\\n        }\\n        \\n        stack<string> stk;\\n        \\n        for(auto s : arr){\\n            if(stk.size()>0 && s==\"..\") stk.pop(); // as we move one step back in directory\\n            else if(s != \"\" && s!= \".\" && s!=\"..\") stk.push(s);\\n        }\\n        \\n        //edge case = when \"\" path is given\\n        if(stk.empty()) return \"/\";\\n        \\n        //PATH FORMATION\\n        string res=\"\";\\n        while(!stk.empty()){\\n           \\n            res = \\'/\\' + stk.top() + res;\\n            stk.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\n//TIME : O(N)\\n//SPACE: O(N)\\n\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        vector<string> arr;\\n        int N = path.size();\\n        int i = 1;\\n        int j = 1;\\n        while(j < N){\\n            if(path[j] == \\'/\\'){\\n                arr.push_back(path.substr(i,j-i));\\n                //now point j to a non /\\n                while(path[j]==\\'/\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n            //else its not / \\n            j++;\\n        }\\n        \\n        if(i<N){\\n            //Edge case = when there is no last back slash\\n            arr.push_back(path.substr(i,j-i));\\n        }\\n        \\n        stack<string> stk;\\n        \\n        for(auto s : arr){\\n            if(stk.size()>0 && s==\"..\") stk.pop(); // as we move one step back in directory\\n            else if(s != \"\" && s!= \".\" && s!=\"..\") stk.push(s);\\n        }\\n        \\n        //edge case = when \"\" path is given\\n        if(stk.empty()) return \"/\";\\n        \\n        //PATH FORMATION\\n        string res=\"\";\\n        while(!stk.empty()){\\n           \\n            res = \\'/\\' + stk.top() + res;\\n            stk.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695541,
                "title": "easy-solution-in-c-two-approaches-using-stack",
                "content": "**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote if u liked my Solution\\uD83D\\uDE42**\\n# Code\\n***1st Approach***\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<char> sta;\\n        while(i<size){\\n            if(sta.size()==0){\\n                sta.push(path[i++]);\\n                continue;\\n            }\\n            if((sta.top()==\\'/\\' && path[i]==\\'/\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+1<size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'/\\')||(i+1==size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+2==size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'.\\')||(i+2<size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\' && path[i+1]==\\'.\\' && path[i+2]==\\'/\\')){\\n                sta.pop();\\n                while(sta.size()>0 && sta.top()!=\\'/\\')\\n                    sta.pop();\\n                i+=2;\\n            }\\n            else\\n                sta.push(path[i++]);\\n        }\\n        string ans=\"\";\\n        if(sta.size()==0)\\n            return \"/\";\\n        else if(sta.size()>=2 && sta.top()==\\'/\\')\\n            sta.pop();\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n***2nd Approach(A bit easier)***\\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n       int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<string> sta;\\n        while(i<size){\\n            if(path[i]==\\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            string tmp=\"\";\\n            while(i<size && path[i]!=\\'/\\')\\n                tmp+=path[i++];\\n            if(tmp == \".\" || tmp == \"\")\\n                continue;\\n            else if(tmp == \"..\"){\\n                if(sta.size())\\n                    sta.pop();\\n            }\\n            else\\n                sta.push(tmp);\\n        } \\n        if(sta.size()==0)\\n            return \"/\";\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans=\"/\"+sta.top()+ans;\\n            sta.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n        int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<char> sta;\\n        while(i<size){\\n            if(sta.size()==0){\\n                sta.push(path[i++]);\\n                continue;\\n            }\\n            if((sta.top()==\\'/\\' && path[i]==\\'/\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+1<size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'/\\')||(i+1==size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\')){\\n                i++;\\n                continue;\\n            }\\n            else if((i+2==size && sta.top()==\\'/\\' && path[i]==\\'.\\' && path[i+1]==\\'.\\')||(i+2<size && sta.top()==\\'/\\' && \\n            path[i]==\\'.\\' && path[i+1]==\\'.\\' && path[i+2]==\\'/\\')){\\n                sta.pop();\\n                while(sta.size()>0 && sta.top()!=\\'/\\')\\n                    sta.pop();\\n                i+=2;\\n            }\\n            else\\n                sta.push(path[i++]);\\n        }\\n        string ans=\"\";\\n        if(sta.size()==0)\\n            return \"/\";\\n        else if(sta.size()>=2 && sta.top()==\\'/\\')\\n            sta.pop();\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string simplifyPath(string path) {\\n       int size=path.size(),i=0;\\n        if(size==1)\\n            return path;\\n        stack<string> sta;\\n        while(i<size){\\n            if(path[i]==\\'/\\'){\\n                i++;\\n                continue;\\n            }\\n            string tmp=\"\";\\n            while(i<size && path[i]!=\\'/\\')\\n                tmp+=path[i++];\\n            if(tmp == \".\" || tmp == \"\")\\n                continue;\\n            else if(tmp == \"..\"){\\n                if(sta.size())\\n                    sta.pop();\\n            }\\n            else\\n                sta.push(tmp);\\n        } \\n        if(sta.size()==0)\\n            return \"/\";\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans=\"/\"+sta.top()+ans;\\n            sta.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659732,
                "title": "simple-cpp-solution-using-stringstream",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string simplifyPath(string path)\\n        {\\n            vector<string> vec;\\n            vector<string> st;\\n\\n            stringstream s(path);\\t//split function using stringstream\\n            string w;\\n            while (getline(s, w, \\'/\\'))\\n                if (w.size() != 0)\\n                    vec.push_back(w);\\n\\n            for (auto i: vec)\\n            {\\n                if (i == \"..\" && st.size() != 0) st.pop_back();\\n                else if (i != \".\" && i != \"..\") st.push_back(i);\\n            }\\n            w = \"\";\\n            if (st.size() == 0)\\n                w.push_back(\\'/\\');\\n            for (auto i: st)\\n            {\\n                w.push_back(\\'/\\');\\n                w += i;\\n            }\\n\\n            return w;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string simplifyPath(string path)\\n        {\\n            vector<string> vec;\\n            vector<string> st;\\n\\n            stringstream s(path);\\t//split function using stringstream\\n            string w;\\n            while (getline(s, w, \\'/\\'))\\n                if (w.size() != 0)\\n                    vec.push_back(w);\\n\\n            for (auto i: vec)\\n            {\\n                if (i == \"..\" && st.size() != 0) st.pop_back();\\n                else if (i != \".\" && i != \"..\") st.push_back(i);\\n            }\\n            w = \"\";\\n            if (st.size() == 0)\\n                w.push_back(\\'/\\');\\n            for (auto i: st)\\n            {\\n                w.push_back(\\'/\\');\\n                w += i;\\n            }\\n\\n            return w;\\n        }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1861053,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565677,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1860833,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565479,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861113,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574273,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567841,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1572868,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569365,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566708,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861053,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565677,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1860833,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565479,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861113,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574273,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567841,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1572868,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569365,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566708,
                "content": [
                    {
                        "username": "prakashtarun313",
                        "content": "MORE EXAMPLES THAT YOU CAN UNDERSTAND :\\n\\nCHEAT CODE :\\n\" . \"        ==>   Continue;\\n\" . .  \"     ==>   Remove the before directory;\\n\" // \"      ==> make it into \"/\"\\n\\nExample 1:\\nInput: \"/home/user/Documents/../Pictures\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 2:\\nInput: \"/../home/user/Documents\"\\nOutput: \"/home/user/Documents\"\\n\\nExample 3:\\nInput: \"/home/user/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 4:\\nInput: \"/home/user/./Downloads/../Pictures/././\"\\nOutput: \"/home/user/Pictures\"\\n\\nExample 5:\\nInput: \"/home/user/Documents/../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nExample 6:\\nInput: \"/home/user/Documents/../../../usr/local/bin\"\\nOutput: \"/usr/local/bin\"\\n\\nPLEASE UPVOTE"
                    },
                    {
                        "username": "unofficialmaitry",
                        "content": "You are a leetcode saver"
                    },
                    {
                        "username": "Arun_A",
                        "content": "Thank you :) \\n\\n"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Although these should be properly explained in the problem statement itself but they are not. But your examples are very helpful."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "This is very helpful, thank you \\n"
                    },
                    {
                        "username": "connectnitesh8",
                        "content": "\"/a//b////c/d//././/..\" == > /a/b/c "
                    },
                    {
                        "username": "rus_eell",
                        "content": "[@padmavathidevi71625](/padmavathidevi71625) yeah, this should be "
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Example 5's answer is wrong.\noutput: /home/usr/local/bin\n=>Btw thnx for Amazing Examples :p"
                    },
                    {
                        "username": "padmavathidevi71625",
                        "content": "Example 5:\\nOutput: \"/home/usr/local/bin\""
                    },
                    {
                        "username": "noobie@work",
                        "content": "Simplify the directory path (Unix like)\\nGiven an absolute path for a file (Unix-style), simplify it. Note that absolute path always begin with \\u2018/\\u2019 ( root directory ), a dot in path represent current directory and double dot represents parent directory.\\n\\nExamples:\\n\\n\"/a/./\"   --> means stay at the current directory \\'a\\'\\n\"/a/b/..\" --> means jump to the parent directory\\n              from \\'b\\' to \\'a\\'\\n\"////\"    --> consecutive multiple \\'/\\' are a  valid  \\n              path, they are equivalent to single \"/\".\\n\\nInput : /home/\\nOutput : /home\\n\\nInput : /a/./b/../../c/\\nOutput : /c\\n\\nInput : /a/..\\nOutput : /\\n\\nInput : /a/../\\nOuput : /\\n\\nInput : /../../../../../a\\nOuput : /a\\n\\nInput : /a/./b/./c/./d/\\nOuput : /a/b/c/d\\n\\nInput : /a/../.././../../.\\nOuput : /\\n\\nInput : /a//b//c//////d\\nOuput : /a/b/c/d"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@sohamkulkarni](/sohamkulkarni) i think its something like, you go to a, then stay there(/./) go to directory b, then go back one levl(so now u r in a) then again go back one level(u r now at the root dir) and now u go to c...so thefinal directory where u at is c. Let me know if im wrong coz im still a learner"
                    },
                    {
                        "username": "Pega_One",
                        "content": "Thanks all of you."
                    },
                    {
                        "username": "mustafiz7",
                        "content": "[@sohamkulkarni](/sohamkulkarni) \\n/a/./ --> remain in a only (as `.` means stay in current directory)\\n/b/ --> go to b directory\\n/../ --> go to parent of current directory, current directory is b and b parent is a.\\n/../--> current directory is is a, go to parent of a i.e. root ( / ).\\n/c/ --> go to c.\\n\\n==> hence,    /c"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "/a/./b/../../c/ -> how output /c ??\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Thanks. I cant imagine WHY those are valid, or how this is useful, but sure. The description really needed more examples. "
                    },
                    {
                        "username": "PinkGlove",
                        "content": "legend"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I would have liked more examples for this question."
                    },
                    {
                        "username": "user5400vw",
                        "content": "you can experiment with custom testcases  - as long as your input is well-formed you will see the expected output"
                    },
                    {
                        "username": "xuzhenqi1993",
                        "content": "My code failed at the test case \"/abc/...\".\\n\\nThe expected output is \"/abc/...\".\\n\\nBut I think it may be \"/...\".\\n\\nCould anybody who have passed this one tell me why it is \"/abc/...\"?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "THey have clearly mentioned that \\'...\\' represents a directory."
                    },
                    {
                        "username": "rajatul26",
                        "content": "[@Ritesh_Jha](/Ritesh_Jha) Comment is dated back in 2014. By then most of us might not not have even heard of leetcode. :) "
                    },
                    {
                        "username": "Ritesh_Jha",
                        "content": "it\\'s clearly mentioned in the question that dots more than two can be treated as file/directory name. hence \"/abc/xyz\" and \"/abc/...\"  both gives same output as input."
                    },
                    {
                        "username": "jdkern11",
                        "content": "In the description it states that any time a sequence of periods occurs where the number of periods is greater than 2, that sequence is treated as its own directory."
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "                               APPROACH/PSUEDO CODE\nIf you don't want to see solution then see this approach\n1. Create a Stack of String with following condition.\n2. Iterate the loop till you doesn't reaches the end of string.\n3. If you encounter a \"/\" then ignore it.\n4. Create a temp String & Iterate the while loop till you doesn't find \"/\" and append it to temp.\n5. Now check if temp == \".\" , then ignore it.\n6. If temp == \"..\" then pop the element from the stack if it exists.\n7. If no of the above 2 matches push temp to stack as you find a valid path.\n8. Check out temp string on basis of above conditions till you doesn't find \"/\".\n9. Now add all stack elements to result as res = \"/\" + st.top() + res\n10. If res.size() is 0 then return \"/\" if no directory or file is present.\n     At last return res.\n\n `**See This Testcase for better understanding **`\n\n `input : \"/home/../foo/\"  `\n`output : \"/foo\"` \n\n`input : \"/home/test/../foo/\" `\n `output : \"/home/foo\"`\n\n`input : \"/home/...//foo/\" `\n ` output : \"/home/.../foo\"`\n\nSolution of above approach (Beginner-friendly-code)\nhttps://leetcode.com/problems/simplify-path/solutions/3406777/c-beginner-friendly-explanation-multiple-testcase-using-stack/\n"
                    },
                    {
                        "username": "piyushkr6161",
                        "content": "Thanks everyone if any doubt please comment here"
                    },
                    {
                        "username": "hackerbhai6161",
                        "content": "please give the code "
                    },
                    {
                        "username": "expertsolver241",
                        "content": "Nice explain bhaiya thanks \\n"
                    },
                    {
                        "username": "_cichipi_",
                        "content": "Note : single \".\" is useless , just ignore it \\n\\n/a/./b///c/../../d  think it as : { a , b , c , .. , .. , d} \\nsimplify it to {a , b , .. , d } \\nfurther simplify it to {a,d} \\n\\nconstruct result from it which is :  /a/d"
                    },
                    {
                        "username": "spookie886",
                        "content": "Thank you!!!"
                    },
                    {
                        "username": "ronaldo123",
                        "content": "Input:\\t\"/...\"\\nOutput:\\t\"/\"\\nExpected:\\t\"/...\"\\n\\n\\nThe \"/...\" is a legal path command ?  I test it on my mac, but it returns\\n\\n-bash: cd: /...: No such file or directory"
                    },
                    {
                        "username": "thatonemorekid",
                        "content": "you can actually create a directory with name \\'...\\' and it will be a valid path command"
                    },
                    {
                        "username": "sunnyharne008",
                        "content": "It doesn\\'t matter for solving this problem, as it is mentioned clearly that dots more than two can be treated as a directory/file name.\\n "
                    },
                    {
                        "username": "tonytontian",
                        "content": "https://www.geeksforgeeks.org/simplify-directory-path-unix-like/\\nThis artical provide more examples and better explanation."
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Brother"
                    },
                    {
                        "username": "thorneliu",
                        "content": "My code result in / in this case, but the answer is /...\\n\\nHow could that be?!!!"
                    },
                    {
                        "username": "Umair9912",
                        "content": "[@satyam_rai15](/satyam_rai15) better late than never ? ig.\\n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "[@gozie11](/gozie11) It\\'s a little too late to reply, isn\\'t it?"
                    },
                    {
                        "username": "gozie11",
                        "content": "It\\'s because the description says that \"...\" counts as a directory name!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/simplify-path/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Using Stacks\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1861103,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1567840,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861108,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1860920,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1860884,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1568892,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1567186,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1993508,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861426,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861406,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "Split by \\'/\\'. Use a stack and ignore empty spaces and \\'.\\'; pop on double dot \\'..\\'"
                    },
                    {
                        "username": "JiahuanChen1993",
                        "content": "Hello, I met with this following problem:\\nInput:\"/\"\\nOutput:\"\\\\/\"\\nExpected:\"/\"\\nHow can I fix it? I tried some accepted code and also got errors."
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "in this question there is a testcase in which \\ninput : \"/a//b////c/d//././/..\"\\nexpected output : \"/a/b/c\"\\n\\ni think output is : \"/a/b/c/d\" .\\ndoes somebody explain why isnot this output"
                    },
                    {
                        "username": "gouravkadyan555",
                        "content": "i get it coz at the end its .. means its jump d to c thats why"
                    },
                    {
                        "username": "pokaChika",
                        "content": "a double period \\'..\\' refers to the directory up a level, Shouldn\\'t this linebe changed to \\'..\\' refers to going a level down. It makes the problem understanding unnecessarily difficult"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Going up sounds more logical. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Really? Is that difficult to understand? \nYour version sounds less correct to me. Going a level down suggests going deeper into the directory tree to me, not backtracking up towrds the root."
                    },
                    {
                        "username": "hosua",
                        "content": "This problem had a lot of annoying edge cases lol"
                    },
                    {
                        "username": "HanBurger",
                        "content": "Isn't \"/..\" represents the parent folder?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "yes, unless you are already at the root dir in which case it does nothing"
                    },
                    {
                        "username": "huangGmail",
                        "content": "shoudn't i outpu \" / \" instead of \"/...\" ?"
                    },
                    {
                        "username": "ayeagle",
                        "content": "Can someone explain how this test case:\\n\\n\"/a//b////c/d//././/..\"\\n\\nevaluates to: \"/a/b/c\"\\n\\nand not \"/a/b/c/d\" ???"
                    },
                    {
                        "username": "rrdlpl",
                        "content": "There is a `..` at the end "
                    },
                    {
                        "username": "tejasX",
                        "content": "Question was rather implementation based instead of Concept."
                    },
                    {
                        "username": "eduard92",
                        "content": "I god damn it solved it on my own, after 3 versions and 25% "
                    }
                ]
            },
            {
                "id": 1861071,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1860928,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1672377,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1572767,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2059103,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2033835,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2018566,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2007982,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 2002807,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1979717,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "if your PL has built in split method the problem becomes a matter of handling 4 cases.\\nsuprised at the acceptance rate tbh"
                    },
                    {
                        "username": "veeyikpong",
                        "content": "Process the command from end to start\\n\\nYou can either\\nUse\\n1. `split(\"/\")\\' the commands into a list, reverse the list and process the command one by one \\n2. Loop the `path` from end to start, appending the current command text into a temp variable. Whenever we meet a slash (/), process the current command text and clear it.\\n3. Have a `back` variable to keep track of `..` operations. When we meet a normal file path, ignore it if `back > 0`, and minus it.\\n\\nSome important checks are\\n1. When command is `..`, increase `back` by 1\\n2. When command is empty (many consecutive slashes) or \".\", ignore the command\\n3. When command is neither empty, `.` nor `..`, it is a file path. If `back` is 0 , add the command into our result string, else `back--`"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": " \"/a//b////c/d//././/..\"\\nexpected output is \\'/a/b/c\\', why? why not \\'/a/b/c/d\\'?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I got caught by this test case as well. `..` (*without* a trailing `/`) is treated the same as `../` (read: go up on level/directory). The \"big picture\" is test cases don\\'t always end in a `/`."
                    },
                    {
                        "username": "rosemelon",
                        "content": "Hi, I just had a simple Unix question about the one period. \\n\\nFrom my understanding at looking at other people\\'s code, we skip the period if we ever see it. \\nIs this because if we have \"/a/b/.\" is equivalent to \"/a/b\"? If so, what does anyone ever use the period for if we don\\'t even include it in our shortest path?"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "Lots of Idiots Test cases is here. Frustrating problem ."
                    },
                    {
                        "username": "fkie4",
                        "content": "this should be categorised as easy"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "okay first of all, author of this problem has not given sufficient examples. I am getting issues to fully understand problem."
                    },
                    {
                        "username": "huggie",
                        "content": "If using C, is there a C stack library already included by leetcode? Or do I have to resort to uthash?"
                    },
                    {
                        "username": "kikopy89",
                        "content": "What?\\npath =\\n\"/a/./b/../../c/\"\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\""
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "rule 3: The path does not end with a trailing \\'/\\'.\\nAnd check the example 2 pls"
                    },
                    {
                        "username": "mahesh105",
                        "content": "if the size of string is 1 then it can,else no"
                    }
                ]
            },
            {
                "id": 1912855,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1862055,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861803,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861713,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861635,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861630,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861617,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861393,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861359,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861346,
                "content": [
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "this is not a medium problem definitely hard one. "
                    },
                    {
                        "username": "mahesh105",
                        "content": "I cannot agree more"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "Input\\npath =\\n\"/a/./b/../../c/\"\\n\\nOutput\\n\"/a/b/c\"\\nExpected\\n\"/c\"\\n\\ncan someone explain why the output is /c and not /a/b/c"
                    },
                    {
                        "username": "aitachii",
                        "content": "the first \"..\" goes back one directory, so b is popped\ne.g. /a/b/.. == /a\nthe second \"..\" goes back one directory, so a is popped\ne.g. /a/.. == /\n\nc has no \"..\" to its right so it just gets pushed"
                    },
                    {
                        "username": "DavidCastillo",
                        "content": "Ok, guys. It\\'s incredible that many people were claiming that [yesterday\\'s daily challenge](https://leetcode.com/problems/removing-stars-from-a-string/) was easy. Today, it\\'s almost the same, but now we have an acceptance rate of 40.5%. What\\'s happening?\""
                    },
                    {
                        "username": "lakpareek",
                        "content": "what am i doing wrong here? it keeps on returning an empty string as the answer. Please help if you can  :((\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        queue<char> q;\n        for(int i = 0; i<path.size(); i++){\n            if(path[i] == '/' && q.front() == '/'){\n                continue;\n            }\n            else{\n                q.push(path[i]);\n            }\n        }\n        vector<string> col;\n        while(!q.empty()){\n            string n = \"\";\n            if(q.front() != '/'){\n                n.push_back(q.front());\n                q.pop();\n            }\n            else if(q.front() == '/' && !col.empty()){\n                col.push_back(n);\n                n = \"\";\n            }\n            else{\n                q.pop();\n            }\n        }\n        string ans = \"/\";\n        for(int i = 0; i<col.size(); ){\n            if(col[i] == \".\" || col[i] == \"..\"){\n                i+=2;\n            }\n            else{\n                ans += col[i];\n                ans.push_back('/');\n                i++;\n            }\n        }\n        ans.pop_back();\n        return ans;\n    }\n};\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I wrote the worst code of my life and solved this problem any how"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This took me way longer than it should have. Got stuck multiple times with just a stack approach. I split the string on '/' first that made it slightly easier."
                    },
                    {
                        "username": "why-sid",
                        "content": "Can somebody explainf this question in a simple manner...like how do we tackle the slashes? I understood using the stack but not more than that."
                    },
                    {
                        "username": "why-sid",
                        "content": "[@vickyshankar23](/vickyshankar23) No, I mean I understood the approach and the logic of the question, it is just that I cannot build the exact code for it...needed to see the solution before submitting...like how actually to implement the solution in stack after pushing it, is the problem..you getting it?"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "Do you mean multiple slashes? If so, you can just see if the head of the stack is a \"/\", if so just ignore other \"/\". \\nIf this is more generic, I just split the path string on \"/\" before using a stack to build the canonical path. That made it easier."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like a stack series"
                    },
                    {
                        "username": "_drigger",
                        "content": "my code cross 90 lines i don\\'t know what i have written \\uD83E\\uDD28"
                    },
                    {
                        "username": "singhom",
                        "content": "faltu question tha bhai but hogaya"
                    },
                    {
                        "username": "singhom",
                        "content": "go on gfg u will get a better insight about the edge cases"
                    }
                ]
            },
            {
                "id": 1861266,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861260,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861184,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861101,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861057,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861048,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861046,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861036,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861035,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1861004,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "If you want a challenge, try doing it in O(1) space."
                    },
                    {
                        "username": "aitachii",
                        "content": "[@charonme](/charonme) Either that or using a string instead of a stack."
                    },
                    {
                        "username": "charonme",
                        "content": "so in-place modification of the input string?"
                    },
                    {
                        "username": "ng812057",
                        "content": "here m not able to solve it in o(n).... and u r talking about o(1)\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "\"/..hidden\"\\nWhy the answer for this test case is \"/..hidden\" instead of \"/hidden\" ?"
                    },
                    {
                        "username": "rajat_171",
                        "content": "I\\'m not able to understand the question .....\\uD83E\\uDD72.\\n"
                    },
                    {
                        "username": "_priyang__",
                        "content": "are these type of questions asked in technical interviews???"
                    },
                    {
                        "username": "sk03167",
                        "content": "I would hope not. Somehow, the code I wrote just luckily happened to pass for edge cases. Otherwise it probably would have taken a couple of failed attempts to solve this one."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Simple task to practice **Stack** using skills"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "Try these testcases -\\n```\\n\"/..hidden\"\\n\"/.aa/....hidden\"\\n```"
                    },
                    {
                        "username": "harikrishnacn1999",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "From past 3 days, only the question  from the stack is coming\n\nDon't you found this strange?\n\nWhat's your opinionn"
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "Can someone explain me what\"s the deal with \"...\" ?\\n "
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The question says that \\'...\\' is treated as a file or directory name"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Split the input path string by the appropriate delimiter (e.g., \"/\" for Unix-like systems, \"\\\\\" for Windows) to obtain an array or list of substrings, each representing a component of the file system path.\\n\\n- Create an empty stack or list to store the simplified components of the path.\\n\\n- Iterate over each component s in the array or list of substrings.\\n\\n- For each component s:\\n\\n- If the stack or list is not empty and s is equal to \"..\", then pop the top element (the previous component) from the stack or remove the last element from the list to effectively move up one level in the file system hierarchy.\\n- Otherwise, if s is not equal to \".\" (which represents the current directory), \"..\" (which represents moving up one level in the file system hierarchy), or an empty string (which can occur due to consecutive delimiters in the input path), push s onto the stack or add it to the list to include it as a component of the simplified path.\\n- After iterating over all components of the input path, check if the stack or list is empty. If it is, return the root directory representation (\"/\" for Unix-like systems, \"C:\\\\\" for Windows), as the simplified path.\\n\\n- If the stack or list is not empty, build the simplified path by popping components from the stack or joining elements in the list with the appropriate delimiter. Finally, return the simplified path as a string."
                    }
                ]
            },
            {
                "id": 1860966,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860952,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860914,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860898,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860878,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860847,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860829,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860810,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1860807,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            },
            {
                "id": 1817683,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Make a problem with peculiar scenarios then don't provide enough examples. That's what leetcode does once in a while, even from the times of problem 71 ! We are in the 2000's (both AD & LC) right now and 71 seems near the time Jesus existed.\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "sad when the daily problem is one you\\'ve already solved :("
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Until we encounter '/' we keep a string of all chars and then check if it is '.' || '..' , if not then we consider it a name and and the directory name to the Stack."
                    },
                    {
                        "username": "vetor",
                        "content": "When u realize answer mostly lies in splitting of string  \\uD83D\\uDE09 . then easier than yesterdays question"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Looks like it\\'s the week of stacks! "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Kinda same as yesterday\\'s."
                    },
                    {
                        "username": "vetor",
                        "content": "Anyone understood this question property \\uD83E\\uDD72"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I recommend using \"Testcases\" to actually test the possible inputs."
                    },
                    {
                        "username": "AMerrill",
                        "content": "XD When the problem you skipped because you didn\\'t want to deal with it becomes the problem of the day..."
                    },
                    {
                        "username": "meow_power",
                        "content": "why is it taking me so long to think an approach for this problem. I cant even understand the examples:?"
                    },
                    {
                        "username": "MrCelestis",
                        "content": "I have no idea how this happened to be a medium difficulty problem, there are others in this category which are orders of magnitude harder."
                    }
                ]
            }
        ]
    },
    {
        "title": "Excel Sheet Column Number",
        "question_content": "<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;A&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;AB&quot;\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;ZY&quot;\n<strong>Output:</strong> 701\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnTitle.length &lt;= 7</code></li>\n\t<li><code>columnTitle</code> consists only of uppercase English letters.</li>\n\t<li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1790101,
                "title": "c-4-lines-easy-to-understand-0ms-100",
                "content": "# 171. Excel Sheet Column Number\\n**KNOCKCAT**\\n* **Someone is intentionally downvoting answer , if you cannot support please dont spread hate**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 4 Lines 0ms , 100 % faster.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\\n\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)                 **Link to LeetCode Repository**\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n![image](https://assets.leetcode.com/users/images/8e18cdad-9e69-4a3a-a6a0-86f3e7cc3898_1645490636.3928394.png)\\n\\n\\n* **EXPLANATION**\\n```\\n1. There are 26 letters in our alphabet and we start counting from 1, not zero.\\n   So \\'Z\\' is 26.\\n2. The rest of the combinations start from a base 26\\n\\nAA --> 26*1+ 1 = 27 (A == 1)\\nAB --> 26*1+ 2 = 28 (B == 2)\\nAC -->26*1 + 3 = 29 (C == 3)\\n.....\\n\\nSo we can write like this:\\n\\nresult = 0\\nd = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the letter to a number like it\\'s going to be C)\\nresult = result* 26 + d\\n\\nIf the given input is only one letter, it will automatically take the value s[i] - \\'A\\' + 1 as the first result is 0.\\n```\\n\\n* **Some More Explanation**\\n\\n```\\n1. For every additional digit of the string, we multiply the value of the digit by 26^n\\n2. here n is the number of digits it is away from the one\\'s place.\\n3. This is similar to how the number 254 could be broken down as this:\\n\\t (2 x 10 x 10) + (5 x 10) + (4).\\n4. The reason we use 26 instead of 10 is because 26 is our base.\\n\\nFor s = \"BCM\" the final solution would be (2 x 26 x 26) + (3 x 26) + (13)\\n\\nWe could do this process iteratively. Start at looking at the first digit \"B\". Add the int equivalent of \"B\" to the running sum and continue. \\nEvery time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:\\n\\n\"B\" = 2\\n\"BC\" = (2)26 + 3\\n\"BCM\" = (2(26) + 3)26 + 13\\n```\\n\\n* **Time Complexity : O(n)**       *one scan of string , n is number of characters in the string* \\n\\n* **CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int result = 0;\\n        for(char c : columnTitle)\\n        {\\n\\t\\t\\t//d = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the letter to a number like it\\'s going to be C)\\n\\n            int d = c - \\'A\\' + 1;\\n            result = result * 26 + d;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. 4 Lines 0ms , 100 % faster.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\n```\\n1. There are 26 letters in our alphabet and we start counting from 1, not zero.\\n   So \\'Z\\' is 26.\\n2. The rest of the combinations start from a base 26\\n\\nAA --> 26*1+ 1 = 27 (A == 1)\\nAB --> 26*1+ 2 = 28 (B == 2)\\nAC -->26*1 + 3 = 29 (C == 3)\\n.....\\n\\nSo we can write like this:\\n\\nresult = 0\\nd = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the letter to a number like it\\'s going to be C)\\nresult = result* 26 + d\\n\\nIf the given input is only one letter, it will automatically take the value s[i] - \\'A\\' + 1 as the first result is 0.\\n```\n```\\n1. For every additional digit of the string, we multiply the value of the digit by 26^n\\n2. here n is the number of digits it is away from the one\\'s place.\\n3. This is similar to how the number 254 could be broken down as this:\\n\\t (2 x 10 x 10) + (5 x 10) + (4).\\n4. The reason we use 26 instead of 10 is because 26 is our base.\\n\\nFor s = \"BCM\" the final solution would be (2 x 26 x 26) + (3 x 26) + (13)\\n\\nWe could do this process iteratively. Start at looking at the first digit \"B\". Add the int equivalent of \"B\" to the running sum and continue. \\nEvery time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:\\n\\n\"B\" = 2\\n\"BC\" = (2)26 + 3\\n\"BCM\" = (2(26) + 3)26 + 13\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int result = 0;\\n        for(char c : columnTitle)\\n        {\\n\\t\\t\\t//d = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the letter to a number like it\\'s going to be C)\\n\\n            int d = c - \\'A\\' + 1;\\n            result = result * 26 + d;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790567,
                "title": "python3-clean-solution-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nEssentially, what we asked to do here is to convert a number in the base 26 numeral system to a decimal number. This is a standard algorithm, where we iterate over the digits from right to left and multiply them by the base to the power of the position of the digit. To translate a letter to a number we use the Python method `ord` which returns the Unicode code of the letter. By subtracting the code by 64, we can map letters to the numbers from 1 to 26.\\n\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        ans, pos = 0, 0\\n        for letter in reversed(columnTitle):\\n            digit = ord(letter)-64\\n            ans += digit * 26**pos\\n            pos += 1\\n            \\n        return ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        ans, pos = 0, 0\\n        for letter in reversed(columnTitle):\\n            digit = ord(letter)-64\\n            ans += digit * 26**pos\\n            pos += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52154,
                "title": "concise-java-solution-with-explanation",
                "content": "For every additional digit of the string, we multiply the value of the digit by 26^n where n is the number of digits it is away from the one's place. This is similar to how the number 254 could be broken down as this: (2 x 10 x 10) + (5 x 10) + (4). The reason we use 26 instead of 10 is because 26 is our base.\\n\\nFor s = \"BCM\" the final solution would be (2 x 26 x 26) + (3 x 26) + (13)\\n\\nWe could do this process iteratively. Start at looking at the first digit \"B\". Add the int equivalent of \"B\" to the running sum and continue. Every time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:\\n\\n\"B\" = 2\\n\"BC\" = (**2**)26 + 3\\n\"BCM\" = (**2(26) + 3**)26 + 13\\n\\nif you expand this expression you will see it is identical to the example above  :).\\n```\\npublic class Solution {\\n    public int titleToNumber(String s) {\\n        if (s == null) return -1;\\n        int sum = 0;\\n        // for each loop so we don't need to mess with index values.\\n        for (char c : s.toUpperCase().toCharArray()) {\\n            sum *= 26;\\n            sum += c - 'A' + 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int titleToNumber(String s) {\\n        if (s == null) return -1;\\n        int sum = 0;\\n        // for each loop so we don't need to mess with index values.\\n        for (char c : s.toUpperCase().toCharArray()) {\\n            sum *= 26;\\n            sum += c - 'A' + 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52107,
                "title": "my-solutions-in-3-languages-does-any-one-have-one-line-solution-in-java-or-c",
                "content": "Java:\\n\\n    int result = 0;\\n    for (int i = 0; i < s.length(); result = result * 26 + (s.charAt(i) - 'A' + 1), i++);\\n    return result;\\n\\n\\nC++:\\n\\n    int result = 0;\\n    for (int i = 0; i < s.size(); result = result * 26 + (s.at(i) - 'A' + 1), i++);\\n    return result;\\n\\n\\nPython:\\n\\n    return reduce(lambda x, y : x * 26 + y, [ord(c) - 64 for c in list(s)])\\n\\nPython version is beautiful because reduce function and list comprehensive.\\n\\nI don't know whether exist similar approach to achieve one line solution in Java or C++.\\nOne possible way is defining another method like this:\\n\\n    public int titleToNumber(int num, String s)\\n\\nto store previous result and make recursive call.\\nBut this add much more lines.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Java:\\n\\n    int result = 0;\\n    for (int i = 0; i < s.length(); result = result * 26 + (s.charAt(i) - 'A' + 1), i++);\\n    return result;\\n\\n\\nC++:\\n\\n    int result = 0;\\n    for (int i = 0; i < s.size(); result = result * 26 + (s.at(i) - 'A' + 1), i++);\\n    return result;\\n\\n\\nPython:\\n\\n    return reduce(lambda x, y : x * 26 + y, [ord(c) - 64 for c in list(s)])\\n\\nPython version is beautiful because reduce function and list comprehensive.\\n\\nI don't know whether exist similar approach to achieve one line solution in Java or C++.\\nOne possible way is defining another method like this:\\n\\n    public int titleToNumber(int num, String s)\\n\\nto store previous result and make recursive call.\\nBut this add much more lines.",
                "codeTag": "Unknown"
            },
            {
                "id": 52304,
                "title": "python-concise-solution",
                "content": "\\n    def titleToNumber(self, s):\\n        res = 0\\n        for c in s:\\n            res = res*26 + ord(c)-ord(\\'A\\')+1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def titleToNumber(self, s):\\n        res = 0\\n        for c in s:\\n            res = res*26 + ord(c)-ord(\\'A\\')+1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 818469,
                "title": "python-the-only-explanation-that-is-understandable-and-makes-sense-to-those-who-just-start",
                "content": "**Disclaimer**: I hate when the \"Discussion\" session has tons of posts that contain just a few lines of code with indecipherable variables and an impossible-to-follow logic. For this question, I haven\\'t found a single solution that a novice user can follow and understand.  ```ord()``` is everywhere, etc. \\n\\n**Explanation:**\\nIt\\'s easier to start with a different and, probably, easier problem. How to convert a string of digits to a number. Let\\'s say, you\\'re given \\'67\\' and you want to return 67. Sure you can do \\n``` return int(s)``` \\nbut if you are here for this, you don\\'t want to be here. Let\\'s assume, to make the explanation shorter, you can apply ```int()``` only to single digits but not to the whole number.\\nYou\\'re given \\'67.\\'\\nLet\\'s start reading this line element by element and initialise a variable ```res = 0``` that will contain the final result.\\nWe will put the integer value of the first string\\'s element to ```res```. Now ```res``` contains 6. Are we done with the string? No. Let\\'s read the next character.\\nThe next character is 7. If we just add 7 to ```res```, we will get 13. It\\'s not what we want. We want to take whatever is stored in ```res``` already, multiply it by ten and add seven. This way we will take six, turn it into 60, add 7, and resave into ```res```. Are we done with the line? Yes. Then just return ```res```.\\n\\nHere is the whole thing encoded:\\n```\\ndef str2num(s):\\n    res = 0\\n    for digit in s:\\n        res = res * 10 + int(digit)\\n    return res\\n```\\n\\nBy the way, you can also do it recursively:\\n```\\ndef str2num_recursively(s):\\n    def _helper(s, res):\\n        if not s: return res\\n        return _helper(s[1:], res * 10 + int(s[0]))\\n    return _helper(s, 0)\\n```\\nBut the secret is: **NEVER USE RECURSION UNLESS IT\\'S A DFS PROBLEM**. **In real life**, once you finally get that fat FAANG job, **NEVER USE RECURSION**.\\n\\nLet\\'s get back to 171. The idea here is the same with two differences:\\n1) We will use a dictionary to create a mapping \"character: number.\" \\n2) We will use 26 instead of 10\\n\\n```\\ndef titleToNumber(s):\\n    res = 0\\n    val = [i for i in range(1, 27)]\\n    letters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\\n    d = dict(zip(letters, val))\\n    for ch in s:\\n        res = res * 26 + d[ch]\\n    return res\\n```\\nAs you can see, res is calculated exactly the same way as in the first portion of code above. We just use 26 instead of 10, and ```d[ch]``` instead of ```int(s[0])```.\\n\\nAnd for those who don\\'t listen to good advices, the recursive implementation:\\n```\\ndef titleToNumber_recur(s):\\n    val = [i for i in range(1, 27)]\\n    letters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\\n    d = dict(zip(letters, val))\\n    def _helper(s, res, d):\\n        if not s: return res\\n        res = res * 26 + d[s[0]]\\n        return _helper(s[1:], res, d)\\n    return _helper(s, 0, d)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```ord()```\n``` return int(s)```\n```int()```\n```res = 0```\n```res```\n```res```\n```res```\n```res```\n```res```\n```res```\n```\\ndef str2num(s):\\n    res = 0\\n    for digit in s:\\n        res = res * 10 + int(digit)\\n    return res\\n```\n```\\ndef str2num_recursively(s):\\n    def _helper(s, res):\\n        if not s: return res\\n        return _helper(s[1:], res * 10 + int(s[0]))\\n    return _helper(s, 0)\\n```\n```\\ndef titleToNumber(s):\\n    res = 0\\n    val = [i for i in range(1, 27)]\\n    letters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\\n    d = dict(zip(letters, val))\\n    for ch in s:\\n        res = res * 26 + d[ch]\\n    return res\\n```\n```d[ch]```\n```int(s[0])```\n```\\ndef titleToNumber_recur(s):\\n    val = [i for i in range(1, 27)]\\n    letters = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\\n    d = dict(zip(letters, val))\\n    def _helper(s, res, d):\\n        if not s: return res\\n        res = res * 26 + d[s[0]]\\n        return _helper(s[1:], res, d)\\n    return _helper(s, 0, d)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 52091,
                "title": "here-is-my-java-solution",
                "content": "Here is my Java solution. Similar to the number to title.\\n\\n    public int titleToNumber(String s) {\\n        int result = 0;\\n        for(int i = 0 ; i < s.length(); i++) {\\n          result = result * 26 + (s.charAt(i) - 'A' + 1);\\n        }\\n        return result;\\n      }",
                "solutionTags": [],
                "code": "Here is my Java solution. Similar to the number to title.\\n\\n    public int titleToNumber(String s) {\\n        int result = 0;\\n        for(int i = 0 ; i < s.length(); i++) {\\n          result = result * 26 + (s.charAt(i) - 'A' + 1);\\n        }\\n        return result;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 52289,
                "title": "explanation-in-python",
                "content": "Observe that this is basically the same thing as converting between base 26 and base 10.\\n\\nStart with this:\\n\\n    def titleToNumber(s):\\n        s = s[::-1]\\n        sum = 0\\n        for exp, char in enumerate(s):\\n            sum += (ord(char) - 65 + 1) * (26 ** exp)\\n        return sum\\n\\nThis reverses the string, starts a sum at 0, creates a list of tuples of the index of each character in the reversed string (which corresponds to the exponent) and character itself. Add them up. We take ord(char) to turn the character to an integer, subtract 65 = ord('A') from it, and add one because we want A to equal 1, not 0.\\n\\nYou can do this in one line:\\n\\n    def titleToNumber(s):\\n        return sum((ord(char) - 64) * (26 ** exp) for exp, char in enumerate(s[::-1]))",
                "solutionTags": [],
                "code": "Observe that this is basically the same thing as converting between base 26 and base 10.\\n\\nStart with this:\\n\\n    def titleToNumber(s):\\n        s = s[::-1]\\n        sum = 0\\n        for exp, char in enumerate(s):\\n            sum += (ord(char) - 65 + 1) * (26 ** exp)\\n        return sum\\n\\nThis reverses the string, starts a sum at 0, creates a list of tuples of the index of each character in the reversed string (which corresponds to the exponent) and character itself. Add them up. We take ord(char) to turn the character to an integer, subtract 65 = ord('A') from it, and add one because we want A to equal 1, not 0.\\n\\nYou can do this in one line:\\n\\n    def titleToNumber(s):\\n        return sum((ord(char) - 64) * (26 ** exp) for exp, char in enumerate(s[::-1]))",
                "codeTag": "Python3"
            },
            {
                "id": 783383,
                "title": "python-oneliner-base-26-numeral-system-explained",
                "content": "Note, that all depends on the place we have some symbol, for example:\\nfor `s = DACB`:\\n1. We have symbol `B` on the last place, with stands for `2`\\n2. We have symbol `C` on the previous place, which stands for `3*26`.\\n3. We have symbol `A` on the previous place, which stands for `1*26*26`.\\n4. Finally, we have symbol `D` on the first place, which stands for `4*26*26*26`.\\n5. What we need to return in this case is `2+3*26+1*26*26+4*26*26*26`.\\n\\nNote, that is it very similar to base `26` numeral system, but not exactly it, here we do not have zeros. All this can be written as oneliner.\\n\\n**Complexity**: Time complexity of this oneliner is `O(n log n)`, where `n` is length of string. We need to iterate over all string and use `26**i`. Time complexity can be easily reduced to `O(n)`. Space complexity is `O(n)`, which also can be reduced to `O(1)`. But in this problem `n` is very small: `n<=7`, so it will not make a lot of difference\\n\\n```\\nclass Solution:\\n    def titleToNumber(self, s):\\n        return sum([(ord(T)-ord(\"A\")+1)*26**i for i,T in enumerate(s[::-1])])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, s):\\n        return sum([(ord(T)-ord(\"A\")+1)*26**i for i,T in enumerate(s[::-1])])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52124,
                "title": "my-2ms-java-solution",
                "content": "    public class Solution {\\n        public int titleToNumber(String s) {\\n        \\n            int result  = 0;\\n            for (int i = 0; i < s.length(); i++){\\n                result *= 26;\\n                result += ((s.charAt(i) - 'A') + 1);    \\n            }\\n        \\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int titleToNumber(String s) {\\n        \\n            int result  = 0;\\n            for (int i = 0; i < s.length(); i++){\\n                result *= 26;\\n                result += ((s.charAt(i) - 'A') + 1);    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1790367,
                "title": "c-detailed-explanation-w-comments-faster-than-100-easy-understanding",
                "content": "***Brief note about Question-***\\n* We have to *return the corresponding column number of a string as it appears in the Excel Sheet.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our string given to us is s = \"AZ\"\\n\\nSo, the representation of our string should be \\npos of \\'Z\\' in alphabtes is: 26\\npos of \\'A\\' in alphabets is: 1\\n\\nBut, In string \"AZ\", \\n\\'Z\\' is on unit place and it\\'s pos value in alphabets is 26\\nand \\'A\\' is on ten\\'s digit and it\\'s pos value in alphabets is 1\\nso, \\'A\\' should be multiplied with 26.\\nTherefore, Final answer should be-\\n\"AZ\"\\n(1 * (26 ^ 1)) + (26 * (26 ^ 0))\\n(1 * 26) + (26 * 1)\\n(26) + (26)\\n52\\n\\nThe final answer should be 52.\\n```\\n____________\\n***Solution - I (Accepted)-***\\n* Suppose if we have given a binary number and they ask us to convert that binary number into corrospnding decimal number, then how we will proceed.\\n```\\nSay, if they given us a binary number --> 11\\nthen, how we will proceed,\\nWe reach to our answer something like this, \\n(1 * ( 2 ^ 1)) + (1 * ( 2 ^ 0))\\n(2) + (1)\\n3\\n```\\n* We consider it as the same question but only in the form of string.\\n* In binary, only two values are possible so the base is 2.\\n* **In our alphabets, 26 values are possible so the base should be 26.**\\n* If only one character is present, then obviously we know it\\'s position is our answer.\\n______\\n```\\nTime Complexity --> O(n) // as we are using traversing string only once and n is the length of the string. \\nSpace Complexity --> O(1) // as we are not using anything from our side.\\n\\nIt paases [ 1002 / 1002] in built test cases with faster than 100.00% of C++ online submissions\\n```\\n_________\\n![image](https://assets.leetcode.com/users/images/4adb6907-7939-4974-9c28-e31be07a96ac_1645499732.7979946.png)\\n______________________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n = s.length(); // extracting length of the string\\n        \\n        if(n == 1) // if length is only 1\\n        {\\n            return (s[0] - \\'A\\') + 1; //then return only that position\\n        }\\n        \\n        int increase = 0; // variable used to increase the multiplcation\\n        int ans = 0; // variable used to store answer\\n        \\n        for(int i = n - 1; i >= 0; i--) // start traversing string from back\\n        {\\n            int pos = (s[i] - \\'A\\') + 1; // extracting position\\n            \\n            ans = ans + (pos * pow(26, increase)); // with base 26, do further calculation\\n            increase++; // increase variable\\n        }\\n        \\n        return ans; // finally return the answer\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our string given to us is s = \"AZ\"\\n\\nSo, the representation of our string should be \\npos of \\'Z\\' in alphabtes is: 26\\npos of \\'A\\' in alphabets is: 1\\n\\nBut, In string \"AZ\", \\n\\'Z\\' is on unit place and it\\'s pos value in alphabets is 26\\nand \\'A\\' is on ten\\'s digit and it\\'s pos value in alphabets is 1\\nso, \\'A\\' should be multiplied with 26.\\nTherefore, Final answer should be-\\n\"AZ\"\\n(1 * (26 ^ 1)) + (26 * (26 ^ 0))\\n(1 * 26) + (26 * 1)\\n(26) + (26)\\n52\\n\\nThe final answer should be 52.\\n```\n```\\nSay, if they given us a binary number --> 11\\nthen, how we will proceed,\\nWe reach to our answer something like this, \\n(1 * ( 2 ^ 1)) + (1 * ( 2 ^ 0))\\n(2) + (1)\\n3\\n```\n```\\nTime Complexity --> O(n) // as we are using traversing string only once and n is the length of the string. \\nSpace Complexity --> O(1) // as we are not using anything from our side.\\n\\nIt paases [ 1002 / 1002] in built test cases with faster than 100.00% of C++ online submissions\\n```\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n = s.length(); // extracting length of the string\\n        \\n        if(n == 1) // if length is only 1\\n        {\\n            return (s[0] - \\'A\\') + 1; //then return only that position\\n        }\\n        \\n        int increase = 0; // variable used to increase the multiplcation\\n        int ans = 0; // variable used to store answer\\n        \\n        for(int i = n - 1; i >= 0; i--) // start traversing string from back\\n        {\\n            int pos = (s[i] - \\'A\\') + 1; // extracting position\\n            \\n            ans = ans + (pos * pow(26, increase)); // with base 26, do further calculation\\n            increase++; // increase variable\\n        }\\n        \\n        return ans; // finally return the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790803,
                "title": "python-easy-one-liner-explaination",
                "content": "**How to form a number using a list of digits?**\\n1. We take a variable ```ans``` and initialize it with 0 \\n2. We traverse through the list and update the variable as ```ans = ans * 10 + currDigit ```\\n\\nIn this question we need to do the same but we multiply it with 26 instead of 10\\n```ans = ans * 26 + currDigit```\\n\\n\\nNow we need to think how we will get the ```currDigit``` out of Characters.\\nwe will use ascii value of the characters\\n\\n```ord(i) - ord(\\'A\\') + 1   #ord will return the ascii value of the character```\\n```\\n A = 1         |  ord(\\'A\\') - ord(\\'A\\') + 1  = 1\\n B = 2         |  ord(\\'B\\') - ord(\\'A\\') + 1  = 2\\n C = 3         |  ord(\\'C\\') - ord(\\'A\\') + 1  = 3\\n```\\n\\nLet\\'s code this in a simple way.\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        ans = 0\\n        for i in columnTitle:\\n            ans = ans * 26 + ord(i) - ord(\\'A\\') + 1\\n        return ans\\n```\\n\\nNow If you are in love with python, you might be wondering how we will reduce the line of code to one.\\nSo here is one liner solution.\\n```\\nclass Solution:\\n    def titleToNumber(self, title: str) -> int:\\n        return reduce(lambda x,y: x * 26 + y, map(lambda x: ord(x)-ord(\\'A\\')+1,title))\\n```\\n\\n***If you have any questions or If you have a much shorter code please comment down below***\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```ans```\n```ans = ans * 10 + currDigit ```\n```ans = ans * 26 + currDigit```\n```currDigit```\n```ord(i) - ord(\\'A\\') + 1   #ord will return the ascii value of the character```\n```\\n A = 1         |  ord(\\'A\\') - ord(\\'A\\') + 1  = 1\\n B = 2         |  ord(\\'B\\') - ord(\\'A\\') + 1  = 2\\n C = 3         |  ord(\\'C\\') - ord(\\'A\\') + 1  = 3\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        ans = 0\\n        for i in columnTitle:\\n            ans = ans * 26 + ord(i) - ord(\\'A\\') + 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, title: str) -> int:\\n        return reduce(lambda x,y: x * 26 + y, map(lambda x: ord(x)-ord(\\'A\\')+1,title))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52087,
                "title": "one-line-python-code-using-map-reduce",
                "content": "    def titleToNumber(self, s):\\n        return reduce(lambda x,y:x*26+y,map(lambda x:ord(x)-ord('A')+1,s))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def titleToNumber(self, s):\\n        return reduce(lambda x,y:x*26+y,map(lambda x:ord(x)-ord('A')+1,s))",
                "codeTag": "Python3"
            },
            {
                "id": 52096,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar titleToNumber = function(s) {\\n    const charCodeBase = 'A'.charCodeAt(0) - 1;\\n    const n = s.length;\\n    let number = 0;\\n\\n    /* \\n     * Think of it as base 26. For example,\\n     * Column number of \"AB\" = 1 * 26^1 + 2 * 26^0 \\n     */\\n    for (let i = 0; i < n; i++)\\n        number += (s.charCodeAt(i) - charCodeBase) * Math.pow(26, n-i-1);\\n    \\n    return number;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar titleToNumber = function(s) {\\n    const charCodeBase = 'A'.charCodeAt(0) - 1;\\n    const n = s.length;\\n    let number = 0;\\n\\n    /* \\n     * Think of it as base 26. For example,\\n     * Column number of \"AB\" = 1 * 26^1 + 2 * 26^0 \\n     */\\n    for (let i = 0; i < n; i++)\\n        number += (s.charCodeAt(i) - charCodeBase) * Math.pow(26, n-i-1);\\n    \\n    return number;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448737,
                "title": "easy-100-explained-java-c-python-1-line-c-python3",
                "content": "**Problem Statement:**\\nGiven a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\\n**For example:**\\n\\n\\t\\t\\t\\t\\t\\tA -> 1\\n\\t\\t\\t\\t\\t\\tB -> 2\\n\\t\\t\\t\\t\\t\\tC -> 3\\n\\t\\t\\t\\t\\t\\t............\\n\\t\\t\\t\\t\\t\\tZ -> 26\\n\\t\\t\\t\\t\\t\\tAA -> 27\\n\\t\\t\\t\\t\\t\\tAB -> 28 \\n\\t\\t\\t\\t\\t\\t..................\\n\\n    \\n\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 93.25% of Java online submissions for Excel Sheet Column Number.\\nMemory Usage: 42.4 MB, less than 81.68% of Java online submissions for Excel Sheet Column Number.\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        // Initialize the output result...\\n        int output = 0;\\n        // Traverse the whole list through the loop...\\n        for(int i = 0; i < columnTitle.length(); i++){\\n            // Process to get the excel sheet column number...\\n            output = output * 26 + (columnTitle.charAt(i) - \\'A\\' + 1);\\n        }\\n        return output;      // Return the output...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        // Initialize the output result...\\n        int output = 0;\\n        // Traverse the whole list through the loop...\\n        for(auto c: columnTitle) {\\n            // Process to get the excel sheet column number...\\n            output = output * 26 + (c - \\'A\\' + 1);    \\n        }\\n        return output;    // Return the output...  \\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 22 ms, faster than 83.54% of Python online submissions for Excel Sheet Column Number.\\n```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n            \\n# **C Language:**\\n```\\nint titleToNumber(char * columnTitle){\\n    int output = 0;\\n    for(int i = 0; i < strlen(columnTitle); i++){\\n        output *= 26;\\n        output += (columnTitle[i] - \\'A\\' + 1);\\n    }\\n    return output;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        // Initialize the output result...\\n        int output = 0;\\n        // Traverse the whole list through the loop...\\n        for(int i = 0; i < columnTitle.length(); i++){\\n            // Process to get the excel sheet column number...\\n            output = output * 26 + (columnTitle.charAt(i) - \\'A\\' + 1);\\n        }\\n        return output;      // Return the output...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        // Initialize the output result...\\n        int output = 0;\\n        // Traverse the whole list through the loop...\\n        for(auto c: columnTitle) {\\n            // Process to get the excel sheet column number...\\n            output = output * 26 + (c - \\'A\\' + 1);    \\n        }\\n        return output;    // Return the output...  \\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```\n```\\nint titleToNumber(char * columnTitle){\\n    int output = 0;\\n    for(int i = 0; i < strlen(columnTitle); i++){\\n        output *= 26;\\n        output += (columnTitle[i] - \\'A\\' + 1);\\n    }\\n    return output;\\n}\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        s = columnTitle[::-1]\\n        return sum([(ord(s[i]) - 64) * (26 ** i) for i in range(len(s))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790570,
                "title": "java-solution-one-liner-faster-than-99-69",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        return s.length()==0?0:(s.charAt(s.length()-1)-\\'A\\'+1)+26*titleToNumber(s.substring(0, s.length()-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        return s.length()==0?0:(s.charAt(s.length()-1)-\\'A\\'+1)+26*titleToNumber(s.substring(0, s.length()-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327433,
                "title": "python-3-super-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        \\n        p = 1\\n        summ = 0\\n        for i in columnTitle[::-1] :\\n            summ += p*(ord(i)-64)        # -ord(A)+1\\n            p*= 26\\n        \\n        return summ\\n        \\n```\\n*       \\'\\'\\'\\n\\t\\tA.....to......Z = 26 elements\\n\\t\\tAA.....to......ZZ = 26*26 elements\\n\\t\\tAAA...to.....ZZZ = 26^3 elements\\n\\t\\tso on.....\\n\\t\\t\\n\\t\\ttherefore for eg :  ABCD\\n\\n        ABCD = [(A)*26^3] + [(B)*26^2] + [(C)*26^1] + [(D)] \\n        \\n        where (A) = 1,(B) = 2 ......(AA) = 27....\\n        \\'\\'\\'\\n* eg : **\"ZY\"** --->\\n* --first Y , ord(Y) = 89,-->89-64=25(value of Y in the first 26 elements),therefore its excel sheet value will be = [(26^0)*25] == 25\\n* --second Z, ord(Z) = 90,-->90-64=26(value of Z in the first 26 elements) ,therefore its excel sheet value will be = [(26^1)*26] == 656\\n* taking summ of them gives \"ZY\"\\'s column number i.e, 656 + 25 = 701\\n\\n***please upvote if you like : )***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        \\n        p = 1\\n        summ = 0\\n        for i in columnTitle[::-1] :\\n            summ += p*(ord(i)-64)        # -ord(A)+1\\n            p*= 26\\n        \\n        return summ\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327476,
                "title": "solution-swift-excel-sheet-column-number-test-cases",
                "content": "```swift\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        return columnTitle.unicodeScalars.reduce(0, { $0 * 26 + Int($1.value) - 64})\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.titleToNumber(\"A\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    func test1() {\\n        let value = solution.titleToNumber(\"AB\")\\n        XCTAssertEqual(value, 28)\\n    }\\n    func test2() {\\n        let value = solution.titleToNumber(\"ZY\")\\n        XCTAssertEqual(value, 701)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        return columnTitle.unicodeScalars.reduce(0, { $0 * 26 + Int($1.value) - 64})\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.titleToNumber(\"A\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    func test1() {\\n        let value = solution.titleToNumber(\"AB\")\\n        XCTAssertEqual(value, 28)\\n    }\\n    func test2() {\\n        let value = solution.titleToNumber(\"ZY\")\\n        XCTAssertEqual(value, 701)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52108,
                "title": "a-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int titleToNumber(string s) {\\n            int col = 0;\\n            for(int i = s.length(); i > 0; i--) {\\n                col += (s[i - 1] - 'A' + 1) * pow(26, (s.length() - i));\\n            }\\n            return col;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int titleToNumber(string s) {\\n            int col = 0;\\n            for(int i = s.length(); i > 0; i--) {\\n                col += (s[i - 1] - 'A' + 1) * pow(26, (s.length() - i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1791478,
                "title": "easiest-100-faster-c-solution-with-explanation",
                "content": "**Approach :**\\n\\nAs similar as we Convert Hexadecimal to decimal Shown In Image We Have To Multiply Every Charcter Of String With Respective Pow Of 26 And Have To Multiply It With Coresponding Index Of Char From Alphabate...\\n\\n![image](https://assets.leetcode.com/users/images/6b779012-8f58-41ff-9f7f-f5a7be06d1d3_1645529900.3873541.jpeg)\\n\\nIn Above Image We Are Coverting It To Hexadecimal So That We Multiply It With 16 While Here We Are Dealing With Alphabet (Total 26) So We Have To Multiply With 26 And Character\\'s Index From Alphabet.\\n\\nExample :\\nString S = \"XYZ\"\\nX = 24, Y = 25, Z = 26.\\nSo \\nans = X * pow(26,2) + Y * pow(26,1) + Z * pow(26,0) //Here 2,1,0 Of Pow are string size()-index... As Like Hexadecimal\\nans = 16224 + 650 + 26\\nans = 16900\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n\\t\\tint ans = 0; int y = 1;\\n\\t\\tfor (int i = 0; i < columnTitle.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tans += (columnTitle[i]-\\'A\\'+1) * pow(26,columnTitle.size()-y);\\n\\t\\t\\ty++;\\n\\t\\t}\\n    return ans;\\n    }\\n};\\n\\n```\\n\\n**Don\\'t Forget To Upvote And Ask If Any Query :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n\\t\\tint ans = 0; int y = 1;\\n\\t\\tfor (int i = 0; i < columnTitle.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tans += (columnTitle[i]-\\'A\\'+1) * pow(26,columnTitle.size()-y);\\n\\t\\t\\ty++;\\n\\t\\t}\\n    return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783498,
                "title": "c-oneliner-recursive-vs-iterative-solutions-explained-100-time-70-space",
                "content": "So, this was a fun one, since the problem was a simple lexicographic one and all we had to think was how to count using `A - Z` instead of `0 - 9`. If you are into that and/or what an extra shot of the same medicine, be sure to check [its sibling](https://leetcode.com/problems/excel-sheet-column-title/) and, if you wish, also [my solution for it too](https://leetcode.com/problems/excel-sheet-column-title/discuss/784392/C%2B%2B-Oneliner-Recursive-Vs.-Iterative-Solutions-Explained-100-Time-~70-Space).\\n\\nTo do so, I found more convenient to start from the leftmost \"digit\" and proceed to the right, storing my result in the `res` variable and, one step at a time, multiplying the previous value of `res` by `26` (that is our base) and adding the value of the current character to it.\\n\\nTo turn a `A - Z` range into a `1 - 26` one, just need to subtract `@`, the first character before `A` in [the standard ASCII implementation](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\\n\\nIn my recursive calls I am then passing:\\n* the base string `s` as a reference;\\n* the aforementioned accumulator `res`;\\n* `pos`, initialised to `0`\\n\\nWhen I reach the point in which `pos == s.size()`, it means I am done parsing the string, so I returrn `res` :)\\n\\nNote that you might as well start from the leftmost \"digit\", but in that case you would have to proceed right multiplying by the matching power of `26`: a needless annoyance, if you ask me.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int titleToNumber(string &s, long res = 0, int pos = -1) {\\n        return (pos = pos == -1 ? 0 : pos, pos) == s.size() ? res : titleToNumber(s, res * 26 + s[pos] - \\'@\\', pos + 1);\\n    }\\n};\\n```\\n\\nThe iterative approach, with exactly the same logic, might be easier to grasp (and less elegant, at least to my eyes, but I concede that is subjective):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        long res = 0;\\n        int pos = 0;\\n        while (pos < s.size()) {\\n            res = res * 26 + s[pos] - \\'@\\';\\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int titleToNumber(string &s, long res = 0, int pos = -1) {\\n        return (pos = pos == -1 ? 0 : pos, pos) == s.size() ? res : titleToNumber(s, res * 26 + s[pos] - \\'@\\', pos + 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        long res = 0;\\n        int pos = 0;\\n        while (pos < s.size()) {\\n            res = res * 26 + s[pos] - \\'@\\';\\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52325,
                "title": "a-4ms-c-solution",
                "content": "    int titleToNumber(char* s) {\\n        int number = 0;\\n        for (int i = 0; s[i] != 0; i++) {\\n            number = number*26 + s[i] - 'A' + 1;\\n        }\\n        return number;\\n    }\\n\\nThe question can be rephrased as \"Convert base 26 to base 10\".",
                "solutionTags": [],
                "code": "    int titleToNumber(char* s) {\\n        int number = 0;\\n        for (int i = 0; s[i] != 0; i++) {\\n            number = number*26 + s[i] - 'A' + 1;\\n        }\\n        return number;\\n    }\\n\\nThe question can be rephrased as \"Convert base 26 to base 10\".",
                "codeTag": "Unknown"
            },
            {
                "id": 52253,
                "title": "2ms-java-solution",
                "content": "    public class Solution {\\n        public int titleToNumber(String s) {\\n            char[] title = s.toCharArray();\\n            int number = 0;\\n            for(char c: title) {\\n                number = number * 26 + (c - 'A' + 1);\\n            }\\n            return number;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int titleToNumber(String s) {\\n            char[] title = s.toCharArray();\\n            int number = 0;\\n            for(char c: title) {\\n                number = number * 26 + (c - 'A' + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1790093,
                "title": "java-3-liner-explained",
                "content": "**Idea:** \\n* The solution is similar to converting a number from base 26 to base 10, except instead of digits we have letters.\\n* Multiply the current index value with 26 (base) and add the char value with A being at 1 (so adjust by adding 1)\\n```\\nExample: columnTitle = AB\\n\\nAB\\n^\\ncolumnNumber = 0, current-char = A\\n\\u21D2 columnNumber = (0 x 26) + A - A + 1 = 1\\n\\nAB\\n ^\\ncolumnNumber = 1, current-char = B\\n\\u21D2 columnNumber = (1 x 26) + B - A + 1 = 26 + 1 + 1 = 28 [Ans]\\n```\\n>**T/S:** O(n)/O(1), where n = size(columnTitle)\\n```\\npublic int titleToNumber(String columnTitle) {\\n\\tvar columnNumber = 0;\\n\\tfor (var i = 0; i < columnTitle.length(); i++)\\n\\t\\tcolumnNumber = columnNumber * 26 + columnTitle.charAt(i) - \\'A\\' + 1;\\n\\treturn columnNumber;\\n}\\n```\\n**A micro-optimized variation**: Using unicode value of A = 65\\n```\\npublic int titleToNumber(String columnTitle) {\\n\\tvar columnNumber = 0;\\n\\tfor (var i = 0; i < columnTitle.length(); i++)\\n\\t\\tcolumnNumber = columnNumber * 26 + columnTitle.charAt(i) - 64;\\n\\treturn columnNumber;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nExample: columnTitle = AB\\n\\nAB\\n^\\ncolumnNumber = 0, current-char = A\\n\\u21D2 columnNumber = (0 x 26) + A - A + 1 = 1\\n\\nAB\\n ^\\ncolumnNumber = 1, current-char = B\\n\\u21D2 columnNumber = (1 x 26) + B - A + 1 = 26 + 1 + 1 = 28 [Ans]\\n```\n```\\npublic int titleToNumber(String columnTitle) {\\n\\tvar columnNumber = 0;\\n\\tfor (var i = 0; i < columnTitle.length(); i++)\\n\\t\\tcolumnNumber = columnNumber * 26 + columnTitle.charAt(i) - \\'A\\' + 1;\\n\\treturn columnNumber;\\n}\\n```\n```\\npublic int titleToNumber(String columnTitle) {\\n\\tvar columnNumber = 0;\\n\\tfor (var i = 0; i < columnTitle.length(); i++)\\n\\t\\tcolumnNumber = columnNumber * 26 + columnTitle.charAt(i) - 64;\\n\\treturn columnNumber;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708797,
                "title": "c-0-ms-solution",
                "content": "***Runtime: 0 ms, faster than 100.00% of C++ online submissions for Excel Sheet Column Number.\\nMemory Usage: 5.9 MB, less than 87.22% of C++ online submissions for Excel Sheet Column Number.***\\n\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int result = 0;\\n        for(int i=0;i<s.size();i++){\\n            result = result*26 + (s[i] - \\'A\\' + 1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int result = 0;\\n        for(int i=0;i<s.size();i++){\\n            result = result*26 + (s[i] - \\'A\\' + 1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52274,
                "title": "easy-java-solution-3ms",
                "content": "\\n    public static int titleToNumber(String s) {\\n\\t     int number=0;\\n\\t     for(int i=0;i<s.length();i++)\\n\\t     {\\n\\t    \\tnumber=26*number+(s.charAt(i)-'A')+1; \\n\\t     }\\n\\t     return number;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public static int titleToNumber(String s) {\\n\\t     int number=0;\\n\\t     for(int i=0;i<s.length();i++)\\n\\t     {\\n\\t    \\tnumber=26*number+(s.charAt(i)-'A')+1; \\n\\t     }\\n\\t     return number;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2548566,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum = 0;\\n        for(char ch : columnTitle.toCharArray()) {\\n          \\n            int diff = ch - (\\'A\\' - 1);\\n            sum = sum * 26 + diff;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**Please upvoted me if you like the solution.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum = 0;\\n        for(char ch : columnTitle.toCharArray()) {\\n          \\n            int diff = ch - (\\'A\\' - 1);\\n            sum = sum * 26 + diff;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790347,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\nGiven a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.\\n\\nQuestion Explanation:\\nWhat we have to do here \\uD83E\\uDD14 ? don\\'t worry, i will explain you guys \\uD83D\\uDE04 !!\\nwe have return the corresponding column number for given column title.\\n\\n    For example:\\n        columnTitle = \"A\"\\n        A -> 1\\n        \\uD83D\\uDC49 here our corresponding column number for given column title is 1.\\n\\n        columnTitle = \"AB\"\\n           \\uD83D\\uDC49 here we have AB so we have to do means:\\n                A --> 1\\n                B --> 2\\n                .\\n                .\\n                Z --> 26\\n                After this what will come means :\\n                AB --> 1*26 + 2 = 28\\n                AA --> 27\\n\\n                 how it came \\uD83E\\uDD14:\\n                 AA --> 1 * 26 + 1 = 27\\n            same as above:\\n                AB --> 1 * 26 + 2 = 28\\n\\n            Let me give another Example:\\n                columnTitle = \"CD\"\\n                CD-> 3*26 + 4 = 82\\n\\nCode Explanation:\\n1.we have initialized a variable called corresponding_number .\\n2.then we have start looping and get current letter to find corresponding letter value.\\n3.we are going to use one formula.\\ncorresponding_number += current_Letter_value * pow(26, length_of_string - i- 1)\\n    Example: \\n        current_letter = \"DA\"\\n        corresponding_number = 0\\n        \\u2B50 now we going to start looping:\\n                \\u2B50 i=0\\n                \\u2B50 current_letter = \"D\"\\n                \\u2B50 corresponding_letter_value = 4\\n                \\u2B50 length_of_string = 2\\n                corresponding_number += 4 * pow(26, 2 - 0 - 1) ==> 4 * 26^1 =104\\n                \\u2B50 i=1\\n                \\u2B50 current_letter = \"A\"\\n                \\u2B50 corresponding_letter_value = 1\\n                \\u2B50 length_of_string = 2\\n                corresponding_number += 1 * pow(26, 2 - 1 - 1) ==> 1 * 26^0 = 1\\n        now we will return corresponding_number = 104 + 1 = 105\\n\\n    Big O:\\n        Time Complexity:O(n) where n is the length of string\\n        Space Complexity:O(1) constant space\\n```\\n\\n`    I hope you guys understand now lets code it up \\uD83D\\uDE00.\\n`\\n\\n`javascript`\\n\\n```\\nconst titleToNumber = (columnTitle) => {\\n  let corresponding_number = 0;\\n  for (let i = 0; i < columnTitle.length; i++) {\\n    const current_letter = columnTitle[i]; // current Letter\\n    const current_number = current_letter.charCodeAt(0) - 64; // corresponding number \\n    // here we are subtracting 64 because we aer going to get only Capital letter so the charCodeAt() returns the ASCII value of the character.\\n    corresponding_number +=\\n      current_number * Math.pow(26, columnTitle.length - i - 1);\\n  }\\n  return corresponding_number;\\n};\\n```\\n\\n`python`\\n\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n            corresponding_number = 0\\n            for i in range(len(columnTitle)):\\n                current_letter=columnTitle[i]\\n                corresponding_letter_value=ord(current_letter) - ord(\\'A\\') + 1\\n                corresponding_number += (corresponding_letter_value *pow(26,len(columnTitle)-i-1))\\n\\n            return corresponding_number\\n\\n```\\n\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\nGiven a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.\\n\\nQuestion Explanation:\\nWhat we have to do here \\uD83E\\uDD14 ? don\\'t worry, i will explain you guys \\uD83D\\uDE04 !!\\nwe have return the corresponding column number for given column title.\\n\\n    For example:\\n        columnTitle = \"A\"\\n        A -> 1\\n        \\uD83D\\uDC49 here our corresponding column number for given column title is 1.\\n\\n        columnTitle = \"AB\"\\n           \\uD83D\\uDC49 here we have AB so we have to do means:\\n                A --> 1\\n                B --> 2\\n                .\\n                .\\n                Z --> 26\\n                After this what will come means :\\n                AB --> 1*26 + 2 = 28\\n                AA --> 27\\n\\n                 how it came \\uD83E\\uDD14:\\n                 AA --> 1 * 26 + 1 = 27\\n            same as above:\\n                AB --> 1 * 26 + 2 = 28\\n\\n            Let me give another Example:\\n                columnTitle = \"CD\"\\n                CD-> 3*26 + 4 = 82\\n\\nCode Explanation:\\n1.we have initialized a variable called corresponding_number .\\n2.then we have start looping and get current letter to find corresponding letter value.\\n3.we are going to use one formula.\\ncorresponding_number += current_Letter_value * pow(26, length_of_string - i- 1)\\n    Example: \\n        current_letter = \"DA\"\\n        corresponding_number = 0\\n        \\u2B50 now we going to start looping:\\n                \\u2B50 i=0\\n                \\u2B50 current_letter = \"D\"\\n                \\u2B50 corresponding_letter_value = 4\\n                \\u2B50 length_of_string = 2\\n                corresponding_number += 4 * pow(26, 2 - 0 - 1) ==> 4 * 26^1 =104\\n                \\u2B50 i=1\\n                \\u2B50 current_letter = \"A\"\\n                \\u2B50 corresponding_letter_value = 1\\n                \\u2B50 length_of_string = 2\\n                corresponding_number += 1 * pow(26, 2 - 1 - 1) ==> 1 * 26^0 = 1\\n        now we will return corresponding_number = 104 + 1 = 105\\n\\n    Big O:\\n        Time Complexity:O(n) where n is the length of string\\n        Space Complexity:O(1) constant space\\n```\n```\\nconst titleToNumber = (columnTitle) => {\\n  let corresponding_number = 0;\\n  for (let i = 0; i < columnTitle.length; i++) {\\n    const current_letter = columnTitle[i]; // current Letter\\n    const current_number = current_letter.charCodeAt(0) - 64; // corresponding number \\n    // here we are subtracting 64 because we aer going to get only Capital letter so the charCodeAt() returns the ASCII value of the character.\\n    corresponding_number +=\\n      current_number * Math.pow(26, columnTitle.length - i - 1);\\n  }\\n  return corresponding_number;\\n};\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n            corresponding_number = 0\\n            for i in range(len(columnTitle)):\\n                current_letter=columnTitle[i]\\n                corresponding_letter_value=ord(current_letter) - ord(\\'A\\') + 1\\n                corresponding_number += (corresponding_letter_value *pow(26,len(columnTitle)-i-1))\\n\\n            return corresponding_number\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783875,
                "title": "c-one-liner",
                "content": "```\\n    public int TitleToNumber(string s) =>\\n        s.Aggregate(0, (seed, c) => seed*26 + (c - \\'A\\' + 1));\\n```",
                "solutionTags": [],
                "code": "```\\n    public int TitleToNumber(string s) =>\\n        s.Aggregate(0, (seed, c) => seed*26 + (c - \\'A\\' + 1));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537403,
                "title": "javascript-o-n",
                "content": "```\\nvar titleToNumber = function(s) {\\n    let columnNumber = 0;\\n    for(let i = 0; i < s.length; i++){\\n        // get the last ith character\\n        let char = s[(s.length - 1) - i];\\n        \\n        // subtracting from 64 (not 65, ascii of A) to get the value directly \\n        // instead of ascii index\\n        // ex: A = 1 (65 - 64 = 1)\\n        columnNumber += Math.pow(26, i) * (char.charCodeAt(0) - 64);\\n        \\n    } \\n    return columnNumber;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar titleToNumber = function(s) {\\n    let columnNumber = 0;\\n    for(let i = 0; i < s.length; i++){\\n        // get the last ith character\\n        let char = s[(s.length - 1) - i];\\n        \\n        // subtracting from 64 (not 65, ascii of A) to get the value directly \\n        // instead of ascii index\\n        // ex: A = 1 (65 - 64 = 1)\\n        columnNumber += Math.pow(26, i) * (char.charCodeAt(0) - 64);\\n        \\n    } \\n    return columnNumber;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52284,
                "title": "my-cpp-solution",
                "content": "    class Solution \\n    {\\n    public:\\n        int titleToNumber(string s) \\n        {\\n            int ret=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                ret*=26;\\n                ret+=s[i]-'A'+1;\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n    {\\n    public:\\n        int titleToNumber(string s) \\n        {\\n            int ret=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                ret*=26;\\n                ret+=s[i]-'A'+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3946743,
                "title": "2-line-code-well-explained-and-commented-jai-shree-ram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# **Here\\'s a step-by-step breakdown:**\\n\\n1)Initialize a result variable to 0.\\n2)Iterate through the characters in the column Title from right to left.\\n3)For each character: Convert the character to its corresponding numeric value by subtracting the ASCII value of \\'A\\' and adding 1.\\n4)Multiply the numeric value by the appropriate power of 26 based on its position from the right (similar to how decimal places work: 10^0, 10^1, 10^2, ...).\\n5)Add this product to the result variable.\\n6)Once you\\'ve processed all characters, the result variable will hold the column number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Initialize Result: Start with initializing a variable result to store the final column number. Initialize it to 0.\\n2)Iterate Through Characters: Iterate through the characters of the column Title from right to left. This means you start with the least significant digit and move towards the most significant digit.\\n3)Character to Value Conversion: For each character encountered:\\n\\n4)Convert the character to its corresponding numeric value in the range 1 to 26. You can do this by subtracting the ASCII value of \\'A\\' and adding 1. This means \\'A\\' becomes 1, \\'B\\' becomes 2, and so on.\\n5)Update Result: Multiply the numeric value obtained in step 3 by the appropriate power of 26 based on the position of the character from the right. The rightmost character corresponds to 26^0, the next character to the left corresponds to 26^1, and so on.\\n\\nFor example, the rightmost character contributes its value as is (26^0 = 1), the next character contributes its value multiplied by 26 (26^1), the character after that contributes its value multiplied by 26^2, and so on.\\n6)Accumulate Result: Add the product obtained in step 4 to the result variable.\\n7)Repeat: Repeat steps 3-5 for all characters in the column Title.\\n8)Return Result: Once you\\'ve processed all characters, the result variable will hold the final column number. Return this value as the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int result=0;\\n\\n        for(int i=0;i<columnTitle.size();i++)\\n        {\\n            result*=26;\\n            // columnTitle[i] --> YE CURRENT ELEMENT KA ASCII CODE DEGA\\n            result+=columnTitle[i]-\\'A\\'+1;\\n        }\\n        return result;\\n        \\n    }\\n\\n    // EX--> AB\\n    // RES=26*0,   RES=0\\n    // RES= 0 + (65-65)+1\\n    //   65 IS ASCII CODE OF A \\n    /// SO FINALLY 1 IS STORED IN RESULT\\n\\n    /// NOW INCREMENT I==B \\n\\n    //RES=1*26 RES=52\\n    // RES=26+(66-65)+1\\n    // RES=28   AND THAT IS THE REQUIRED ANSWER\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int result=0;\\n\\n        for(int i=0;i<columnTitle.size();i++)\\n        {\\n            result*=26;\\n            // columnTitle[i] --> YE CURRENT ELEMENT KA ASCII CODE DEGA\\n            result+=columnTitle[i]-\\'A\\'+1;\\n        }\\n        return result;\\n        \\n    }\\n\\n    // EX--> AB\\n    // RES=26*0,   RES=0\\n    // RES= 0 + (65-65)+1\\n    //   65 IS ASCII CODE OF A \\n    /// SO FINALLY 1 IS STORED IN RESULT\\n\\n    /// NOW INCREMENT I==B \\n\\n    //RES=1*26 RES=52\\n    // RES=26+(66-65)+1\\n    // RES=28   AND THAT IS THE REQUIRED ANSWER\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042234,
                "title": "very-simple-but-smart-javascript-solution",
                "content": "# Intuition\\nWell I quickly realised, that this is a math problem and a simple one. I just took a look at different values and understood how they work and saw the solution right away\\n# Approach\\nVery simple charCode of a upper case character - 64 = their alphabet position and 26 pow position of the character (starting from right) - so length - (i+1) means that the last character will end up being just it\\'s alphabet position (character * 1), the one before is going to be * 26, the one before * 26 * 26 and so on.\\nSimple math solution that works just fine.\\n# Complexity\\n- Time complexity:\\nBeats 97.51%\\n\\n- Space complexity:\\nBeats 72.98%\\n# Code\\n```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    let result = 0;\\n    let length = columnTitle.length;\\n    for(let i = 0; i < length; i++){\\n        result += (columnTitle.charCodeAt(i) - 64) * Math.pow(26, length - (i + 1));\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    let result = 0;\\n    let length = columnTitle.length;\\n    for(let i = 0; i < length; i++){\\n        result += (columnTitle.charCodeAt(i) - 64) * Math.pow(26, length - (i + 1));\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790374,
                "title": "c-solution-with-explanation",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- While iterating over the string we\\u2019ll store the present character value in a.\\n- Here ***A to Z*** represents by ***1 to 26.*** No value starts with 0, that\\'s why we\\u2019re adding 1.\\n- Now in ans multiply it with 26 & add a with it.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        \\n        for(auto x:columnTitle){\\n            int a = x-\\'A\\'+1;\\n            ans = ans*26 + a;\\n        }\\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        \\n        for(auto x:columnTitle){\\n            int a = x-\\'A\\'+1;\\n            ans = ans*26 + a;\\n        }\\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616047,
                "title": "python-intuitive-straightforward-beginner-friendly-mathematical-solution-using-dictionary",
                "content": "## Step 1:\\nTo start, when seeing the 26 English alphabets are used to represent numbers, the first intuition is to use a dictionary to pair 1-26 and A-Z, before considering the calculation in detials.\\n* Method 1: \\nUsing zip()\\n```\\nalphabet = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\nnums = range(1,27)\\nalpha_dict = dict(zip(alphabet, nums))\\nprint(alpha_dict)\\n```\\n\\n* Method 2:\\nComprehension\\n```\\nalpha_dict = {alphabet[i]: nums[i] for i in range(len(alphabet))}\\nprint(alpha_dict)\\n```\\n\\n## Step 2:\\nWith this dictionary in mind, write down a few examples, a formula will soon pop up clearly:\\n* AA  ->  26 * 1 + 1  \\n* AB  ->  26 * 1 + 2\\n* ZZ  ->  26 * 26 + 26\\n* ABC  ->  26^2 * 1 + 26 * 2 + 3\\nThat is:\\n* AA  ->  26^1 * A + 26^0 * A  \\n* AB  ->  26^1 * A + 26^0 * B\\n* ZZ  ->  26^1 * Z + 26^0 * Z\\n* ABC  ->  26^2 * A + 26^1 * B + 26^0 * C\\n\\n\\nSo the formula is:\\n\\n26^largest_digit_value * Letter_on_digit  + ... +  26^0 * Letter_on_digit\\n\\n\\n## Translate above intuition into code:\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n\\t\\n\\t\\t# Use dictionary to map alphabets A to Z one-on-one to integer 1 to 26:\\n        alphabet = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        nums = range(1,27)\\n        alpha_to_nums = {alphabet[i]: nums[i] for i in range(len(alphabet))}\\n\\t\\t\\n\\t\\t# Express the formula above in a simple for loop, iterating from the last digit:\\n        column_number = 0\\n        for pos, letter in enumerate (reversed(columnTitle)):\\n            column_number +=  26**(pos) * alpha_to_nums[letter] \\n\\t\\t\\t\\n        return column_number\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nalphabet = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\nnums = range(1,27)\\nalpha_dict = dict(zip(alphabet, nums))\\nprint(alpha_dict)\\n```\n```\\nalpha_dict = {alphabet[i]: nums[i] for i in range(len(alphabet))}\\nprint(alpha_dict)\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n\\t\\n\\t\\t# Use dictionary to map alphabets A to Z one-on-one to integer 1 to 26:\\n        alphabet = \\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\\'\\n        nums = range(1,27)\\n        alpha_to_nums = {alphabet[i]: nums[i] for i in range(len(alphabet))}\\n\\t\\t\\n\\t\\t# Express the formula above in a simple for loop, iterating from the last digit:\\n        column_number = 0\\n        for pos, letter in enumerate (reversed(columnTitle)):\\n            column_number +=  26**(pos) * alpha_to_nums[letter] \\n\\t\\t\\t\\n        return column_number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191434,
                "title": "c-100-faster-0ms",
                "content": "\\n    int titleToNumber(string columnTitle) \\n    {\\n        int res = 0;\\n        int n = columnTitle.size();\\n        for(int i = 0; i < n; i++)\\n            res = res * 26 + (columnTitle[i] - \\'A\\' + 1);\\n        \\n        return res;\\n            \\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    int titleToNumber(string columnTitle) \\n    {\\n        int res = 0;\\n        int n = columnTitle.size();\\n        for(int i = 0; i < n; i++)\\n            res = res * 26 + (columnTitle[i] - \\'A\\' + 1);\\n        \\n        return res;\\n            \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 281073,
                "title": "simple-readable-python-code-with-explanations",
                "content": "Here is a simple readable Python code that is faster than 99.6% of submissions.:\\n```\\n        uc = string.ascii_letters[26:]    #upper capital alphabetical letters   \\n        ans = 0\\n        s = s[::-1]     #reverse the input\\n        for i in xrange(len(s)):\\n            index = uc.find(s[i]) + 1      #find the order of each letter.\\n            ans = ans + index * 26 ** i    # calculate the number for each letter, then make the summation.\\n        return ans\\n```\\n\\n**Explanations**\\nThis problem is similar to converting a number string (e.g. \"25\") to integer (e.g. 25), but instead of using 10 as the base, we need to use 26 as the base.\\n\\n**A simple example**\\nConsider AB.\\nWe know that the column number is equal to 28, because the column numbers from A to Z are equal to 1 to 26, respectively. AA column number is 27 and AB column number is 28. \\n- Lets reverse the input: BA, and seperate the characters: B, A.\\n- B is the second character in the alphabet, so the order of B is equal to 2\\n- A is the first character in the alphabet, so the order of A is equal to 1. However, there are 26 columns before that, so the number for this character is: 1 * 26.\\n- Therefore, the column number is equal to 2 + 26 = 28.\\n\\n**Generalization**\\nAssume the input is ACZ. The code reverses the input (ZCA), find the alphabetical order of each character  and find the number for each character by this calculation:\\norder of Z: 26, so: 26 * (26 ** 0) = 26\\norder of C: 3,   so:  3 * (26 ** 1) = 78\\norder of A: 1,   so: 1 * (26 ** 2) = 676\\nThe column number is equal to: 26 + 78 + 676 = 780\\n\\nFinally, the one-line code, though I am not a fan of one-line codes. There is no point in writing a code when it is not readable.\\n```\\n        return sum((string.ascii_letters[26:].find(s[::-1][i]) + 1) * 26 ** i for i in xrange(len(s)))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n        uc = string.ascii_letters[26:]    #upper capital alphabetical letters   \\n        ans = 0\\n        s = s[::-1]     #reverse the input\\n        for i in xrange(len(s)):\\n            index = uc.find(s[i]) + 1      #find the order of each letter.\\n            ans = ans + index * 26 ** i    # calculate the number for each letter, then make the summation.\\n        return ans\\n```\n```\\n        return sum((string.ascii_letters[26:].find(s[::-1][i]) + 1) * 26 ** i for i in xrange(len(s)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267019,
                "title": "handling-overflow-in-c-and-c",
                "content": "**Handling overflow in c/cpp**\\nThe question does not speak about overflow or the size of the string input. So it is clear that the answer can fit in int.\\n\\nBut it is possible that overflow could occur in one of the intermediate steps, if you are not careful.\\n\\nThe below code is an example:\\n\\n\\n\\tint toNum(char a) {\\n        return a - \\'A\\' + 1;\\n    }\\n    \\n    int titleToNumber(string s) {\\n        int n = s.size();\\n        int factor = 1, ans = 0;\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            int num = toNum(s[i]);\\n            ans += num * factor;\\n            factor *= 26; // ----- overflow can occur here\\n        }\\n        \\n        return ans;\\n    }\\nYou can observe that factor is multiplied by 26 at the end of the loop, hence it is ahead of the current iteration. The new value of factor that is calculated at an iteration is used only in the next iteration. Which will lead to an unnecessary calculation of factor at the last iteration of the loop. \\n\\nLet us try debugging:\\n\\n\\tfor(int i=n-1;i>=0;i--) {\\n\\t\\tcout<<\"loop begin : i=\"<<i<<\" char:\"<<s[i]<<\" factor:\"<<factor<<\" ans:\"<<ans<<endl;\\n\\t\\tint num = toNum(s[i]);\\n\\t\\tans += num * factor;\\n\\t\\tfactor *= 26;\\n\\t\\tcout<<\"loop end    : i=\"<<i<<\" char:\"<<s[i]<<\" factor:\"<<factor<<\" ans:\"<<ans<<endl;\\n\\t\\tcout<<endl;\\n\\t}\\n\\t\\t\\n\\tOutput:\\n\\t\\n\\tloop begin : i=6 char:M factor:1 ans:0\\n\\tloop end   : i=6 char:M factor:26 ans:13\\n\\n\\tloop begin : i=5 char:X factor:26 ans:13\\n\\tloop end   : i=5 char:X factor:676 ans:637\\n\\n\\tloop begin : i=4 char:S factor:676 ans:637\\n\\tloop end   : i=4 char:S factor:17576 ans:13481\\n\\n\\tloop begin : i=3 char:G factor:17576 ans:13481\\n\\tloop end   : i=3 char:G factor:456976 ans:136513\\n\\n\\tloop begin : i=2 char:D factor:456976 ans:136513\\n\\tloop end   : i=2 char:D factor:11881376 ans:1964417\\n\\n\\tloop begin : i=1 char:F factor:11881376 ans:1964417\\n\\tloop end   : i=1 char:F factor:308915776 ans:73252673\\n\\n\\tloop begin : i=0 char:C factor:308915776 ans:73252673\\n\\t\\n\\truntime error: signed integer overflow: 308915776 * 26 cannot be represented in type \\'int\\' (solution.cpp)\\n\\t\\n\\t\\nThis can be solved by avoiding the factor calculation at the last iteration.\\n\\n```\\nfor(int i=n-1;i>=0;i--) {\\n\\tint num = toNum(s[i]);\\n\\tans += num * factor;\\n\\tif(i!=0)\\n\\tfactor *= 26;\\n}\\n```\\nBut the fix looks hacky.\\nIt is always good to learn and write cleaner code like this:\\n\\n```\\nint toNum(char a) {\\n\\treturn a - \\'A\\' + 1;\\n}\\n\\nint titleToNumber(string s) {\\n\\tint n = s.size();\\n\\tint ans = 0;\\n\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tans = ans*26 + toNum(s[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\nWe do not do any unnecessary calculations in the above solution.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nfor(int i=n-1;i>=0;i--) {\\n\\tint num = toNum(s[i]);\\n\\tans += num * factor;\\n\\tif(i!=0)\\n\\tfactor *= 26;\\n}\\n```\n```\\nint toNum(char a) {\\n\\treturn a - \\'A\\' + 1;\\n}\\n\\nint titleToNumber(string s) {\\n\\tint n = s.size();\\n\\tint ans = 0;\\n\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tans = ans*26 + toNum(s[i]);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52243,
                "title": "1-line-c-solution-8ms",
                "content": "    int titleToNumber(string s) {\\n        return accumulate(s.begin(), s.end(), 0, [](int num, char ch) { return num * 26 + ch - 'A' + 1; });\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int titleToNumber(string s) {\\n        return accumulate(s.begin(), s.end(), 0, [](int num, char ch) { return num * 26 + ch - 'A' + 1; });\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52244,
                "title": "3-lines-2ms-java-solution",
                "content": "    public class Solution {\\n        public int titleToNumber(String s) {\\n            int answer = 0;\\n            for(char c: s.toCharArray()) answer = answer * 26 + (c - 'A' + 1);\\n            return answer;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int titleToNumber(String s) {\\n            int answer = 0;\\n            for(char c: s.toCharArray()) answer = answer * 26 + (c - 'A' + 1);\\n            return answer;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52311,
                "title": "one-line-in-java",
                "content": "    return s.length()==0?0:(s.charAt(s.length()-1)-'A'+1)+26*titleToNumber(s.substring(0, s.length()-1));",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    return s.length()==0?0:(s.charAt(s.length()-1)-'A'+1)+26*titleToNumber(s.substring(0, s.length()-1));",
                "codeTag": "Unknown"
            },
            {
                "id": 3212781,
                "title": "171-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe are given a string columnTitle representing the column title as appears in an Excel sheet. We are supposed to return its corresponding column number.\\n\\nOne way to solve the problem is by traversing the string columnTitle and for each character, we multiply the result so far by 26 and add the value corresponding to the current character.\\n\\nFor example, if columnTitle is \"AB\", then the corresponding column number is 1*26 + 2 = 28. Here, we start with 0, and multiply the result by 26 (which is the number of alphabets), and then add the value of the first character which is 1, which corresponds to the letter \\'A\\'. Then we multiply the result by 26 again, and add the value of the second character which is 2, corresponding to the letter \\'B\\'. This gives us the final result of 28.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        result = 0\\n        for ch in columnTitle:\\n            result = result*26 + ord(ch)-ord(\\'A\\')+1\\n        return result\\n\\n```\\nIn the above code, we first initialize the result variable to 0. We then traverse the string columnTitle character by character. For each character, we multiply the result by 26 and add the value of the current character (after converting it to its corresponding integer value). Finally, we return the result.\\n\\nNote that we subtract ord(\\'A\\')-1 from the integer value of the character ch to get its corresponding value. We add 1 to it to get the actual value of the character (since \\'A\\' corresponds to 1 and not 0).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        result = 0\\n        for ch in columnTitle:\\n            result = result*26 + ord(ch)-ord(\\'A\\')+1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783605,
                "title": "java-4-lines-code",
                "content": "\\t\\tint sum =0;\\n        for(char c: s.toCharArray()){\\n            sum = sum *26 + (c - \\'A\\') +1;\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "\\t\\tint sum =0;\\n        for(char c: s.toCharArray()){\\n            sum = sum *26 + (c - \\'A\\') +1;\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 654014,
                "title": "very-simple-5-line-solution",
                "content": "```\\nfunc titleToNumber(s string) int {\\n    col := 0\\n    \\n    for _, char := range s {\\n        col *= 26\\n        col += int(char - \\'A\\') + 1\\n    }\\n    \\n    return col\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc titleToNumber(s string) int {\\n    col := 0\\n    \\n    for _, char := range s {\\n        col *= 26\\n        col += int(char - \\'A\\') + 1\\n    }\\n    \\n    return col\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52340,
                "title": "share-my-python-solution-use-int-i-base-36-and-simple-java-solution",
                "content": "    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        res = 0\\n        for i in s:\\n            res = 26*res + int(i, 36) - 9\\n        return res\\n\\nOne line\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        return sum(26**n*(int(i, 36)-9) for n, i in enumerate(s[::-1]))\\n\\nJAVA\\n\\n        public int titleToNumber(String s) {\\n        int res = 0;\\n        for (char c: s.toCharArray())\\n            res = 26*res + c-'A'+1;\\n\\n        return res;\\n        }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        res = 0\\n        for i in s:\\n            res = 26*res + int(i, 36) - 9\\n        return res\\n\\nOne line\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        return sum(26**n*(int(i, 36)-9) for n, i in enumerate(s[::-1]))\\n\\nJAVA\\n\\n        public int titleToNumber(String s) {\\n        int res = 0;\\n        for (char c: s.toCharArray())\\n            res = 26*res + c-'A'+1;\\n\\n        return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52349,
                "title": "share-my-java-solution",
                "content": "here is my Java solution\\n    \\n     public class Solution {\\n        public int titleToNumber(String s) {\\n            int colNumber = 0;\\n            \\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tcolNumber = colNumber*26 + ((int)s.charAt(i)-64);\\n    \\t    }\\n            \\n            return colNumber;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int titleToNumber(String s) {\\n            int colNumber = 0;\\n            \\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tcolNumber = colNumber*26 + ((int)s.charAt(i)-64);\\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 3412943,
                "title": "easiest-codewalk",
                "content": "EASIEST CODEWALK\\nJUST NEED TO UNDERSTAND THE BASE-GO THROUGH THE DIAGRAM\\n![photo_2023-04-13_19-02-26.jpg](https://assets.leetcode.com/users/images/0e4dde6c-3f20-46da-86bd-6530edf9f047_1681392768.0137668.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int counter=-1, res=0;\\n    for(int i=columnTitle.length()-1; i>=0; i--){\\n        counter++;\\n        res+= (columnTitle.charAt(i)-\\'A\\'+1)*Math.pow(26,counter);\\n    }    \\n    return res;\\n    }\\n}\\n```![471ac8c9-5c1b-4052-a76c-b8019c47bb11_1679937665.6666765.png](https://assets.leetcode.com/users/images/1216c94a-97c8-4e36-88b7-6ad63018435b_1681392780.8354228.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int counter=-1, res=0;\\n    for(int i=columnTitle.length()-1; i>=0; i--){\\n        counter++;\\n        res+= (columnTitle.charAt(i)-\\'A\\'+1)*Math.pow(26,counter);\\n    }    \\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257405,
                "title": "best-python-solution-beaten-98-codes-in-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have iterated the given input string from the end and multiplied the index of the character with 26 power of k value , which is intialized to zero.\\nk=indicates the length from the end\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        k=0\\n        res=0\\n        for i in range(len(columnTitle)-1,-1,-1):\\n            p=str.index(columnTitle[i])\\n            res+=(p+1)*(26**k)\\n            k+=1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        str=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        k=0\\n        res=0\\n        for i in range(len(columnTitle)-1,-1,-1):\\n            p=str.index(columnTitle[i])\\n            res+=(p+1)*(26**k)\\n            k+=1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791811,
                "title": "c-simple-solution-0ms-runtime-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int answer = 0;\\n\\t    int power = 1;\\n\\t    for (int i = columnTitle.length() - 1; i >= 0; i--)\\n\\t    {\\n\\t\\t    answer += ((columnTitle[i] - \\'A\\' + 1) * (power));\\n            if(i!=0) power = power * 26;\\n\\t    }\\n\\t    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int answer = 0;\\n\\t    int power = 1;\\n\\t    for (int i = columnTitle.length() - 1; i >= 0; i--)\\n\\t    {\\n\\t\\t    answer += ((columnTitle[i] - \\'A\\' + 1) * (power));\\n            if(i!=0) power = power * 26;\\n\\t    }\\n\\t    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790495,
                "title": "python-3-2-different-solutions-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] 2 Different Solutions and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Scan From Right to Left Approach:\\n* By observation we can know that when letter from right to left increase, it immediately increase letter * 26. Just like 26 carry system but only represent by alphabet letter.\\n* So we can scan from right to left and each time increase carry, so we will add **(number * (26  carry))**\\n\\n## Complexity Analysis\\n* Time: O(N) : Let N be length of columnTitle\\n* Space: O(1)\\n\\n## Dry Run\\n\\n```\\ncolumnTitle = \"ABZCD\"\\n# From right to left\\nLetter: D COL Num: 4 Times 1 Res = 4\\nLetter: C COL Num: 3 Times 26 Res = 82\\nLetter: Z COL Num: 26 Times 676 Res = 17658\\nLetter: B COL Num: 2 Times 17576 Res = 52810\\nLetter: A COL Num: 1 Times 456976 Res = 509786\\n\\nreturn 509786\\n```\\n\\n## Code\\n```\\n# From Right to Left O(N) | O(1)\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        res, carry = 0, 0\\n        for s in columnTitle[::-1]:\\n            res += (ord(s) - ord(\\'A\\') + 1) * (26 ** carry)\\n            carry += 1\\n        return res\\n```\\n\\n## 2\\uFE0F\\u20E3 Left to Right Approach:\\n* In this approach, we not scan from right. We directly scan from left, and each time res carry in, the whole res times 26.\\n\\n## Dry Run\\n\\n```\\ncolumnTitle = \"ABZCD\"\\n# From Left to Right\\nLetter: A COL Num: 1 Res = 0 * 26 + 1 = 1\\nLetter: B COL Num: 2 Res = 1 * 26 + 2 = 28\\nLetter: Z COL Num: 26 Res = 28 * 26 + 26 = 754\\nLetter: C COL Num: 3 Res = 754 * 26 + 3 = 19607\\nLetter: D COL Num: 4 Res = 19607 * 26 + 4 = 509786\\n```\\n\\n## Complexity Analysis\\n* Time: O(N) : Let N be length of columnTitle\\n* Space: O(1)\\n\\n\\n\\n## Code\\n```\\n# Left to Righ O(N) | O(1)\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        res = 0\\n        for s in columnTitle:\\n            res *= 26\\n            res += ord(s) - ord(\\'A\\') + 1\\n        return res\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\\ncolumnTitle = \"ABZCD\"\\n# From right to left\\nLetter: D COL Num: 4 Times 1 Res = 4\\nLetter: C COL Num: 3 Times 26 Res = 82\\nLetter: Z COL Num: 26 Times 676 Res = 17658\\nLetter: B COL Num: 2 Times 17576 Res = 52810\\nLetter: A COL Num: 1 Times 456976 Res = 509786\\n\\nreturn 509786\\n```\n```\\n# From Right to Left O(N) | O(1)\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        res, carry = 0, 0\\n        for s in columnTitle[::-1]:\\n            res += (ord(s) - ord(\\'A\\') + 1) * (26 ** carry)\\n            carry += 1\\n        return res\\n```\n```\\ncolumnTitle = \"ABZCD\"\\n# From Left to Right\\nLetter: A COL Num: 1 Res = 0 * 26 + 1 = 1\\nLetter: B COL Num: 2 Res = 1 * 26 + 2 = 28\\nLetter: Z COL Num: 26 Res = 28 * 26 + 26 = 754\\nLetter: C COL Num: 3 Res = 754 * 26 + 3 = 19607\\nLetter: D COL Num: 4 Res = 19607 * 26 + 4 = 509786\\n```\n```\\n# Left to Righ O(N) | O(1)\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        res = 0\\n        for s in columnTitle:\\n            res *= 26\\n            res += ord(s) - ord(\\'A\\') + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477401,
                "title": "1ms-java-solution-faster-than-100-with-explanation",
                "content": "\\nThis problem was solved using a simple math equation, where by analysis I found that any letter can be converted to its corresponding column number using this equation: columnNum = letter * 26^j, where j is its position in the column title starting from the right, zero indexed. By summation of all letters in the columnTitle we will get its corresponding column number.\\nExamples:\\n1- Input: columnTitle = \"A\":\\n   Output: A * 26^0 = 1 * 1 = 1\\n   \\n2- Input: columnTitle = \"AB\":\\n   Output: columnNum = (B * 26^0) + (A * 26^1) = 2 + 26 = 28\\n   \\n3- Input: columnTitle = \"ZY\":\\n   Output: columnNum = (Y * 26^0) + (Z * 26^1) = 25 + (26 * 26) = 25 + 676 = 701\\n\\n4- Input: columnTitle = \"FXSHRXW\":\\n   Output: columnNum = (W * 26^0) + (X * 26^1) + (R * 26^2) + (H * 26^3) +\\n   (S * 26^4) + (X * 26^5) + (F * 26^6) = 2147483647\\n   \\nO(N) Time || O(1) Space\\n\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int columnNum = 0;\\n        for (int i = columnTitle.length() - 1, j = 0; i >= 0; i--, j++) {\\n            // 64 is subtracted from the char val to get its value from 1->26\\n            columnNum += (columnTitle.charAt(i) - 64) * Math.pow(26, j);\\n        }\\n        \\n        return columnNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int columnNum = 0;\\n        for (int i = columnTitle.length() - 1, j = 0; i >= 0; i--, j++) {\\n            // 64 is subtracted from the char val to get its value from 1->26\\n            columnNum += (columnTitle.charAt(i) - 64) * Math.pow(26, j);\\n        }\\n        \\n        return columnNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406828,
                "title": "python-one-liner-comprehension-with-explanation",
                "content": "we know the first element is always 1-26, as follows:\\n```\\nA  = 1\\nZ  = 26\\nAA = 27 26*1 + 1\\nAZ = 52 26*1 + 26\\nBA = 53 26*2 + 1\\nBZ = 78 26*2 + 26\\nAAA  = 26*26*1 + 26*1 + 1\\nZAA  = 26*26*26 + 26*1 + 1\\n```\\nWriting these out helped me to see the pattern - do you see it?\\nEssentially, we can. rewrite them as:\\n```\\nAAA  = 26^2*1 + 26^1*1 + 26^0\\nZAA  = 26^2*26 + 26^1*1 + 26^0\\n```\\nSo we simply have to reverse s, and iterate through it since we want the last character to be raised to the power of i where i is ranged 0 to 25. And we can multiply by the mapping of each character using ord(s[i]) - 64, deriving from ASCII values.\\n```\\ndef titleToNumber(self, s: str) -> int:\\n\\treturn sum([26**i*(ord(c)-64) for i,c in enumerate(s[::-1])])\\n```",
                "solutionTags": [],
                "code": "```\\nA  = 1\\nZ  = 26\\nAA = 27 26*1 + 1\\nAZ = 52 26*1 + 26\\nBA = 53 26*2 + 1\\nBZ = 78 26*2 + 26\\nAAA  = 26*26*1 + 26*1 + 1\\nZAA  = 26*26*26 + 26*1 + 1\\n```\n```\\nAAA  = 26^2*1 + 26^1*1 + 26^0\\nZAA  = 26^2*26 + 26^1*1 + 26^0\\n```\n```\\ndef titleToNumber(self, s: str) -> int:\\n\\treturn sum([26**i*(ord(c)-64) for i,c in enumerate(s[::-1])])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 376680,
                "title": "rust-one-line",
                "content": "```\\nimpl Solution {\\n    pub fn title_to_number(s: String) -> i32 {\\n        s.into_bytes().into_iter().fold(0, |acc, ele| acc*26 + (ele - 65 + 1) as i32)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn title_to_number(s: String) -> i32 {\\n        s.into_bytes().into_iter().fold(0, |acc, ele| acc*26 + (ele - 65 + 1) as i32)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308476,
                "title": "compact-javascript-solution-60-ms-faster-than-99-34",
                "content": "\\n```\\nvar titleToNumber = function(s) {\\n    let colNum = 0;\\n    for (let i = s.length - 1, powerOf26 = 1; i >= 0; i--, powerOf26 *= 26) {\\n        colNum += powerOf26 * (s.charCodeAt(i) - 64);\\n    }    \\n    return colNum;\\n};\\n```\\nRuntime: 60 ms, faster than 99.34% of JavaScript online submissions for Excel Sheet Column Number.\\nMemory Usage: 35 MB, less than 47.01% of JavaScript online submissions for Excel Sheet Column Number.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar titleToNumber = function(s) {\\n    let colNum = 0;\\n    for (let i = s.length - 1, powerOf26 = 1; i >= 0; i--, powerOf26 *= 26) {\\n        colNum += powerOf26 * (s.charCodeAt(i) - 64);\\n    }    \\n    return colNum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52121,
                "title": "my-python-solution",
                "content": "\\n        lenS = len(s)\\n        n2 = 0\\n        for i in range(0,lenS):\\n            n1 = ord(s[i])-64\\n            n2 = 26*n2 +n1\\n        return n2",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        lenS = len(s)\\n        n2 = 0\\n        for i in range(0,lenS):\\n            n1 = ord(s[i])-64\\n            n2 = 26*n2 +n1\\n        return n2",
                "codeTag": "Unknown"
            },
            {
                "id": 52283,
                "title": "4-line-c-solution",
                "content": "\\n    int titleToNumber(string s) {\\n    \\n        int len = s.length(), sum=0;\\n        \\n        for(int i=0;i<len;i++)\\n            sum += (int(s[i]-'A'+1))*pow(26,len-1-i);\\n            \\n        return sum;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    int titleToNumber(string s) {\\n    \\n        int len = s.length(), sum=0;\\n        \\n        for(int i=0;i<len;i++)\\n            sum += (int(s[i]-'A'+1))*pow(26,len-1-i);\\n            \\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52354,
                "title": "sharing-my-simple-java-solution",
                "content": "    public class Solution {\\n        public int titleToNumber(String s) {\\n            int val = 0;\\n            for (int i=0; i<s.length(); i++){\\n                val = val * 26 + 1 + (int) s.charAt(i) - (int) 'A';\\n            }\\n            return val;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int titleToNumber(String s) {\\n            int val = 0;\\n            for (int i=0; i<s.length(); i++){\\n                val = val * 26 + 1 + (int) s.charAt(i) - (int) 'A';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 52090,
                "title": "any-fast-python-code",
                "content": "Hi, I come up with a Python code using reduce.\\nIt costs 75ms, but from the distribution detail, I can see someone get even faster Python code.\\nCan anyone share a faster implementation?\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        l = list(s)\\n        l.insert(0,0)\\n        return reduce(lambda x,y: 26*x+ord(y)-64, l)",
                "solutionTags": [],
                "code": "Hi, I come up with a Python code using reduce.\\nIt costs 75ms, but from the distribution detail, I can see someone get even faster Python code.\\nCan anyone share a faster implementation?\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return an integer\\n    def titleToNumber(self, s):\\n        l = list(s)\\n        l.insert(0,0)\\n        return reduce(lambda x,y: 26*x+ord(y)-64, l)",
                "codeTag": "Java"
            },
            {
                "id": 3810249,
                "title": "explained-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Treat it exactly like converting a string to number, but with base 26.\\n\\n1. There are 26 letters in our alphabet and we start counting from 1, not zero.\\n   So \\'Z\\' is 26.\\n2. The rest of the combinations start from a base 26\\n\\n    AA --> 26*1+ 1 = 27 (A == 1)\\n    AB --> 26*1+ 2 = 28 (B == 2)\\n    AC -->26*1 + 3 = 29 (C == 3)\\n    .....\\n\\n3. So we can write like this:\\n\\n    result = 0\\n    d = s\\\\[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the letter to a number like it\\'s going to be C)\\n    result = result* 26 + d\\n\\n4. If the given input is only one letter, it will automatically take the value s[i] - \\'A\\' + 1 as the first result is 0.\\n# Complexity\\n- Time complexity: O(n) : to parse the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string colTitle) {\\n        // colTitle--;\\n        // // s.charAt(i) - \\'A\\' + 1\\n        // map<char, int> mp;\\n        // for(char ch =\\'A\\';ch <=\\'Z\\'; ch++){\\n        //     mp[ch] = int(ch)+1;\\n        // }\\n        int res=0;\\n        for( char ch: colTitle){\\n            int dig = ch - \\'A\\' + 1;\\n            res = res*26 + dig;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string colTitle) {\\n        // colTitle--;\\n        // // s.charAt(i) - \\'A\\' + 1\\n        // map<char, int> mp;\\n        // for(char ch =\\'A\\';ch <=\\'Z\\'; ch++){\\n        //     mp[ch] = int(ch)+1;\\n        // }\\n        int res=0;\\n        for( char ch: colTitle){\\n            int dig = ch - \\'A\\' + 1;\\n            res = res*26 + dig;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593861,
                "title": "java-efficient-use-of-time-and-space",
                "content": "# Intuition\\nConvert base 26 to base 10.\\n\\n\\n# Approach\\nsubstract the @ symbol because any letter minus @ equals 1-26.\\n\\n# Code\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int column = 0;\\n        for (int i = columnTitle.length() - 1; i >= 0; i-- ){\\n            column += (columnTitle.charAt(i) - \\'@\\') * Math.pow(26,columnTitle.length() - 1 - i);\\n        }\\n        return column;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int column = 0;\\n        for (int i = columnTitle.length() - 1; i >= 0; i-- ){\\n            column += (columnTitle.charAt(i) - \\'@\\') * Math.pow(26,columnTitle.length() - 1 - i);\\n        }\\n        return column;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470734,
                "title": "python-smallest-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        \"\"\"\\n        :type columnTitle: str\\n        :rtype: int\\n        \"\"\"\\n        s = 0\\n        for jj in columnTitle:\\n            s = s * 26 + ord(jj) - ord(\\'A\\') + 1\\n        return s\\n\\'\\'\\'Please Upvote\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        \"\"\"\\n        :type columnTitle: str\\n        :rtype: int\\n        \"\"\"\\n        s = 0\\n        for jj in columnTitle:\\n            s = s * 26 + ord(jj) - ord(\\'A\\') + 1\\n        return s\\n\\'\\'\\'Please Upvote\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270116,
                "title": "easy-to-understand-python-solution-runtime-27ms-faster-than-96-of-other-solution",
                "content": "Please Upvote if you like the solution.\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        a = 0\\n        for i in columnTitle:\\n            a = a * 26 + ord(i) - ord(\\'A\\') + 1\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Please Upvote if you like the solution.\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        a = 0\\n        for i in columnTitle:\\n            a = a * 26 + ord(i) - ord(\\'A\\') + 1\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 1874524,
                "title": "java-simple-approach-with-explaination",
                "content": "# Please Upvote If i was able to help. It gives me confdence to code and post more! :)\\n<hr>\\n\\n## Approach\\nTo find column number for a particular column title we can think of it like converting from one number system to another number system.\\nLike in decimal number we have characters 0 to 9 to represent any number in decimal. Similarly in column title the characters are from A to Z to represent any number. There are total of 26 symbols for each place, therefore we can think of a number in a system whose base is 26.\\n\\nNow question becomes very simple. Like we convert any binary or hexa-decimal number to its decimal form, we have to convert this title string into a decimal number.\\n\\nFor example, if we want to find the decimal value of string \\u201C1337\\u201D, we can iteratively find the number by traversing the string from left to right as follows:\\n```\\n\\u20181\\u2019 = 1\\n\\u201913\\u2019 = (1 x 10) + 3 = 13\\n\\u2018133\\u2019 = (13 x 10) + 3 = 133\\n\\u20181337\\u2019 = (133 x 10) + 7 = 1337\\n```\\n\\n**Now in this problem as we are dealing with base-26 number system. Based on the same idea, we can just replace 10s with 26s and convert alphabets to numbers.**\\n\\n```\\nFor a title \\u201CLEET\\u201D:\\nL = 12\\nE = (12 x 26) + 5 = 317\\nE = (317 x 26) + 5 = 8247\\nT = (8247 x 26) + 20 = 214442\\n```\\n# Code: \\n```\\nclass Solution {\\n    \\n    public final int countOfAlphabet = 26;          // Tried To showoff the Java features\\n    \\n    public int titleToNumber(String columnTitle) {\\n        \\n         int i=0, n = columnTitle.length(), result=0;\\n        \\n        while ( i<n){\\n            \\n            // Main Formula to remenber \\n            //Tried To map out the formula from this example.\\n//             For a title \\u201CLEET\\u201D:\\n\\n//                     L = 12\\n//                     E = (12 x 26) + 5 = 317\\n//                     E = (317 x 26) + 5 = 8247\\n//                     T = (8247 x 26) + 20 = 214442\\n                        \\n            result = (result * countOfAlphabet) + (columnTitle.charAt(i)-\\'A\\'+1);    \\n            // result is initialized as 0 therefore in the first iteration letter value will be added,\\n            //it will not n=be multipled by the countOfAlphabet\\n            i++;\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n*#Article Refered for Formula Understanding: https://www.tutorialcup.com/leetcode-solutions/excel-sheet-column-number-leetcode-solution.htm*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\u20181\\u2019 = 1\\n\\u201913\\u2019 = (1 x 10) + 3 = 13\\n\\u2018133\\u2019 = (13 x 10) + 3 = 133\\n\\u20181337\\u2019 = (133 x 10) + 7 = 1337\\n```\n```\\nFor a title \\u201CLEET\\u201D:\\nL = 12\\nE = (12 x 26) + 5 = 317\\nE = (317 x 26) + 5 = 8247\\nT = (8247 x 26) + 20 = 214442\\n```\n```\\nclass Solution {\\n    \\n    public final int countOfAlphabet = 26;          // Tried To showoff the Java features\\n    \\n    public int titleToNumber(String columnTitle) {\\n        \\n         int i=0, n = columnTitle.length(), result=0;\\n        \\n        while ( i<n){\\n            \\n            // Main Formula to remenber \\n            //Tried To map out the formula from this example.\\n//             For a title \\u201CLEET\\u201D:\\n\\n//                     L = 12\\n//                     E = (12 x 26) + 5 = 317\\n//                     E = (317 x 26) + 5 = 8247\\n//                     T = (8247 x 26) + 20 = 214442\\n                        \\n            result = (result * countOfAlphabet) + (columnTitle.charAt(i)-\\'A\\'+1);    \\n            // result is initialized as 0 therefore in the first iteration letter value will be added,\\n            //it will not n=be multipled by the countOfAlphabet\\n            i++;\\n            \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792228,
                "title": "solution-using-maps-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        map<char,int> satwik;\\n        const int n=columnTitle.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            satwik[65+i]=1+i;\\n        }\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            num=(num*26)+satwik[columnTitle[i]];\\n        }\\n        return num;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        map<char,int> satwik;\\n        const int n=columnTitle.size();\\n        for(int i=0;i<26;i++)\\n        {\\n            satwik[65+i]=1+i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1790606,
                "title": "simple-and-short-code-understanding-bases-of-numbers-0ms",
                "content": "```\\n// 0ms solution is in comments \\n// Upvote if helpful | Someone is intentionally downvoting answers\\n```\\n**Intuition:**\\nSuppose you are given a integer string s =\"248\". How will you convert it to integer?\\n```\\nans=0;\\nfor( int i=0; i<s.size();i++)\\n\\tans=ans*10+s[i];\\n```\\n**Why did we multiply 10 here?**\\nBecause our **base is 10** i.e. total different digits that we have are 10{0-9}. \\n\\nSimilar case will be for converting:\\n1.Binary(base-2 {0,1}), \\n2.Hexadecimal(base-16 {0-9+A-F(10-15)}) and \\n3.Octal strings(base-8 {0-7}),etc. to integers, \\nwe just multiply by their respective base in each iteration.\\nEg: \\n1. s=\"101\" in binary to integer=> **1**x2x2 +**0**x2+**1**= 4+0+1=5\\n2. s=\"101\" in octal to integer=> **1**x8x8 +**0**x8 + **1**= 64+0+ 1=65\\n3. s=\"101\" in decimal to integer=>**1**x10x10+ **0**x10 + **1**= 100+0+1= 101\\n\\n**Now what will be the base for alphabetic numbering?**\\nAs you might have guessed 26 {A-Z}. Where {A-Z}=>{1-26}. Our solution is ready.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) \\n    {\\n        int ans=0;\\n        for(auto&x: columnTitle)\\n            ans=26*ans+(x-\\'A\\'+1);     //base*ans + value of charachter\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// 0ms solution is in comments \\n// Upvote if helpful | Someone is intentionally downvoting answers\\n```\n```\\nans=0;\\nfor( int i=0; i<s.size();i++)\\n\\tans=ans*10+s[i];\\n```\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) \\n    {\\n        int ans=0;\\n        for(auto&x: columnTitle)\\n            ans=26*ans+(x-\\'A\\'+1);     //base*ans + value of charachter\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790122,
                "title": "c-0-ms-easy-explanation-smallest-code",
                "content": "#### Someone is intentionally downvoting answer , if you cannot support please dont spread hate\\n### CODE EXPLANANTION\\n```\\n1. STORE THE LENGTH IN A VARIABLE \\'L\\'.\\n2. RUN A LOOP TO ACCESS EACH CHARACTER.\\n3. DECLARE A VARIABLE TO STORE VALUE AND INITIALIZE TO \\'0\\' (LIKE \\'RES\\')\\n3. CLCULATE THE VALUE OF THE CHARACTER AND STORE IT IN RES.\\n\\t\\t3.1 MULTIPLYING THE RES WITH \\'26\\'.\\n\\t\\t3.2 VALUE = TO GET INT VALUE OF  CAHRACTER VALUE MINUS IT BY \\'A\\' AND THEN ADD 1. \\n\\t\\t3.3 WE ARE ADDING 1 BECAUSE THE COUNT OF ALPHABET IS STARTING FROM \\'1\\' NOT \\'0\\' AND ENDING TO Z i.e \\'26\\'.\\n4. AFTER COMPLETION  RETURN RES\\n```\\n\\n**QUESTION ??**\\n```\\nWHY I AM MULTIPLING \\'26\\' ? ?\\n->BASICALLY IT\\'S EASY TO GET A SINGLE LETTER INTO ITS NUMBER FORM.\\n->BUT WHERE IF IT IS A COMBINATION THEN ITS GET TRICKY.\\n->WE KNOW Z=\\'26\\'.\\n->IF I HAVE \\'AA\\' IT MEANS THAT AFTER COMPLETING ONE CYCLE A TO Z . I AM GOING TO NEXT. SO IT PUT \\'A\\' TO \\'Z\\' ACCORDINGLY TO NUMBER OF CYCLES IT IS DOING.\\n\\tIF I SAY I GO FROM A TO Z THEN I GO A TO Z AGAIN AND NOW AGAIN I GET TO A. SO THIS TIME IT \\'BA\\' AND ITS VALUE IS 53. \\n->IT BASICALLY INCREASING THE COUNT BY \\'26 AFTER EACH CYCLE.\\n\\nEX.\\nA -------> \\'26\\'\\nAA------>\\'26 + 1\\'\\n.\\n.\\n.\\nBA------>\\'2*26+1=53\\'\\n.\\n.\\n.\\n.\\nBAA------>\\'(2*26+1)26+1\\'   (here already 2 cycles are completed and we are on third cycle).\\n\\nSO WE HAVE TO ITERATIVELY MANAGE IT TO GET PROPER NUMBER OF CYCLES FOR MULTIPLING \\'26\\' AND THEN ADD TO ITS SUBSEQUENT ONE.\\nBASICALLY WHENEVER WE ARE ADDING THE DIGITS BEORE THAT WE HAVE TO MULTIPLY IT BY \\'26\\'\\n```\\n\\n```\\n                                                        //UPVOTE THIS IF YOU LIKE IT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n        int ans = 0;\\n        for(int i = 0; i < c.length(); ++i){\\n            ans*=26;\\n            ans += (c[i] - \\'A\\') + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n1. STORE THE LENGTH IN A VARIABLE \\'L\\'.\\n2. RUN A LOOP TO ACCESS EACH CHARACTER.\\n3. DECLARE A VARIABLE TO STORE VALUE AND INITIALIZE TO \\'0\\' (LIKE \\'RES\\')\\n3. CLCULATE THE VALUE OF THE CHARACTER AND STORE IT IN RES.\\n\\t\\t3.1 MULTIPLYING THE RES WITH \\'26\\'.\\n\\t\\t3.2 VALUE = TO GET INT VALUE OF  CAHRACTER VALUE MINUS IT BY \\'A\\' AND THEN ADD 1. \\n\\t\\t3.3 WE ARE ADDING 1 BECAUSE THE COUNT OF ALPHABET IS STARTING FROM \\'1\\' NOT \\'0\\' AND ENDING TO Z i.e \\'26\\'.\\n4. AFTER COMPLETION  RETURN RES\\n```\n```\\nWHY I AM MULTIPLING \\'26\\' ? ?\\n->BASICALLY IT\\'S EASY TO GET A SINGLE LETTER INTO ITS NUMBER FORM.\\n->BUT WHERE IF IT IS A COMBINATION THEN ITS GET TRICKY.\\n->WE KNOW Z=\\'26\\'.\\n->IF I HAVE \\'AA\\' IT MEANS THAT AFTER COMPLETING ONE CYCLE A TO Z . I AM GOING TO NEXT. SO IT PUT \\'A\\' TO \\'Z\\' ACCORDINGLY TO NUMBER OF CYCLES IT IS DOING.\\n\\tIF I SAY I GO FROM A TO Z THEN I GO A TO Z AGAIN AND NOW AGAIN I GET TO A. SO THIS TIME IT \\'BA\\' AND ITS VALUE IS 53. \\n->IT BASICALLY INCREASING THE COUNT BY \\'26 AFTER EACH CYCLE.\\n\\nEX.\\nA -------> \\'26\\'\\nAA------>\\'26 + 1\\'\\n.\\n.\\n.\\nBA------>\\'2*26+1=53\\'\\n.\\n.\\n.\\n.\\nBAA------>\\'(2*26+1)26+1\\'   (here already 2 cycles are completed and we are on third cycle).\\n\\nSO WE HAVE TO ITERATIVELY MANAGE IT TO GET PROPER NUMBER OF CYCLES FOR MULTIPLING \\'26\\' AND THEN ADD TO ITS SUBSEQUENT ONE.\\nBASICALLY WHENEVER WE ARE ADDING THE DIGITS BEORE THAT WE HAVE TO MULTIPLY IT BY \\'26\\'\\n```\n```\\n                                                        //UPVOTE THIS IF YOU LIKE IT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n        int ans = 0;\\n        for(int i = 0; i < c.length(); ++i){\\n            ans*=26;\\n            ans += (c[i] - \\'A\\') + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296706,
                "title": "c-0ms-100-faster",
                "content": "Simple C++ question\\n```\\nint titleToNumber(string columnTitle) {\\n        reverse(columnTitle.begin(),columnTitle.end());\\n        long ans=0,factor=1;\\n        for(int i=0;i<columnTitle.size();i++)\\n        {\\n            ans=ans+factor*(columnTitle[i]-64);\\n            factor*=26;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint titleToNumber(string columnTitle) {\\n        reverse(columnTitle.begin(),columnTitle.end());\\n        long ans=0,factor=1;\\n        for(int i=0;i<columnTitle.size();i++)\\n        {\\n            ans=ans+factor*(columnTitle[i]-64);\\n            factor*=26;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974161,
                "title": "java-faster-than-100-easy-to-understand-just-a-simple-loop",
                "content": "\\tclass Solution {\\n    public int titleToNumber(String s) {\\n        if (s.length() == 0) return 0;\\n        int res = 0;\\n        for (int i = 0; i < s.length(); i++) {           \\n            int n = s.charAt(i)-64;    // ascall table, A-64 = 1       \\n            res+=n*Math.pow(26, s.length()-i-1);\\n        }\\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int titleToNumber(String s) {\\n        if (s.length() == 0) return 0;\\n        int res = 0;\\n        for (int i = 0; i < s.length(); i++) {           \\n            int n = s.charAt(i)-64;    // ascall table, A-64 = 1       \\n            res+=n*Math.pow(26, s.length()-i-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 783687,
                "title": "c-4-line-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int res=0;\\n        int end = s.size()-1;\\n        for (int i=0; i<s.size();i++)\\n            res+=(pow(26, i))*(s[end-i]-\\'A\\'+1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int res=0;\\n        int end = s.size()-1;\\n        for (int i=0; i<s.size();i++)\\n            res+=(pow(26, i))*(s[end-i]-\\'A\\'+1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783650,
                "title": "simple-c-solution-o-n-time-o-1-space",
                "content": "This is a simple problem of converting BASE 26 to Decimal.\\nFor example:-  \"ZZA\" --> (26^2)*26 + (26^1)*26 + (26^0)*1 \\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        \\n        int result = 0;\\n        int n = s.length()-1;\\n        int i = n;\\n        while(i>=0)\\n        {\\n            result = result + (pow(26,(n-i))*(s[i]-\\'A\\'+1));\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\nHope that helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        \\n        int result = 0;\\n        int n = s.length()-1;\\n        int i = n;\\n        while(i>=0)\\n        {\\n            result = result + (pow(26,(n-i))*(s[i]-\\'A\\'+1));\\n            i--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712836,
                "title": "java-100-faster-with-easy-explanation",
                "content": "Concept: If there is ony one character then there will be 26 numbers for column from A-Z.\\n\\nNow if we use two characters for column then there will be also 26 numbers like AA-AZ. And we have to add previous 26 numbers to this to find final column.\\n\\nSo we have to multiply the result every time by 26 upto the length of our string given.\\n\\nEx. Input : ABC\\n\\n\\t   ans = 0;\\n\\t\\n\\t1) i = 0\\n\\t    ans = 0\\n\\t\\tans = 0 + \\'A\\' - \\'A\\' + 1 = 1;\\n\\t\\n\\t2) i = 1\\n  \\t   ans = 1 * 26 = 26\\n\\t   ans = 26 + \\'B\\' - \\'A\\' + 1 = 26 + 1 + 1 = 28.\\n\\t   \\n    3) i = 2\\n       ans = 28 * 26 = 728\\n\\t   ans = 728 + \\'C\\' - \\'A\\' + 1 = 728 + 2 + 1 = 731\\n\\t\\n\\treturn 731\\n\\n<br />\\n\\nSolution:\\n\\n```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        \\n        int ans = 0;\\n        \\n        for(char c: s.toCharArray()) {\\n            \\n            ans *= 26;\\n            \\n            ans += (c - \\'A\\' + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        \\n        int ans = 0;\\n        \\n        for(char c: s.toCharArray()) {\\n            \\n            ans *= 26;\\n            \\n            ans += (c - \\'A\\' + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160559,
                "title": "swift-solution-16ms-beats-100",
                "content": "```\\nfunc titleToNumber(_ s: String) -> Int {\\n   var columnNumber = 0\\n   let offset = 64   \\n       \\n   for letter in s.utf8 { \\n       columnNumber = columnNumber * 26 + Int(letter) - offset\\n   }   \\n      \\n   return columnNumber\\n} ",
                "solutionTags": [],
                "code": "```\\nfunc titleToNumber(_ s: String) -> Int {\\n   var columnNumber = 0\\n   let offset = 64   \\n       \\n   for letter in s.utf8 { \\n       columnNumber = columnNumber * 26 + Int(letter) - offset\\n   }   \\n      \\n   return columnNumber\\n} ",
                "codeTag": "Unknown"
            },
            {
                "id": 52167,
                "title": "javascript-beat-100-152ms",
                "content": "/**\\n * @param {string} s\\n * @return {number}\\n */\\n\\nvar titleToNumber = function(s) {\\n    \\n        var result = 0;\\n        \\n        var sLength = s.length;\\n        \\n        for (var i = 0; i < sLength; i++)\\n        {\\n             result = result * 26 + (s.charCodeAt(i) - 'A'.charCodeAt(0) + 1);\\n        }\\n        \\n        return result;\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {string} s\\n * @return {number}\\n */\\n\\nvar titleToNumber = function(s) {\\n    \\n        var result = 0;\\n        \\n        var sLength = s.length;\\n        \\n        for (var i = 0; i < sLength; i++)\\n        {\\n             result = result * 26 + (s.charCodeAt(i) - 'A'.charCodeAt(0) + 1);\\n        }\\n        \\n        return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 52236,
                "title": "simple-and-accepted-as-best-in-c",
                "content": "    //AC - 4ms;\\n    int titleToNumber(char* s)\\n    {\\n        int sum = 0;\\n        while(*s) sum = 26*sum+(*(s++)-'A'+1);\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "    //AC - 4ms;\\n    int titleToNumber(char* s)\\n    {\\n        int sum = 0;\\n        while(*s) sum = 26*sum+(*(s++)-'A'+1);\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52242,
                "title": "8-lines-c-solution-in-8ms-with-explanation",
                "content": "The question is:\\n\\n*Given a **column title** as appear in an **Excel sheet**, return its **corresponding column number**.*\\n\\nLet's write some title's for example:\\n\\n**A~Z**\\n\\n - A: **1**\\n - B: **2**\\n - ........\\n - Z: **26**\\n\\n***A~Z* TOTAL**: ***26***\\n\\n----------\\n**AA~ZZ**\\n\\n - AA: 26 + **1**\\n - AB: 26 + **2**\\n - .......\\n - AZ: 26 + **26** = 26 + **26 \\xd7 *1***\\n\\n----------\\n - BA: 26 + 26 + **1**\\n - BB: 26 + 26 + **2**\\n - ........\\n - BZ: 26 + 26 + **26** = 26 + **26 \\xd7 *2***\\n\\n----------\\n - ..............................\\n\\n----------\\n - ZA: 26 + 26 \\xd7 25 + **1**\\n - ZB: 26 + 26 \\xd7 25 + **2**\\n - ........\\n - ZZ: 26 + 26 \\xd7 25 + **26** = 26 + **26 \\xd7 *26***\\n\\n***AA~ZZ* TOTAL**: ***26 \\xd7 26***\\n\\n----------\\nIf we write more, we can find that from ***AA...A*** to ***ZZ...Z* (the SAME length *n*)**, there are ***26^n*** numbers.\\n\\nIn order to get the **corresponding column number** of a normal **column title**,\\n\\nwe can ***DIVIDE*** the problem into ***2 PARTS***:\\n\\n----------\\n***PART 1***: **GET** the length of column title ***s***\\n\\n**Q: Why to get the length of column title s?**\\n\\nA: Suppose ***k* = *s.length()***, If ***k*** equals **1**, return **s[0] - 'A' + 1**.\\n\\nIf not, we need to ***FIRST*** find the biggest ***ZZ...Z*** (the length is ***k - 1***) ***NO MORE THAN s***.\\n\\nAnd get the ***SUM***:\\n\\n**S_1 = 26 + 26^2 + 26^3 +...+ 26^(k - 1)**.\\n\\nThis is the ***TOTAL*** from ***A*** to ***ZZZ...* (the length is *k - 1*)**\\n\\n----------\\n***PART 2***: **GET the rest (from *AA...A* (the length is *k*) to *s*)**\\n\\nWe can **MINUS *s*** with ***AA...A*** (the length is ***k***) ***DIGIT BY DIGIT SEPERATLY***.\\n\\nSuppose ***s* = *Q1Q2...Qk***,\\n\\n**S_2 = (Q1- 'A') \\xd7 26^(k - 1) + (Q2- 'A') \\xd7 26^(k - 2) + ... + (Qk- 'A') \\xd7 1** + ***1***\\n\\n***NOTE***: There is a ***1*** in the end of **S_2**.\\n\\nThe ***RESULT*** will be \\n\\n**S** = **S_1** + **S_2**\\n\\n**= (Q1- 'A' + 1) \\xd7 26^(k - 1) + (Q2- 'A' + 1) \\xd7 26^(k - 2) + ... + (Qk- 'A' + 1) \\xd7 1**\\n\\n----------\\n***My code:***\\n\\n    class Solution {\\n    public:\\n        int titleToNumber(string s) {\\n            int sum = 0;\\n            for(int i = 0; i < s.length(); i++)\\n            {\\n                sum += (s[i] - 'A' + 1)* pow(26, s.length() - 1 - i);\\n            }\\n            return sum;\\n        }\\n    };\\n\\n   ***Time Complexity: O(k), k is the length of s***",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n    public:\\n        int titleToNumber(string s) {\\n            int sum = 0;\\n            for(int i = 0; i < s.length(); i++)\\n            {\\n                sum += (s[i] - 'A' + 1)* pow(26, s.length() - 1 - i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 52279,
                "title": "my-java-solution-4ms-4-lines",
                "content": "public class Solution {\\n\\n    public int titleToNumber(String s) {\\n        int sum = 0;\\n        for(int i = 0; i < s.length(); i++ )\\n            sum = sum + (int)Math.pow(26,s.length() - i - 1) * (s.charAt(i) - 'A' + 1);\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int titleToNumber(String s) {\\n        int sum = 0;\\n        for(int i = 0; i < s.length(); i++ )\\n            sum = sum + (int)Math.pow(26,s.length() - i - 1) * (s.charAt(i) - 'A' + 1);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3733518,
                "title": "simple-solution-beats-100",
                "content": "\\n# # Please Upvote if feel it easy!\\n# its same as convert the binary to decimal\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum=0,p=0; //  p to increse the power\\n        int n = columnTitle.length();\\n        for(int i=n-1;i>=0;i--) {\\n            int temp = columnTitle.charAt(i)-64;\\n            sum=sum+(int)Math.pow(26,p++)*temp;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum=0,p=0; //  p to increse the power\\n        int n = columnTitle.length();\\n        for(int i=n-1;i>=0;i--) {\\n            int temp = columnTitle.charAt(i)-64;\\n            sum=sum+(int)Math.pow(26,p++)*temp;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313961,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum = 0;\\n        for(char ch : columnTitle.toCharArray()) {\\n            int diff = ch-(\\'A\\' - 1);\\n            sum = sum *26 + diff;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int sum = 0;\\n        for(char ch : columnTitle.toCharArray()) {\\n            int diff = ch-(\\'A\\' - 1);\\n            sum = sum *26 + diff;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200654,
                "title": "go-0ms-simple-solution",
                "content": "# Intuition\\nIts like calculating decimals at one\\'s, ten\\'s, hundred\\'s places\\nexcept the base is 26 here not 10\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc titleToNumber(columnTitle string) int {\\n    \\n    multiplier := 1\\n    result := 0\\n\\n    for i := len(columnTitle) - 1; i >= 0; i -= 1 {\\n        result += (int(columnTitle[i]) - int(\\'A\\') + 1) * multiplier\\n        multiplier *= 26\\n    }\\n\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc titleToNumber(columnTitle string) int {\\n    \\n    multiplier := 1\\n    result := 0\\n\\n    for i := len(columnTitle) - 1; i >= 0; i -= 1 {\\n        result += (int(columnTitle[i]) - int(\\'A\\') + 1) * multiplier\\n        multiplier *= 26\\n    }\\n\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3200119,
                "title": "converting-excel-column-title-to-column-number-using-positional-value-of-letters",
                "content": "# Intuition\\n To convert a column title to a corresponding column number in Excel, we need to understand the positional value of each letter in the title. Each letter in the title represents a value that is a power of 26, where the letter \\'A\\' represents the zeroth power of 26, \\'B\\' represents the first power of 26, and so on. We can start from the rightmost letter of the title and work our way left, accumulating the corresponding values using the formula (value = (letter value) * (26 ^ position)). Once we have computed the values for each letter in the title, we can add them up to get the final column number. \\n\\n# Approach\\nThe approach I used is to iterate through each character in the input string and convert it to its corresponding column value by subtracting the ASCII value of \\'A\\' and adding 1. We use a variable to keep track of the positional value of the letter and calculate the corresponding value using the formula mentioned earlier. Finally, we add up all the values to get the final result.\\n\\n# Complexity\\n- Time complexity:\\n The time complexity of this approach is$$ O(n),$$ where n is the length of the input string. This is because we need to iterate over each character in the string once to compute its corresponding column value. \\n\\n- Space complexity:\\n The space complexity of this approach is $$O(1)$$, as we are only using a constant amount of extra space to store variables such as the result and positional value.\\n\\n# Code\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        result = 0\\n        for i in range(len(columnTitle)):\\n            letter_value = ord(columnTitle[i]) - ord(\\'A\\') + 1\\n            position = len(columnTitle) - i - 1\\n            result += letter_value * (26 ** position)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        result = 0\\n        for i in range(len(columnTitle)):\\n            letter_value = ord(columnTitle[i]) - ord(\\'A\\') + 1\\n            position = len(columnTitle) - i - 1\\n            result += letter_value * (26 ** position)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857817,
                "title": "c-solution-for-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        int output=0;\\n        for (int i=0;i<columnTitle.Length;i++){\\n            int curr=columnTitle[i]-\\'A\\'+1;\\n            output=output*26+curr;\\n        }\\n        return output;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        int output=0;\\n        for (int i=0;i<columnTitle.Length;i++){\\n            int curr=columnTitle[i]-\\'A\\'+1;\\n            output=output*26+curr;\\n        }\\n        return output;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717425,
                "title": "python-3-clean-and-easy-solutoin",
                "content": "T.C: O(N), where N is the length of the string\\nS.C: O(1)\\n````\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        col_no = 0\\n        for c in columnTitle:\\n            col_no = (col_no * 26) + (ord(c) - ord(\\'A\\') + 1)\\n        return col_no",
                "solutionTags": [],
                "code": "T.C: O(N), where N is the length of the string\\nS.C: O(1)\\n````\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        col_no = 0\\n        for c in columnTitle:\\n            col_no = (col_no * 26) + (ord(c) - ord(\\'A\\') + 1)\\n        return col_no",
                "codeTag": "Java"
            },
            {
                "id": 2675758,
                "title": "easy-approach-using-math-pow-function-o-nloglogn",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int res=0;\\n        int add=0;\\n        for(int i=columnTitle.length()-1;i>=0;i--){\\n            add = (pow(26,columnTitle.length()-1-i)*(columnTitle[i]-64));\\n            res+=(add);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int res=0;\\n        int add=0;\\n        for(int i=columnTitle.length()-1;i>=0;i--){\\n            add = (pow(26,columnTitle.length()-1-i)*(columnTitle[i]-64));\\n            res+=(add);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355756,
                "title": "simplest-java-solution-100-faster-1ms",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int ans = 0;\\n        \\n        for (int i = 0; i < columnTitle.length(); i++) {\\n            ans *= 26;\\n            char c = columnTitle.charAt(i);\\n            int n = (int) (c - \\'A\\' + 1);\\n            ans += n;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int ans = 0;\\n        \\n        for (int i = 0; i < columnTitle.length(); i++) {\\n            ans *= 26;\\n            char c = columnTitle.charAt(i);\\n            int n = (int) (c - \\'A\\' + 1);\\n            ans += n;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792695,
                "title": "simple-recursive-solution",
                "content": "```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    let value = 0;\\n    \\n    const getNumericValue = (arr) => {\\n        if (arr.length > 1) {\\n            getNumericValue(arr.slice(1));\\n        }\\n        \\n        value += (alphabet.indexOf(arr[0]) + 1) * (Math.pow(26, (arr.length - 1)));\\n    }\\n    \\n    getNumericValue(columnTitle);\\n    \\n    return value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    const alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\\n    let value = 0;\\n    \\n    const getNumericValue = (arr) => {\\n        if (arr.length > 1) {\\n            getNumericValue(arr.slice(1));\\n        }\\n        \\n        value += (alphabet.indexOf(arr[0]) + 1) * (Math.pow(26, (arr.length - 1)));\\n    }\\n    \\n    getNumericValue(columnTitle);\\n    \\n    return value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792010,
                "title": "171-excel-sheet-column-number",
                "content": "Approach : \\nJust think about like the binary of base 2 simlarly in alphabet base is 26. So it multiply with string   [n-1-i]\\n\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) \\n    {\\n        int sum=0;\\n        int ch;\\n        int n=columnTitle.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ch=columnTitle[n-i-1]-\\'A\\';\\n            sum+=(ch+1)*pow(26,i);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) \\n    {\\n        int sum=0;\\n        int ch;\\n        int n=columnTitle.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ch=columnTitle[n-i-1]-\\'A\\';\\n            sum+=(ch+1)*pow(26,i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791420,
                "title": "c-recursive-solution-math-beats-100-of-c-solution",
                "content": "```\\nA - 1   (26 * 0 + 1)             AA - 27   (26 * 1 + 1)\\nB - 2   (26 * 0 + 2)             AB - 28   (26 * 1 + 2)\\nC - 3   (26 * 0 + 3)             AC - 29   (26 * 1 + 3)\\n.                                           .\\n.                                           .\\nZ - 26  (26 * 0 + 26)            AZ - 52   (26 * 1 + 26)\\n```\\n\\nLets now take an example - \\nAAC - value of AAC is 26 * (value of \"AA\") + value of \\'C\\'.\\nWe have seen that value of \"AA\" is 27. Then value of \"AAC\" is 26 * 27 + 3 = 705.\\nHence we get a recursive idea from the above example.\\n\\n```\\nclass Solution {\\nprivate:\\n    long solve(string &s,int index){\\n        if(index == 0) return s[index] - \\'A\\' + 1;\\n        \\n        long rest = solve(s,index - 1);\\n        return 26 * rest + s[index] - \\'A\\' + 1;\\n    }\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n = columnTitle.size() - 1;\\n        return solve(columnTitle,n);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b7bc5de5-6078-442b-afa3-761379f0df0a_1645529472.6236694.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nA - 1   (26 * 0 + 1)             AA - 27   (26 * 1 + 1)\\nB - 2   (26 * 0 + 2)             AB - 28   (26 * 1 + 2)\\nC - 3   (26 * 0 + 3)             AC - 29   (26 * 1 + 3)\\n.                                           .\\n.                                           .\\nZ - 26  (26 * 0 + 26)            AZ - 52   (26 * 1 + 26)\\n```\n```\\nclass Solution {\\nprivate:\\n    long solve(string &s,int index){\\n        if(index == 0) return s[index] - \\'A\\' + 1;\\n        \\n        long rest = solve(s,index - 1);\\n        return 26 * rest + s[index] - \\'A\\' + 1;\\n    }\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n = columnTitle.size() - 1;\\n        return solve(columnTitle,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791411,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int num=0;\\n        for(int i=0;i<columnTitle.length();i++)\\n        {\\n            int digit=columnTitle[i]-\\'A\\'+1;\\n            num=(26*num)+digit;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int num=0;\\n        for(int i=0;i<columnTitle.length();i++)\\n        {\\n            int digit=columnTitle[i]-\\'A\\'+1;\\n            num=(26*num)+digit;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791152,
                "title": "javascript-faster-than-94-with-explanation",
                "content": "**Javascript | Faster than 94%**\\nlet string = \\'ZZZ\\'\\n how we\\'ll calculate the output?\\n as we know... \\n A - 1,\\n B - 2 . . . \\n . \\n .\\n Z - 26\\n AA - 27  i.e 26 + 1\\n ZA = 26*26 + 1 = 677\\n so the formula we can make is  n = n + ((Ascii - 64)*(26^l--))\\n \\n\\n```\\nvar titleToNumber = function(columnTitle) {\\n    let l = columnTitle.length-1; \\n    let result = 0;\\n    for(let i = 0;i<columnTitle.length;i++){\\n        result = result + ((columnTitle[i].charCodeAt()-64) * Math.pow(26,l--)); \\n    }\\n    return result;\\n};\\n```\\n\\n**Upvote**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar titleToNumber = function(columnTitle) {\\n    let l = columnTitle.length-1; \\n    let result = 0;\\n    for(let i = 0;i<columnTitle.length;i++){\\n        result = result + ((columnTitle[i].charCodeAt()-64) * Math.pow(26,l--)); \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791008,
                "title": "python-3-50ms-ord-math-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        r=0\\n        for i in columnTitle:\\n            r = r * 26 + ord(i)-64\\n        return r\\n```\\n```\\n```\\n\\n* Example : \"ZY\" -->\\n* First Y , ord(Y) = 89,-->89-64=25(value of Y in the first 26 elements),therefore its excel sheet value will be = [(26^0)*25] == 25\\n* Second Z, ord(Z) = 90,-->90-64=26(value of Z in the first 26 elements) ,therefore its excel sheet value will be = [(26^1)*26] == 656\\n* Taking summ of them gives \"ZY\"\\'s column number i.e, 656 + 25 = 701\\n\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        r=0\\n        for i in columnTitle:\\n            r = r * 26 + ord(i)-64\\n        return r\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790677,
                "title": "c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string col) {\\n        int s=col.length();\\n        int ans=0,c=0;\\n        for(int i=s-1;i>=0;i--){\\n            ans+=pow(26,c++)*(col[i]-64);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string col) {\\n        int s=col.length();\\n        int ans=0,c=0;\\n        for(int i=s-1;i>=0;i--){\\n            ans+=pow(26,c++)*(col[i]-64);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1767775,
                "title": "c-o-n-time-o-1-space-100-faster-simple-logic-with-detailed-explanation",
                "content": "If we closely observe, there is a pattern while counting the column number (traverse from right to left of the string).\\n\\nNormally, in decimal digits, the base value is 10, because there are 10 digits, 0 to 9. \\nSo, For Ex :172 can be represented as :  1x100 + 7x10 +2x1 , which is equal to  1x(10^2) + 7x(10^1) + 2x(10^0),\\nwhich is in turn equal to (traversing from right to left) : **[2 x (10^0)] + [7 x (10^1)] + [1 x (10^2)]  = 172**\\n\\nIf we consider the same for letters, the base will be 26, because there are 26 letters, A to Z. So, instead of powers of 10, we will use powers of 26, along with the values of each letter (A = 1, B = 2, C = 3, ..... Y = 25, Z = 26).\\n\\n**Example : \\nConsider input \"ABC\"\\nHere, traversing from right, we get:\\nC : 3 x (26^0) (since C is the rightmost letter, its place value will be 0)\\nB : 2 x (26^1) (incrementing place value by 1)\\nA : 1 x (26^2) (incrementing place value by 1)\\nNow adding all the above, we get \"ABC\" = [3 x (26^0)] + [2 x (26^1)] + [1 x (26^2)] = 731**\\n\\nWhen it comes to applying this concept in code, we can **initialise a variable j=0**, and increment it each time while traversing from right to left of the string, so as to **keep track of the power of 26**, and keep adding to a sum variable.\\n\\n```\\n  \\n       int titleToNumber(string columnTitle) {\\n        \\n\\t\\t// Logic :   \\n\\t\\t// AAAB\\n        // (26^0) *2 + (26^1)*(1) + (26^2)(1) + (26^3) * (1)\\n\\t\\t\\n        int sum = 0;\\n        int j=0;\\n        for(int i=columnTitle.length()-1 ; i>=0 ; i--)\\n        {\\n            // (columnTitle[i]-\\'A\\'+1) : used to estimate the value of the character at the index i. \\n\\t\\t\\t// Ex : \\'A\\' -\\'A\\' +1 = 1\\n\\t\\t\\t// Ex : \\'B\\' -\\'A\\' + 1 = 2 and so on\\n            sum += ((columnTitle[i]-\\'A\\'+1) * pow(26, j));\\n            j++;\\n        }\\n        return sum;\\n    }\\n```\\n\\nThis is my very first time answering a question in LeetCode Discuss. Hope you find it helpful. Please comment below if you have any doubts, and upvote if you liked my approach. Thanks!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n  \\n       int titleToNumber(string columnTitle) {\\n        \\n\\t\\t// Logic :   \\n\\t\\t// AAAB\\n        // (26^0) *2 + (26^1)*(1) + (26^2)(1) + (26^3) * (1)\\n\\t\\t\\n        int sum = 0;\\n        int j=0;\\n        for(int i=columnTitle.length()-1 ; i>=0 ; i--)\\n        {\\n            // (columnTitle[i]-\\'A\\'+1) : used to estimate the value of the character at the index i. \\n\\t\\t\\t// Ex : \\'A\\' -\\'A\\' +1 = 1\\n\\t\\t\\t// Ex : \\'B\\' -\\'A\\' + 1 = 2 and so on\\n            sum += ((columnTitle[i]-\\'A\\'+1) * pow(26, j));\\n            j++;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1525817,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        if (columnTitle == null || columnTitle == string.Empty)\\n            return 0;\\n        \\n        int res = 0;\\n        \\n        for (int i = columnTitle.Length - 1; i > -1; i--)\\n        {\\n            res += (columnTitle[i] - \\'A\\' + 1) * (int)Math.Pow(26, columnTitle.Length - 1 - i);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        if (columnTitle == null || columnTitle == string.Empty)\\n            return 0;\\n        \\n        int res = 0;\\n        \\n        for (int i = columnTitle.Length - 1; i > -1; i--)\\n        {\\n            res += (columnTitle[i] - \\'A\\' + 1) * (int)Math.Pow(26, columnTitle.Length - 1 - i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1515237,
                "title": "simple-to-understand-using-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        var result = 0;\\n        \\n        foreach (var letter in columnTitle) {            \\n            // Get the alphabet position of the letter\\n            var pos = (letter - \\'A\\') + 1;\\n            \\n            // Calculate the result\\n            result = result * 26 + pos;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        var result = 0;\\n        \\n        foreach (var letter in columnTitle) {            \\n            // Get the alphabet position of the letter\\n            var pos = (letter - \\'A\\') + 1;\\n            \\n            // Calculate the result\\n            result = result * 26 + pos;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436715,
                "title": "4-lines-easiest-code-detailed-explanation-of-approach-for-beginners-coders-o-n",
                "content": "In this question you have to given the string as columnTitle. and from it you have to calculate the column number.\\nfor Calculating the column number always traverse the string from end .so first of all reverse the string \\nthen traverse the string from start to end , \\nans+=pow(26,i)*((columnTitle[i] % 65)+1)\\nthen return ans.\\n\\n\\nint titleToNumber(string columnTitle) {\\n        \\n     reverse(columnTitle.begin(),columnTitle.end());\\n      \\n      int ans=0, n=columnTitle.length();\\n      \\n      for(int i=0;i<n;i++)  ans=ans+pow(26,i)*((columnTitle[i]%65)+1);\\n      \\n      return ans;\\n      \\n    }\\n\\t\\n\\t//plz upvote my solution if you really like it. and comment if you have any doubt. keep coding",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "In this question you have to given the string as columnTitle. and from it you have to calculate the column number.\\nfor Calculating the column number always traverse the string from end .so first of all reverse the string \\nthen traverse the string from start to end , \\nans+=pow(26,i)*((columnTitle[i] % 65)+1)\\nthen return ans.\\n\\n\\nint titleToNumber(string columnTitle) {\\n        \\n     reverse(columnTitle.begin(),columnTitle.end());\\n      \\n      int ans=0, n=columnTitle.length();\\n      \\n      for(int i=0;i<n;i++)  ans=ans+pow(26,i)*((columnTitle[i]%65)+1);\\n      \\n      return ans;\\n      \\n    }\\n\\t\\n\\t//plz upvote my solution if you really like it. and comment if you have any doubt. keep coding",
                "codeTag": "Unknown"
            },
            {
                "id": 879606,
                "title": "faster-than-99-17-of-python3",
                "content": "```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        res = 0\\n        for i, c in enumerate(s[::-1]):\\n            res += (ord(c)-64)*(26**(i))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        res = 0\\n        for i, c in enumerate(s[::-1]):\\n            res += (ord(c)-64)*(26**(i))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785177,
                "title": "excel-sheet-colum-number-java-solution-faster-than-100-w-explanation",
                "content": "`String s`  is basically a base 26 number where A = 1 and Z = 26, except there are no letters representing some form of 0. This doesn\\'t end up making a difference though. So, the last char in the string corresponds to some number between 1-26, then the char in front of it is a number between (1-26) * 26, the next (1-26) * 26 * 26, and so forth. You then add all the individual values of each char together.\\nSorry if it\\'s unclear, this is my first time posting.\\n\\n```\\nclass Solution \\n{\\n    public int titleToNumber(String s) \\n    {\\n        int res = 0;\\n        for(int i = s.length() - 1; i >= 0; i--)\\n        {\\n            res += (s.charAt(i) - \\'A\\' + 1) * Math.pow(26, s.length() - i - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int titleToNumber(String s) \\n    {\\n        int res = 0;\\n        for(int i = s.length() - 1; i >= 0; i--)\\n        {\\n            res += (s.charAt(i) - \\'A\\' + 1) * Math.pow(26, s.length() - i - 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784001,
                "title": "c-python-similar-to-decimal-iteration-and-recursion-1-line",
                "content": "Solution 1: Iteration\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int ans = 0;\\n        for(auto c:s)  ans = ans * 26 + (c-\\'A\\'+1);        \\n        return ans;\\n    }\\n};\\n```\\n\\nSolution 2: Recursion\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        return s.empty() ?0 : titleToNumber(s.substr(0, s.size() - 1)) * 26 + (s.back()-\\'A\\'+1);       \\n    }\\n};\\n```\\n\\nSolution 3: Python\\n```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        return reduce(lambda x, y : x * 26 + y, [ord(c) - ord(\\'A\\') + 1 for c in list(s)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int ans = 0;\\n        for(auto c:s)  ans = ans * 26 + (c-\\'A\\'+1);        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        return s.empty() ?0 : titleToNumber(s.substr(0, s.size() - 1)) * 26 + (s.back()-\\'A\\'+1);       \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        return reduce(lambda x, y : x * 26 + y, [ord(c) - ord(\\'A\\') + 1 for c in list(s)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602684,
                "title": "runtime-100-simple-python3",
                "content": "```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        ans = 0\\n        for c in s:\\n            ans = ans * 26 + ord(c) - ord(\\'A\\') + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        ans = 0\\n        for c in s:\\n            ans = ans * 26 + ord(c) - ord(\\'A\\') + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141519,
                "title": "short-clean-and-easy-to-understand-java-solution-1ms",
                "content": "Integers are base 10 numbers calculated as: \\n`321 = 3 * (10^2) + 2 * (10^1) +  1 * (10^0)`\\n\\nAn excel sheet column number(replace alphabets with corresponding number) is a base 26 number:\\n\\n`CBA = C * (26^2) + B * (26^1) + A * (26^0)`\\n\\nwhere C = 3, B = 2 & A = 1\\n\\n\\n```\\n    public int titleToNumber(String s) {\\n        double sum = 0;\\n        int len = s.length();\\n        for(int i = len - 1;i > -1;i--){\\n            sum += Math.pow(26, len - (i + 1)) * (s.charAt(i) - \\'A\\' + 1) ;\\n        }\\n        return (int)sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int titleToNumber(String s) {\\n        double sum = 0;\\n        int len = s.length();\\n        for(int i = len - 1;i > -1;i--){\\n            sum += Math.pow(26, len - (i + 1)) * (s.charAt(i) - \\'A\\' + 1) ;\\n        }\\n        return (int)sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52312,
                "title": "c-4ms-so-easy",
                "content": "class Solution {\\npublic:\\n\\n    int titleToNumber(string s) {\\n        int len=s.size();\\n        int sum=s[0]-64;\\n        for (int i=1;i<len;i++){\\n            sum=sum*26+int(s[i]-64);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int titleToNumber(string s) {\\n        int len=s.size();\\n        int sum=s[0]-64;\\n        for (int i=1;i<len;i++){\\n            sum=sum*26+int(s[i]-64);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3867599,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        number=0\\n        for alpha in columnTitle:\\n            number=number*26 + (ord(alpha)-64)\\n        return number\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        number=0\\n        for alpha in columnTitle:\\n            number=number*26 + (ord(alpha)-64)\\n        return number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820095,
                "title": "easy-to-use",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans=0;\\n         for(int i=0;i<columnTitle.size();i++){\\n          ans *=26;\\n          ans += columnTitle[i]-\\'A\\'+1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans=0;\\n         for(int i=0;i<columnTitle.size();i++){\\n          ans *=26;\\n          ans += columnTitle[i]-\\'A\\'+1;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672145,
                "title": "easy-solution-in-javascript-wow-you-must-watch-solution",
                "content": "#  IF you like solution, please upvote\\n\\n# Code\\n```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    let sum = 0;\\n    let index = 1;\\n    for(let i = columnTitle.length - 1; i >= 0; i--) {\\n        sum += index * (columnTitle[i].charCodeAt() - 64)\\n        index*= 26\\n    }\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} columnTitle\\n * @return {number}\\n */\\nvar titleToNumber = function(columnTitle) {\\n    let sum = 0;\\n    let index = 1;\\n    for(let i = columnTitle.length - 1; i >= 0; i--) {\\n        sum += index * (columnTitle[i].charCodeAt() - 64)\\n        index*= 26\\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436429,
                "title": "python-simple-clean-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        n = len(s)\\n        cnt = [0] * 7\\n        p = 0\\n        for i in range(n -1, -1, -1):\\n            cnt[i] = (ord(s[i]) - ord(\\'A\\') + 1) * 26 ** p\\n            p += 1\\n        return sum(cnt)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, s: str) -> int:\\n        n = len(s)\\n        cnt = [0] * 7\\n        p = 0\\n        for i in range(n -1, -1, -1):\\n            cnt[i] = (ord(s[i]) - ord(\\'A\\') + 1) * 26 ** p\\n            p += 1\\n        return sum(cnt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406257,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        for(auto c: columnTitle) {\\n            int x = c - \\'A\\' + 1;\\n            ans = ans * 26 + x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        for(auto c: columnTitle) {\\n            int x = c - \\'A\\' + 1;\\n            ans = ans * 26 + x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171797,
                "title": "c-4-lines-code-well-explained",
                "content": "First we will find the size of columnTitle string. In this string every character will have different position and this position will decide what value it contributes to the entire sum value.\\nLike in AB. B is at position \\'0\\' means its value will be int p =  (26^0)*2.\\nwhile A is at position \\'1\\' means its value will be int k = (26^1)*1.\\nSo the entire value of AB is  p+k.\\n![image](https://assets.leetcode.com/users/images/f962d7f3-1c46-4edd-a477-8e73de5f6cee_1676117657.332754.png)\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n = columnTitle.size(); int sum = 0;\\n        for(int i=0; i<n; i++){ char ch = columnTitle[i];   int p =  ch -\\'A\\' + 1; sum = sum + (pow(26,n-i-1)*p); } \\n\\t\\treturn sum;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n = columnTitle.size(); int sum = 0;\\n        for(int i=0; i<n; i++){ char ch = columnTitle[i];   int p =  ch -\\'A\\' + 1; sum = sum + (pow(26,n-i-1)*p); }",
                "codeTag": "Java"
            },
            {
                "id": 3167956,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        int ans=0;\\n        int doubler=0;\\n        for(int i=columnTitle.Length-1;i>-1;i--){\\n            ans+=(columnTitle[i]-\\'A\\' + 1)*(int)Math.Pow(26,doubler);\\n            doubler+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int TitleToNumber(string columnTitle) {\\n        int ans=0;\\n        int doubler=0;\\n        for(int i=columnTitle.Length-1;i>-1;i--){\\n            ans+=(columnTitle[i]-\\'A\\' + 1)*(int)Math.Pow(26,doubler);\\n            doubler+=1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159132,
                "title": "simple-1-line-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n        int ans=0;\\n        int j=0;\\n    for(int i=c.size()-1;i>=0;i--)  ans+=(c[i]-\\'A\\'+1)*pow(26,j++);      \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n        int ans=0;\\n        int j=0;\\n    for(int i=c.size()-1;i>=0;i--)  ans+=(c[i]-\\'A\\'+1)*pow(26,j++);      \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918485,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(N*M) <br>N is the length of string<br> M is the time complexity of power function \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int power=0;\\n        int ans=0;\\n        for(int i=columnTitle.length()-1;i>=0;i--){\\n            ans+=((columnTitle[i]-\\'A\\'+1)*pow(26,power));\\n            power++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int power=0;\\n        int ans=0;\\n        for(int i=columnTitle.length()-1;i>=0;i--){\\n            ans+=((columnTitle[i]-\\'A\\'+1)*pow(26,power));\\n            power++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913704,
                "title": "runtime-342-ms-beats-100-dart",
                "content": "\\n\\n\\nIf you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n  int titleToNumber(String columnTitle) {\\n      int res =0 ;\\n        for(int i=0; i<columnTitle.length;i++){\\n            int s = columnTitle.codeUnits[i] - 64 ;//64=codeUnits[\\'A\\'] -1\\n            res=res*26+s ;\\n        }\\n        return res ;\\n  }\\n}\\n```\\nPls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding :)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int titleToNumber(String columnTitle) {\\n      int res =0 ;\\n        for(int i=0; i<columnTitle.length;i++){\\n            int s = columnTitle.codeUnits[i] - 64 ;//64=codeUnits[\\'A\\'] -1\\n            res=res*26+s ;\\n        }\\n        return res ;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844270,
                "title": "java-just-in-2ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        if (s.length() == 1) return s.charAt(0) - \\'A\\' + 1;\\n        int pow = 1, sum = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            sum += (c - \\'A\\' + 1) * pow;\\n            pow *= 26;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String s) {\\n        if (s.length() == 1) return s.charAt(0) - \\'A\\' + 1;\\n        int pow = 1, sum = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            char c = s.charAt(i);\\n            sum += (c - \\'A\\' + 1) * pow;\\n            pow *= 26;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785780,
                "title": "c-easiest-solution-simple-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n=columnTitle.size();\\n        map<char,int> m;// for storing characters from A to Z\\n        int i=1;\\n        for(char c=\\'A\\';c<=\\'Z\\';c++)\\n        {\\n            m[c]=i;\\n            i++;\\n        }\\n        if(n==1)\\n        return m[columnTitle[0]];\\n        int x=n-1;\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int y=x;\\n            int p=1;\\n            while(y--)\\n            {\\n                p*=26;//multiply 26  n-1 times for zeroth place n-2 for 1st n-3 for 2nd place......\\n\\t\\t\\t\\t// where n is the length of string\\n            }\\n            if(p!=1)\\n            s+=p*m[columnTitle[i]];\\n            x--;\\n        }\\n        s+=m[columnTitle[n-1]];\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int n=columnTitle.size();\\n        map<char,int> m;// for storing characters from A to Z\\n        int i=1;\\n        for(char c=\\'A\\';c<=\\'Z\\';c++)\\n        {\\n            m[c]=i;\\n            i++;\\n        }\\n        if(n==1)\\n        return m[columnTitle[0]];\\n        int x=n-1;\\n        int s=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int y=x;\\n            int p=1;\\n            while(y--)\\n            {\\n                p*=26;//multiply 26  n-1 times for zeroth place n-2 for 1st n-3 for 2nd place......\\n\\t\\t\\t\\t// where n is the length of string\\n            }\\n            if(p!=1)\\n            s+=p*m[columnTitle[i]];\\n            x--;\\n        }\\n        s+=m[columnTitle[n-1]];\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757432,
                "title": "swift-easy-to-understand-with-single-line-solution",
                "content": "# Easy To Understand:\\n```\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        var result = 0\\n        \\n        for c in columnTitle.unicodeScalars {\\n            let value = Int(c.value) - 64\\n            result = (result * 26) + value\\n        }\\n        \\n        return result\\n    }\\n}\\n```\\n\\n# Single Line Solution:\\n```\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        columnTitle.unicodeScalars.reduce(0) { $0 * 26 + Int($1.value) - 64 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        var result = 0\\n        \\n        for c in columnTitle.unicodeScalars {\\n            let value = Int(c.value) - 64\\n            result = (result * 26) + value\\n        }\\n        \\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func titleToNumber(_ columnTitle: String) -> Int {\\n        columnTitle.unicodeScalars.reduce(0) { $0 * 26 + Int($1.value) - 64 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722848,
                "title": "my-code-in-java",
                "content": "\\'\\'\\'\\npublic int titleToNumber(String ct) {\\n\\n        if(ct.length() == 1) return ct.charAt(0) - \\'A\\' + 1;\\n        \\n        int ans = 0;\\n        \\n        for(int i = ct.length() - 1; i >= 0; i--){\\n            int idx = ct.length() - 1 - i;\\n            int power = (int)Math.pow(26, idx);\\n            char ch = ct.charAt(i);\\n            ans += power * (ch - \\'A\\' + 1);\\n        }\\n        \\n        return ans;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\npublic int titleToNumber(String ct) {\\n\\n        if(ct.length() == 1) return ct.charAt(0) - \\'A\\' + 1;\\n        \\n        int ans = 0;\\n        \\n        for(int i = ct.length() - 1; i >= 0; i--){\\n            int idx = ct.length() - 1 - i;\\n            int power = (int)Math.pow(26, idx);\\n            char ch = ct.charAt(i);\\n            ans += power * (ch - \\'A\\' + 1);\\n        }\\n        \\n        return ans;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2658707,
                "title": "java-easy-solution",
                "content": "public int titleToNumber(String columnTitle) {\\n       int ans=0;\\n        int i=0;\\n        int len=columnTitle.length();\\n        while(len>0){\\n            ans+=Math.pow(26,len-1)*(columnTitle.charAt(i)-64);\\n            len--;\\n            i++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "public int titleToNumber(String columnTitle) {\\n       int ans=0;\\n        int i=0;\\n        int len=columnTitle.length();\\n        while(len>0){\\n            ans+=Math.pow(26,len-1)*(columnTitle.charAt(i)-64);\\n            len--;\\n            i++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2440072,
                "title": "4-line-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        map<char, int> mp; int ans = 0;\\n        mp[\\'A\\'] = 1; mp[\\'B\\'] = 2; mp[\\'C\\'] = 3; mp[\\'D\\'] = 4; mp[\\'E\\'] = 5; mp[\\'F\\'] = 6; mp[\\'G\\'] = 7; mp[\\'H\\'] = 8; mp[\\'I\\'] = 9; mp[\\'J\\'] = 10; mp[\\'K\\'] = 11; mp[\\'L\\'] = 12; mp[\\'M\\'] = 13; mp[\\'N\\'] = 14; mp[\\'O\\'] = 15; mp[\\'P\\'] = 16; mp[\\'Q\\'] = 17; mp[\\'R\\'] = 18; mp[\\'S\\'] = 19; mp[\\'T\\'] = 20; mp[\\'U\\'] = 21; mp[\\'V\\'] = 22; mp[\\'W\\'] = 23; mp[\\'X\\'] = 24; mp[\\'Y\\'] = 25; mp[\\'Z\\'] = 26;\\n        for (int i = s.size() - 1; i >= 0; i--) ans += (mp[s[i]]) * pow(26, (s.size() - i - 1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        map<char, int> mp; int ans = 0;\\n        mp[\\'A\\'] = 1; mp[\\'B\\'] = 2; mp[\\'C\\'] = 3; mp[\\'D\\'] = 4; mp[\\'E\\'] = 5; mp[\\'F\\'] = 6; mp[\\'G\\'] = 7; mp[\\'H\\'] = 8; mp[\\'I\\'] = 9; mp[\\'J\\'] = 10; mp[\\'K\\'] = 11; mp[\\'L\\'] = 12; mp[\\'M\\'] = 13; mp[\\'N\\'] = 14; mp[\\'O\\'] = 15; mp[\\'P\\'] = 16; mp[\\'Q\\'] = 17; mp[\\'R\\'] = 18; mp[\\'S\\'] = 19; mp[\\'T\\'] = 20; mp[\\'U\\'] = 21; mp[\\'V\\'] = 22; mp[\\'W\\'] = 23; mp[\\'X\\'] = 24; mp[\\'Y\\'] = 25; mp[\\'Z\\'] = 26;\\n        for (int i = s.size() - 1; i >= 0; i--) ans += (mp[s[i]]) * pow(26, (s.size() - i - 1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327359,
                "title": "c-2-lines",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n\\n        int result = 0;\\n        for(char c : columnTitle)\\n        {\\n            int d = c - \\'A\\' + 1;////d = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the lette\\n            result = result * 26 + d;\\n        }\\n        return result;\\n        \\n    }\\n};   \\n    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n\\n        int result = 0;\\n        for(char c : columnTitle)\\n        {\\n            int d = c - \\'A\\' + 1;////d = s[i](char) - \\'A\\' + 1 (we used  s[i] -  \\'A\\' to convert the lette\\n            result = result * 26 + d;\\n        }\\n        return result;\\n        \\n    }\\n};   \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180354,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int result = 0;\\n        \\n        if(columnTitle.length() > 1)\\n        {\\n            for(int i =0; i <columnTitle.length(); i++)\\n            {\\n                char c = columnTitle.charAt(i);\\n                result = (result*26) + (int)c - 64;\\n            }\\n        }\\n        else\\n            result = (int)columnTitle.charAt(0) - 64;\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int result = 0;\\n        \\n        if(columnTitle.length() > 1)\\n        {\\n            for(int i =0; i <columnTitle.length(); i++)\\n            {\\n                char c = columnTitle.charAt(i);\\n                result = (result*26) + (int)c - 64;\\n            }\\n        }\\n        else\\n            result = (int)columnTitle.charAt(0) - 64;\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795929,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n     int res = 0;\\n    int n = columnTitle.size();\\n    for(int i = 0; i < n; i++)\\n        res = res * 26 + (columnTitle[i] - \\'A\\' + 1);\\n    \\n    return res;   \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n     int res = 0;\\n    int n = columnTitle.size();\\n    for(int i = 0; i < n; i++)\\n        res = res * 26 + (columnTitle[i] - \\'A\\' + 1);\\n    \\n    return res;   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1793622,
                "title": "python3-fast-solution-using-maths",
                "content": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        result_num = 0\\n        power = 0\\n        A=0\\n        len_alphabet = len(alphabet)\\n        while len(columnTitle) > 0:\\n            position = alphabet.find(columnTitle[-1]) + 1\\n            columnTitle = columnTitle[0: -1]\\n            A= position * len_alphabet ** power\\n            result_num += A\\n            power += 1\\n        return result_num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n        alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\\n        result_num = 0\\n        power = 0\\n        A=0\\n        len_alphabet = len(alphabet)\\n        while len(columnTitle) > 0:\\n            position = alphabet.find(columnTitle[-1]) + 1\\n            columnTitle = columnTitle[0: -1]\\n            A= position * len_alphabet ** power\\n            result_num += A\\n            power += 1\\n        return result_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792253,
                "title": "c-one-line-with-std-accumulate",
                "content": "```cpp\\nint titleToNumber(string s) {\\n\\treturn accumulate(s.begin(), s.end(), 0, [](const int&a, const char&b){return 26 * a + (b - \\'A\\') + 1;});\\n}  \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint titleToNumber(string s) {\\n\\treturn accumulate(s.begin(), s.end(), 0, [](const int&a, const char&b){return 26 * a + (b - \\'A\\') + 1;});\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791601,
                "title": "java-simple-easy-single-traversal-o-n",
                "content": "```\\npublic int titleToNumber(String columnTitle) {\\n        int n = columnTitle.length();\\n        \\n        int columnNumber = 0;\\n        \\n        for(int i = 0;i < n;i++){\\n            int currentColumn = columnTitle.charAt(i) - \\'A\\' + 1;\\n            columnNumber = columnNumber * 26 + currentColumn;\\n        }\\n        return columnNumber;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int titleToNumber(String columnTitle) {\\n        int n = columnTitle.length();\\n        \\n        int columnNumber = 0;\\n        \\n        for(int i = 0;i < n;i++){\\n            int currentColumn = columnTitle.charAt(i) - \\'A\\' + 1;\\n            columnNumber = columnNumber * 26 + currentColumn;\\n        }\\n        return columnNumber;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791535,
                "title": "c-solution-100-faster-with-explanation",
                "content": "The whole game revolves around the number 26( (26 alphabets) and powers of 26(Depends on the lenth of string).\\nExample:\\n\\nA = 1\\nAA = 26\\\\*1 + 1\\nAAA = 26\\\\*26\\\\*1 + 26\\\\*1 + 1\\n.........\\nOverall ```Formula: 26*(l-1)*x + 26*(l-2)*x + .... + 26*x + x```\\nWhere, L = length of string\\n\\t\\t\\tx = Numerical value of that particular letter(```columnTitle[i]```) of the string. \\n```\\nint titleToNumber(string columnTitle) {\\n       //columnTitle\\n        \\n        int l = columnTitle.length();\\n        \\n        //We\\'ll have to keep a note regarding powers of 26.\\n        int it = l-1;\\n        \\n        //storing result\\n        long long int sum = 0;\\n        \\n        for(int i = 0;i<l;i++)\\n        {\\n            int curr = columnTitle[i]-\\'A\\';\\n            curr+=1; //A=1, not 0\\n            \\n            curr = pow(26,it)*curr;\\n            \\n            sum = sum+curr;\\n            it--;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Formula: 26*(l-1)*x + 26*(l-2)*x + .... + 26*x + x```\n```columnTitle[i]```\n```\\nint titleToNumber(string columnTitle) {\\n       //columnTitle\\n        \\n        int l = columnTitle.length();\\n        \\n        //We\\'ll have to keep a note regarding powers of 26.\\n        int it = l-1;\\n        \\n        //storing result\\n        long long int sum = 0;\\n        \\n        for(int i = 0;i<l;i++)\\n        {\\n            int curr = columnTitle[i]-\\'A\\';\\n            curr+=1; //A=1, not 0\\n            \\n            curr = pow(26,it)*curr;\\n            \\n            sum = sum+curr;\\n            it--;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791500,
                "title": "easy-c-solution-please-upvote",
                "content": "class Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n=s.size();\\n        int k=n;\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int x=s[i]-64;\\n            ans+=(pow(26,n-1))*x;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n=s.size();\\n        int k=n;\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int x=s[i]-64;\\n            ans+=(pow(26,n-1))*x;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791163,
                "title": "simple-java-solution",
                "content": "```class Solution {\\n    public int titleToNumber(String s) {\\n        s=s.toLowerCase();\\n        int p=0;\\n        for(char c:s.toCharArray())\\n        {\\n            p*=26;\\n            p+=(c-\\'a\\')+1;\\n        }\\n        return p;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int titleToNumber(String s) {\\n        s=s.toLowerCase();\\n        int p=0;\\n        for(char c:s.toCharArray())\\n        {\\n            p*=26;\\n            p+=(c-\\'a\\')+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791105,
                "title": "python-ascii-with-simple-comments",
                "content": "**Approach 1** \\n\\n```\\nclass Solution:\\n    \\n    def titleToNumber(self, columnTitle: str) -> int:\\n        soln=0\\n        # 1.Reverse the given string using [::-1],  enumerate function will generate value of i=0, i=1 etc for each iteration\\n        for i,char in enumerate(columnTitle[::-1]):\\n        # 2. As per problem statement A-Z is 26 and AA takes 27 which is (26^0)*1 for the 1st A and (26^1)*1 for the second A.Adding it is 27\\n        # 3. Assume BB - (26^0)*2= 1*2 = 2 for the first B and (26^1)*2=52 for the next B. Sum is 54\\n            soln+=pow(26,i)*(ord(char)-64)\\n        return soln\\n```\\n\\n\\n**Approach 2 - One liner**\\n```\\n# Given XYZ as input the answer is Z*(26^0)+Y*(26^1)+X*(26^2)\\n# Ascii of A = 65, however we want to consider A = 1 hence we subtract every ASCII with 64\\n# iterate everycolumn in reverse and increase 26^i in every step\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n            return sum([(ord(columnTitle[-i-1])-64)*(26**i) for i in range(len(columnTitle))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def titleToNumber(self, columnTitle: str) -> int:\\n        soln=0\\n        # 1.Reverse the given string using [::-1],  enumerate function will generate value of i=0, i=1 etc for each iteration\\n        for i,char in enumerate(columnTitle[::-1]):\\n        # 2. As per problem statement A-Z is 26 and AA takes 27 which is (26^0)*1 for the 1st A and (26^1)*1 for the second A.Adding it is 27\\n        # 3. Assume BB - (26^0)*2= 1*2 = 2 for the first B and (26^1)*2=52 for the next B. Sum is 54\\n            soln+=pow(26,i)*(ord(char)-64)\\n        return soln\\n```\n```\\n# Given XYZ as input the answer is Z*(26^0)+Y*(26^1)+X*(26^2)\\n# Ascii of A = 65, however we want to consider A = 1 hence we subtract every ASCII with 64\\n# iterate everycolumn in reverse and increase 26^i in every step\\nclass Solution:\\n    def titleToNumber(self, columnTitle: str) -> int:\\n            return sum([(ord(columnTitle[-i-1])-64)*(26**i) for i in range(len(columnTitle))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790908,
                "title": "easy-solution-in-python",
                "content": "```\\ndef titleToNumber(self, columnTitle: str) -> int:\\n        givenStr = columnTitle[::-1]\\n        result = 0\\n        for i, c in enumerate(givenStr):\\n            result += (ord(c)%64)*(26**i) \\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef titleToNumber(self, columnTitle: str) -> int:\\n        givenStr = columnTitle[::-1]\\n        result = 0\\n        for i, c in enumerate(givenStr):\\n            result += (ord(c)%64)*(26**i) \\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1790867,
                "title": "easy-intuitive-c",
                "content": "![image](https://assets.leetcode.com/users/images/3baa5c6a-2f08-4b42-b5cd-5cb6cfe3babb_1645511943.7372382.png)\\n\\nHere we are given to encode the column title string into a numeric value\\nA-Z we know mapped as 1-26 which we can get as \\ncolumntitle[i]-\\'A\\'+1 given all uppercase letters\\n\\nNow if we observe carefully\\nif length of this input string is 1 its eazy we can directly say 1-26 whatever it is\\nNow look at this string for example:\\nAAB\\nlets break it into a part and try to visualize it\\n(A ->(  A->  (B)  ))\\n\\nNow B is 2 we know.\\nGoing till Z we will have 26 then again a series starts like AA-AZ which goes from 27-52\\nso now as we move our pointer to the 2nd last character as we are moving right to left\\nwe see what character it is,  for our case its an \\'A\\' but in the 2nd last place so it should start from 26+(whatever we have accumulated after it)\\nif the 2nd last character was a B instead, (after AZ we start with BA-> which is 53 which means 26*(2)+1)\\n\\nand similarly in the 3rd character we have 26 x 26 x (whatever the character is)\\n\\nSo our eg string AAB can be encoded as\\n(26 x 26 x 1) +(26 x 1)+(2)\\n......................................... _______\\n.............................................. B\\n........................___________\\n________________A\\nA\\n------\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n       int ans=0;\\n        int k=0;\\n        for(int i=c.length()-1;i>=0;i--){\\n            int t=c[i]-\\'A\\'+1;\\n            ans=ans+t*pow(26,k);\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string c) {\\n       int ans=0;\\n        int k=0;\\n        for(int i=c.length()-1;i>=0;i--){\\n            int t=c[i]-\\'A\\'+1;\\n            ans=ans+t*pow(26,k);\\n            k++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790704,
                "title": "js-70-faster-using-reduce",
                "content": "```\\nvar titleToNumber = function(columnTitle) {\\n    return columnTitle.split(\"\").reverse().reduce((acum, ch, i) => {\\n        const charValue = ch.charCodeAt(0) - 64;\\n        return acum + (charValue*(26**i));\\n    },0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar titleToNumber = function(columnTitle) {\\n    return columnTitle.split(\"\").reverse().reduce((acum, ch, i) => {\\n        const charValue = ch.charCodeAt(0) - 64;\\n        return acum + (charValue*(26**i));\\n    },0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790682,
                "title": "js-using-reduce-and-math-pow",
                "content": "\\n\\n```\\nconst titleToNumber = s => s.split(\\'\\').reduce((a,e,i)=> a+=Math.pow(26,s.length-i-1)*alphabet[e] , 0)\\n    \\nconst alphabet={\\n        \\'A\\':1,\\n        \\'B\\':2,\\n        \\'C\\':3,\\n        \\'D\\':4,\\n        \\'E\\':5,\\n        \\'F\\':6,\\n        \\'G\\':7,\\n        \\'H\\':8,\\n        \\'I\\':9,\\n        \\'J\\':10,\\n        \\'K\\':11,\\n        \\'L\\':12,\\n        \\'M\\':13,\\n        \\'N\\':14,\\n        \\'O\\':15,\\n        \\'P\\':16,\\n        \\'Q\\':17,\\n        \\'R\\':18,\\n        \\'S\\':19,\\n        \\'T\\':20,\\n        \\'U\\':21,\\n        \\'V\\':22,\\n        \\'W\\':23,\\n        \\'X\\':24,\\n        \\'Y\\':25,\\n        \\'Z\\':26\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst titleToNumber = s => s.split(\\'\\').reduce((a,e,i)=> a+=Math.pow(26,s.length-i-1)*alphabet[e] , 0)\\n    \\nconst alphabet={\\n        \\'A\\':1,\\n        \\'B\\':2,\\n        \\'C\\':3,\\n        \\'D\\':4,\\n        \\'E\\':5,\\n        \\'F\\':6,\\n        \\'G\\':7,\\n        \\'H\\':8,\\n        \\'I\\':9,\\n        \\'J\\':10,\\n        \\'K\\':11,\\n        \\'L\\':12,\\n        \\'M\\':13,\\n        \\'N\\':14,\\n        \\'O\\':15,\\n        \\'P\\':16,\\n        \\'Q\\':17,\\n        \\'R\\':18,\\n        \\'S\\':19,\\n        \\'T\\':20,\\n        \\'U\\':21,\\n        \\'V\\':22,\\n        \\'W\\':23,\\n        \\'X\\':24,\\n        \\'Y\\':25,\\n        \\'Z\\':26\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790645,
                "title": "easy-c-sol-faster-than-100-sol-o-n-time",
                "content": "```\\n class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {  // Time : O(N) :::: Aux_Space: O(1)\\n        \\n        int res = 0;\\n        \\n        for(auto x: columnTitle){\\n            int d = x - \\'A\\' + 1;\\n            res = res*26 + d;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {  // Time : O(N) :::: Aux_Space: O(1)\\n        \\n        int res = 0;\\n        \\n        for(auto x: columnTitle){\\n            int d = x - \\'A\\' + 1;\\n            res = res*26 + d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1790643,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n         int ans = 0;\\n        for(int i = 0 ; i < columnTitle.length();i++){\\n            ans= ans*26 + (columnTitle[i] - \\'A\\' + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n         int ans = 0;\\n        for(int i = 0 ; i < columnTitle.length();i++){\\n            ans= ans*26 + (columnTitle[i] - \\'A\\' + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790494,
                "title": "simple-rust",
                "content": "```\\nimpl Solution {\\n    pub fn title_to_number(column_title: String) -> i32 {\\n        column_title\\n        .chars()\\n        .map(|c| c as i32 - \\'A\\' as i32 + 1)\\n        .fold(0, |prev, next| prev * 26 + next)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn title_to_number(column_title: String) -> i32 {\\n        column_title\\n        .chars()\\n        .map(|c| c as i32 - \\'A\\' as i32 + 1)\\n        .fold(0, |prev, next| prev * 26 + next)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790438,
                "title": "beginner-friendly-python-soluiton",
                "content": "**Time Complexity : O(n)**\\n```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        position = 0\\n        for c in columnTitle:\\n            position = position*26 + ord(c) - ord(\"A\") + 1\\n        return position\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def titleToNumber(self, columnTitle):\\n        position = 0\\n        for c in columnTitle:\\n            position = position*26 + ord(c) - ord(\"A\") + 1\\n        return position\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790431,
                "title": "beginner-friendly-java-solution",
                "content": "**Approach 1 :**\\nTime Complexity : O(n)\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int position = 0;\\n        for(int i=0; i<columnTitle.length(); i++){\\n            position = position*26;\\n            for(int j=\\'A\\'; j<=\\'Z\\'; j++){\\n                position++;\\n                if(j == columnTitle.charAt(i))   \\n                    break;\\n            }\\n        }\\n        return position;\\n    }\\n}\\n```\\n\\n\\n**Approach 2 :**\\nTime Complexity : O(n)\\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int position = 0;\\n        for(char c : columnTitle.toCharArray()){\\n            position = position * 26 + (int) c - (int) \\'A\\' + 1;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int position = 0;\\n        for(int i=0; i<columnTitle.length(); i++){\\n            position = position*26;\\n            for(int j=\\'A\\'; j<=\\'Z\\'; j++){\\n                position++;\\n                if(j == columnTitle.charAt(i))   \\n                    break;\\n            }\\n        }\\n        return position;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int position = 0;\\n        for(char c : columnTitle.toCharArray()){\\n            position = position * 26 + (int) c - (int) \\'A\\' + 1;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790212,
                "title": "c-0ms-solution-3-lines-of-code",
                "content": "\\n```\\nint titleToNumber(string columnTitle) {\\n    int res=0;\\n    for(auto &c:columnTitle) res=res26+(c-\\'A\\'+1);\\n    return res;\\n}\\n```\\n\\n**Please upvote :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint titleToNumber(string columnTitle) {\\n    int res=0;\\n    for(auto &c:columnTitle) res=res26+(c-\\'A\\'+1);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762011,
                "title": "java-solution-1ms-runtime",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int value = 0;\\n        for (int i = 0; i < columnTitle.length(); i++) {\\n            value += charToValue(columnTitle.charAt(i), columnTitle.length() - i);\\n        }\\n        return value;\\n    }\\n    \\n    public int charToValue(char letter, int place) {\\n        int value = Character.getNumericValue(letter) - 9;\\n        if (place == 1) return value;\\n        value *= Math.pow(26, place - 1);\\n        return value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n        int value = 0;\\n        for (int i = 0; i < columnTitle.length(); i++) {\\n            value += charToValue(columnTitle.charAt(i), columnTitle.length() - i);\\n        }\\n        return value;\\n    }\\n    \\n    public int charToValue(char letter, int place) {\\n        int value = Character.getNumericValue(letter) - 9;\\n        if (place == 1) return value;\\n        value *= Math.pow(26, place - 1);\\n        return value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570582,
                "title": "c-solution-4-ms-5-9-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        long long int pow = 1; \\n        for (int i = columnTitle.size() - 1; i >= 0; i--) {\\n            ans += (columnTitle[i] - 64) * pow;\\n            pow *= 26;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        long long int pow = 1; \\n        for (int i = columnTitle.size() - 1; i >= 0; i--) {\\n            ans += (columnTitle[i] - 64) * pow;\\n            pow *= 26;\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403465,
                "title": "easy-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        long long pow = 1;\\n        int n = columnTitle.size();\\n        for(int i=n-1; i>=0; i--) {\\n            ans += (columnTitle[i] - 64)*pow;\\n            pow = pow*26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string columnTitle) {\\n        int ans = 0;\\n        long long pow = 1;\\n        int n = columnTitle.size();\\n        for(int i=n-1; i>=0; i--) {\\n            ans += (columnTitle[i] - 64)*pow;\\n            pow = pow*26;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371512,
                "title": "c-linq-one-liner",
                "content": "One liner solution in C# using LINQ. Using the `Aggregate` function here (think of reduce in Map and Reduce). \\n\\n```csharp\\npublic int TitleToNumber(string columnTitle) {\\n\\treturn columnTitle.Aggregate(0, (acc, x) => {\\n\\t\\treturn (acc * 26) + x - \\'A\\' + 1;\\n\\t});\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int TitleToNumber(string columnTitle) {\\n\\treturn columnTitle.Aggregate(0, (acc, x) => {\\n\\t\\treturn (acc * 26) + x - \\'A\\' + 1;\\n\\t});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309279,
                "title": "my-easy-and-clear-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n       char[] res =  columnTitle.toCharArray();\\n        int sum =0;\\n        for(int i=0; i<res.length; i++){\\n            int temp = res[i];\\n            sum = sum*26 + (temp - 64);\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int titleToNumber(String columnTitle) {\\n       char[] res =  columnTitle.toCharArray();\\n        int sum =0;\\n        for(int i=0; i<res.length; i++){\\n            int temp = res[i];\\n            sum = sum*26 + (temp - 64);\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243171,
                "title": "c-iterative-and-recursive-solution",
                "content": "##### 1) Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint titleToNumber(string columnTitle) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(i < columnTitle.size()){\\n\\t\\t\\t\\tres =  res * 26 + (columnTitle[i] - (\\'A\\' - 1));\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n##### 2) Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint titleToNumber(string columnTitle) {\\n\\t\\t\\tint len = columnTitle.size();\\n\\t\\t\\tif(len == 0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(len == 1){\\n\\t\\t\\t\\treturn columnTitle[0] - (\\'A\\' - 1);\\n\\t\\t\\t}\\n\\t\\t\\tint smallAns = columnTitle[len - 1] - (\\'A\\' - 1);  \\n\\t\\t\\treturn smallAns + 26 * titleToNumber(columnTitle.substr(0, len - 1));        \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint titleToNumber(string columnTitle) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(i < columnTitle.size()){\\n\\t\\t\\t\\tres =  res * 26 + (columnTitle[i] - (\\'A\\' - 1));\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1226737,
                "title": "python3-very-easy-solution-with-counting-in-the-26-number-system",
                "content": "```\\n def titleToNumber(self, columnTitle: str) -> int:\\n        \\n        \"\"\"\\n        instead of using the 10 system for counting\\n        we are using the 26 system\\n        \\n        so ABC would be  1*26^2 + 2*26 + 3.\\n        \\n        \\n        A--> 1, ..., Z--> 26\\n        \\n        So we just just count in a serial way.\\n        \\n        \\n        \"\"\"\\n        \\n        letters = list(string.ascii_lowercase)\\n        \\n        mapping = {i:j for j, i in enumerate(letters, start = 1)}\\n        \\n        count = 0\\n        \\n        for i, st in enumerate(columnTitle.lower()[::-1]):\\n            count += mapping[st]*26**i\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n def titleToNumber(self, columnTitle: str) -> int:\\n        \\n        \"\"\"\\n        instead of using the 10 system for counting\\n        we are using the 26 system\\n        \\n        so ABC would be  1*26^2 + 2*26 + 3.\\n        \\n        \\n        A--> 1, ..., Z--> 26\\n        \\n        So we just just count in a serial way.\\n        \\n        \\n        \"\"\"\\n        \\n        letters = list(string.ascii_lowercase)\\n        \\n        mapping = {i:j for j, i in enumerate(letters, start = 1)}\\n        \\n        count = 0\\n        \\n        for i, st in enumerate(columnTitle.lower()[::-1]):\\n            count += mapping[st]*26**i\\n            \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1217832,
                "title": "1ms-java-solution-beats-100-submission",
                "content": "```\\n  \\tpublic int titleToNumber(String columnTitle) {\\n\\n\\t\\tint n = columnTitle.length();\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn findCharNumber(columnTitle.charAt(0));\\n\\t\\t}\\n\\t\\tint runningSum = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\trunningSum = (runningSum * 26) + findCharNumber(columnTitle.charAt(i));\\n\\t\\t}\\n\\n\\t\\treturn runningSum;\\n\\t}\\n\\n\\tprivate int findCharNumber(char ch) {\\n\\t\\treturn ch - \\'A\\' + 1;\\n\\t}\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  \\tpublic int titleToNumber(String columnTitle) {\\n\\n\\t\\tint n = columnTitle.length();\\n\\n\\t\\tif (n == 1) {\\n\\t\\t\\treturn findCharNumber(columnTitle.charAt(0));\\n\\t\\t}\\n\\t\\tint runningSum = 0;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\trunningSum = (runningSum * 26) + findCharNumber(columnTitle.charAt(i));\\n\\t\\t}\\n\\n\\t\\treturn runningSum;\\n\\t}\\n\\n\\tprivate int findCharNumber(char ch) {\\n\\t\\treturn ch - \\'A\\' + 1;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118170,
                "title": "fastest-no-array-or-hashmap-0-ms-java-with-comments",
                "content": "```\\n public int titleToNumber(String columnTitle) {\\n        \\n        int sum = 0;\\n        for(int i = columnTitle.length() - 1; i >= 0 ;i--){\\n\\t\\t   //ASCII of A is 65 and of Z is 91 , we will map it to 1-26 by subtracting 64\\n            //Using ASCII  values to map it to 1,2,3 \\n\\t\\t\\t//A = 65-64 = 1\\n\\t\\t\\t//B = 66 - 64 = 2 and so on\\n            sum += Math.pow(26, (columnTitle.length() - i - 1))* (columnTitle.charAt(i) - 64);\\n\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int titleToNumber(String columnTitle) {\\n        \\n        int sum = 0;\\n        for(int i = columnTitle.length() - 1; i >= 0 ;i--){\\n\\t\\t   //ASCII of A is 65 and of Z is 91 , we will map it to 1-26 by subtracting 64\\n            //Using ASCII  values to map it to 1,2,3 \\n\\t\\t\\t//A = 65-64 = 1\\n\\t\\t\\t//B = 66 - 64 = 2 and so on\\n            sum += Math.pow(26, (columnTitle.length() - i - 1))* (columnTitle.charAt(i) - 64);\\n\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112769,
                "title": "java-hashmap",
                "content": "\\n```\\npublic int titleToNumber(String columnTitle) {\\n        String[] arrColumn = columnTitle.split(\"\");\\n        \\n        int order = 1;\\n        HashMap<String, Integer> hashMap = new HashMap();\\n        for(char ch = \\'A\\'; ch<=\\'Z\\'; ch++){\\n            hashMap.put(String.valueOf(ch), order);\\n            order++;\\n        }\\n        \\n        int res = 0;\\n        for(int i=0; i<arrColumn.length; i++){\\n            res += hashMap.get(arrColumn[arrColumn.length-1-i])*Math.pow(26, (i));\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int titleToNumber(String columnTitle) {\\n        String[] arrColumn = columnTitle.split(\"\");\\n        \\n        int order = 1;\\n        HashMap<String, Integer> hashMap = new HashMap();\\n        for(char ch = \\'A\\'; ch<=\\'Z\\'; ch++){\\n            hashMap.put(String.valueOf(ch), order);\\n            order++;\\n        }\\n        \\n        int res = 0;\\n        for(int i=0; i<arrColumn.length; i++){\\n            res += hashMap.get(arrColumn[arrColumn.length-1-i])*Math.pow(26, (i));\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067085,
                "title": "5-lines-of-code-with-100-faster-on-online-compiler-any-programming-language",
                "content": "![image](https://assets.leetcode.com/users/images/760498ff-b611-4404-98b5-df8869b16688_1613409259.8730543.png)\\n\\n\\tint ans=0;\\n\\tfor(auto &c:s){\\n\\t\\tans*=26;\\n\\t\\tans+=c-\\'A\\'+1;\\n\\t}\\n\\treturn ans;\\n **Don\\'t Forget to upvote if you like it!**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/760498ff-b611-4404-98b5-df8869b16688_1613409259.8730543.png)\\n\\n\\tint ans=0;\\n\\tfor(auto &c:s){\\n\\t\\tans*=26;\\n\\t\\tans+=c-\\'A\\'+1;\\n\\t}\\n\\treturn ans;\\n **Don\\'t Forget to upvote if you like it!**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1006143,
                "title": "easiest-solution-100-faster-0ms-c-cpp",
                "content": "iterate string from last\\nfor get int value of your string use s[i]-64 because A-Z ASCII value start from 65 to 90, \\nfor eg. value of A in ASCII is 65 and in question there A will be 1 so 65-64 = 1 so we can match A\\'s value as per question\\nthen make ans valriable which will store final ans = ans + value of string * it\\'s power ( intially for 1 string power will be 1) \\nthen make power = power * 26 until string length is increasing\\neg. A = 1;\\nAA = 27 so A + A = (1x1 )+ (26x1) = 27\\nAB = 28 so A + B = (2x1) + (26x1) = 28\\nfor AAA\\nA + A + A = (1*1) + (26x1) + (26x26x1)\\n```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n=s.size();\\n        long long int ans =0;\\n        long long int power =1;\\n        int value;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            value = s[i]-64;\\n            ans += value*power;\\n            power *= 26;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int n=s.size();\\n        long long int ans =0;\\n        long long int power =1;\\n        int value;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            value = s[i]-64;\\n            ans += value*power;\\n            power *= 26;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994759,
                "title": "easy-clear-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int res=0;\\n        for(char x:s){\\n            res*=26;\\n            res+=x-\\'A\\'+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int titleToNumber(string s) {\\n        int res=0;\\n        for(char x:s){\\n            res*=26;\\n            res+=x-\\'A\\'+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564639,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1571373,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1731453,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1565813,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1871892,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1568995,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 2024600,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1987915,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1676495,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1571374,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1564639,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1571373,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1731453,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1565813,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1871892,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1568995,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 2024600,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1987915,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1676495,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            },
            {
                "id": 1571374,
                "content": [
                    {
                        "username": "dengruixistudent",
                        "content": "I was asked of this question during an interview with microsoft. The interviewer asked whether I want a coding question or a brain teaser, I asked for the latter and here comes the question. I did not do it very well at that time, though."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/excel-sheet-column-number/solutions/2780198/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "ralph097",
                        "content": "Treat the column value as a base 26 number. Map A to 1, B to 2..., and Z to 26.\\n\\nYZ = 25*(26^1) + 26*(26^0)\\nXYZ = 24*(26^2) + 25*(26^1) + 26*(26^0)\\n\\nTook me waayyyy too much time to figure it out. Probably too long for an interview."
                    },
                    {
                        "username": "pponsarandev",
                        "content": "Same here... to be honest, it being framed within the context of a spreadsheet threw me off a little bit... once you realize it's similar to a base-26 number system, the answer is trivial"
                    },
                    {
                        "username": "salimshamim",
                        "content": "I have often wondered how alphabets are just base 26 numbers, which helped me quickly do this. But it would have been another story if I hadn\\'t thought about it before."
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Treat it as a problem to convert from one numerical representation to another. For example, Hex to Decimal."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/excel-sheet-column-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Right to Left\n\n  \n**Approach 2:** Left to Right\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "I was confusing with a three-letter word, but then I figured out, check this example\\nFor Example\\nABC = \\nA = 26 * 26 * 1; | 676 \\nB = 26 * 2;         | 52\\nC = 3;                 | 3\\n676 + 52 + 3 = 731\\n"
                    },
                    {
                        "username": "Override",
                        "content": "    public int TitleToNumber(string s) { return s.Aggregate(0, (n, c) => n * 26 + c - 0x40); }"
                    },
                    {
                        "username": "aykhan_eng",
                        "content": "i dont use Exel how does it work?)"
                    },
                    {
                        "username": "matt_lv",
                        "content": "Easy Question \\uD83E\\uDD21"
                    },
                    {
                        "username": "iCantC",
                        "content": "currentCharacter - \\'A\\' + 1 is \\u2764\\uFE0F"
                    },
                    {
                        "username": "naresh_saini",
                        "content": "yes it is also use in trie data structure\\n"
                    },
                    {
                        "username": "Bruce_Ken",
                        "content": "Generally speaking, C/C++ is faster than Java, but in this problem, I see the Solution of Java is faster than \\nC/C++ in average, I don`t know why,  can anyone explain it ?Thanks!"
                    }
                ]
            }
        ]
    }
]