[
    {
        "title": "Time Needed to Rearrange a Binary String",
        "question_content": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.\n&nbsp;\nExample 1:\n\nInput: s = \"0110101\"\nOutput: 4\nExplanation: \nAfter one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation:\nNo occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\n&nbsp;\nFollow up:\nCan you solve this problem in O(n) time complexity?",
        "solutions": [
            {
                "id": 2454262,
                "title": "dp-vs-brute-force",
                "content": "DP is O(n) but could be tricky to figure out; Brute-Force is good enough for the contest since `n <= 1,000`.\\n\\n#### DP\\n\\nWe count \"zeros\" so far. If we have a string `00001`, we need `4` seconds (as we have `4` zeros) to make it `10000`.\\n\\nWe also track `seconds` we need to rearrange first `i` letters.\\n\\nIf `i + 1` letter is `1`, we need at least `seconds + 1` seconds, but not less than `zero` seconds.\\n\\nHere is calculation for the `\"100111110001000001\"` test case:\\n- For `i == 11` (yellow), the result is `7` as we need `6` seconds for `i - 1`.\\n- For `i == 17` (green), the result is `10` as we have `10` zeros, even though we need `7` seconds for `i - 1`.\\n\\n![image](https://assets.leetcode.com/users/images/c15cc22e-885f-47ab-8f67-4225cb40525c_1661020625.9402463.png)\\n\\n**Java**\\n```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1)\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * n) - OK for n <= 1,000. We process `n` characters in the string `n` times in the worst case (`0111...1`).\\n- Memory: O(n) to store an interim string.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454884,
                "title": "no-dp-o-n-time-o-1-space",
                "content": "First off, the final string will be of the form 1111....000.... \\n\\nOne observation is that since a \\'1\\' has to be swapped with every occurence of \\'0\\' to its left, the time taken for that \\'1\\' to reach its final position is atleast the number of zeroes to its left.\\n\\nWhy is it not equal to number of \\'0\\'s to its left ?\\nIn a testcase like \\'011\\' -> \\'101\\' -> \\'110\\', the second \\'1\\' had to wait for the first \\'1\\' in the first turn. \\n\\nThe total number of time taken for a \\'1\\' to reach its final position is number of \\'0\\'s to its left + number of turns it waits.\\n\\nEvery time we come across two consequetive ones, the waiting time increases by one.\\n\\nAnd everytime we come acress two consequetive zeroes, the waiting time decreases by one.\\n( consider 0 1 1 0 0 1  The waiting time for the first \\'1\\' is 0, for the second \\'1\\' is 1 , but for the third \\'1\\' is again 0, because while the second \\'1\\' was waiting, the third \\'1\\' would not waste a turn by moving through the zeroes before it.)\\n\\nAlso, it is obvious that the last occurence of a \\'1\\' is the one that will reach its destination the last. \\nSo we just have to find the number of zeroes to the left of it + its waiting time\\n\\nPython:\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454195,
                "title": "python3-o-n-dp-approach",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nGiven the size of the problem, it is okay to run a simulation which takes `O(N^2)` to complete. However, a faster `O(N)` DP approach is available. \\nHere, we consider the task as \"moving 1s to the left\". Two key observatoins are \\n1) to move \\'1\\' at `i`th index it takes at least x steps if there are x \\'0\\'s preceeding it. \\n2) if there is a \\'1\\' at \\'i-1\\'st index, it takes at least one more step to move this \\'1\\' to proper position. \\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`\\n```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454526,
                "title": "java-3-lines-easy-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454176,
                "title": "c-brute-force-with-explanation",
                "content": "Upvote if it helps :)\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454424,
                "title": "python-easy-approach-replace-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454160,
                "title": "easy-understanding-python",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454388,
                "title": "c-straightforward-easy-short",
                "content": "![image](https://assets.leetcode.com/users/images/bc6076ed-f081-429f-a169-c78f621230f4_1661011671.1091099.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2467821,
                "title": "c-two-loop-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488547,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454162,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467165,
                "title": "leetcode-the-hard-way-brute-force-approach-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458917,
                "title": "explanation-python-c-simple-and-concise-code",
                "content": "Intituion:\\nWe do the operation untill all the \\'1\\'s and \\'0\\'s are separated and take the count.\\n\\n\\n*  **C++** \\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n* **Python**\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```\\n\\nAppriciate an upvote...",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2795812,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458535,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-5-line-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2380. Time Needed to Rearrange a Binary String***\\nYou are given a binary string s. In one second, all occurrences of `\"01\"` are simultaneously replaced with `\"10\"`. This process repeats until no occurrences of `\"01\"` exist.\\n\\nReturn the number of seconds needed to complete this process.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\\n**Runtime:**  139 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Runtime:**  338 ms\\t\\t\\n**Memory Usage:**  114.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Runtime:** 129 ms\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454989,
                "title": "my-dp-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }\\n      \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\' && zerocnt[i]){\\n                sum = max(sum + 1, zerocnt[i]);\\n            }\\n        }\\n      \\n        \\n        return sum;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3684059,
                "title": "simple-recursive-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process until there is at least 1 swap.\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9d11b9c5-0846-4f56-b069-b501a37463f4_1687765172.989497.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439289,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163010,
                "title": "brute-force-c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032709,
                "title": "queue-solution",
                "content": "# Intuition\\nIdea come from that we can perform some operation and put it to the queue for the next iteration on it ( checking the number of swaps) and so on\\n\\n# Approach\\nInit queue and push the giving string. Start process of swap and push it again the queue\\n\\n# Complexity\\n- Time complexity:\\nO(N) * O(K), where the N is the length of string and K the number of \"seconds\"\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676981,
                "title": "brute-force-approach-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585925,
                "title": "java-no-dp-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489509,
                "title": "single-pass-with-explanation",
                "content": "`jth` \"1\" at index `i` will take at a minimum `i-j` moves to reach `jth` index.\\nFirst incorrectly placed \\'1\\' will take `i-0` steps\\nIf the next \"1\" was right next to it, then it will have to wait a round. To extend it further, each \"1\" will take either `j-i` moves or it will take as many moves as the previous \"1\" takes + 1\\n\\nIf the ones are at indexes [1, 2], then `j-i` for both are [1-0, 2-1]. However, since the first one takes 1 move which is equal to the number of moves taken by the second \"1\", it means that the second \"1\" will have to wait a turn.\\n\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457959,
                "title": "3-lines-of-code-easy-and-simple-c-java",
                "content": "**Time Needed to Rearrange a Binary String Solution :**\\n.\\n.\\n**In Java :**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457634,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456398,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456280,
                "title": "go-solution",
                "content": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455850,
                "title": "easy-approach-c-no-dp-simple-solution-beginners-friendly",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455588,
                "title": "c-brute-force-solution-easy-to-understand",
                "content": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2454917,
                "title": "easy-o-n-2-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454387,
                "title": "no-math-solution",
                "content": "I spent my whole time finding a math solution for this question. Is there any?\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2454358,
                "title": "simple-beginner-friendly-c-solution-o-n-2",
                "content": "**Upvote if You Like**\\n```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454340,
                "title": "loop-until-all-ones-placed-at-left-side-and-zeros-places-right-side",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454319,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454264,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }\\n            }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            k++;\\n        }\\n        return k;\\n    }\\n    public void task(char c[], int i, int j)\\n    {\\n        char d=c[i];\\n        c[i]=c[j];\\n        c[j]=d;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454241,
                "title": "python-7-lines",
                "content": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454214,
                "title": "c-brute-force-dp-o-n-time",
                "content": "**Method 1: Brute force**\\nTime O(n^2)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\\n**Method 2: DP**\\nTime O(n)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724659,
                "title": "tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439219,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253347,
                "title": "python3-easy-with-string-replace",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930334,
                "title": "runtime-35ms-memory-13-8mb-python-solution",
                "content": "# Approach\\n- The last \"1\" will take the longest time to travel to its destination in the string, which is the number of \"0\"s infront. \\n- The special case is when \"1\" is right next to another \"1\", which will add one more step for the second 1 to move to the right.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864901,
                "title": "simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                if(zero>0)\\n                ans = Math.max(ans+1, zero);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2677222,
                "title": "python-beginner-easy-81-faster",
                "content": "**Please upvode if it helps...**\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2675000,
                "title": "brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605893,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```\\nDo upvote if you find helpful !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558947,
                "title": "c-don-t-know-the-time-complexity-simple-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554095,
                "title": "rust-0-ms-functional-style-one-liner-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/795590438/) employs a functional-style approach to scan the string and count swaps. It demonstrated **0 ms runtime (100%)** and used **2.0 MB memory (83.87%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482625,
                "title": "2-appoach-dp-o-n-bruteforce-o-n-n",
                "content": "DP APPROACH\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\\n\\nBRUTE FORCE :\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478370,
                "title": "python-brute-force-step-by-step-solution-small-solution",
                "content": "### **Brute Force Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\\n\\n### **Easy & Small Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466135,
                "title": "java-solution-2-3-ms",
                "content": "1. Any **\"1\"** needs to pass all **\"0\"** before it. -> Count the number of **\"0\"**\\n2. **00 ... 00 111**\\n* Suppose first **\"1\"** need **m** steps to pass all **\"0\"** before it.\\n* Second **\"1\"** need **m+1** steps\\n* Third **\"1\"** need **m+2** steps\\n* Summary: count steps of previous **\"1\"** + 1\\n3. **00 ... 00 1 00 ... 00 1**\\n* Suppose the number of **\"0\"** between **\"1\"** s are **n** and first **\"1\"** need **m** steps\\n* If there is a X, X >= n and X < m, String s becomes **00 ... 00 11 00 ... 00** after X steps and Y is the remaining steps for first **\"1\"** to pass all **\"0\"**\\n* The remaining steps of second **\"1\"** is Y+1 -> the total steps of second **\"1\"** is X+Y+1 = m+1\\n* If X does not exist, count zeros before it because first **\"1\"** won\\'t impact second **\"1\"**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459556,
                "title": "easy-to-understand-c-simple",
                "content": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }\\n            if(z>0)\\n            {\\n                 for(int j=0;j<s.size()-1;j++)\\n                 {\\n                     if(s[j]==\\'0\\' && s[j+1]==\\'1\\')\\n                     {\\n                            s[j]=\\'1\\';\\n                           s[j+1]=\\'0\\';\\n                           j++;\\n                     }\\n                 }\\n              \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n           \\n        }\\n       return c;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2459235,
                "title": "java-bruteforce-approach",
                "content": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458555,
                "title": "c-brute-force-solution-74-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nplease upvote if post is helpful for you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458298,
                "title": "java-easy-approach-less-space-complexity",
                "content": "It is a very easy approach just, we have to do one thing that if \"01\" is present in the string, then replace it with \"10\" untill all \"01\" is vanished. \\n\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458069,
                "title": "o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2458003,
                "title": "java-ac-solution-60-faster",
                "content": "\\n\\t \\n\\t class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            } \\n            i++;\\n        }\\n            if(change==true)\\n            {\\n              c++;\\n              change = false;\\n            }\\n            else if(change == false){\\n                break;\\n            }\\n            \\n            \\n        }\\n        return c;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457683,
                "title": "python3-for-beiginners",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456194,
                "title": "python-o-n",
                "content": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "solutionTags": [],
                "code": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 2456038,
                "title": "javascript-brute-force",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455948,
                "title": "simple-rust-solution-explained-2ms-o-n-time-o-1-mem",
                "content": "Firstly, we need to understand that in this problem we need to find how many steps will it take the rightmost one to travel all the way to the left. \\n\\nImagine input `00001`: one needs to travel to the left as many steps as there are zeroes before it. If there are some ones in the very beginning they won\\'t make a difference: `11100001`, so we ignore all the ones before the first zero. \\n\\nThen the question is what happens if there are two ones in a row: `000011`. Second one is blocked on the very first step, but then it can travel in parallel with the first one. So, it will always be 1 step slower than the previous one. Note, that it still needs to travel as many steps as there are zeroes before it + maybe get blocked by other ones. \\n\\nIf there are few blocks of ones interchanged with zeroes it doesn\\'t really change anything. If our last one catches up with a block of ones (`011.111.001 -> 110.111.100 -> 111.110.100` - dots just for visibility) it will need at least 1 more second than the previous one, but not less than number of zeroes (ex. `011.111.000000000000000001`).\\n\\n\\n```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455367,
                "title": "java-simple-solution-clean-code-easy-approach",
                "content": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455308,
                "title": "cpp-java-python-dp-brute-force-tc-0-n-2-o-n-sc-o-n-o-1",
                "content": "**Please Upvote, If you like this solutions.**\\n\\n```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\\n\\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```\\n\\n**Thank you...**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455044,
                "title": "c-solution-using-two-loops",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454872,
                "title": "c-easy-solution-by-swaping",
                "content": "**C++ Code:**\\n\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454742,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i+=2;\\n                }\\n                else i++;\\n            }      \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2454731,
                "title": "java-easy-understanding-o-n-2",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454695,
                "title": "best-java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454658,
                "title": "c-easy-beginner",
                "content": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2454548,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2454486,
                "title": "easy-and-concise-java-solution",
                "content": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454464,
                "title": "easy-solution",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454438,
                "title": "java-easy-solution",
                "content": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454393,
                "title": "c",
                "content": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "solutionTags": [],
                "code": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454316,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454295,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                changes = false;\\n        }\\n        return sec;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454293,
                "title": "cpp-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```\\n\\n\\nSimilar to Rotting oranges \\n\\n**Please Upvote!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454190,
                "title": "intutive-solution-using-stack-easy-to-understand",
                "content": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454180,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056868,
                "title": "the-real-bruteforce-solution-self-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4032305,
                "title": "go-dp-80-faster-100-less-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028005,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966171,
                "title": "c-simple-beginner-friendly-do-upvote-if-the-solution-helped-u",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923545,
                "title": "java-optimized-solution-bubble-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909426,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906406,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853046,
                "title": "worst-solution-ever-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845360,
                "title": "1-nested-loop-to-speed-up-and-in-place-replacing-to-reduce-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812224,
                "title": "brute-force-c-o-n-2-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform the replacement process and count number of iterations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a sliding window to keep track of whether a \"01\" sequence exists and replace it if so, continue until no further \"01\" sequence exists.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628857,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565584,
                "title": "ruby-w-reduce",
                "content": "\\n```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3540886,
                "title": "easy-in-java-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538129,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490329,
                "title": "solve-the-problem-in-typescript-it-s-very-inefficient-from-the-looks-of-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to use a recursive function to iterate over the string and replace all occurrences of \"01\" with \"10\". The recursive function starts by checking if the current character is less than the next character. If it is, then the recursive function replaces the current character and the next character with \"10\". The recursive function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\".\\n\\nThe intuition behind this algorithm is that it is more efficient to replace all occurrences of \"01\" in one step than to do it one at a time. By using a recursive function, we can avoid having to do the same work over and over again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach of this algorithm is to recursively iterate over the string and replace all occurrences of \"01\" with \"10\". The algorithm starts by calling the count() function with the original string. The count() function iterates over the string, and for each character, it checks if the next character is less than it. If the next character is less than it, then the count() function replaces the current character and the next character with \"10\". The count() function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\". The number of steps taken by the algorithm is the number of times the count() function is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the algorithm is $$O(n)$$ where n is the length of the string, because it takes linear time to iterate over the string and replace all occurrences of \"01\" with \"10\".\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is $$O(1)$$  because it only uses constant space to store the current string and the number of steps taken\\n\\n# Code\\n```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489805,
                "title": "recursion-for-fun",
                "content": "\\n```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486712,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486711,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482087,
                "title": "o-n-time-o-1-space-c-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457443,
                "title": "easy-brute-force-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDone it Using brute force and simple sliding window with Every pass\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414865,
                "title": "java-solution-brute-force-approach-dp-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(n^2)$$ $$replace() method takes O(n) for each replace $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Brute-Force Code\\n```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### DP Code\\n\\n## \\uD83E\\uDEE1 Inspired by @[votrubac](https://leetcode.com/votrubac/)\\n## [code Link](https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/solutions/2454262/dp-vs-brute-force/?orderBy=most_votes)\\n\\n##### complexity :\\n- Time Compexity : $$O(n)$$\\n- Space Compexity : $$O(1)$$\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n# Happy Coding \\uD83D\\uDC96",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413225,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375961,
                "title": "c-easy-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374059,
                "title": "python-o-n-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust like the brute force approach but using bit manipulation instead of transforming the string.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359385,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n)\\n\\n- Space complexity:\\n  - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303295,
                "title": "here-comes-the-brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283278,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219765,
                "title": "simulation-python3-solution-o-n-2-time",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206965,
                "title": "acc-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203109,
                "title": "java-brute-force-clear-explanations",
                "content": "# Approach\\n1. While there are replaces to be made, traverse the char[] chars of String from 0 to n and replace all 01 with 10. \\nAfter each loop, if changes have been made, increment the steps, break otherwise.\\n2. Return the number of steps.\\n\\n# Complexity\\n- Time complexity:$$O(n * n - worst-case)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196527,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194877,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187791,
                "title": "worst-solution-for-java-aasheesh-63th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![UP vote ki bhik.jpeg](https://assets.leetcode.com/users/images/25b0befb-f6d4-46b1-baa8-c0a53ef3f36d_1676440598.5032725.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166454,
                "title": "easy-python-dp-n-time-complexity",
                "content": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "solutionTags": [],
                "code": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "codeTag": "Java"
            },
            {
                "id": 3159238,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137643,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122250,
                "title": "easy-brute-force-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104832,
                "title": "c-easy-simple-solution",
                "content": "# Dont forget to give it upvote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n![you-upvote-me.webp](https://assets.leetcode.com/users/images/55fd002e-b472-4a22-ac71-3205b8775a2e_1674813108.8949456.webp)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094520,
                "title": "simple-cpp-datta-bayo",
                "content": "Simple BrutForce Solution nothing tough go throgh one dry run you will get it buddy. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086280,
                "title": "concise-java-solution-using-inbuilt-function",
                "content": "\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057262,
                "title": "c-solution",
                "content": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040964,
                "title": "hindi-version-c-easy-approach",
                "content": "The post is in hindi because there are very less post written in HINDI language.\\n\\n# Approach\\nSimply har baar string mein last se traverse karke check karenge ki kya \\'01\\' present hai agar present hai toh replacements karne honge warna number of seconds ko return kardenge. Code mein comments ke through explain kiya hai ek baar read karo and dry run karo saath mein ek case lekar.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N) because worst case 01111 hoga is par dry run karo toh tumhe pata chalega ki string ke through N times jaana padega 0 last position par le jaane ke liye\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\nAgar approach samajh aayi ho and kuch help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025011,
                "title": "string-replace-easy-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015272,
                "title": "easy-to-understand-python-o-n-time-o-1-space",
                "content": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```\\nRuntime: 52.17%\\nMemory: 45.65%",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976460,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925364,
                "title": "recursive-scala-solution",
                "content": "\\n```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2911314,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903199,
                "title": "dart-implementation-o-n-time-o-1-space",
                "content": "# Intuition\\nSimple observation - every second we move \"1\" to the left whenever there is a \"0\" on the left side. If not and there are continues \"11111\" - the rightmost \"1\" waits number of seconds equal to the length of the \"train of 1\" till at least one zero comes on the left and we can start moving it. \\nSo for every \"1\" we can calculate two variables - number of 0-s to swap with and number of 1-s to wait for. Solution if the max( 0-s + 1-s) :-)\\n\\n\\n\\n# Approach\\nAt first we can clean the input string from the leading \"1\"s and tailing \"0\"\\'s since they do not affect result.\\n\\nThen iterate through the remaining string and calculate two variables mentioned above- zero - number of zeros up to the index i, and dup - number of continues \"11111\" to wait for (increased whenever we meet \"11\" and decreased whenever we meet \"00\"). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902460,
                "title": "simple-solution",
                "content": "# Approach\\nRepeat replacing all `\"01\"` with `\"10\"` until all is done. Count and return the times that this process is executed \\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889075,
                "title": "no-string-replace-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nTook me a while and a few iterations to get here. If current 1 encounters or gets blocked the previous 1, then the answer is one more than the previous one. Whether or not current 1 encounters a previous 1 depends on the number of 0s before it.\\n\\n# Approach\\nSimple for loop that keeps track of num0s and previous ans to compute the current answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876822,
                "title": "easy-and-clean-solution-using-simple-approach",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869692,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }\\n        }\\n        return second;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2858463,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\nBased on the description, I realized that the result would always be of the form 111...111000...000. Therefore, I just tried a few examples until I got the pattern and condensed it into a dp solution. Here are 3 examples that I tried that helped me:\\n\\nConsider \"10001\". In this case, it takes the number of zeros\\' seconds, 3 shifts of the 1 to the left to get to \"11000\"\\n\\nNext, consider \"10011\". In this case, we need 2 seconds for the zeros and an additional second for the 1 on the far right. Visually, it looks like this (with a \"wait\" second for the farthest right 1):\\n    10011 -> (\"furthest right waits 1 second\") 10101 -> 11010 -> 11100\\n\\nLastly, consider \"1100011101\". If we just do the arduous work, we can see it takes 6 seconds:\\n    1100011101 -> 1100101110 -> 1101010110 -> 1110101010 -> 1111010100 -> 1111101000 -> 1111110000\\nBreaking it down at each step, as we encounter a 0, that adds one second to the solution, however, each subsequent 1 could potentially add an additional second to the solution depending on the number of zeros we have encountered thus far. Taking the max of each suffices.\\n\\nLastly, our corner cases to explain the if statement in my code: 11111, 111000\\nThe problem states that s[i] is either \\'0\\' or \\'1\\', but doesn\\'t state there have to be both. In either case, the same if statement catches both. Namely, we don\\'t encounter any 0\\'s before 1\\'s, hence the result is 0.\\n\\n# Approach\\n```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where $$n$$ is the length of $$s$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857310,
                "title": "easy-to-understand-python-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854756,
                "title": "video-walkthrough-three-line-solution-python-o-n",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/c9FPc5GNROI)\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851409,
                "title": "python3-intelligent-tracking-of-0s",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850116,
                "title": "here-is-javascript-solution",
                "content": "```\\n\\n```var secondsToRemoveOccurrences = function(s) {\\n    let count=0\\n\\n  while(s.indexOf(\"01\")!=-1)\\n    {\\n        ar=s.split(\"\")\\n        for(let i=0;i<ar.length;i++)\\n            {\\n                if(ar[i]==\"0\" && ar[i+1]==\"1\" )\\n                    {\\n                        ar[i]=\"1\"\\n                        ar[i+1]=\"0\"\\n                        i++\\n                    }\\n            }\\n      \\n      s=ar.join(\"\")\\n      count++\\n   }\\n    return count\\n    \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848029,
                "title": "easiest-java-solution-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837892,
                "title": "simple-well-explained-c-solution",
                "content": "- After completely swapping all the \\'01\\' to \\'10\\', at the end we will get a sorted string in such a way that all the 1\\'s will come before all the 0\\'s. Eg. if a string is \"10111000\" it will become \"11110000\" at the end.\\n- So we will make a temporary string equal to the string we will obtain at the end and run a loop until our original string becomes equal to that string.\\n- Then in each iteration of while loop we will maintain the indices of the 0\\'s who have 1 as the next element and swap them all at once and increment the time needed by 1.\\n- Doing so will give us the answer. \\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805690,
                "title": "brute-force-recursion-2-solutions",
                "content": "### **Brute Force Easy One Two While**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### **Recursion Easy Solution Function calling**\\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794996,
                "title": "normal-solution-for-javascript",
                "content": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2764667,
                "title": "c-o-n-simple-and-intuitive-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749641,
                "title": "dp-bruteforce",
                "content": "*\\'\\'\\'\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }\\n            \\n        }\\n         if(flag == 0) return 0;\\n        return 1 + secondsToRemoveOccurrences(s);\\n    }\\n};\\n\\'\\'\\'*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2749273,
                "title": "javascript-dp-vs-brute",
                "content": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745988,
                "title": "javascript-easy-approach-100-faster-beginners-friendly",
                "content": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738487,
                "title": "easy-brute-force-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735369,
                "title": "c",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728807,
                "title": "python-simple-maths",
                "content": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "solutionTags": [],
                "code": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2719115,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719113,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709322,
                "title": "easy-solution-java-simple-approach-no-dp",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692721,
                "title": "c-solution",
                "content": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1709830,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            },
            {
                "id": 1751017,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            }
        ]
    }
]