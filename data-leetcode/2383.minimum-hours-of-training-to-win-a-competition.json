[
    {
        "title": "Time Needed to Rearrange a Binary String",
        "question_content": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.\n&nbsp;\nExample 1:\n\nInput: s = \"0110101\"\nOutput: 4\nExplanation: \nAfter one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation:\nNo occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\n&nbsp;\nFollow up:\nCan you solve this problem in O(n) time complexity?",
        "solutions": [
            {
                "id": 2454262,
                "title": "dp-vs-brute-force",
                "content": "DP is O(n) but could be tricky to figure out; Brute-Force is good enough for the contest since `n <= 1,000`.\\n\\n#### DP\\n\\nWe count \"zeros\" so far. If we have a string `00001`, we need `4` seconds (as we have `4` zeros) to make it `10000`.\\n\\nWe also track `seconds` we need to rearrange first `i` letters.\\n\\nIf `i + 1` letter is `1`, we need at least `seconds + 1` seconds, but not less than `zero` seconds.\\n\\nHere is calculation for the `\"100111110001000001\"` test case:\\n- For `i == 11` (yellow), the result is `7` as we need `6` seconds for `i - 1`.\\n- For `i == 17` (green), the result is `10` as we have `10` zeros, even though we need `7` seconds for `i - 1`.\\n\\n![image](https://assets.leetcode.com/users/images/c15cc22e-885f-47ab-8f67-4225cb40525c_1661020625.9402463.png)\\n\\n**Java**\\n```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1)\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * n) - OK for n <= 1,000. We process `n` characters in the string `n` times in the worst case (`0111...1`).\\n- Memory: O(n) to store an interim string.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454884,
                "title": "no-dp-o-n-time-o-1-space",
                "content": "First off, the final string will be of the form 1111....000.... \\n\\nOne observation is that since a \\'1\\' has to be swapped with every occurence of \\'0\\' to its left, the time taken for that \\'1\\' to reach its final position is atleast the number of zeroes to its left.\\n\\nWhy is it not equal to number of \\'0\\'s to its left ?\\nIn a testcase like \\'011\\' -> \\'101\\' -> \\'110\\', the second \\'1\\' had to wait for the first \\'1\\' in the first turn. \\n\\nThe total number of time taken for a \\'1\\' to reach its final position is number of \\'0\\'s to its left + number of turns it waits.\\n\\nEvery time we come across two consequetive ones, the waiting time increases by one.\\n\\nAnd everytime we come acress two consequetive zeroes, the waiting time decreases by one.\\n( consider 0 1 1 0 0 1  The waiting time for the first \\'1\\' is 0, for the second \\'1\\' is 1 , but for the third \\'1\\' is again 0, because while the second \\'1\\' was waiting, the third \\'1\\' would not waste a turn by moving through the zeroes before it.)\\n\\nAlso, it is obvious that the last occurence of a \\'1\\' is the one that will reach its destination the last. \\nSo we just have to find the number of zeroes to the left of it + its waiting time\\n\\nPython:\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454195,
                "title": "python3-o-n-dp-approach",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nGiven the size of the problem, it is okay to run a simulation which takes `O(N^2)` to complete. However, a faster `O(N)` DP approach is available. \\nHere, we consider the task as \"moving 1s to the left\". Two key observatoins are \\n1) to move \\'1\\' at `i`th index it takes at least x steps if there are x \\'0\\'s preceeding it. \\n2) if there is a \\'1\\' at \\'i-1\\'st index, it takes at least one more step to move this \\'1\\' to proper position. \\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`\\n```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454526,
                "title": "java-3-lines-easy-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454176,
                "title": "c-brute-force-with-explanation",
                "content": "Upvote if it helps :)\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454424,
                "title": "python-easy-approach-replace-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454160,
                "title": "easy-understanding-python",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454388,
                "title": "c-straightforward-easy-short",
                "content": "![image](https://assets.leetcode.com/users/images/bc6076ed-f081-429f-a169-c78f621230f4_1661011671.1091099.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2467821,
                "title": "c-two-loop-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488547,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454162,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467165,
                "title": "leetcode-the-hard-way-brute-force-approach-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458917,
                "title": "explanation-python-c-simple-and-concise-code",
                "content": "Intituion:\\nWe do the operation untill all the \\'1\\'s and \\'0\\'s are separated and take the count.\\n\\n\\n*  **C++** \\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n* **Python**\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```\\n\\nAppriciate an upvote...",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2795812,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458535,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-5-line-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2380. Time Needed to Rearrange a Binary String***\\nYou are given a binary string s. In one second, all occurrences of `\"01\"` are simultaneously replaced with `\"10\"`. This process repeats until no occurrences of `\"01\"` exist.\\n\\nReturn the number of seconds needed to complete this process.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\\n**Runtime:**  139 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Runtime:**  338 ms\\t\\t\\n**Memory Usage:**  114.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Runtime:** 129 ms\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454989,
                "title": "my-dp-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }\\n      \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\' && zerocnt[i]){\\n                sum = max(sum + 1, zerocnt[i]);\\n            }\\n        }\\n      \\n        \\n        return sum;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3684059,
                "title": "simple-recursive-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process until there is at least 1 swap.\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9d11b9c5-0846-4f56-b069-b501a37463f4_1687765172.989497.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439289,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163010,
                "title": "brute-force-c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032709,
                "title": "queue-solution",
                "content": "# Intuition\\nIdea come from that we can perform some operation and put it to the queue for the next iteration on it ( checking the number of swaps) and so on\\n\\n# Approach\\nInit queue and push the giving string. Start process of swap and push it again the queue\\n\\n# Complexity\\n- Time complexity:\\nO(N) * O(K), where the N is the length of string and K the number of \"seconds\"\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676981,
                "title": "brute-force-approach-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585925,
                "title": "java-no-dp-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489509,
                "title": "single-pass-with-explanation",
                "content": "`jth` \"1\" at index `i` will take at a minimum `i-j` moves to reach `jth` index.\\nFirst incorrectly placed \\'1\\' will take `i-0` steps\\nIf the next \"1\" was right next to it, then it will have to wait a round. To extend it further, each \"1\" will take either `j-i` moves or it will take as many moves as the previous \"1\" takes + 1\\n\\nIf the ones are at indexes [1, 2], then `j-i` for both are [1-0, 2-1]. However, since the first one takes 1 move which is equal to the number of moves taken by the second \"1\", it means that the second \"1\" will have to wait a turn.\\n\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457959,
                "title": "3-lines-of-code-easy-and-simple-c-java",
                "content": "**Time Needed to Rearrange a Binary String Solution :**\\n.\\n.\\n**In Java :**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457634,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456398,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456280,
                "title": "go-solution",
                "content": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455850,
                "title": "easy-approach-c-no-dp-simple-solution-beginners-friendly",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455588,
                "title": "c-brute-force-solution-easy-to-understand",
                "content": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2454917,
                "title": "easy-o-n-2-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454387,
                "title": "no-math-solution",
                "content": "I spent my whole time finding a math solution for this question. Is there any?\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2454358,
                "title": "simple-beginner-friendly-c-solution-o-n-2",
                "content": "**Upvote if You Like**\\n```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454340,
                "title": "loop-until-all-ones-placed-at-left-side-and-zeros-places-right-side",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454319,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454264,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }\\n            }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            k++;\\n        }\\n        return k;\\n    }\\n    public void task(char c[], int i, int j)\\n    {\\n        char d=c[i];\\n        c[i]=c[j];\\n        c[j]=d;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454241,
                "title": "python-7-lines",
                "content": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454214,
                "title": "c-brute-force-dp-o-n-time",
                "content": "**Method 1: Brute force**\\nTime O(n^2)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\\n**Method 2: DP**\\nTime O(n)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724659,
                "title": "tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439219,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253347,
                "title": "python3-easy-with-string-replace",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930334,
                "title": "runtime-35ms-memory-13-8mb-python-solution",
                "content": "# Approach\\n- The last \"1\" will take the longest time to travel to its destination in the string, which is the number of \"0\"s infront. \\n- The special case is when \"1\" is right next to another \"1\", which will add one more step for the second 1 to move to the right.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864901,
                "title": "simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                if(zero>0)\\n                ans = Math.max(ans+1, zero);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2677222,
                "title": "python-beginner-easy-81-faster",
                "content": "**Please upvode if it helps...**\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2675000,
                "title": "brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605893,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```\\nDo upvote if you find helpful !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558947,
                "title": "c-don-t-know-the-time-complexity-simple-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554095,
                "title": "rust-0-ms-functional-style-one-liner-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/795590438/) employs a functional-style approach to scan the string and count swaps. It demonstrated **0 ms runtime (100%)** and used **2.0 MB memory (83.87%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482625,
                "title": "2-appoach-dp-o-n-bruteforce-o-n-n",
                "content": "DP APPROACH\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\\n\\nBRUTE FORCE :\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478370,
                "title": "python-brute-force-step-by-step-solution-small-solution",
                "content": "### **Brute Force Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\\n\\n### **Easy & Small Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466135,
                "title": "java-solution-2-3-ms",
                "content": "1. Any **\"1\"** needs to pass all **\"0\"** before it. -> Count the number of **\"0\"**\\n2. **00 ... 00 111**\\n* Suppose first **\"1\"** need **m** steps to pass all **\"0\"** before it.\\n* Second **\"1\"** need **m+1** steps\\n* Third **\"1\"** need **m+2** steps\\n* Summary: count steps of previous **\"1\"** + 1\\n3. **00 ... 00 1 00 ... 00 1**\\n* Suppose the number of **\"0\"** between **\"1\"** s are **n** and first **\"1\"** need **m** steps\\n* If there is a X, X >= n and X < m, String s becomes **00 ... 00 11 00 ... 00** after X steps and Y is the remaining steps for first **\"1\"** to pass all **\"0\"**\\n* The remaining steps of second **\"1\"** is Y+1 -> the total steps of second **\"1\"** is X+Y+1 = m+1\\n* If X does not exist, count zeros before it because first **\"1\"** won\\'t impact second **\"1\"**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459556,
                "title": "easy-to-understand-c-simple",
                "content": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }\\n            if(z>0)\\n            {\\n                 for(int j=0;j<s.size()-1;j++)\\n                 {\\n                     if(s[j]==\\'0\\' && s[j+1]==\\'1\\')\\n                     {\\n                            s[j]=\\'1\\';\\n                           s[j+1]=\\'0\\';\\n                           j++;\\n                     }\\n                 }\\n              \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n           \\n        }\\n       return c;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2459235,
                "title": "java-bruteforce-approach",
                "content": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458555,
                "title": "c-brute-force-solution-74-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nplease upvote if post is helpful for you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458298,
                "title": "java-easy-approach-less-space-complexity",
                "content": "It is a very easy approach just, we have to do one thing that if \"01\" is present in the string, then replace it with \"10\" untill all \"01\" is vanished. \\n\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458069,
                "title": "o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2458003,
                "title": "java-ac-solution-60-faster",
                "content": "\\n\\t \\n\\t class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            } \\n            i++;\\n        }\\n            if(change==true)\\n            {\\n              c++;\\n              change = false;\\n            }\\n            else if(change == false){\\n                break;\\n            }\\n            \\n            \\n        }\\n        return c;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457683,
                "title": "python3-for-beiginners",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456194,
                "title": "python-o-n",
                "content": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "solutionTags": [],
                "code": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 2456038,
                "title": "javascript-brute-force",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455948,
                "title": "simple-rust-solution-explained-2ms-o-n-time-o-1-mem",
                "content": "Firstly, we need to understand that in this problem we need to find how many steps will it take the rightmost one to travel all the way to the left. \\n\\nImagine input `00001`: one needs to travel to the left as many steps as there are zeroes before it. If there are some ones in the very beginning they won\\'t make a difference: `11100001`, so we ignore all the ones before the first zero. \\n\\nThen the question is what happens if there are two ones in a row: `000011`. Second one is blocked on the very first step, but then it can travel in parallel with the first one. So, it will always be 1 step slower than the previous one. Note, that it still needs to travel as many steps as there are zeroes before it + maybe get blocked by other ones. \\n\\nIf there are few blocks of ones interchanged with zeroes it doesn\\'t really change anything. If our last one catches up with a block of ones (`011.111.001 -> 110.111.100 -> 111.110.100` - dots just for visibility) it will need at least 1 more second than the previous one, but not less than number of zeroes (ex. `011.111.000000000000000001`).\\n\\n\\n```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455367,
                "title": "java-simple-solution-clean-code-easy-approach",
                "content": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455308,
                "title": "cpp-java-python-dp-brute-force-tc-0-n-2-o-n-sc-o-n-o-1",
                "content": "**Please Upvote, If you like this solutions.**\\n\\n```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\\n\\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```\\n\\n**Thank you...**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455044,
                "title": "c-solution-using-two-loops",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454872,
                "title": "c-easy-solution-by-swaping",
                "content": "**C++ Code:**\\n\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454742,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i+=2;\\n                }\\n                else i++;\\n            }      \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2454731,
                "title": "java-easy-understanding-o-n-2",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454695,
                "title": "best-java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454658,
                "title": "c-easy-beginner",
                "content": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2454548,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2454486,
                "title": "easy-and-concise-java-solution",
                "content": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454464,
                "title": "easy-solution",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454438,
                "title": "java-easy-solution",
                "content": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454393,
                "title": "c",
                "content": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "solutionTags": [],
                "code": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454316,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454295,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                changes = false;\\n        }\\n        return sec;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454293,
                "title": "cpp-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```\\n\\n\\nSimilar to Rotting oranges \\n\\n**Please Upvote!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454190,
                "title": "intutive-solution-using-stack-easy-to-understand",
                "content": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454180,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056868,
                "title": "the-real-bruteforce-solution-self-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4032305,
                "title": "go-dp-80-faster-100-less-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028005,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966171,
                "title": "c-simple-beginner-friendly-do-upvote-if-the-solution-helped-u",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923545,
                "title": "java-optimized-solution-bubble-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909426,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906406,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853046,
                "title": "worst-solution-ever-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845360,
                "title": "1-nested-loop-to-speed-up-and-in-place-replacing-to-reduce-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812224,
                "title": "brute-force-c-o-n-2-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform the replacement process and count number of iterations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a sliding window to keep track of whether a \"01\" sequence exists and replace it if so, continue until no further \"01\" sequence exists.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628857,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565584,
                "title": "ruby-w-reduce",
                "content": "\\n```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3540886,
                "title": "easy-in-java-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538129,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490329,
                "title": "solve-the-problem-in-typescript-it-s-very-inefficient-from-the-looks-of-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to use a recursive function to iterate over the string and replace all occurrences of \"01\" with \"10\". The recursive function starts by checking if the current character is less than the next character. If it is, then the recursive function replaces the current character and the next character with \"10\". The recursive function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\".\\n\\nThe intuition behind this algorithm is that it is more efficient to replace all occurrences of \"01\" in one step than to do it one at a time. By using a recursive function, we can avoid having to do the same work over and over again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach of this algorithm is to recursively iterate over the string and replace all occurrences of \"01\" with \"10\". The algorithm starts by calling the count() function with the original string. The count() function iterates over the string, and for each character, it checks if the next character is less than it. If the next character is less than it, then the count() function replaces the current character and the next character with \"10\". The count() function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\". The number of steps taken by the algorithm is the number of times the count() function is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the algorithm is $$O(n)$$ where n is the length of the string, because it takes linear time to iterate over the string and replace all occurrences of \"01\" with \"10\".\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is $$O(1)$$  because it only uses constant space to store the current string and the number of steps taken\\n\\n# Code\\n```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489805,
                "title": "recursion-for-fun",
                "content": "\\n```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486712,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486711,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482087,
                "title": "o-n-time-o-1-space-c-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457443,
                "title": "easy-brute-force-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDone it Using brute force and simple sliding window with Every pass\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414865,
                "title": "java-solution-brute-force-approach-dp-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(n^2)$$ $$replace() method takes O(n) for each replace $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Brute-Force Code\\n```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### DP Code\\n\\n## \\uD83E\\uDEE1 Inspired by @[votrubac](https://leetcode.com/votrubac/)\\n## [code Link](https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/solutions/2454262/dp-vs-brute-force/?orderBy=most_votes)\\n\\n##### complexity :\\n- Time Compexity : $$O(n)$$\\n- Space Compexity : $$O(1)$$\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n# Happy Coding \\uD83D\\uDC96",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413225,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375961,
                "title": "c-easy-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374059,
                "title": "python-o-n-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust like the brute force approach but using bit manipulation instead of transforming the string.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359385,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n)\\n\\n- Space complexity:\\n  - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303295,
                "title": "here-comes-the-brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283278,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219765,
                "title": "simulation-python3-solution-o-n-2-time",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206965,
                "title": "acc-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203109,
                "title": "java-brute-force-clear-explanations",
                "content": "# Approach\\n1. While there are replaces to be made, traverse the char[] chars of String from 0 to n and replace all 01 with 10. \\nAfter each loop, if changes have been made, increment the steps, break otherwise.\\n2. Return the number of steps.\\n\\n# Complexity\\n- Time complexity:$$O(n * n - worst-case)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196527,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194877,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187791,
                "title": "worst-solution-for-java-aasheesh-63th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![UP vote ki bhik.jpeg](https://assets.leetcode.com/users/images/25b0befb-f6d4-46b1-baa8-c0a53ef3f36d_1676440598.5032725.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166454,
                "title": "easy-python-dp-n-time-complexity",
                "content": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "solutionTags": [],
                "code": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "codeTag": "Java"
            },
            {
                "id": 3159238,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137643,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122250,
                "title": "easy-brute-force-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104832,
                "title": "c-easy-simple-solution",
                "content": "# Dont forget to give it upvote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n![you-upvote-me.webp](https://assets.leetcode.com/users/images/55fd002e-b472-4a22-ac71-3205b8775a2e_1674813108.8949456.webp)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094520,
                "title": "simple-cpp-datta-bayo",
                "content": "Simple BrutForce Solution nothing tough go throgh one dry run you will get it buddy. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086280,
                "title": "concise-java-solution-using-inbuilt-function",
                "content": "\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057262,
                "title": "c-solution",
                "content": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040964,
                "title": "hindi-version-c-easy-approach",
                "content": "The post is in hindi because there are very less post written in HINDI language.\\n\\n# Approach\\nSimply har baar string mein last se traverse karke check karenge ki kya \\'01\\' present hai agar present hai toh replacements karne honge warna number of seconds ko return kardenge. Code mein comments ke through explain kiya hai ek baar read karo and dry run karo saath mein ek case lekar.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N) because worst case 01111 hoga is par dry run karo toh tumhe pata chalega ki string ke through N times jaana padega 0 last position par le jaane ke liye\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\nAgar approach samajh aayi ho and kuch help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025011,
                "title": "string-replace-easy-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015272,
                "title": "easy-to-understand-python-o-n-time-o-1-space",
                "content": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```\\nRuntime: 52.17%\\nMemory: 45.65%",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976460,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925364,
                "title": "recursive-scala-solution",
                "content": "\\n```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2911314,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903199,
                "title": "dart-implementation-o-n-time-o-1-space",
                "content": "# Intuition\\nSimple observation - every second we move \"1\" to the left whenever there is a \"0\" on the left side. If not and there are continues \"11111\" - the rightmost \"1\" waits number of seconds equal to the length of the \"train of 1\" till at least one zero comes on the left and we can start moving it. \\nSo for every \"1\" we can calculate two variables - number of 0-s to swap with and number of 1-s to wait for. Solution if the max( 0-s + 1-s) :-)\\n\\n\\n\\n# Approach\\nAt first we can clean the input string from the leading \"1\"s and tailing \"0\"\\'s since they do not affect result.\\n\\nThen iterate through the remaining string and calculate two variables mentioned above- zero - number of zeros up to the index i, and dup - number of continues \"11111\" to wait for (increased whenever we meet \"11\" and decreased whenever we meet \"00\"). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902460,
                "title": "simple-solution",
                "content": "# Approach\\nRepeat replacing all `\"01\"` with `\"10\"` until all is done. Count and return the times that this process is executed \\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889075,
                "title": "no-string-replace-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nTook me a while and a few iterations to get here. If current 1 encounters or gets blocked the previous 1, then the answer is one more than the previous one. Whether or not current 1 encounters a previous 1 depends on the number of 0s before it.\\n\\n# Approach\\nSimple for loop that keeps track of num0s and previous ans to compute the current answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876822,
                "title": "easy-and-clean-solution-using-simple-approach",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869692,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }\\n        }\\n        return second;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2858463,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\nBased on the description, I realized that the result would always be of the form 111...111000...000. Therefore, I just tried a few examples until I got the pattern and condensed it into a dp solution. Here are 3 examples that I tried that helped me:\\n\\nConsider \"10001\". In this case, it takes the number of zeros\\' seconds, 3 shifts of the 1 to the left to get to \"11000\"\\n\\nNext, consider \"10011\". In this case, we need 2 seconds for the zeros and an additional second for the 1 on the far right. Visually, it looks like this (with a \"wait\" second for the farthest right 1):\\n    10011 -> (\"furthest right waits 1 second\") 10101 -> 11010 -> 11100\\n\\nLastly, consider \"1100011101\". If we just do the arduous work, we can see it takes 6 seconds:\\n    1100011101 -> 1100101110 -> 1101010110 -> 1110101010 -> 1111010100 -> 1111101000 -> 1111110000\\nBreaking it down at each step, as we encounter a 0, that adds one second to the solution, however, each subsequent 1 could potentially add an additional second to the solution depending on the number of zeros we have encountered thus far. Taking the max of each suffices.\\n\\nLastly, our corner cases to explain the if statement in my code: 11111, 111000\\nThe problem states that s[i] is either \\'0\\' or \\'1\\', but doesn\\'t state there have to be both. In either case, the same if statement catches both. Namely, we don\\'t encounter any 0\\'s before 1\\'s, hence the result is 0.\\n\\n# Approach\\n```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where $$n$$ is the length of $$s$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857310,
                "title": "easy-to-understand-python-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854756,
                "title": "video-walkthrough-three-line-solution-python-o-n",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/c9FPc5GNROI)\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851409,
                "title": "python3-intelligent-tracking-of-0s",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850116,
                "title": "here-is-javascript-solution",
                "content": "```\\n\\n```var secondsToRemoveOccurrences = function(s) {\\n    let count=0\\n\\n  while(s.indexOf(\"01\")!=-1)\\n    {\\n        ar=s.split(\"\")\\n        for(let i=0;i<ar.length;i++)\\n            {\\n                if(ar[i]==\"0\" && ar[i+1]==\"1\" )\\n                    {\\n                        ar[i]=\"1\"\\n                        ar[i+1]=\"0\"\\n                        i++\\n                    }\\n            }\\n      \\n      s=ar.join(\"\")\\n      count++\\n   }\\n    return count\\n    \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848029,
                "title": "easiest-java-solution-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837892,
                "title": "simple-well-explained-c-solution",
                "content": "- After completely swapping all the \\'01\\' to \\'10\\', at the end we will get a sorted string in such a way that all the 1\\'s will come before all the 0\\'s. Eg. if a string is \"10111000\" it will become \"11110000\" at the end.\\n- So we will make a temporary string equal to the string we will obtain at the end and run a loop until our original string becomes equal to that string.\\n- Then in each iteration of while loop we will maintain the indices of the 0\\'s who have 1 as the next element and swap them all at once and increment the time needed by 1.\\n- Doing so will give us the answer. \\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805690,
                "title": "brute-force-recursion-2-solutions",
                "content": "### **Brute Force Easy One Two While**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### **Recursion Easy Solution Function calling**\\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794996,
                "title": "normal-solution-for-javascript",
                "content": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2764667,
                "title": "c-o-n-simple-and-intuitive-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749641,
                "title": "dp-bruteforce",
                "content": "*\\'\\'\\'\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }\\n            \\n        }\\n         if(flag == 0) return 0;\\n        return 1 + secondsToRemoveOccurrences(s);\\n    }\\n};\\n\\'\\'\\'*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2749273,
                "title": "javascript-dp-vs-brute",
                "content": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745988,
                "title": "javascript-easy-approach-100-faster-beginners-friendly",
                "content": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738487,
                "title": "easy-brute-force-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735369,
                "title": "c",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728807,
                "title": "python-simple-maths",
                "content": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "solutionTags": [],
                "code": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2719115,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719113,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709322,
                "title": "easy-solution-java-simple-approach-no-dp",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692721,
                "title": "c-solution",
                "content": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1709830,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            },
            {
                "id": 1751017,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Shifting Letters II",
        "question_content": "<p>You are given a string <code>s</code> of lowercase English letters and a 2D integer array <code>shifts</code> where <code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>. For every <code>i</code>, <strong>shift</strong> the characters in <code>s</code> from the index <code>start<sub>i</sub></code> to the index <code>end<sub>i</sub></code> (<strong>inclusive</strong>) forward if <code>direction<sub>i</sub> = 1</code>, or shift the characters backward if <code>direction<sub>i</sub> = 0</code>.</p>\n\n<p>Shifting a character <strong>forward</strong> means replacing it with the <strong>next</strong> letter in the alphabet (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>). Similarly, shifting a character <strong>backward</strong> means replacing it with the <strong>previous</strong> letter in the alphabet (wrapping around so that <code>&#39;a&#39;</code> becomes <code>&#39;z&#39;</code>).</p>\n\n<p>Return <em>the final string after all such shifts to </em><code>s</code><em> are applied</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<strong>Output:</strong> &quot;ace&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 1 backward. Now s = &quot;zac&quot;.\nSecondly, shift the characters from index 1 to index 2 forward. Now s = &quot;zbd&quot;.\nFinally, shift the characters from index 0 to index 2 forward. Now s = &quot;ace&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]\n<strong>Output:</strong> &quot;catz&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 0 backward. Now s = &quot;cztz&quot;.\nFinally, shift the characters from index 1 to index 1 forward. Now s = &quot;catz&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2454167,
                "title": "line-sweep-with-explanation",
                "content": "**Explanation:-**\\n\\n1. ```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\\n2. So how you will do?\\n3. ```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\\n4. Can we do better?\\n5. ```Lets create a array from index 0 to 1e5.```\\n6. ```Now iterate over each interval.Eg.:-```\\n7.  ```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\\n8. ``` Now do prefix sum.```\\n9.  This will incerase each position value in linear time.\\n10. In question when we do forward shift then we have to increase the count from position left to right.\\n11.So i will do line[left]++ and line[right+1]--.\\n12. For backward shift we want to decrease the value so\\n13. So i will do line[left]-- and line[right+1]++.\\nI hope you can do question now.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\n```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\n```Lets create a array from index 0 to 1e5.```\n```Now iterate over each interval.Eg.:-```\n```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\n``` Now do prefix sum.```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454158,
                "title": "fenwick-tree-vs-line-sweep",
                "content": "First, we accumulate all shifts. To do that efficiently, we can use a Fenwick Tree or Line Sweep.\\n\\n#### Line Sweep\\nWe add shifts to the beginning and end of each interval. Then, we use a line sweep technique to accumulate shifts for each position in `s`.\\n\\n**C++**\\n```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\\n#### Fenwick Tree\\nFenwick Tree provides is a mutable prefix sum functionality - we can increment all elements in a range, and get a sum of that range in O(log n).\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454324,
                "title": "prefix-sum-range-update-o-n-java-6-ms-100",
                "content": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454359,
                "title": "prefix-sum-c-simple-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454404,
                "title": "python-cumulative-sum-easy-solution",
                "content": "In this problem, we should be doing the exact same thing as in the first part of this problem (shifting letters) but there is an extra complexity of finding the final changes for each of the letters. \\n\\nA brute force approach would be to iterate through all of the letters that need to be changed for each shift in array shifts (e.g., from 0 to 2 in forward direction). However, this adds extra complexity if we have large ranges of letters that need to be changed. This is why we should be using a cumulative sum approach here. \\n\\nFor example, instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454310,
                "title": "c-o-n-scanline-algorithm",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. using \\'Scanline Algorithm\\' to keep track of how a particular shift is affecting a range \\n2. reference video: https://www.youtube.com/watch?v=lFBpH_Mt_LI\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485135,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465791,
                "title": "python3-8-lines-letter-indexing-w-explanation-t-m-100-60",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "codeTag": "Java"
            },
            {
                "id": 2454172,
                "title": "range-update-java",
                "content": "\\n    class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }\\n        //creating the diff array for l-r range update\\n        diff[0]=arr[0];\\n        for(int i=1;i<n;i++){\\n            diff[i]=arr[i]-arr[i-1];\\n        }\\n        for(int p[]:shifts){\\n            int u=p[0];\\n            int v=p[1];\\n            int w=p[2];\\n            //doing the range update\\n            if(w==0){\\n                diff[u]+=(-1);\\n                diff[v+1]-=(-1);\\n            }\\n            else{\\n                diff[u]+=1;\\n                diff[v+1]-=1;\\n            }\\n        }\\n        //updating the array \\n        for(int i=0;i<n;i++){\\n            if(i==0)\\n                arr[i]=diff[i];\\n            else\\n                arr[i]=diff[i]+arr[i-1];  \\n        }\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            //handling the negative value of arr[i]\\n            if(arr[i]<0){\\n                int c=1;\\n                while(Math.abs(arr[i])>(26*c)){\\n                    c++;\\n                }\\n                int temp=26*c;\\n                arr[i]+=temp;\\n            }\\n            //converting into string\\n            str+=(char)((arr[i]%26)+97);\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454260,
                "title": "prefix-sum",
                "content": "**Please Upvote If you got it : )**\\nWe will use prefix sum concept in this problem:\\n\\nWe will perform total three passes:\\n1) In first pass we traverse shifts vector: we will put value in vector,\\n      if(shifts[i][2]==1), then do +=1 at shifts[i][0] index & -=1 at shifts[i][0]+1 index of vector(prefixsum)\\n      else ,do -=1 at shifts[i][0] index & +=1 at shifts[i][0]+1 index of vector(prefixsum)\\n\\n2) In second pass we traverse vector and do prefixsum to find displacement of character at index i\\n\\n3) In third pass we traverse string and shift the character ((s[i]-\\'a\\')+vec[i])%26 places from \\'a\\'\\n   \\n\\n**Time Complexity: 3xO(n)\\nSpaceComplexity: O(n)**\\n\\n**Code:**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455331,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456336,
                "title": "c-difference-array-solution-100-time-305ms-100-space-92mb",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially `50000` `shifts` covering the whole size of `s`, which is of the same size, for a grand total of `250M` operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of `s.size()` elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of `x` across all the values from `a` to `b` (included), we are going to do so just by writing `x` at index `a` and `-x` at index `b + 1` (cancelling the effect of the first change on `a`).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for `\"abcdefgh\"`:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\n\\nThen we decide to increase by `1` all the values from `1` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\n\\nNow we decide to increase by `1` all the values from `4` to `6` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\n\\nNext we decrease by `1` all the values from `2` to `3` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\n\\nFinally we increase by `1` all the values from `3` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\n\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\n\\nThe remaining part of the problem is just how to handle when a character gets shifted past `\\'a\\'` or `\\'z\\'`, but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n* `len` will store the size of `s`;\\n* `diffArray` is where we will store our indexes, creating it with a length of `len + 1` to avoid extra logic on the `-x` mark when applied to the last cell - saving us `shifts.size()` conditional statements for the cost of a couple of bytes;\\n* `dir` will be a support variable for when we iterate `shifts`.\\n\\nWe will then set all the cells of `diffArray` to `0`, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each `shift` in `shifts`, we will:\\n* set `dir` to be `1` if `shift[2]` is also `1`, `-1` otherwise, as specified in the specs;\\n* increase our starting point `diffArray[shift[0]]` by `dir`;\\n* decrease our ending point `diffArray[shift[1] + 1]` by `dir`.\\n\\nWith `diffArray` fully populated, we can now work on `s` and, with our ongoing sum `c` initialised to `0` and for each position `i` in it, we will:\\n* set `c` to increase by `diffArray[i]` (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating `diffArray` in place);\\n*  set `pos` to the value in which we would pick a character in an ideal `\"abcdefghijklmnopqrstuvwxyz\"` string, with the value equal to the original (`s[i]`), minus `\\'a\\'` (to turn it into a value in the `0 - 25` range), plus `c` (so, the final shift for this specific cell);\\n*  we will add `26` to `pos` as long as it is `< 0` to make sure it is within range;\\n*  we will subtract `26` to `pos` as long as it is `> 25` to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\n*  finally, we will set back the value in `s[i]` to be equal to `pos` (our adjusted `0 - 25` final value), plus `\\'a\\'` (to make sure it is again a valid lowercase ASCII character).\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454210,
                "title": "c-solution-using-prefix-array",
                "content": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454194,
                "title": "segment-tree-o-nlog-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494034,
                "title": "python-3-sweep-line-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454995,
                "title": "prefix-sum-and-range-query-python-explanation-o-n",
                "content": "**Explanation**\\nFor a given shift i.e., start, end, direction, we need to shift all ```s[i]``` where ```start<=i<=end```. In other words, we shift ```s[i]``` beginning from ```i=start``` and stop the shifting operation at ```i=end+1```.\\n\\nSo, we create an array ```pos``` that stores the shift operations by marking ```pos[start]``` and ```pos[end+1]```\\n* for ```shift = [start, end, forward_shift]```\\n ```pos[start] += 1```\\n ```pos[end+1] -= 1```\\n \\n* for ```shift = [start, end, backward_shift]```\\n```pos[start] -= 1```\\n```pos[end+1] += 1```\\n\\n\\n**Example**\\n**Given**, ```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\\n**Initially**, ```pos = [0, 0, 0 ,0]```\\n* After accounting  for ```shift=[0, 1, 0]```,  ``` pos = [-1, 0, 1, 0]```\\n* After accounting  for ```shift=[1,2,1]```,  ``` pos =[-1, 1, 1, -1]```\\n* After accounting  for ```shift=[0,2,1]```,  ``` pos = [0, 1, 1, -2]```\\n**Finally**, ```pos = [0, 1, 1, -2]```\\n\\nThe **net shift** of ```s[i]``` = prefix sum of ```pos[i]``` = ```pos[0]+pos[1]+pos[2]+....+pos[i]```\\n\\n\\n**Note:** The ```len(pos)=len(s)+1``` as we mark ```pos[end+1]``` to denote the end of a shift operation.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```\\n\\n**Time Complexity** = **O(n)**, where n=s.length or shifts.length\\n**Space Complexity** = **O(n)**, where n = s.length",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```s[i]```\n```start<=i<=end```\n```s[i]```\n```i=start```\n```i=end+1```\n```pos```\n```pos[start]```\n```pos[end+1]```\n```shift = [start, end, forward_shift]```\n```pos[start] += 1```\n```pos[end+1] -= 1```\n```shift = [start, end, backward_shift]```\n```pos[start] -= 1```\n```pos[end+1] += 1```\n```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\n```pos = [0, 0, 0 ,0]```\n```shift=[0, 1, 0]```\n``` pos = [-1, 0, 1, 0]```\n```shift=[1,2,1]```\n``` pos =[-1, 1, 1, -1]```\n```shift=[0,2,1]```\n``` pos = [0, 1, 1, -2]```\n```pos = [0, 1, 1, -2]```\n```s[i]```\n```pos[i]```\n```pos[0]+pos[1]+pos[2]+....+pos[i]```\n```len(pos)=len(s)+1```\n```pos[end+1]```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475078,
                "title": "easy-understanding-prefix-sum-approach-detailed-aprroach-o-n-c-faster",
                "content": "In Brute force approach , we are traversing left to right and performing operation for each ith shift. So, to optimise the brute force approach , Instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463201,
                "title": "shifting-letters-2-prefix-sum-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\nNow try doing: https://leetcode.com/problems/describe-the-painting/discuss/2463197/Just-like-Shifting-Letters-2.-Prefix-Sum-Trick.-Commented-Code",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458572,
                "title": "segment-tree-lazy-propagation-o-n-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455055,
                "title": "easiest-solution-practice-this-type-of-question-becoming-common",
                "content": "Comment for explanation:-\\nIf you find it helpful upvote\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454949,
                "title": "java-ez-2-understand",
                "content": "for more details refer 2\\nhttps://iq.opengenus.org/multiple-array-range-increments-linear-time/\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }\\n        diff[0]%=26;\\n        for(int i=1;i<n+1;i++){\\n            diff[i]+=diff[i-1];\\n            diff[i]%=26;\\n        }\\n        for(int i=0;i<n;i++){\\n            int ind=arr[i]+diff[i];\\n            if(ind<97)\\n                ind+=26;\\n            if(ind>122)\\n                ind-=26;\\n            arr[i]=(char)ind;\\n        }\\n        return new String(arr);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454760,
                "title": "c-line-sweep-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454332,
                "title": "python-shifts",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291122,
                "title": "easy-prefix-sum-approach-two-approach",
                "content": "**INTUITION :**\\nWe have to increase/decrease every character by one if lying in the given range.\\n\\n# **First Approach (NAIVE TLE) :**\\nThe naive approach would be for evey shift[i] run a loop from shift[i][0] to shift[i][1] and increment or decrement depending upon shift[i][2].\\nThis is a possible solution but give TLE as per the given constraints.\\n\\n**CODE** *(TLE)*\\n```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\\n\\n# **Second Approach (Accepted Sol.)**\\n\\nHere in this Approach we are going to use is ***PREFIX SUM***.\\ncreate a vector of integers (say v) assigh 0 to it,\\nFor every shift   \\n*if shift[i][0] is 1*:\\n* \\tIncrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then decrese v[shift[i][0]+1] by 1\\n\\nif shift[i][0] is 0:\\n* \\tdecrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then increase v[shift[i][0]+1] by 1\\n\\n**Then calculate prefix sum in a differnet array (say psum) of v and for every index increment the character at that index by psum[i].**\\n\\n**CODE**(Accepted Sol.)\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```\\n\\n***TC: O(N)\\nSC: O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/f25f5a63-0b86-48b9-958a-0e189cadd307_1678691732.0941956.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163358,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816587,
                "title": "java-entire-thought-process-working-explained-commented",
                "content": "**I\\'m damn sure, If you read then you\\'ll learn some new insights**\\n**Must read in order to learn, Clean Code at the end of commented one otherwise**\\n\\n```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\\n\\n```\\nImplementation\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\\n\\n\\n```\\nClean Code\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\n```\\nImplementation\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\n```\\nClean Code\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630531,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2519438,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493593,
                "title": "c-line-sweep-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492482,
                "title": "python-3-prefix-sum-explanation",
                "content": "### Explanation\\n- Use prefix sum to avoid extra calculations on overlapped ranges\\n- The key is, for each shift\\n\\t- Accumulate the direction at the beginning of this shift (-1 for left, 1 for right)\\n\\t- Accumulate the inversed direction at the index after the end of this shift (1 for left, -1 for right). This is to cancel out the effect from the shift starting from the beginning index\\n\\t- For example (first example from the problem description):\\n\\t\\t- `s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]`\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\\n\\t\\t- Then we need to accumulate shifts for each index, and do a prefix sum for the next index\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\\n\\t\\t- Now we know, for `s = \"abc\"`:\\n\\t\\t\\t- No shift is needed for index 0, we get `a` \\n\\t\\t\\t- 1 right shift is needed for index 1, we get `c`\\n\\t\\t\\t- 2 right shifts are needed for index 2, we get `e`\\n\\t\\t\\t- The result is `ace`\\n- Time: `O(n), n = len(s)`\\n### Implementation\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\n```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479823,
                "title": "python-brute-force-to-optimised-detailed-explanation",
                "content": "First of all, this problem is an extension of [848. Shifting Letters](https://leetcode.com/problems/shifting-letters/)\\n\\nIf you have not solved that, I recommand you to look into that first.\\nhttps://leetcode.com/problems/shifting-letters/discuss/2479524/Python-Shift-by-sum\\n\\nCan we convert this problem to 848 by updating shifts to store shift value at each index?\\n\\nBrute force way is to loop through all the shifts and range start to end and update the shift value for each index in hashmap - O(N2)\\n\\n```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\\n***Can we improve this?***\\n\\nLets taken an example\\nWe have to increase value of index [0, 5] by 1\\nOne way is to loop from 0 to 5 and increase each index by 1 - **O(N)**\\n\\nOther way to to increase index 0 by 1 and then apply prefix sum\\n[1, 0, 0, 0, 0]\\nprefix[1] = prefix[0] + prefix[1] => 1 + 0 = 1\\nprefix[2] = prefix[1] + prefix[2] => 1 + 0 = 1\\n.......\\nwe will get [1, 1, 1, 1, 1] - **O(1)**\\n\\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474340,
                "title": "python-3-100-in-time-100-in-space",
                "content": "Consider an array of size 11 intialized with zeros.\\n**[0,0,0,0,0,0,0,0,0,0,  0]**   **<-** array\\n**[0,1,2,3,4,5,6,7,8,9,10]**   **<-** index\\nNow if you want to repeatedly increase count in a range then you can use prefix sum.\\nAssume you want to increase the count from range [1,6],[1,7],[1,8] then simply increase the count at start and decrease the count at end+1 i.e,\\nthe modified array after first query [1,6] would be as \\n**[0,1,0,0,0,0,0,-1,0,0,0]**\\nnow perform prefix sum then the result would be as\\n**[0,1,1,1,1,1,1,0,0,0,0]**\\nthis result is equivalent to iterating from start to end and increasing the count.\\nsimilary look at second query which is [1,7]\\nso the modified array would be\\n**[0,2,0,0,0,0,0,-1,-1,0,0]**\\nso after prefix sum we would have \\n**[0,2,2,2,2,2,2,1,0,0,0]** . so after performing all the shifts we do the final prefix sum and shift the string\\n## Code:-\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```\\n![image](https://assets.leetcode.com/users/images/a9da71f2-070f-4351-89e9-bc13f01957c9_1661360163.5349534.png)\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472389,
                "title": "c-prefix-sum-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469075,
                "title": "prefix-sum-easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\nTC=O(N)\\nSC=O(N)\\n**Please upvote if you liked my solution :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462692,
                "title": "100-00-of-c-based-on-scanline-algo-prefix-sum-optimise-tc",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially 50000 shifts covering the whole size of s, which is of the same size, for a grand total of 250M operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of s.size() elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of x across all the values from a to b (included), we are going to do so just by writing x at index a and -x at index b + 1 (cancelling the effect of the first change on a).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for \"abcdefgh\":\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\nThen we decide to increase by 1 all the values from 1 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\nNow we decide to increase by 1 all the values from 4 to 6 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\nNext we decrease by 1 all the values from 2 to 3 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\nFinally we increase by 1 all the values from 3 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\nThe remaining part of the problem is just how to handle when a character gets shifted past \\'a\\' or \\'z\\', but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n\\nlen will store the size of s;\\ndiffArray is where we will store our indexes, creating it with a length of len + 1 to avoid extra logic on the -x mark when applied to the last cell - saving us shifts.size() conditional statements for the cost of a couple of bytes;\\ndir will be a support variable for when we iterate shifts.\\nWe will then set all the cells of diffArray to 0, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each shift in shifts, we will:\\n\\nset dir to be 1 if shift[2] is also 1, -1 otherwise, as specified in the specs;\\nincrease our starting point diffArray[shift[0]] by dir;\\ndecrease our ending point diffArray[shift[1] + 1] by dir.\\nWith diffArray fully populated, we can now work on s and, with our ongoing sum c initialised to 0 and for each position i in it, we will:\\n\\nset c to increase by diffArray[i] (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating diffArray in place);\\nset pos to the value in which we would pick a character in an ideal \"abcdefghijklmnopqrstuvwxyz\" string, with the value equal to the original (s[i]), minus \\'a\\' (to turn it into a value in the 0 - 25 range), plus c (so, the final shift for this specific cell);\\nwe will add 26 to pos as long as it is < 0 to make sure it is within range;\\nwe will subtract 26 to pos as long as it is > 25 to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\nfinally, we will set back the value in s[i] to be equal to pos (our adjusted 0 - 25 final value), plus \\'a\\' (to make sure it is again a valid lowercase ASCII character).\\nOnce done, we can just return res :)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n# **Please Upvote if you found this helpful **",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459170,
                "title": "leetcode-the-hard-way-line-sweep",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459015,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454934,
                "title": "simple-o-n-c-prefix-sum",
                "content": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454901,
                "title": "c-o-n-time-using-prefixsum",
                "content": "**C++ Code:**\\n\\n```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454536,
                "title": "doubt-why-to-use-after-v",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```\\n why is it giving WRONG ANSWER when i am not writing %26 in  s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\';\\n \\n i.e why s[i]=( (s[i]-\\'a\\')+26+v[i])%26+\\'a\\'; is giving WRONG ANSWER?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454326,
                "title": "javascript-generate-a-operation-map-to-reduce-running-time",
                "content": "> Runtime: 9369 ms, faster than 100.00% of JavaScript online submissions for Shifting Letters II.\\nMemory Usage: 70.4 MB, less than 100.00% of JavaScript online submissions for Shifting Letters II.\\n\\n```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454274,
                "title": "very-stupid-segment-tree-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454215,
                "title": "python3-line-sweep",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nThis is a typical line sweeping problem. While looping through `shifts`, we break [start, end, direction] into two paris and put them on a line of ops \\n\\n```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\\nIn addition, I use a linear transformation to scale {0, 1} direction to {1, -1} for later calculations. I sort the ops and process the amount of shift via a prefix sum. At index i, I\\'d sum all shifts up to this point and apply the shift to the character. \\n**Caveat** Python modulo automatically gives positive value which nicely suits the requirement of this problem. For other languages (e.g. C++), you might need to manually offset it by another 26 to avoid negative values. \\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390639,
                "title": "java-100-faster-100-beats",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263580,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3160790,
                "title": "beats-91-prefix-sum-similar-to-range-addition",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046286,
                "title": "c-o-n-solution",
                "content": "# Approach\\n-Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718990,
                "title": "c-o-n-time-complexity",
                "content": "# Intuition\\nAs problem is related to segments, first thought was to use segment tree. But we have to increment each character, complexity will be n^2 to update segment tree. Then prefix sum will work as shown in approach below.\\n\\n# Approach \\nFor example consider string of length 10.\\nIf we have to update string as [2,5,1].\\nWhat we can do here is, we can increment each character from 2nd position till last. But to reduce updation after 5 at position we will derement it by 1;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597481,
                "title": "segment-tree-template-including-lazy-coolest-segment-tree-problem",
                "content": "**Segment Tree : Sum Template**\\n`Applications:`\\n1. Find sum in particular range.\\n2. Point Update.\\n3. Range Update\\n\\n```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\\n\\n**Approach : Straighforward Range update in Segment Tree**\\n\\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n**Doubts, Queries & Better Approaches are most welcome\\uD83C\\uDF3B**",
                "solutionTags": [],
                "code": "```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2543352,
                "title": "c-line-sweep-easy",
                "content": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512848,
                "title": "98-faster-concise-t-c-o-n-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION!!!**\\n**IDEA:-**\\nWE HAVE THREE PARTS FOR THIS QUESTION \\n**1. LINE SWEEP**\\n we use this technique because its efficient as compared to increase a given range by 1 by visiting each and every element.\\n In this technique to achieve the same we mark only the first index of the range suppose increment by 1 (if direction is forward) and decrement the (last index+1 ) by 1.\\n Now move to the next step.\\n**2. PREFIX SUM**\\n\\tNow after using the technique you just have to take the prefix sum and you will notice that we have achieved the same thing and this method is very efficient as it runs in O(N) runtime as compared to earlier O(N^2) which will give TLE in this question.\\n**3. SHIFTING LETTERS**\\nwe use the statement provided in the code to shift the letters.\\n\\n**T.C:-** O(N)  **S.C:-** O(N)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496267,
                "title": "python3-line-sweep-o-n-simple",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485096,
                "title": "scanline-algorithm",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]+=prefix[i-1];    // prefix sum  // to calculate how many times a particular index is changed\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            prefix[i]%=26;    // to keep offset within 26 as a-z are 26\\n            \\n            if(int(s[i])+prefix[i] < 97) \\n            {\\n                s[i] = char(int(s[i])+prefix[i]+26); // ascii value of a-z are from 97 to 122;\\n            }\\n            else if(int(s[i])+prefix[i]>122)\\n            {\\n                s[i] = char(int(s[i])+prefix[i]-26);\\n            }\\n            else\\n            {\\n                s[i] = char(int(s[i])+prefix[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2485017,
                "title": "easy-c-faster-then-80-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }\\n               }\\n            else{\\n                 dp[shifts[i][0]]+=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]-=1;\\n                }\\n\\t\\t\\t}\\n        }\\n        for(int i=1;i<s.size();i++){\\n            dp[i]=dp[i-1]+dp[i];   //Saving no of movement required \\n        }\\n\\t\\t//some aptitude maths \\n        for(int i=0;i<s.size();i++){\\n            dp[i]=dp[i]%26;\\n            if(dp[i]+s[i]>\\'z\\'){\\n                char indx=dp[i]+s[i]-\\'z\\';\\n                s[i]=\\'a\\'+indx-1;\\n            }\\n            else if (dp[i]+s[i]<\\'a\\'){\\n                s[i]=s[i]+(26+dp[i]);\\n            }\\n            else\\n                s[i]=s[i]+dp[i];  \\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2476492,
                "title": "best-easiest-solution-in-c",
                "content": "***Please Upvote if U liked my solution***\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }\\n            else{\\n                vec[start]+=-1;\\n                vec[end+1]+=1;\\n            }\\n        }\\n        int prefixSum=0;\\n        for(int i=0;i<size;i++){\\n            prefixSum+=vec[i];\\n            while(prefixSum<0)\\n                prefixSum+=26;\\n            s[i]=(char)(\\'a\\'+(((s[i]-\\'a\\')+prefixSum)%26));\\n        }   \\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2476153,
                "title": "java-range-caching",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472774,
                "title": "python3-line-sweep-method-with-hashmap",
                "content": "Note that for one who doesn\\'t know about line sweep technique, there will be a test case with enormous length giving TLE.\\n\\nFor knowing what character will become after shifting **n** position forward, we can use a list to achieve that purpose.\\nAs there will be only lower letter, we can assign \"a\" ~ \"z\" to a list of length 26.\\nFor instance, to know what character will be given after shifting \"a\" 3 times forward, the answer will be :\\n**lettermap[ ( ord(\"a\") - 97 + 3 ) % 26 ]** = \"d\"\\n\\nNext is to determine how to shift each character efficiently. It will be time-consuming if one goes to all characters between start and end of an interval then do the same to all intervals. \\nBy applying line sweep, the time complexity could be reduced substantially to linear time.\\n\\nTo see the idea of line sweep : \\n![image](https://assets.leetcode.com/users/images/1babae20-e732-41c5-9d33-c24ec3806bd1_1661335019.4304667.png)\\n\\nAfter iterating all shifting intervals and keep track of the shift offset starting at specific index,\\nwe can get the number of shifts starting at each index then use this information to perform character shifting.\\n\\n![image](https://assets.leetcode.com/users/images/0f4c25f2-6cd0-4b55-870e-e281a04ca38f_1661336267.0428574.png)\\n\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467047,
                "title": "very-easy-explanation-brute-force-prefix-sum-optimized",
                "content": "* **Brute Force ( Time Limit Exceed )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n*  **Prefix Sum ( Optimized )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460326,
                "title": "rust-linear-solution-almost-all-contest-front-runners-use",
                "content": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2458908,
                "title": "square-root-decompostion",
                "content": "Hello Friends,\\nThis question can be easily done by prefix-sum array but here I want to give an approach of sqaure root decomposition. First of all learning sqaure root decomposition is an way to solve range queries question. Generally this has time complexity of sqrt(n)*n;\\nl=shifts[i][0];\\nr=shifts[i][1];\\n\\nPrerequiste : Sqaure Root Decomposition \\n\\nAll the questions of SQRTD has a common structure so learning only question will push you to solve this one.\\nFor practicing you can solve \\nhttps://www.spoj.com/problems/RMQSQ/\\n\\nAfter this you will get this without any explaination.\\n\\n\\'\\'\\'\\n\\n\\t class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n            }\\n            else{\\n                \\n                for(int i=l;i<blk*(lb+1);i++){\\n                    arr[i]+=add;\\n                }\\n              \\n                for(int i=lb+1;i<rb;i++){\\n                    f[i]+=add;\\n                }\\n                \\n                for(int i=blk*rb;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n             \\n            }\\n           \\n            \\n        }\\n        \\n        \\n       \\n        \\n     \\n       \\n        for(int i=0;i<n;i++){\\n           \\n            int change=arr[i]+f[i/blk];\\n            int k=change%26;\\n            int p1=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p1);\\n            \\n        }\\n        \\n        return s;\\n    }\\n    };\\n\\'\\'\\'\\nTC ==> O(N*SQRT(N))\\nSC==> O(N)",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2458369,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\\n**C++**\\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457263,
                "title": "prefix-sum",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456450,
                "title": "beats-100-c-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456011,
                "title": "2-python-solutions-with-explanation-bruteforce-linesweep",
                "content": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "codeTag": "Java"
            },
            {
                "id": 2455458,
                "title": "java-solution-prefix-sum",
                "content": "```java \\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i>0)\\n                a[i]+=a[i-1];\\n            a[i]%=26;\\n            if(s.charAt(i)+a[i]<97)\\n                sb.append((char)(s.charAt(i)+26+a[i]));\\n            else if(s.charAt(i)+a[i]>122)\\n                sb.append((char)(s.charAt(i)-26+a[i]));\\n            else\\n                sb.append((char)(s.charAt(i)+a[i]));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void fill(int[] a,int start,int end, int shift)\\n    {\\n        if(shift==0){\\n        a[start]--;\\n        a[end+1]++;\\n        }\\n        else{\\n        a[start]++;\\n        a[end+1]--;\\n        }   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455351,
                "title": "c-easy-to-understand-using-prefix-array-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please Upvote if you like it**",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454931,
                "title": "c-easy-and-simple-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454745,
                "title": "easy-c-code-prefix-sum",
                "content": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }\\n            else {\\n                v[l]++;\\n                v[r + 1]--;\\n            }\\n        }\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            v[i] = v[i] + v[i - 1];\\n        }\\n        \\n        for(auto i = 0; i < s.size(); i++) {\\n            \\n            int ans = ((s[i] - \\'a\\') + v[i]) % 26;\\n            s[i] = \\'a\\' + (ans + 26)%26;\\n        }\\n\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454607,
                "title": "using-1-1-trick-prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454592,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454585,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "codeTag": "Java"
            },
            {
                "id": 2454506,
                "title": "python3-sum-changes-per-element",
                "content": "**Biweekly Contest 85 Submission**\\n\\n**Sum Changes per Element**\\n1. Get the sum of the changes to each character in ```s``` given the intervals in ```shifts``` (linearly with a prefix sum array ```dp```).\\n2. Apply the changes from ```dp``` per character in ```s``` and return the result.\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```s```\n```shifts```\n```dp```\n```dp```\n```s```\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454412,
                "title": "c-partial-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454399,
                "title": "o-n-difference-array",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454355,
                "title": "c-range-query-o-n",
                "content": "Upvote If you like the solution\\ncomment down any doubts or suggestions\\nTime : O(n)\\nSpace : O(n)\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454345,
                "title": "partial-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454343,
                "title": "scala-sorted-shifts-and-simple-recursion",
                "content": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454322,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454280,
                "title": "segment-tree-lazy-propagation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454253,
                "title": "c-o-n-time",
                "content": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454200,
                "title": "java-solution-o-n-range-sum-update-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086434,
                "title": "cpp-range-sum-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969482,
                "title": "o-n-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938533,
                "title": "rust-solution-from-interval-tree-to-o-n-solution",
                "content": "# First Intuition\\nWe have to update a range so the first idea can be to use an interval tree that updates ranges (in `O(log(n))`) and gets a single value (also in `O(log(n)`)).\\n\\n# Approach\\nWe construct an interval tree and then update every range from `shifts`.\\n\\n# Notes\\nObviously, when `shifts[i][2]` is `0` we can treat it as `-1` but to avoid if statements (which are typically slower than arithmetic operations) we can multiply it by `2` and then subtract `1`\\n\\nSecondly, to handle wrapping we can simply do `v mod 26` (we count `a` as `0`, `b` as `1`, and so on). Unfortunately when we for example do `-3%26` we get `-3` instead of `23` to fix this we will do `((v%26) + 26)%26` which gives desired results.\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(nlog(n) + mlog(n))`\\n  - Constructing tree O(n) - because of creating vector\\n  - Updating tree with every of m shifts in `O(log(n))` so it\\'s `O(mlog(n))`\\n  - Reading every of `n` values in `O(log(n))` and making computation in `O(1)` so it\\'s `O(nlog(n))`\\n- Space complexity: `O(n)`\\n  - Tree has at worst `2*n - 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\\n\\n# Observation\\nAdding any value to every value of any arbitrary range of whole numbers `[beg; end]` is the same as adding it to every value of `[beg; inf)` and subtracting from every value of `(end; inf)`\\n\\n\\n# Approach\\nWe create an `array` in which `array[i]` represents a value that should be added to `[i;inf)` and then we fill it with shifts.\\nFinally, we iterate over the whole string keeping track of the current prefix sum of the `array` and adding it to every element of the string (of course we still have to do some modulo operations).\\n\\nIn other words:\\n``\\ns[i] += prefix_sum_of_array[i]\\n``\\n``\\ns[i] = ((s[i]%26) + 26)%26\\n``\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(n + m)`\\n  - Creating `array` `O(n)`\\n  - Filling `array` with every of `m` shifts in `O(1)` each, so it\\'s `O(m)`\\n  - Iterating over every of `n` element of string and applying changes `O(1)`, so it\\'s `O(n)`\\n\\n- Space complexity: `O(n)`\\n  - `array` has `n + 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932589,
                "title": "scaline-algo-prefix-sum",
                "content": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }\\n        \\n        //now take the prefix sums\\n        for(int i = 1; i < n + 1; i++){\\n            dir[i] += dir[i - 1];\\n        }\\n        \\n        char [] res = new char[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            int idx = (s.charAt(i) - \\'a\\' + dir[i]) % 26;\\n            if(idx < 0){\\n                idx += 26;\\n            }\\n            \\n           char newCh = (char)(idx + \\'a\\'); \\n            res[i] = newCh;\\n        }\\n        \\n        return new String(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3899045,
                "title": "c-clearly-explained-maintaining-ranges",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881792,
                "title": "c-simple-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847262,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835782,
                "title": "prefix-sum-python-97-in-runtime-98-in-space",
                "content": "# Intuition\\nFor each shift operation, the direct way is to shift all the chars in the range one by one. However, when the range is large, this brute force method is too slow. A better way is to calculated the cumulative shifts for each char first and then shift each char only once. To do this in an efficient way, we need to maintain an array `cnt` with the same length as `s`\\uFF0Cthen for the shift [start,end,direction], we should first transform direction into $\\\\pm 1$\\uFF0Cthen add `direction` to `cnt[start]` and substract it from `cnt[end+1]`. Finally, calculate the cumulative sums of `cnt` and they are just the cumulative shift distance for each char.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814493,
                "title": "easiest-difference-array",
                "content": "# Intuition\\nWe can maintain an array which keeps track of the total positive and negative shift of each char in s. But that would take $$O(n\\xB2)$$ complexity. We need to use a difference array to reduce the time complexity. Difference array is kind of the reverse of presum array, and you can do further research on it before attempting this question, it is a classic range-update query algorithm. \\n\\n# Approach\\nWe traverse through shifts and appropriately update our difference array. Then we use a variable sum to gather the presum of this difference array(hint:The presum at each index is the change/shift for that index). Next, we calculate how the char is turned due to the change, and finally we update the characters one by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ we traverse the shifts array and the difference array which is linear complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ extra space for difference array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n*__UPVOTE IF EASY__*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778541,
                "title": "c-line-sweep-easy-solution",
                "content": "# Approach\\nStore the contribution of each index using line sweep and then update each character in final string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774892,
                "title": "line-sweep-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742530,
                "title": "most-smallest-code-i-bet-you-will-not-understand-last-line-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593600,
                "title": "o-n-time-and-space",
                "content": "# Intuition\\nSweep line\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567965,
                "title": "prefix-sum-solution-with-explanation-easy-to-understand",
                "content": "# Intuition\\nAt first we see that we have to print the final string after performing all operation so we can perform operation at a time we don\\'t need to perform every time to do this we can use prefix sum technique to store how many time a operation perform in an index\\n\\n# Approach\\nTo solve this problem, we can declare two array one for forwad direction another for backward direction in those array we mark the starting index and ending index of every operation to do this we have to increase the array value in starting index of an operation and decrease the value for ending index then in those array we can do prefix sum after that we just travers every index and see how many time we have to do forward operation and backward we simply perform those operation in that index\\n\\n# Complexity\\n- Time complexity:\\nO(max(string size,shifts size))\\n\\n- Space complexity:\\nO(max(string size,shifts size))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566455,
                "title": "c-prefix-sum-faster-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553363,
                "title": "rust-diff-array-and-prefix-o-n-solution-100",
                "content": "# Intuition\\n\\nOriginal array is the prefix sum of it\\'s diff array.\\nif you want to update range from [a, b] to some value -\\nupdate diff[a] += val and diff[b + 1] -= val, then build the prefix sum and convert indexes to chars\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538804,
                "title": "segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538286,
                "title": "line-sweep-algorithm-solution-c-best-approach-for-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3490375,
                "title": "translate-lachezartsk-s-javascript-to-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI simply translated LachezarTsK\\'s approach from JavaScript to TypeScript.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe code first defines a constant called ALPHABET_SIZE which is the number of letters in the alphabet (26). It also defines a constant called ASCII_SMALL_CASE_A which is the ASCII code for the letter \\'a\\' (97).\\n\\nNext, the code defines an array called totalShifts. This array will be used to store the total number of shifts that have been applied to each letter in the input string. The array is initialized to all zeros.\\n\\nThe next loop iterates through the shifts array. The shifts array is an array of arrays. Each inner array contains three elements: the start index, the end index, and the shift amount.\\n\\nFor each inner array, the code adds the shift amount to the totalShifts array at the start index. It then subtracts the shift amount from the totalShifts array at the end index + 1.\\n\\nNext, the code defines an array called shiftedLetters. This array will be used to store the shifted letters of the input string. The array is initialized to be the same as the input string.\\n\\nThe next loop iterates through the shiftedLetters array. For each letter, the code calculates the new position of the letter by adding the total shift for that letter to the original position of the letter. The code then uses the String.fromCodePoint() function to convert the new position to a letter.\\n\\nThe final step is to join the shiftedLetters array together to form a string. The code then returns the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is $$O(n)$$. This is because the code iterates through the shifts array once, and the input and shiftedLetters arrays twice. The number of iterations is proportional to the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $$O(n)$$, where n is the length of the input string. This is because the code only needs to store the input string, the totalShifts array, and the shiftedLetters array. The size of these arrays is proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457566,
                "title": "prefix-sum-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3393419,
                "title": "line-sweep",
                "content": "**time: `O(N+S)`; space: `O(S)`**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```\\n**Similar problems:**\\n[2406. Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/discuss/3393422/line-sweep)\\n[2381. Shifting Letters II](https://leetcode.com/problems/shifting-letters-ii/discuss/3393419/line-sweep)\\n[1943. Describe the Painting](https://leetcode.com/problems/describe-the-painting/discuss/3387661/line-sweep)\\n[253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/2115681/few-solutions)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388373,
                "title": "c-accumulate-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345046,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310229,
                "title": "c-golang-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297769,
                "title": "java-concise-linesweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240516,
                "title": "line-sweep-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236883,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234339,
                "title": "c-o-n-m-simple-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove an interval `[l, r]` forward for 1 alphabet is equivalent to a representation of \\n```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\\nwhere the 1 at entry `l` means every element after index `l` are shifted by 1 char forward. The -1 at `r+1` means we are resetting the element after `r+1` backward for one char.\\n\\nSuch representation is accumulative, meaning we can accumulate all the shifts and then compute the total shift of each element. The representation can also be updated in `O(1)` time for each interval shift.\\n\\nWhen querying the total shift after all the operations at index `i`, it is equivalent to the prefix sum of `0` to `i` in the above array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(|shift| + n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226312,
                "title": "python-2381-shifting-letters-ii-easy-and-neat-python-code",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226309,
                "title": "python-prefix-sum-easy-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209927,
                "title": "java-solution-with-prefix-sum-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140384,
                "title": "python-endpoints-trick",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134802,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3110448,
                "title": "python-o-n-labeling-to-do-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084036,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079200,
                "title": "java-line-sweep-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062613,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3030017,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }\\n        int[] arr = new int[s.length()+1];\\n        int index = 0;        \\n        for(int i = 0; i < shifts.length; i++) {\\n            int add = -1;\\n            if(shifts[i][2] == 1)\\n                add = 1;\\n            arr[shifts[i][0]]+=add;\\n            arr[shifts[i][1]+1]-=add;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length();i++) {\\n            if(i != 0)\\n                arr[i]+=arr[i-1];\\n            val = s.charAt(i)-\\'a\\'+arr[i];\\n            while(val < 0)\\n                val+=26;\\n            val%=26;\\n            sb.append(map.get(val));\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2966735,
                "title": "c-simple-line-sweep-prefix-sum-o-n-o-n",
                "content": "# Intuition : Intervals are given and we have to modify the values in the intervals\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }\\n\\n        //calculatePrefixSum\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i] + prefixSum[i-1];\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            int dax = (s[i]-\\'a\\');\\n            int val = ((((dax + prefixSum[i] + 26) % 26) + 26)) % 26;\\n            s[i] = \\'a\\' + val;\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2949488,
                "title": "beats-95-python-solution-prefixsum-technique",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926396,
                "title": "python-clean-solution-with-explanation",
                "content": "This problem is basically the same as https://leetcode.com/problems/maximum-population-year/. I use the same approach:\\n1. Count the number of shifts occurring at each index\\n2. Scan the string from left to right, keeping track of the cumulative shift amount\\n\\nInstead of using 4 arrays to track the shifts, I could use a single array where the `ith` element indicates how much shift to add before processing the `ith` character. This would be more concise, but with the same asymptotic time complexity and less readability.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907010,
                "title": "line-sweep-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891766,
                "title": "python-simple-sweep-line-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872407,
                "title": "simple-prefix-sum-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862852,
                "title": "c",
                "content": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834226,
                "title": "javascript-intuitive",
                "content": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828211,
                "title": "python3-using-cumulative-sum",
                "content": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "codeTag": "Java"
            },
            {
                "id": 2798405,
                "title": "javascript-cumulative-sum-efficient-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate an array to find all the shifts using cumulative sum approach, this way TC will be O(n) otherwise it\\'ll be O(n**2)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774832,
                "title": "c-10-line",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2768330,
                "title": "c-prefix-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764071,
                "title": "python-3-line-sweep-o-n-o-n",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 2753031,
                "title": "golang-move-solution",
                "content": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752763,
                "title": "python-prefix-sum-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732749,
                "title": "ruby-solution",
                "content": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2668723,
                "title": "python3-line-sweep",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668634,
                "title": "c-prefix-sum-simple",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tpreSum[st] += (-1);\\n\\t\\t\\t\\t\\tpreSum[e+1] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\tsum += preSum[i];\\n\\t\\t\\t\\tint val = (s[i] - \\'a\\' + sum%26 + 26) % 26;\\n\\t\\t\\t\\ts[i] = \\'a\\' + val;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2642136,
                "title": "easy-js-solution-with-diagram",
                "content": "**Approach 1**: O(n ^2)\\n\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n**Approach 2**: O(n)\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4727f50b-c129-4be0-8a66-30f44ba6c508_1664537717.8534641.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605876,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596771,
                "title": "python-cumulative-shift-deltas",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572585,
                "title": "prefix-sum-ascii",
                "content": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }\\n          else{\\n            v[start] +=-1;\\n            v[end+1] +=1;\\n          }\\n        }\\n        for(int i=1;i<n;i++){\\n          v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n          v[i] = v[i]%26;\\n        }\\n        for(int i=0;i<n;i++){\\n          int x = s[i]-\\'a\\';\\n          v[i]+=x;\\n          v[i] = v[i]%26;\\n            if(v[i]<0){\\n            v[i]= 26+v[i];\\n          }\\n          cout<<v[i]<<\" \";\\n        }\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n          res+=v[i]+\\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2559073,
                "title": "c-line-sweep-solution",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525964,
                "title": "c-segment-tree-solution",
                "content": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2514522,
                "title": "c-easy-solution-line-sweep-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513237,
                "title": "o-n-time-o-n-space-clear-explanation-also-1943-1854-1094-1109",
                "content": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 2495789,
                "title": "c",
                "content": "**Bucket**\\nSimilar to: https://leetcode.com/problems/meeting-rooms-ii/discuss/2135429/four-cpp-methods (First Method and follow up)\\n```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495654,
                "title": "very-easy-java-solution-using-prefixsum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490446,
                "title": "c-prefix-sum",
                "content": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489403,
                "title": "c-easy-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489120,
                "title": "c-recursive-solution-simple-bruteforce-o-n-2",
                "content": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2029012,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925903,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925899,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Segment Sum After Removals",
        "question_content": "<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums</code> and <code>removeQueries</code>, both of length <code>n</code>. For the <code>i<sup>th</sup></code> query, the element in <code>nums</code> at the index <code>removeQueries[i]</code> is removed, splitting <code>nums</code> into different segments.</p>\n\n<p>A <strong>segment</strong> is a contiguous sequence of <strong>positive</strong> integers in <code>nums</code>. A <strong>segment sum</strong> is the sum of every element in a segment.</p>\n\n<p>Return<em> an integer array </em><code>answer</code><em>, of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>maximum</strong> segment sum after applying the </em><code>i<sup>th</sup></code> <em>removal.</em></p>\n\n<p><strong>Note:</strong> The same index will <strong>not</strong> be removed more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<strong>Output:</strong> [14,7,2,2,0]\n<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].\nQuery 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].\nQuery 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. \nQuery 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. \nQuery 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [14,7,2,2,0].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<strong>Output:</strong> [16,5,3,0]\n<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].\nQuery 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].\nQuery 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].\nQuery 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [16,5,3,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li>All the values of <code>removeQueries</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2454208,
                "title": "reverse-union-find",
                "content": "In the end, we remove all elements from the array (`nums.length == removeQueries.length`). \\n    \\nSo, we can start from no segments, add elements in the reverse (of the removal) order, and create/merge segments.\\n    \\nAs we add an element, it can either:\\n- create a new segment (e.g. `__, [7], __`)\\n- join an existing segment on the left (e.g. `5, 6, [7], __`)\\n- join an existing segment on the right (e.g. `__, [7], 8, 9`)\\n- merge existing segments on the left and right into one (e.g. `5, 6, [7], 8, 9`)\\n    \\n**Union-Find**\\nWe initialize the `ds` array with `INT_MAX`, so we can check if we an element on the left (or right) has been inserted.\\n\\nAs we insert an element `j`, we set `ds[j]` to `nums[j]` (negated). Then, we check if an element on the left/right has been inserted, and do a merge if it has. \\n\\nA non-negative value is an index of the set \"parent\". A negative value is the negated sum of all elements in the set.\\n    \\n**C++**\\n```cpp\\nint find(int i, vector<long long>& ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvoid merge(int s1, int s2, vector<long long>& ds) {\\n    int p1 = find(s1, ds), p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n    vector<long long> res(nums.size()), ds(nums.size(), INT_MAX);\\n    for (int i = rq.size() - 1; i > 0; --i) {\\n        int j = rq[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] != INT_MAX)\\n            merge(j, j - 1, ds);\\n        if (j < nums.size() - 1 && ds[j + 1] != INT_MAX)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(int i, vector<long long>& ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvoid merge(int s1, int s2, vector<long long>& ds) {\\n    int p1 = find(s1, ds), p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n    vector<long long> res(nums.size()), ds(nums.size(), INT_MAX);\\n    for (int i = rq.size() - 1; i > 0; --i) {\\n        int j = rq[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] != INT_MAX)\\n            merge(j, j - 1, ds);\\n        if (j < nums.size() - 1 && ds[j + 1] != INT_MAX)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454192,
                "title": "c-sets-prefix-sum-solution-approach-code",
                "content": "**Approach:**\\n\\n- Store current segments in form of intervals in a set. \\n- Have another multiset to store sums of all the current intervals or segments.\\n- For each query find the interval in which the query[i] belongs and split that interval into 2 segments.\\n- Erase the previous segment sum from multiset and the previous interval from set and insert new sum and new    intervals.\\n- For faster calculation of segment sum, have a prefix sum array.\\n\\n```\\n/*\\n *  Space Complexity: O(N)\\n *\\tTime Complexity: O(N + QlogQ),  \\n *  where, Q = count of remove queries, N = length of nums array.\\n */\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        multiset<long long> s;\\n        s.insert(0);\\n        set<pair<int, int>> in;\\n        vector<long long> pre(n, nums[0]);\\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\\n        \\n        in.insert({0, n - 1});\\n        \\n        s.insert(pre[n - 1]);\\n        \\n        vector<long long> ans;\\n        for(auto p : removeQueries) {\\n            auto it = in.upper_bound({p, 2e9});\\n            it--;\\n            \\n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\\n            long long R = pre[it -> second] - pre[p];\\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\\n            \\n            s.erase(s.find(T));\\n            if(it -> first <= p - 1) {\\n                in.insert({it -> first, p - 1});\\n                s.insert(L);\\n            }\\n            if(it -> second >= p + 1) {\\n                in.insert({p + 1, it -> second});\\n                s.insert(R);\\n            }\\n            \\n            in.erase(it);\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Do Upvote if you liked the solution :).**",
                "solutionTags": [],
                "code": "```\\n/*\\n *  Space Complexity: O(N)\\n *\\tTime Complexity: O(N + QlogQ),  \\n *  where, Q = count of remove queries, N = length of nums array.\\n */\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        multiset<long long> s;\\n        s.insert(0);\\n        set<pair<int, int>> in;\\n        vector<long long> pre(n, nums[0]);\\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\\n        \\n        in.insert({0, n - 1});\\n        \\n        s.insert(pre[n - 1]);\\n        \\n        vector<long long> ans;\\n        for(auto p : removeQueries) {\\n            auto it = in.upper_bound({p, 2e9});\\n            it--;\\n            \\n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\\n            long long R = pre[it -> second] - pre[p];\\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\\n            \\n            s.erase(s.find(T));\\n            if(it -> first <= p - 1) {\\n                in.insert({it -> first, p - 1});\\n                s.insert(L);\\n            }\\n            if(it -> second >= p + 1) {\\n                in.insert({p + 1, it -> second});\\n                s.insert(R);\\n            }\\n            \\n            in.erase(it);\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454397,
                "title": "do-it-backwards-o-n",
                "content": "For nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1], the reverse process will be \\nadd 1 : [0, 2, 0 ,0 ,0]\\nadd 4 : [0, 2, 0 ,0 ,1]\\nadd 2 : [0, 2, 5 ,0 ,1]\\nadd 3 : [0, 2, 5, 6, 1]\\nadd 0 : [1, 2, 5, 6, 1]\\n\\nWhen an index q is added, extend the contiguous sequence by finding if q+1 or q-1 exists, and also record the value of the maximum segment sum. For example, before adding the 3rd element, there are two contiguous sequences, [2, 5] and [1], and we can extend it to a length 4 sequence after the 3rd element is added.\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        mp, cur, res = {}, 0, []\\n        for q in reversed(removeQueries[1:]):\\n            mp[q] = (nums[q], 1)\\n            rv, rLen = mp.get(q+1, (0, 0))\\n            lv, lLen = mp.get(q-1, (0, 0))\\n                \\n            total = nums[q] + rv + lv\\n            mp[q+rLen] = (total, lLen + rLen + 1)\\n            mp[q-lLen] = (total, lLen + rLen + 1)\\n        \\n            cur = max(cur, total)\\n            res.append(cur)\\n            \\n        return res[::-1] + [0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        mp, cur, res = {}, 0, []\\n        for q in reversed(removeQueries[1:]):\\n            mp[q] = (nums[q], 1)\\n            rv, rLen = mp.get(q+1, (0, 0))\\n            lv, lLen = mp.get(q-1, (0, 0))\\n                \\n            total = nums[q] + rv + lv\\n            mp[q+rLen] = (total, lLen + rLen + 1)\\n            mp[q-lLen] = (total, lLen + rLen + 1)\\n        \\n            cur = max(cur, total)\\n            res.append(cur)\\n            \\n        return res[::-1] + [0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461035,
                "title": "python-reverse-union-find-clean-concise",
                "content": "**Idea**\\n- At the end, we remove all elements in `nums` array.\\n- Instead of doing forward, we can do it back-ward\\n- Let grab an example for easy to understand:\\n```\\nnums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\n```\\n- 4th query, we remove `1th` element, the state before it: `_, 2, _, _, _` (add node `1th` to our UnionFind)\\n- 3th query, we remove `4th` element, the state before it: `_, 2, _, _, 1` (add node `4th` to our UnionFind)\\n- 2th query, we remove `2th` element, the state before it: `_, 2, 5, _, 1` (add node `2th` to our UnionFind, merge node `2th` with node `1th`)\\n- 1th query, we remove `3th` element, the state before it: `_, 2, 5, 6, 1` (add node `3th` to our UnionFind, merge node `3th` with node `2th` and node `3th` with node `4th`)\\n- 0th query, we remove `0th` element, the state before it: `1, 2, 5, 6, 1` (add node `0th` to our UnionFind, merge node `0th` with node `1th`)\\n\\n\\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.sum = {}\\n        self.maxSumSegment = 0\\n        \\n    def addAndMergeAdjSegment(self, u, value):\\n        self.parent[u] = u\\n        self.sum[u] = value\\n        self.maxSumSegment = max(self.maxSumSegment, value)\\n        if u-1 in self.parent:\\n            self.union(u, u-1)\\n        if u+1 in self.parent:\\n            self.union(u, u+1)\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return\\n        self.sum[pu] += self.sum[pv]\\n        self.parent[pv] = pu\\n        self.maxSumSegment = max(self.maxSumSegment, self.sum[pu])\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        uf = UnionFind()\\n        \\n        ans = [0] * n\\n        for i in range(n-1, -1, -1):\\n            ans[i] = uf.maxSumSegment\\n            q = removeQueries[i]\\n            uf.addAndMergeAdjSegment(q, nums[q])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N` is length of `nums` array\\n\\t- Each operation `union`, `find` cost `O(logN)` since we do path compression only.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nnums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\n```\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.sum = {}\\n        self.maxSumSegment = 0\\n        \\n    def addAndMergeAdjSegment(self, u, value):\\n        self.parent[u] = u\\n        self.sum[u] = value\\n        self.maxSumSegment = max(self.maxSumSegment, value)\\n        if u-1 in self.parent:\\n            self.union(u, u-1)\\n        if u+1 in self.parent:\\n            self.union(u, u+1)\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return\\n        self.sum[pu] += self.sum[pv]\\n        self.parent[pv] = pu\\n        self.maxSumSegment = max(self.maxSumSegment, self.sum[pu])\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        uf = UnionFind()\\n        \\n        ans = [0] * n\\n        for i in range(n-1, -1, -1):\\n            ans[i] = uf.maxSumSegment\\n            q = removeQueries[i]\\n            uf.addAndMergeAdjSegment(q, nums[q])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454227,
                "title": "java-no-need-of-segment-tree-set-priority-queue",
                "content": "**APPROACH is little bit tricky try to dry run this code , you will get the idea behind it**\\n\\nfirst i used the ,priority Queue that will store the interval data\\ni.e., start index, end index, and sum of interval \\nand sort them on the base of decreasing sum,\\n\\nTreeSet, that will store the partitions , means queries value\\n\\nThen i do prefic evaluation, means \\nsuppose query type is 1, \\nthen i do arr[st]++ and arr[en+1]--;\\nwhere st and en is the starting and ending index of query \\n\\n**IMPORTANT PART BEGIN FROM HERE** \\n\\nfor every query i will , check the upper bound and lower bound ,\\nand add in my prioriy queue to 2 range\\n1st lowerbound to current query value\\n2nd current query value to upperbound \\nsame like the i split the query\\n\\nthen i run the while loop until i get the valid range(partition)\\nmeans range ,in which there is no parition between them\\n\\n```\\npublic long[] maximumSegmentSum(int[] nums, int[] quer) {       \\n        int n=nums.length;\\n        PriorityQueue<long []> pq=new PriorityQueue<>((long a[],long b[])->(a[2]<=b[2])?1:-1);  \\n        TreeSet<Integer> set=new TreeSet<>();\\n        long arr[]=new long[n],ans[]=new long[n];\\n        set.add(-1);\\n        set.add(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n            if(i!=0) arr[i]+=arr[i-1];\\n        }\\n        pq.add(new long[]{0,n-1,arr[n-1]});\\n        for(int i=0;i<n;i++){\\n            int num=quer[i];\\n            set.add(quer[i]);\\n            int a=set.lower(num), b=set.higher(num);\\n            if((a+1)<num){\\n                pq.add(new long[]{(long)a+1,(long)num-1,arr[num-1]-(long)((a==-1)?0:arr[a])});\\n            }\\n            if((num+1)<b){\\n                pq.add(new long[]{(long)num+1,(long)b-1,arr[b-1]-arr[num]});\\n            } \\n            while(!pq.isEmpty()){\\n                long ab[]=pq.peek();\\n                int s=(int) ab[0],e=(int) ab[1];\\n\\n                if(set.higher(s-1)>e){\\n                    ans[i]=pq.peek()[2];\\n                    break;\\n                }\\n                else pq.remove();\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n**Please Upvote The Post\\nHappy Coding :)**",
                "solutionTags": [],
                "code": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] quer) {       \\n        int n=nums.length;\\n        PriorityQueue<long []> pq=new PriorityQueue<>((long a[],long b[])->(a[2]<=b[2])?1:-1);  \\n        TreeSet<Integer> set=new TreeSet<>();\\n        long arr[]=new long[n],ans[]=new long[n];\\n        set.add(-1);\\n        set.add(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n            if(i!=0) arr[i]+=arr[i-1];\\n        }\\n        pq.add(new long[]{0,n-1,arr[n-1]});\\n        for(int i=0;i<n;i++){\\n            int num=quer[i];\\n            set.add(quer[i]);\\n            int a=set.lower(num), b=set.higher(num);\\n            if((a+1)<num){\\n                pq.add(new long[]{(long)a+1,(long)num-1,arr[num-1]-(long)((a==-1)?0:arr[a])});\\n            }\\n            if((num+1)<b){\\n                pq.add(new long[]{(long)num+1,(long)b-1,arr[b-1]-arr[num]});\\n            } \\n            while(!pq.isEmpty()){\\n                long ab[]=pq.peek();\\n                int s=(int) ab[0],e=(int) ab[1];\\n\\n                if(set.higher(s-1)>e){\\n                    ans[i]=pq.peek()[2];\\n                    break;\\n                }\\n                else pq.remove();\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454165,
                "title": "c-prefix-sum-multiset-nlogn",
                "content": "Steps for each Query:\\n\\n1. For current index (cur), find left removed index (L) and right removed index (R)\\n2. Delete current segment sum,   pre[R-1] - pre[L]\\n3. Insert left segment sum,   pre[cur-1] - pre[L]\\n4. Insert right segment sum,  pre[R-1] - pre[cur]\\n5. Take the maximum from all sums\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remove) {\\n        int n = nums.size();\\n        vector<ll> pre(n,0);\\n\\n        pre[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            pre[i] += pre[i-1] + nums[i];        // create prefix sum\\n        }\\n\\n        set<int> ind;         // ind will store removed index\\n        ind.insert(-1);\\n        ind.insert(n);\\n\\n        vector<ll> ans(n,0);\\n        multiset<ll> mp;     // mp will store sum of all segments \\n        mp.insert(pre[n-1]);\\n\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\tint cur = remove[i];\\n\\n            auto it = ind.lower_bound(cur);\\n            int r = *it;                         // right removed index\\n            int l = *(prev(it));                 // left removed index\\n            \\n            ll cur_sum = pre[r-1] - ( l == -1 ? 0 : pre[l] );\\n            mp.erase(mp.find(cur_sum));                 // remove current segment sum\\n\\n            ll left_sum = ( cur == 0 ? 0 : pre[cur-1] ) - (l == -1? 0 : pre[l] );\\n            ll right_sum = (r == 0 ? 0 : pre[r-1]) - pre[cur];\\n\\n            mp.insert(left_sum);                // insert left segment sum\\n            mp.insert(right_sum);               // insert right segment sum\\n\\n            ind.insert(cur);\\n            ans[i] = *(mp.rbegin());           // take the maximum\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remove) {\\n        int n = nums.size();\\n        vector<ll> pre(n,0);\\n\\n        pre[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            pre[i] += pre[i-1] + nums[i];        // create prefix sum\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454787,
                "title": "python-maintaining-segments-with-sortedlist",
                "content": "We will maintain our segments and their sums using `SortedList` library. \\n\\nAdding a segment and removing a segment are cleanly implemented in `add, remove` functions. Thus we just need to go through each query, remove segment containing `removeQueries[i]` index, and then add two new created segments back. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n, ps, ans = len(nums), [0], []\\n        segments, sums = SortedList(), SortedList([0])\\n\\n        # compute prefix sums\\n        for k in nums:\\n            ps.append(ps[-1] + k)\\n\\n        # adding a segment with (left, right) borders and its sum\\n        def add(l, r):\\n            if l > r: return\\n            segments.add((l, r))\\n            sums.add(ps[r + 1] - ps[l])\\n\\n        # removing a segment\\n        def remove(l, r):\\n            segments.remove((l, r))\\n            sums.remove(ps[r + 1] - ps[l])\\n\\n        # initial segment with borders (0, n - 1)\\n        add(0, n - 1)\\n\\n        for i in removeQueries:\\n            # get index of an interval containing `i`\\n            ind = segments.bisect_left((i + 1, -1)) - 1\\n            left, right = segments[ind]\\n\\n            # remove, then add two new segments\\n            remove(left, right)\\n            add(left, i - 1)\\n            add(i + 1, right)\\n\\n            ans.append(sums[-1])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n, ps, ans = len(nums), [0], []\\n        segments, sums = SortedList(), SortedList([0])\\n\\n        # compute prefix sums\\n        for k in nums:\\n            ps.append(ps[-1] + k)\\n\\n        # adding a segment with (left, right) borders and its sum\\n        def add(l, r):\\n            if l > r: return\\n            segments.add((l, r))\\n            sums.add(ps[r + 1] - ps[l])\\n\\n        # removing a segment\\n        def remove(l, r):\\n            segments.remove((l, r))\\n            sums.remove(ps[r + 1] - ps[l])\\n\\n        # initial segment with borders (0, n - 1)\\n        add(0, n - 1)\\n\\n        for i in removeQueries:\\n            # get index of an interval containing `i`\\n            ind = segments.bisect_left((i + 1, -1)) - 1\\n            left, right = segments[ind]\\n\\n            # remove, then add two new segments\\n            remove(left, right)\\n            add(left, i - 1)\\n            add(i + 1, right)\\n\\n            ans.append(sums[-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454166,
                "title": "c-explained-solution-using-set-and-multiset-time-o-nlogn-space-o-n",
                "content": "**Approach -**\\n\\nStep 1 - Make a prefix sum array for getting the sum in O(1) (Constant time)\\nStep 2 - Declare a set of pair for storing all segments and a multiset for storing the sum of all segments\\nStep 3 - Insert starting segment i.e. {0,n-1} and starting sum i.e. sum of all elements in set and multiset respectively\\nStep 4 - traverse removeQueries array from 0 to n-2 ( last maximum sum is always 0 so no need to traverse till n-1)\\n\\ti)  Find that segment in a set of segments in which removeQueries[i] present.\\n\\tii) Remove that segment and sum elements of that segment\\n\\tiii) Insert a new segment in the set which is come after breaking the previous segment\\n\\tiv) Find the sum of new segments and add them to multiset\\n\\tv) Find max sum in multiset and store in the answer\\n\\nQ - > Why we used multiset?\\n\\nAns -> Let\\'s understand using one example \\n\\n**One Example -** \\n\\nArr - [1,2,3,4,5] , Remove - [3,0,4,2,1]\\n\\nprefixSum ->  [1,3,6,10,15]\\nSet - > {{0,4}}\\nMultiset -> {15}\\n\\nFor -> Remove[0]\\nSet -> {{0,2},{4,4}}\\nMultiset -> {5,6}\\nAns -> {6}\\n\\nFor -> Remove[1]\\nSet -> {{1,2},{4,4}}\\nMultiset -> {5,5}       -> **Here, if we use a set then we can not store multiple value of the same type**\\nAns -> {6,5}\\n\\nFor -> Remove[2]\\nSet -> {{1,2}}\\nMultiset -> {5}\\nAns -> {6,5,5}\\n\\nFor -> Remove[3]\\nSet -> {{1,1}}\\nMultiset -> {2}\\nAns -> {6,5,5,2}\\n\\nFor -> Remove[4]\\nSet -> {}\\nMultiset -> {}\\nAns -> {6,5,5,2,0}\\n\\n**Output -> {6,5,5,2,0}**\\n\\n\\n**Code**\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll find_sum(int start,int end,vector<ll> &sum)\\n    {\\n        if(start==0)\\n            return sum[end];\\n        return sum[end]-sum[start-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& a, vector<int>& t) {\\n        \\n        int n = a.size();\\n        ll br,val1,val2,val,res;\\n        \\n        set<pair<int,int>> seg ;\\n        multiset<ll> value;\\n        pair<int,int> p;\\n        \\n        vector<ll> prefixSum(n),ans;\\n        prefixSum[0] = a[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i] = a[i]+prefixSum[i-1];\\n       \\n        seg.insert({0,n-1});\\n        value.insert(prefixSum[n-1]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            val1=-1,val2=-1;\\n            br = t[i];\\n            auto it = seg.lower_bound({br,br});\\n            if(it==seg.end()) it--;\\n            if(it->first>br) it--;\\n            p = *it;\\n            val = find_sum(p.first,p.second,prefixSum);\\n            seg.erase(it);\\n            auto ik = value.lower_bound(val);\\n            value.erase(ik);\\n            if(p.first==br){\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            else if(p.second==br){\\n                seg.insert({p.first,br-1});\\n                val2 = find_sum(p.first,br-1,prefixSum);\\n            }\\n            else{\\n                seg.insert({p.first,br-1});\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(p.first,br-1,prefixSum);\\n                val2 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            if(val1!=-1) value.insert(val1);\\n            if(val2!=-1) value.insert(val2);\\n            auto last = value.end();\\n            last--;\\n            res = *last;\\n            ans.push_back(res);\\n        }\\n        \\n        ans.push_back(0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**Time Complexity - O(NlogN) \\nSpace Complexity - O(N)**\\nN is length of given array\\n\\n**Upvote if you like it!**\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll find_sum(int start,int end,vector<ll> &sum)\\n    {\\n        if(start==0)\\n            return sum[end];\\n        return sum[end]-sum[start-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& a, vector<int>& t) {\\n        \\n        int n = a.size();\\n        ll br,val1,val2,val,res;\\n        \\n        set<pair<int,int>> seg ;\\n        multiset<ll> value;\\n        pair<int,int> p;\\n        \\n        vector<ll> prefixSum(n),ans;\\n        prefixSum[0] = a[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i] = a[i]+prefixSum[i-1];\\n       \\n        seg.insert({0,n-1});\\n        value.insert(prefixSum[n-1]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            val1=-1,val2=-1;\\n            br = t[i];\\n            auto it = seg.lower_bound({br,br});\\n            if(it==seg.end()) it--;\\n            if(it->first>br) it--;\\n            p = *it;\\n            val = find_sum(p.first,p.second,prefixSum);\\n            seg.erase(it);\\n            auto ik = value.lower_bound(val);\\n            value.erase(ik);\\n            if(p.first==br){\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            else if(p.second==br){\\n                seg.insert({p.first,br-1});\\n                val2 = find_sum(p.first,br-1,prefixSum);\\n            }\\n            else{\\n                seg.insert({p.first,br-1});\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(p.first,br-1,prefixSum);\\n                val2 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            if(val1!=-1) value.insert(val1);\\n            if(val2!=-1) value.insert(val2);\\n            auto last = value.end();\\n            last--;\\n            res = *last;\\n            ans.push_back(res);\\n        }\\n        \\n        ans.push_back(0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454472,
                "title": "treemap-o-nlogn-java",
                "content": "* Get range in which current index to be remove is lying.\\n* Remove that range from map and that range\\'s sum from sums map.\\n* Split that range into two halves, leftRange and rightRange respectively.\\n* If leftRange and rightRange is valid to be put on map then calculate sum from prefix computation and put both in range map and sum in sums map.\\n```\\nclass Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        long[] ans = new long[q.length];\\n        TreeMap<Long, long[]> map = new TreeMap<>(); // rangeStart,[rangeEnd,rangeSum]\\n        long pref[] = new long[nums.length];\\n        pref[0] = (long) nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            pref[i] = pref[i - 1];\\n            pref[i] += (long) nums[i];\\n        }\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        sums.put(pref[nums.length - 1], 1);\\n        map.put(0l, new long[] { nums.length - 1, pref[nums.length - 1] });\\n        for (int i = 0; i < q.length; i++) {\\n            Long x = map.floorKey((long) q[i]);\\n            if (x == null) {\\n                if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n                continue;\\n            }\\n            long range[] = { x, map.get(x)[0] };\\n            sums.put(map.get(x)[1], sums.get(map.get(x)[1]) - 1);\\n            if (sums.get(map.get(x)[1]) == 0) sums.remove(map.get(x)[1]);\\n            map.remove(x);\\n\\n            long leftSum = -1, rightSum = -1;\\n            long leftRange[] = { range[0], q[i] - 1 };\\n            long rightRange[] = { q[i] + 1, range[1] };\\n\\n            if (leftRange[0] >= 0 && leftRange[1] >= 0 && (leftRange[1] - leftRange[0] + 1) >= 1) {\\n                leftSum = pref[(int) leftRange[1]] - (leftRange[0] - 1 >= 0 ? pref[(int) (leftRange[0] - 1)] : 0);\\n                sums.put(leftSum, sums.getOrDefault(leftSum, 0) + 1);\\n                map.put(leftRange[0], new long[] { leftRange[1], leftSum });\\n            }\\n            if (rightRange[0] >= 0 && rightRange[1] >= 0 && (rightRange[1] - rightRange[0] + 1) >= 1) {\\n                rightSum = pref[(int) rightRange[1]] - (rightRange[0] - 1 >= 0 ? pref[(int) (rightRange[0] - 1)] : 0);\\n                sums.put(rightSum, sums.getOrDefault(rightSum, 0) + 1);\\n                map.put(rightRange[0], new long[] { rightRange[1], rightSum });\\n            }\\n            if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        long[] ans = new long[q.length];\\n        TreeMap<Long, long[]> map = new TreeMap<>(); // rangeStart,[rangeEnd,rangeSum]\\n        long pref[] = new long[nums.length];\\n        pref[0] = (long) nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            pref[i] = pref[i - 1];\\n            pref[i] += (long) nums[i];\\n        }\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        sums.put(pref[nums.length - 1], 1);\\n        map.put(0l, new long[] { nums.length - 1, pref[nums.length - 1] });\\n        for (int i = 0; i < q.length; i++) {\\n            Long x = map.floorKey((long) q[i]);\\n            if (x == null) {\\n                if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n                continue;\\n            }\\n            long range[] = { x, map.get(x)[0] };\\n            sums.put(map.get(x)[1], sums.get(map.get(x)[1]) - 1);\\n            if (sums.get(map.get(x)[1]) == 0) sums.remove(map.get(x)[1]);\\n            map.remove(x);\\n\\n            long leftSum = -1, rightSum = -1;\\n            long leftRange[] = { range[0], q[i] - 1 };\\n            long rightRange[] = { q[i] + 1, range[1] };\\n\\n            if (leftRange[0] >= 0 && leftRange[1] >= 0 && (leftRange[1] - leftRange[0] + 1) >= 1) {\\n                leftSum = pref[(int) leftRange[1]] - (leftRange[0] - 1 >= 0 ? pref[(int) (leftRange[0] - 1)] : 0);\\n                sums.put(leftSum, sums.getOrDefault(leftSum, 0) + 1);\\n                map.put(leftRange[0], new long[] { leftRange[1], leftSum });\\n            }\\n            if (rightRange[0] >= 0 && rightRange[1] >= 0 && (rightRange[1] - rightRange[0] + 1) >= 1) {\\n                rightSum = pref[(int) rightRange[1]] - (rightRange[0] - 1 >= 0 ? pref[(int) (rightRange[0] - 1)] : 0);\\n                sums.put(rightSum, sums.getOrDefault(rightSum, 0) + 1);\\n                map.put(rightRange[0], new long[] { rightRange[1], rightSum });\\n            }\\n            if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454234,
                "title": "python3-priority-queue",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nHere, I use \\n1) a ordered set to store the points where `nums` are divided; \\n2) a hash table mapping from left boundary to right boundary to validate if a triplet is still effective;\\n3) a priority queue to the triplet of <range sum, left boundary, right boundary>.\\n\\nAt each query, I add the point to the set of dividers, adjust the mapping of its left and right boundary points, and add the new two pieces to the priority queue. While finding current maximum from the priority queue, I first validate if the triplet is still in effect by checking if the left boundary matches the right boundary in the hash table. If not, I discard the top element until a valid triplet. \\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n```\\nclass Solution: \\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        sl = SortedList([-1, n])\\n        prefix = list(accumulate(nums, initial=0))\\n        mp = {-1 : n}\\n        pq = [(-prefix[-1], -1, n)]\\n        \\n        ans = []\\n        for q in removeQueries: \\n            sl.add(q)\\n            i = sl.bisect_left(q)\\n            lo = sl[i-1]\\n            hi = sl[i+1]\\n            mp[lo] = q\\n            mp[q] = hi \\n            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))\\n            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))\\n            \\n            while mp[pq[0][1]] != pq[0][2]: heappop(pq)\\n            ans.append(-pq[0][0])\\n        return ans \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        sl = SortedList([-1, n])\\n        prefix = list(accumulate(nums, initial=0))\\n        mp = {-1 : n}\\n        pq = [(-prefix[-1], -1, n)]\\n        \\n        ans = []\\n        for q in removeQueries: \\n            sl.add(q)\\n            i = sl.bisect_left(q)\\n            lo = sl[i-1]\\n            hi = sl[i+1]\\n            mp[lo] = q\\n            mp[q] = hi \\n            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))\\n            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))\\n            \\n            while mp[pq[0][1]] != pq[0][2]: heappop(pq)\\n            ans.append(-pq[0][0])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066942,
                "title": "java-6ms-o-n-time-space-arrays-only",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. --> Instead of removing elements one by one from the complete set, iterate backwards through removeQueries and start building the segments element by element. \\n \\n# Approach \\nFor each element that is either the start or end of a segment, record two things:\\n - The other end of the segment ```other[]```\\n - The sum of the segment ```sums[]```\\n\\nWhenever a new element is added, it will create a new segment:\\n- If the recorded sum of the element on the left is nonzero, the left end of our new segment will be ```other[left]```\\n- Otherwise, the left end will be the added element\\n- Use the same method to find the right end of the new segment\\n- The sum of the new segment will be ```sums[left] + sums[right] + (the value of the added element)```\\n- Compare that sum with a running max to keep track of the sum of the largest segment\\n\\n# Complexity \\n- Time complexity: $$O(n)$$  \\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] sums = new long[nums.length+2];\\n        int[] other = new int[nums.length+2];\\n\\n        long max = 0;\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = removeQueries.length-1; i > -1; --i) {\\n            int now = removeQueries[i];\\n            int left = sums[now] == 0 ? now+1 : other[now];\\n            int right = sums[now+2] == 0 ? now+1 : other[now+2];\\n            other[left] = right;\\n            other[right] = left;\\n\\n            long sum = sums[left]+sums[right]+nums[now];\\n            sums[left] = sums[right] = sum;\\n\\n            ans[i] = max;\\n            max = Math.max(max, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```other[]```\n```sums[]```\n```other[left]```\n```sums[left] + sums[right] + (the value of the added element)```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] sums = new long[nums.length+2];\\n        int[] other = new int[nums.length+2];\\n\\n        long max = 0;\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = removeQueries.length-1; i > -1; --i) {\\n            int now = removeQueries[i];\\n            int left = sums[now] == 0 ? now+1 : other[now];\\n            int right = sums[now+2] == 0 ? now+1 : other[now+2];\\n            other[left] = right;\\n            other[right] = left;\\n\\n            long sum = sums[left]+sums[right]+nums[now];\\n            sums[left] = sums[right] = sum;\\n\\n            ans[i] = max;\\n            max = Math.max(max, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455461,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long max_val=0;\\n    vector<long long>parent,sum;\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        x=find(x);\\n        y=find(y);\\n        if(x==y)\\n        {\\n            return ;\\n        }\\n        sum[x]+=sum[y];\\n        max_val=max(max_val,sum[x]);\\n        parent[y]=x;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& r)\\n    {\\n        n=nums.size();\\n        parent.resize(n+10);\\n        sum.resize(n+10);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i];\\n            parent[i]=i;\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<long long>ans(n,0);\\n         max_val=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans[i]=max_val;\\n            int index=r[i];\\n            vis[index]=1;\\n            max_val=max(max_val,1ll*nums[index]);\\n            if(index+1<n&&vis[index+1])\\n            {\\n                merge(index,index+1);\\n            }\\n            if(index-1>=0&&vis[index-1])\\n            {\\n                merge(index,index-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long max_val=0;\\n    vector<long long>parent,sum;\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        x=find(x);\\n        y=find(y);\\n        if(x==y)\\n        {\\n            return ;\\n        }\\n        sum[x]+=sum[y];\\n        max_val=max(max_val,sum[x]);\\n        parent[y]=x;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& r)\\n    {\\n        n=nums.size();\\n        parent.resize(n+10);\\n        sum.resize(n+10);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i];\\n            parent[i]=i;\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<long long>ans(n,0);\\n         max_val=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans[i]=max_val;\\n            int index=r[i];\\n            vis[index]=1;\\n            max_val=max(max_val,1ll*nums[index]);\\n            if(index+1<n&&vis[index+1])\\n            {\\n                merge(index,index+1);\\n            }\\n            if(index-1>=0&&vis[index-1])\\n            {\\n                merge(index,index-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454219,
                "title": "c-o-nlogn-solution-with-explanation-illustration-using-set",
                "content": "We use an `O(logN)` container (segmentSums) to store the sums of the current segments in the array.\\nAfter every time we remove an index, we remove the sum of the old segment and insert the\\nsums of the two new ones.\\n\\nWe also keep track of all the removed indices in another `O(logN)` container (removedIndices) that\\nwill allow us to get the bounds of a segment in `O(logN)`.\\n\\nThe algorithm goes like this:\\n- find which segment this removeQueries[i] belongs to.\\n- remove the sum of elements of this segment from the segmentSums container.\\n- add the 2 sums of the 2 new segments to the container.\\n- the answer at this index will be the biggest sum in the segmentSums container.\\n- add the removed index to the removedIndices container.\\n\\n\\n#### Example:\\n```\\n[1,2,5,6,1] [0,3,2,4,1]\\nWe start with the containers like this:\\n    segmentSums     removedIndices        segments\\n      [  15  ]        [ -1   5 ]         1-2-5-6-1\\n\\n1) remove the item at index 0\\n    segmentSums     removedIndices        segments\\n      [  14  ]        [ -1 0 5 ]           2-5-6-1\\n\\n2) remove the item at index 3\\n    segmentSums     removedIndices        segments\\n      [  7  ]        [ -1 0 3 5 ]          2-5   1\\n      [  1  ]\\n\\n3) remove the item at index 2\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 5 ]         2     1\\n      [  1  ]\\n\\n4) remove the item at index 4\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 4 5 ]       2\\n      [  1  ]\\n\\n5) remove the item at index 1\\n    segmentSums     removedIndices        segments\\n      [     ]      [ -1 0 1 2 3 4 5 ]\\n```\\nThe answer becomes the top elements at each step which is [15, 14, 7, 2, 2, 0]\\n\\n\\n### Complexity\\nTime: `O(logN)`\\nSpace: `O(N)`\\n\\n\\n#### C++ Code\\n\\n```c++\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    int n = nums.size();\\n    // Use a multiset to store all the sums of the segments after each operation\\n    // The multiset will have the biggest sum at the begin iterator\\n    std::multiset<long long, std::greater<long long>> segmentSums;\\n\\n    // store all the removed indices in this set.\\n    // It will help use find which segment a point belongs to\\n    set<int> removedIndices{-1, n};\\n\\n    // calculate the prefix sum for the array\\n    vector<long long> res(n), prefix(n);\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + nums[i];\\n\\n    // start the segmentsSum with the sum of all elements in the array\\n    segmentSums.insert(prefix.back());\\n\\n    for (int i = 0; i < n; i++) {\\n      // get the bounds of the segment that this item belongs to\\n      auto after = removedIndices.lower_bound(removeQueries[i]);\\n      auto before = prev(after);\\n\\n      // get the sum of the old segment and remove it from the multiset\\n      auto sum = prefix[*after - 1] - (*before < 0 ? 0 : prefix[*before]);\\n      segmentSums.erase(segmentSums.find(sum));\\n\\n      // insert the sums of the 2 broken segments in the multiset\\n      segmentSums.insert(prefix[*after - 1] - prefix[removeQueries[i]]);\\n      if (removeQueries[i] - 1 >= 0)\\n        segmentSums.insert(prefix[removeQueries[i] - 1] - (*before < 0 ? 0 : prefix[*before]));\\n\\n      // added the current removed query index to the set of removed indices\\n      removedIndices.insert(removeQueries[i]);\\n\\n      // update the result with the biggest value in the segmentSums\\n      res[i] = *segmentSums.begin();\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n**Upvote if you find it helpful :)**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n[1,2,5,6,1] [0,3,2,4,1]\\nWe start with the containers like this:\\n    segmentSums     removedIndices        segments\\n      [  15  ]        [ -1   5 ]         1-2-5-6-1\\n\\n1) remove the item at index 0\\n    segmentSums     removedIndices        segments\\n      [  14  ]        [ -1 0 5 ]           2-5-6-1\\n\\n2) remove the item at index 3\\n    segmentSums     removedIndices        segments\\n      [  7  ]        [ -1 0 3 5 ]          2-5   1\\n      [  1  ]\\n\\n3) remove the item at index 2\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 5 ]         2     1\\n      [  1  ]\\n\\n4) remove the item at index 4\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 4 5 ]       2\\n      [  1  ]\\n\\n5) remove the item at index 1\\n    segmentSums     removedIndices        segments\\n      [     ]      [ -1 0 1 2 3 4 5 ]\\n```\n```c++\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    int n = nums.size();\\n    // Use a multiset to store all the sums of the segments after each operation\\n    // The multiset will have the biggest sum at the begin iterator\\n    std::multiset<long long, std::greater<long long>> segmentSums;\\n\\n    // store all the removed indices in this set.\\n    // It will help use find which segment a point belongs to\\n    set<int> removedIndices{-1, n};\\n\\n    // calculate the prefix sum for the array\\n    vector<long long> res(n), prefix(n);\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + nums[i];\\n\\n    // start the segmentsSum with the sum of all elements in the array\\n    segmentSums.insert(prefix.back());\\n\\n    for (int i = 0; i < n; i++) {\\n      // get the bounds of the segment that this item belongs to\\n      auto after = removedIndices.lower_bound(removeQueries[i]);\\n      auto before = prev(after);\\n\\n      // get the sum of the old segment and remove it from the multiset\\n      auto sum = prefix[*after - 1] - (*before < 0 ? 0 : prefix[*before]);\\n      segmentSums.erase(segmentSums.find(sum));\\n\\n      // insert the sums of the 2 broken segments in the multiset\\n      segmentSums.insert(prefix[*after - 1] - prefix[removeQueries[i]]);\\n      if (removeQueries[i] - 1 >= 0)\\n        segmentSums.insert(prefix[removeQueries[i] - 1] - (*before < 0 ? 0 : prefix[*before]));\\n\\n      // added the current removed query index to the set of removed indices\\n      removedIndices.insert(removeQueries[i]);\\n\\n      // update the result with the biggest value in the segmentSums\\n      res[i] = *segmentSums.begin();\\n    }\\n\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454218,
                "title": "dsu",
                "content": "```\\n#define ll long long\\nstruct DSU {\\n    vector<ll> par, lev, sum;\\n    \\n    //sum -> to store the sum of a segment\\n    //currently every index represent a segment\\n    \\n    DSU(int n, vector<int> &ar) {\\n        par.resize(n, 0);\\n        lev.resize(n, 1);\\n        sum.resize(n);\\n        for(int i = 0; i < n; ++i) sum[i] = ar[i];\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    \\n    int fset(int v) {\\n        return v == par[v] ? v : par[v] = fset(par[v]);\\n    }\\n    \\n    void uset(int u, int v) {\\n        u = fset(u), v = fset(v);\\n        if(u != v) {\\n            if(lev[u] < lev[v]) swap(u, v);\\n            par[v] = u;\\n            sum[u] += sum[v]; // if two segments are merged the sum increases\\n        }\\n    }\\n    \\n    ll getSum(int v) {\\n        return sum[fset(v)]; // the total sum of the segment would be stored in the parent node\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& v) {\\n        int n = nums.size();\\n        DSU dsu(n, nums);\\n        \\n        vector<ll> res(n, 0), cur(n, 0);\\n        ll mx = 0;\\n        \\n        //work your way towards the back\\n        for(int i = v.size() - 1; ~i; --i) {\\n            res[i] = mx; // place the current maximum\\n            \\n            cur[v[i]] = nums[v[i]]; //place the value\\n            \\n            if(v[i] + 1 < n and cur[v[i] + 1] != 0) dsu.uset(v[i], v[i] + 1); \\n            // if the value at right index is not zero so the current index can be merged with the right segment\\n            \\n            if(v[i] - 1 >= 0 and cur[v[i] - 1] != 0) dsu.uset(v[i], v[i] - 1);\\n            // if the value at left index is not zero so the current index can be merged with the left segment\\n            \\n            mx = max(mx, dsu.getSum(v[i])); //after merging get the sum of the current segment formed placing the v[i]th element\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nstruct DSU {\\n    vector<ll> par, lev, sum;\\n    \\n    //sum -> to store the sum of a segment\\n    //currently every index represent a segment\\n    \\n    DSU(int n, vector<int> &ar) {\\n        par.resize(n, 0);\\n        lev.resize(n, 1);\\n        sum.resize(n);\\n        for(int i = 0; i < n; ++i) sum[i] = ar[i];\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    \\n    int fset(int v) {\\n        return v == par[v] ? v : par[v] = fset(par[v]);\\n    }\\n    \\n    void uset(int u, int v) {\\n        u = fset(u), v = fset(v);\\n        if(u != v) {\\n            if(lev[u] < lev[v]) swap(u, v);\\n            par[v] = u;\\n            sum[u] += sum[v]; // if two segments are merged the sum increases\\n        }\\n    }\\n    \\n    ll getSum(int v) {\\n        return sum[fset(v)]; // the total sum of the segment would be stored in the parent node\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& v) {\\n        int n = nums.size();\\n        DSU dsu(n, nums);\\n        \\n        vector<ll> res(n, 0), cur(n, 0);\\n        ll mx = 0;\\n        \\n        //work your way towards the back\\n        for(int i = v.size() - 1; ~i; --i) {\\n            res[i] = mx; // place the current maximum\\n            \\n            cur[v[i]] = nums[v[i]]; //place the value\\n            \\n            if(v[i] + 1 < n and cur[v[i] + 1] != 0) dsu.uset(v[i], v[i] + 1); \\n            // if the value at right index is not zero so the current index can be merged with the right segment\\n            \\n            if(v[i] - 1 >= 0 and cur[v[i] - 1] != 0) dsu.uset(v[i], v[i] - 1);\\n            // if the value at left index is not zero so the current index can be merged with the left segment\\n            \\n            mx = max(mx, dsu.getSum(v[i])); //after merging get the sum of the current segment formed placing the v[i]th element\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465271,
                "title": "very-easy-to-understand-java-only-treemap-used-o-nlogn",
                "content": "** Approach:** Using simple logic of storing the ranges and splitting them as solving the query.\\nIntially, we will be having whole array as are range (0, n-1). Now as we solve queries, say remove index x or set index x value as 0, we will split our range into (0, x -1) and (x + 1, n). Also, we will remove our previous range as it is of no use.\\nThere can be cases in that, suppose we need to remove x and there is range (x, x), then we will simple remove it and not adding anything back (refer code below)\\n\\nNow, to get the maximum sum of all the possible ranges, we will use another treemap, which will store sum to its frequency (frequency because multiple ranges can have same sum). And we can fetch maximum sum at any point in O(1) by simple getting last element of treemap.\\n\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] result = new long[n]; // array to store answer\\n        long[] prefixSum = new long[n+1]; // array to store prefixSum of nums\\n\\n        // calculating prefixSum\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        // TreeMap to store ranges to its sum mapping\\n        TreeMap<int[], Long> ranges = new TreeMap<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        \\n        // initially it will have whole array range\\n        ranges.put(new int[]{0, n - 1}, prefixSum[n]);\\n\\n        // TreeMap to store all the possible sums of range we encounter while solving queries, we are storing frequencies because \\n        // multiple range can have same sum.\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        // initialise it with sum of all array.\\n        sums.put(prefixSum[n], 1);\\n\\n        // Iterating on queries\\n        for(int i = 0; i < n; i++){\\n            int node = removeQueries[i]; // index to be removed or set to zero.\\n\\n            // finding range which will split when node index is removed or set 0.\\n            int[] rangeToBeRemoved = ranges.floorKey(new int[]{node});\\n            Long sum = ranges.get(rangeToBeRemoved); // finding its sum\\n\\n            // removing/ reducing sum from sums Map because we are splitting that range, so it is no more valid\\n            int f = sums.get(sum);\\n            if(f == 1) sums.remove(sum);\\n            else sums.put(sum, f - 1);\\n\\n            // removing that range\\n            ranges.remove(rangeToBeRemoved);\\n            \\n            int l = rangeToBeRemoved[0];\\n            int r = rangeToBeRemoved[1];\\n            long newSum = 0;\\n\\n            // Splitting range and store back new ranges form along with its sum.\\n            if (l == node && r != node) {\\n                newSum = prefixSum[r + 1] - prefixSum[l + 1];\\n                ranges.put(new int[]{l+1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            } else if (r == node && l != node) {\\n                newSum = prefixSum[r] - prefixSum[l];\\n                ranges.put(new int[]{l, r - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n            } else if(node > l && node < r){\\n                newSum = prefixSum[node] - prefixSum[l];\\n                ranges.put(new int[]{l, node - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n                newSum = prefixSum[r+1] - prefixSum[node + 1];\\n                ranges.put(new int[]{node + 1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            }\\n\\n\\n            if(sums.size() != 0)\\n                result[i] = sums.lastKey();\\n            else\\n                result[i] = 0;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] result = new long[n]; // array to store answer\\n        long[] prefixSum = new long[n+1]; // array to store prefixSum of nums\\n\\n        // calculating prefixSum\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        // TreeMap to store ranges to its sum mapping\\n        TreeMap<int[], Long> ranges = new TreeMap<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        \\n        // initially it will have whole array range\\n        ranges.put(new int[]{0, n - 1}, prefixSum[n]);\\n\\n        // TreeMap to store all the possible sums of range we encounter while solving queries, we are storing frequencies because \\n        // multiple range can have same sum.\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        // initialise it with sum of all array.\\n        sums.put(prefixSum[n], 1);\\n\\n        // Iterating on queries\\n        for(int i = 0; i < n; i++){\\n            int node = removeQueries[i]; // index to be removed or set to zero.\\n\\n            // finding range which will split when node index is removed or set 0.\\n            int[] rangeToBeRemoved = ranges.floorKey(new int[]{node});\\n            Long sum = ranges.get(rangeToBeRemoved); // finding its sum\\n\\n            // removing/ reducing sum from sums Map because we are splitting that range, so it is no more valid\\n            int f = sums.get(sum);\\n            if(f == 1) sums.remove(sum);\\n            else sums.put(sum, f - 1);\\n\\n            // removing that range\\n            ranges.remove(rangeToBeRemoved);\\n            \\n            int l = rangeToBeRemoved[0];\\n            int r = rangeToBeRemoved[1];\\n            long newSum = 0;\\n\\n            // Splitting range and store back new ranges form along with its sum.\\n            if (l == node && r != node) {\\n                newSum = prefixSum[r + 1] - prefixSum[l + 1];\\n                ranges.put(new int[]{l+1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            } else if (r == node && l != node) {\\n                newSum = prefixSum[r] - prefixSum[l];\\n                ranges.put(new int[]{l, r - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n            } else if(node > l && node < r){\\n                newSum = prefixSum[node] - prefixSum[l];\\n                ranges.put(new int[]{l, node - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n                newSum = prefixSum[r+1] - prefixSum[node + 1];\\n                ranges.put(new int[]{node + 1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            }\\n\\n\\n            if(sums.size() != 0)\\n                result[i] = sums.lastKey();\\n            else\\n                result[i] = 0;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458197,
                "title": "using-multiset-binary-search-o-n-logn",
                "content": "```\\n// Ishwar Govind\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<ll> pre(n+1,0);\\n        multiset<ll> sums;\\n        map<int,pair<int,int>> next;\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n        }\\n        sums.insert(pre[n]);\\n        next[n-1] = {0,n-1};\\n        vector<ll> ans;\\n        for(int i=0;i<removeQueries.size();i++){\\n            int idx = removeQueries[i];\\n            auto tmp = *next.lower_bound(idx);\\n            pair<int,int> pp = next[tmp.first];\\n            if(pp.first==idx){\\n                next.erase(pp.second);\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n            }\\n            else if(pp.second==idx){\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};;\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            else{\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            ans.push_back(*sums.rbegin());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// Ishwar Govind\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<ll> pre(n+1,0);\\n        multiset<ll> sums;\\n        map<int,pair<int,int>> next;\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n        }\\n        sums.insert(pre[n]);\\n        next[n-1] = {0,n-1};\\n        vector<ll> ans;\\n        for(int i=0;i<removeQueries.size();i++){\\n            int idx = removeQueries[i];\\n            auto tmp = *next.lower_bound(idx);\\n            pair<int,int> pp = next[tmp.first];\\n            if(pp.first==idx){\\n                next.erase(pp.second);\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n            }\\n            else if(pp.second==idx){\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};;\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            else{\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            ans.push_back(*sums.rbegin());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455506,
                "title": "java-union-find",
                "content": "Start from the last query and build the array.\\nCheck for every index whether its left or right index was processed previously. If so, merge their chains and add their sum to the representative of the chain. Otherwise, the index cannot be part of a chain, so we make a new set/chain for it.\\n\\n```\\n    static long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length; \\n        DisjointSet d = new DisjointSet();\\n        long [] result = new long [n];\\n        \\n        for(int i = n - 1; i > 0; i--){\\n            int curIndex = removeQueries[i];\\n            d.makeSet(curIndex, nums[curIndex]);\\n            d.merge(curIndex, curIndex-1);\\n            d.merge(curIndex, curIndex + 1);\\n            result[i-1] = Math.max(result[i], d.find(curIndex).value);\\n        }\\n        return result;\\n    }\\n    \\n    public static class Node{\\n        int data, rank;\\n        long value;\\n        Node parent;\\n        public Node(int data, long value){\\n            this.data = data;\\n            this.value = value;\\n\\n        }\\n    }\\n    \\n    public static class DisjointSet{\\n        Map<Integer, Node> map = new HashMap<>();\\n        public void makeSet(int data, long value){\\n            Node node = new Node(data, value);\\n            node.parent = node;\\n            map.put(data, node);\\n        }\\n        \\n        public Node find(int x){\\n            if(map.get(x) == null) return null;\\n            if(map.get(x) == map.get(x).parent) return map.get(x);\\n            return map.get(x).parent = find(map.get(x).parent.data);\\n        }\\n        \\n        public void merge(int x, int y){\\n            Node parentX = find(x), parentY = find(y);\\n            if(parentY == null || parentY.data == parentX.data) return;\\n            parentY.parent = parentX;\\n            parentX.value += parentY.value;\\n        }\\n    }\\n```\\n\\n\\n**Merging by rank for optimization:**\\n```\\n public void merge(int x, int y){\\n\\t\\tNode parentX = find(x), parentY = find(y);\\n\\t\\tif(parentY == null || parentY.data == parentX.data) return;\\n\\t\\tif(parentX.rank > parentY.rank){\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t}\\n\\t\\telse if(parentY.rank > parentX.rank){\\n\\t\\t\\tparentX.parent = parentY;\\n\\t\\t\\tparentY.value += parentX.value;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t\\tparentX.rank++;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    static long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length; \\n        DisjointSet d = new DisjointSet();\\n        long [] result = new long [n];\\n        \\n        for(int i = n - 1; i > 0; i--){\\n            int curIndex = removeQueries[i];\\n            d.makeSet(curIndex, nums[curIndex]);\\n            d.merge(curIndex, curIndex-1);\\n            d.merge(curIndex, curIndex + 1);\\n            result[i-1] = Math.max(result[i], d.find(curIndex).value);\\n        }\\n        return result;\\n    }\\n    \\n    public static class Node{\\n        int data, rank;\\n        long value;\\n        Node parent;\\n        public Node(int data, long value){\\n            this.data = data;\\n            this.value = value;\\n\\n        }\\n    }\\n    \\n    public static class DisjointSet{\\n        Map<Integer, Node> map = new HashMap<>();\\n        public void makeSet(int data, long value){\\n            Node node = new Node(data, value);\\n            node.parent = node;\\n            map.put(data, node);\\n        }\\n        \\n        public Node find(int x){\\n            if(map.get(x) == null) return null;\\n            if(map.get(x) == map.get(x).parent) return map.get(x);\\n            return map.get(x).parent = find(map.get(x).parent.data);\\n        }\\n        \\n        public void merge(int x, int y){\\n            Node parentX = find(x), parentY = find(y);\\n            if(parentY == null || parentY.data == parentX.data) return;\\n            parentY.parent = parentX;\\n            parentX.value += parentY.value;\\n        }\\n    }\\n```\n```\\n public void merge(int x, int y){\\n\\t\\tNode parentX = find(x), parentY = find(y);\\n\\t\\tif(parentY == null || parentY.data == parentX.data) return;\\n\\t\\tif(parentX.rank > parentY.rank){\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t}\\n\\t\\telse if(parentY.rank > parentX.rank){\\n\\t\\t\\tparentX.parent = parentY;\\n\\t\\t\\tparentY.value += parentX.value;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t\\tparentX.rank++;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467671,
                "title": "c-prefix-sum-sets-easy-solution-beginner-friendly",
                "content": "```\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        int q = removeQueries.size();\\n        \\n        vector<ll> prefix(n+1);\\n        for(int j = 1;j <= n;j++)\\n        {\\n            prefix[j] = prefix[j-1]+nums[j-1];\\n        }\\n        \\n        multiset<ll> all;\\n        all.insert(prefix[n]);\\n        all.insert(0);\\n        \\n        set<int> removed;\\n        vector<ll> result;\\n        \\n        for(auto i: removeQueries){\\n            i++;\\n            \\n            auto nxt_itr = removed.upper_bound(i);\\n            int last_ind = n;\\n            if(nxt_itr != removed.end()) last_ind = *nxt_itr - 1;\\n            \\n            int start_ind = 1;\\n            if(nxt_itr != removed.begin()){\\n                --nxt_itr;\\n                start_ind = *nxt_itr + 1;\\n            }\\n            \\n            ll range_sum = prefix[last_ind] - prefix[start_ind-1];\\n            all.erase(all.find(range_sum));\\n            \\n            //[start_ind, i-1]\\n            if(i-1 >= start_ind)all.insert(prefix[i-1] - prefix[start_ind-1]);\\n            \\n            //[i+1,last_ind]\\n            if(last_ind >= i+1)all.insert(prefix[last_ind]-prefix[i]);\\n            \\n            result.push_back(*all.rbegin());\\n            removed.insert(i);\\n        }\\n      return result;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        int q = removeQueries.size();\\n        \\n        vector<ll> prefix(n+1);\\n        for(int j = 1;j <= n;j++)\\n        {\\n            prefix[j] = prefix[j-1]+nums[j-1];\\n        }\\n        \\n        multiset<ll> all;\\n        all.insert(prefix[n]);\\n        all.insert(0);\\n        \\n        set<int> removed;\\n        vector<ll> result;\\n        \\n        for(auto i: removeQueries){\\n            i++;\\n            \\n            auto nxt_itr = removed.upper_bound(i);\\n            int last_ind = n;\\n            if(nxt_itr != removed.end()) last_ind = *nxt_itr - 1;\\n            \\n            int start_ind = 1;\\n            if(nxt_itr != removed.begin()){\\n                --nxt_itr;\\n                start_ind = *nxt_itr + 1;\\n            }\\n            \\n            ll range_sum = prefix[last_ind] - prefix[start_ind-1];\\n            all.erase(all.find(range_sum));\\n            \\n            //[start_ind, i-1]\\n            if(i-1 >= start_ind)all.insert(prefix[i-1] - prefix[start_ind-1]);\\n            \\n            //[i+1,last_ind]\\n            if(last_ind >= i+1)all.insert(prefix[last_ind]-prefix[i]);\\n            \\n            result.push_back(*all.rbegin());\\n            removed.insert(i);\\n        }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559660,
                "title": "python-5-lines-o-n-with-explanation",
                "content": "# Explanation\\nLet\\'s remind ourselves of the problem constraints.\\n\\n1. n == nums.length == removeQueries.length\\n2. 1 <= n <= 10^5\\n3. 1 <= nums[i] <= 10^9\\n4. 0 <= removeQueries[i] < n\\n5. All the values of removeQueries are unique.\\n\\nBecause of constraints 1, 4, and 5, it is guaraunteed that all indices of nums will be in removeQueries. This means that the last value of the answer will always be zero because all values will be removed and all that remains is the null segment.\\n\\nWe can exploit this to simplify the problem by building our segments backwards, visiting each element we wish to introduce to our existing segments from the reverse of the removeQueries array. \\n\\nVisiting the segments backwards is simpler because of constraint 3, which guarauntees that the nums array only contains positive integers. This means that each time we add or extend our segments, the value of the maximum segment can only increase or stay the same. Therefore, we won\\'t need to worry about maintaining a heap to keep track of the largest segments and invalidating segments that no longer exist, we can just use an integer to keep track of what the largest segment ever was and use the maximum of that or the segment we just added to as our largest segment for the next iteration.\\n\\nWe do this by keeping track of existing segments in a dictionary `seg`, which is initialized as an empty dictionary and will be used to map the edges of segments to a tuple containing 1) the index of the opposite edge of the segment and 2) the size of the segment. \\n\\nFor each new element we\\'re introducing, we grab segments to the left and right of index `q` if they exist, using default segments `(q, 0)` if they do not which represents a side of the new segment that extends no further and adds no additional value, and then assign both the left and right sides to the tuple with their compliment index and the sum.\\n\\nFinally, we reverse the output to get the answer to the original question.\\n# Code\\n## 10 lines (prettier)\\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l = seg.get(q-1, (q, 0))\\n            r = seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]] = (r[0], s)\\n            seg[r[0]] = (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\\n\\n## 8 lines (a little crowded)\\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\\n\\n## 7 lines\\n\\nA bit more contrived but just uses ans[-1] to track the top element. Has to slice off the first element of removeQueries to prevent an additional iteration.\\n\\n```python\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            ans.append(max(s, ans[-1]))\\n        return ans[::-1]\\n```\\n\\n## 6 lines\\nYou could also shave off another line by using ans[-1] to track `s`, which requires you to then accumulate the results at the end using `itertools.accumulate` before reversing them.\\n\\n```python\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            (li, ls), (ri, rs) = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            ans.append(s := nums[q] + ls + rs)\\n            seg[li], seg[ri] = (ri, s), (li, s)\\n        return [*accumulate(ans, max)][::-1]\\n```\\n\\n## 5 lines\\n\\nGetting code-golfy, but by further abusing walrus operators you can get this down to 5 lines. Spaces removed and all variables renamed to be length 1 in the code golfing spirit.\\n\\n```python\\n        a,c=[0],{}\\n        for q in reversed(removeQueries[1:]):\\n            a.append(s:=nums[q]+(l:=c.get(q-1,(q, 0)))[1]+(r:=c.get(q+1,(q, 0)))[1])\\n            c[l[0]],c[r[0]]=(r[0],s),(l[0],s)\\n        return [*accumulate(a, max)][::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l = seg.get(q-1, (q, 0))\\n            r = seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]] = (r[0], s)\\n            seg[r[0]] = (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\n```python\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            ans.append(max(s, ans[-1]))\\n        return ans[::-1]\\n```\n```python\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            (li, ls), (ri, rs) = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            ans.append(s := nums[q] + ls + rs)\\n            seg[li], seg[ri] = (ri, s), (li, s)\\n        return [*accumulate(ans, max)][::-1]\\n```\n```python\\n        a,c=[0],{}\\n        for q in reversed(removeQueries[1:]):\\n            a.append(s:=nums[q]+(l:=c.get(q-1,(q, 0)))[1]+(r:=c.get(q+1,(q, 0)))[1])\\n            c[l[0]],c[r[0]]=(r[0],s),(l[0],s)\\n        return [*accumulate(a, max)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498714,
                "title": "python3-reverse-dsu",
                "content": "```\\nclass UnionFind :\\n    def __init__(self):\\n        self.parent = {}\\n        self.maxsum = 0\\n        self.sum = {}\\n        \\n    def find(self,x):\\n        if x!=self.parent[x]:\\n            self.parent[x]=self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,x,y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px==py :\\n            return\\n        self.sum[px]+=self.sum[py]\\n        self.parent[py]=px\\n        self.maxsum = max(self.maxsum,self.sum[px])\\n    \\n    def mergesegment(self,u,value):\\n        self.parent[u]=u\\n        self.maxsum = max(self.maxsum,value)\\n        self.sum[u]=value\\n        if u-1 in self.parent :\\n            self.union(u-1,u)\\n        if u+1 in self.parent :\\n            self.union(u+1,u)\\n        \\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        uf = UnionFind()\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n-1,-1,-1):\\n            ans[i] = uf.maxsum\\n            q = removeQueries[i]\\n            uf.mergesegment(q,nums[q])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind :\\n    def __init__(self):\\n        self.parent = {}\\n        self.maxsum = 0\\n        self.sum = {}\\n        \\n    def find(self,x):\\n        if x!=self.parent[x]:\\n            self.parent[x]=self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,x,y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px==py :\\n            return\\n        self.sum[px]+=self.sum[py]\\n        self.parent[py]=px\\n        self.maxsum = max(self.maxsum,self.sum[px])\\n    \\n    def mergesegment(self,u,value):\\n        self.parent[u]=u\\n        self.maxsum = max(self.maxsum,value)\\n        self.sum[u]=value\\n        if u-1 in self.parent :\\n            self.union(u-1,u)\\n        if u+1 in self.parent :\\n            self.union(u+1,u)\\n        \\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        uf = UnionFind()\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n-1,-1,-1):\\n            ans[i] = uf.maxsum\\n            q = removeQueries[i]\\n            uf.mergesegment(q,nums[q])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475116,
                "title": "java-2-ways-union-find-and-segment-tree",
                "content": "Approach 1: Union Find (24ms)\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        UnionFind uf = new UnionFind(n, nums);\\n        \\n        for (int i=n-1; i>0; i--) {\\n            int cur = removeQueries[i];\\n            uf.add(cur, nums[cur]);\\n            \\n            if (cur > 0 && uf.getSum(cur-1) > 0)\\n                uf.union(cur, cur - 1);\\n            if (cur < n-1 && uf.getSum(cur+1) > 0)\\n                uf.union(cur, cur + 1);\\n            \\n            int root = uf.find(cur);\\n            ans[i-1] = Math.max(uf.getSum(root), ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private long[] sum;\\n\\n    public UnionFind(int size, int[] arr) {\\n        root = new int[size];\\n        rank = new int[size];\\n        sum = new long[size];\\n        \\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1; \\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                sum[rootX] += sum[rootY];\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n                sum[rootY] += sum[rootX];\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n                sum[rootX] += sum[rootY];\\n            }\\n        }\\n    }\\n    \\n    public void add(int idx, int val) {\\n        sum[idx] += val;\\n    }\\n    \\n    public long getSum(int idx) {\\n        return sum[idx];\\n    }\\n}\\n```\\n\\nApproach 2: Segment Tree (199 ms)\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        SegmentTreeNode st = new SegmentTreeNode(0, n-1);\\n        \\n        for (int i=0; i<n; i++) {\\n            st.update(i, nums[i]);\\n        }\\n\\n        for (int i=0; i<n-1; i++) {\\n            ans[i] = st.update(removeQueries[i], -nums[removeQueries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass SegmentTreeNode {\\n    SegmentTreeNode left, right;\\n    long max, leftSum, rightSum;\\n    int lo, hi;\\n    boolean isDivided;\\n    \\n    public SegmentTreeNode(int lo, int hi) {\\n        this.lo = lo;\\n        this.hi = hi;\\n    }\\n    \\n    public int getMid() {\\n        return lo + (hi - lo)/2;\\n    }\\n    \\n    public SegmentTreeNode getLeft() {\\n        if (left == null)\\n            left = new SegmentTreeNode(lo, getMid());\\n        return left;\\n    }\\n    \\n    public SegmentTreeNode getRight() {\\n        if (right == null)\\n            right = new SegmentTreeNode(getMid()+1, hi);\\n        return right;\\n    }\\n    \\n    public long update(int pos, int val) {\\n        if (lo > pos || hi < pos)\\n            return 0;\\n        \\n        if (pos == lo && pos == hi) {\\n            leftSum += val;\\n            rightSum += val;\\n            max += val;\\n            if (max == 0)\\n                isDivided = true;\\n            return max;\\n        }\\n        \\n        getLeft().update(pos, val);\\n        getRight().update(pos, val);\\n        \\n        leftSum = left.isDivided ? left.leftSum : left.leftSum + right.leftSum;\\n        rightSum = right.isDivided ? right.rightSum : right.rightSum + left.rightSum;\\n        max = Math.max(Math.max(left.max, right.max), left.rightSum + right.leftSum);\\n        isDivided = left.isDivided || right.isDivided;\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        UnionFind uf = new UnionFind(n, nums);\\n        \\n        for (int i=n-1; i>0; i--) {\\n            int cur = removeQueries[i];\\n            uf.add(cur, nums[cur]);\\n            \\n            if (cur > 0 && uf.getSum(cur-1) > 0)\\n                uf.union(cur, cur - 1);\\n            if (cur < n-1 && uf.getSum(cur+1) > 0)\\n                uf.union(cur, cur + 1);\\n            \\n            int root = uf.find(cur);\\n            ans[i-1] = Math.max(uf.getSum(root), ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private long[] sum;\\n\\n    public UnionFind(int size, int[] arr) {\\n        root = new int[size];\\n        rank = new int[size];\\n        sum = new long[size];\\n        \\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1; \\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                sum[rootX] += sum[rootY];\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n                sum[rootY] += sum[rootX];\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n                sum[rootX] += sum[rootY];\\n            }\\n        }\\n    }\\n    \\n    public void add(int idx, int val) {\\n        sum[idx] += val;\\n    }\\n    \\n    public long getSum(int idx) {\\n        return sum[idx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        SegmentTreeNode st = new SegmentTreeNode(0, n-1);\\n        \\n        for (int i=0; i<n; i++) {\\n            st.update(i, nums[i]);\\n        }\\n\\n        for (int i=0; i<n-1; i++) {\\n            ans[i] = st.update(removeQueries[i], -nums[removeQueries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass SegmentTreeNode {\\n    SegmentTreeNode left, right;\\n    long max, leftSum, rightSum;\\n    int lo, hi;\\n    boolean isDivided;\\n    \\n    public SegmentTreeNode(int lo, int hi) {\\n        this.lo = lo;\\n        this.hi = hi;\\n    }\\n    \\n    public int getMid() {\\n        return lo + (hi - lo)/2;\\n    }\\n    \\n    public SegmentTreeNode getLeft() {\\n        if (left == null)\\n            left = new SegmentTreeNode(lo, getMid());\\n        return left;\\n    }\\n    \\n    public SegmentTreeNode getRight() {\\n        if (right == null)\\n            right = new SegmentTreeNode(getMid()+1, hi);\\n        return right;\\n    }\\n    \\n    public long update(int pos, int val) {\\n        if (lo > pos || hi < pos)\\n            return 0;\\n        \\n        if (pos == lo && pos == hi) {\\n            leftSum += val;\\n            rightSum += val;\\n            max += val;\\n            if (max == 0)\\n                isDivided = true;\\n            return max;\\n        }\\n        \\n        getLeft().update(pos, val);\\n        getRight().update(pos, val);\\n        \\n        leftSum = left.isDivided ? left.leftSum : left.leftSum + right.leftSum;\\n        rightSum = right.isDivided ? right.rightSum : right.rightSum + left.rightSum;\\n        max = Math.max(Math.max(left.max, right.max), left.rightSum + right.leftSum);\\n        isDivided = left.isDivided || right.isDivided;\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462641,
                "title": "java-using-multiset-and-treeset-o-n-log-n",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int start, end;\\n        Pair(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    class MultiSet {\\n        TreeMap<Long, Integer> freq;\\n    \\n        MultiSet() {\\n            freq = new TreeMap<>();\\n        }\\n    \\n        void add(long x) {\\n            freq.put(x, freq.getOrDefault(x, 0) + 1);\\n        }\\n    \\n        boolean remove(long x) {\\n            Integer f = freq.get(x);\\n            if (f == null)\\n                return false;\\n            else if (f == 1) {\\n                freq.remove(x);\\n            } else {\\n                freq.put(x, f - 1);\\n            }\\n            return true;\\n        }\\n        Long getMax() {\\n            if(freq.size() == 0) return 0L;\\n            return freq.lastKey();\\n        }\\n    }\\n    public long[] maximumSegmentSum(int[] arr, int[] removeQueries) {\\n        long[] pre = new long[arr.length + 1];  // pefix sum to query subarray sum in O(1)\\n        for(int i = 0; i < arr.length; i++) pre[i+1] = pre[i] + arr[i];\\n        TreeSet<Pair> set = new TreeSet<>((a, b) -> a.start - b.start);  // order by start of range\\n        MultiSet sums = new MultiSet();\\n        set.add(new Pair(0, arr.length-1));   // initaially one segment of full range\\n        sums.add(pre[arr.length] - pre[0]);   // add the sum of the full ranged segment to MultiSet sums\\n        long[] ans = new long[removeQueries.length];\\n        for(int i = 0; i < removeQueries.length; i++) {\\n            Pair p = set.floor(new Pair(removeQueries[i], removeQueries[i])); // find range that contains removeQueries[i]\\n            set.remove(p);  // remove the range from set\\n            sums.remove(pre[p.end+1] - pre[p.start]);  // remove the corresponding sum from sums\\n\\t\\t\\t// split the range into two ranges (if non empty)\\n\\t\\t\\t// range with smaller start\\n            if(p.start <= removeQueries[i]-1) {\\n                Pair p1 = new Pair(p.start, removeQueries[i] - 1);\\n                set.add(p1); // add the pair for range with smaller start\\n                sums.add(pre[p1.end + 1] - pre[p1.start]);  // add corresponding sum\\n            }\\n\\t\\t\\t// remaining range\\n            if(removeQueries[i]+1 <= p.end) {\\n                Pair p2 = new Pair(removeQueries[i] + 1, p.end);\\n                set.add(p2); // add the pair with remaining range\\n                sums.add(pre[p2.end + 1] - pre[p2.start]); // add corresponding range\\n            }\\n            ans[i] = sums.getMax()==null?0L:sums.getMax(); // get max or 0 if empty from the MultiSet\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int start, end;\\n        Pair(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    class MultiSet {\\n        TreeMap<Long, Integer> freq;\\n    \\n        MultiSet() {\\n            freq = new TreeMap<>();\\n        }\\n    \\n        void add(long x) {\\n            freq.put(x, freq.getOrDefault(x, 0) + 1);\\n        }\\n    \\n        boolean remove(long x) {\\n            Integer f = freq.get(x);\\n            if (f == null)\\n                return false;\\n            else if (f == 1) {\\n                freq.remove(x);\\n            } else {\\n                freq.put(x, f - 1);\\n            }\\n            return true;\\n        }\\n        Long getMax() {\\n            if(freq.size() == 0) return 0L;\\n            return freq.lastKey();\\n        }\\n    }\\n    public long[] maximumSegmentSum(int[] arr, int[] removeQueries) {\\n        long[] pre = new long[arr.length + 1];  // pefix sum to query subarray sum in O(1)\\n        for(int i = 0; i < arr.length; i++) pre[i+1] = pre[i] + arr[i];\\n        TreeSet<Pair> set = new TreeSet<>((a, b) -> a.start - b.start);  // order by start of range\\n        MultiSet sums = new MultiSet();\\n        set.add(new Pair(0, arr.length-1));   // initaially one segment of full range\\n        sums.add(pre[arr.length] - pre[0]);   // add the sum of the full ranged segment to MultiSet sums\\n        long[] ans = new long[removeQueries.length];\\n        for(int i = 0; i < removeQueries.length; i++) {\\n            Pair p = set.floor(new Pair(removeQueries[i], removeQueries[i])); // find range that contains removeQueries[i]\\n            set.remove(p);  // remove the range from set\\n            sums.remove(pre[p.end+1] - pre[p.start]);  // remove the corresponding sum from sums\\n\\t\\t\\t// split the range into two ranges (if non empty)\\n\\t\\t\\t// range with smaller start\\n            if(p.start <= removeQueries[i]-1) {\\n                Pair p1 = new Pair(p.start, removeQueries[i] - 1);\\n                set.add(p1); // add the pair for range with smaller start\\n                sums.add(pre[p1.end + 1] - pre[p1.start]);  // add corresponding sum\\n            }\\n\\t\\t\\t// remaining range\\n            if(removeQueries[i]+1 <= p.end) {\\n                Pair p2 = new Pair(removeQueries[i] + 1, p.end);\\n                set.add(p2); // add the pair with remaining range\\n                sums.add(pre[p2.end + 1] - pre[p2.start]); // add corresponding range\\n            }\\n            ans[i] = sums.getMax()==null?0L:sums.getMax(); // get max or 0 if empty from the MultiSet\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456252,
                "title": "java-segment-tree",
                "content": "```\\nclass Solution {\\n\\t// once we have defined our segment tree node logic (see below), the implementation of the core algorithm is trivial:\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n= nums.length, k= removeQueries.length;\\n        SegmentTree st= new SegmentTree(nums);\\n        long[] ans= new long[k];\\n        for(int i=0; i<k; i++){\\n            st.setZero(removeQueries[i]);\\n            ans[i]= st.rangeQuery(0, n-1).maxSum;\\n        }\\n        return ans;\\n    }\\n\\n    static class SegmentTree {\\n        int n;      // size of the original array\\n        int[] A;    // original array\\n        Node[] st;  // segment tree array\\n\\n        public SegmentTree(int[] nums){\\n            this.A= nums;\\n            this.n= nums.length;\\n            this.st= new Node[4*n];\\n            build(1, 0, n-1);   // build recursively top-down (p==1 index of the tree root (top) node)\\n        }\\n    \\n        public Node rangeQuery(int i, int j){\\n            return rangeQuery(1, 0, n-1, i, j);      // traverse segment tree from the root\\n        }\\n    \\n        public void setZero(int i){   // set single element\\'s value to zero\\n            update(1, 0, n-1, i, i, 0);\\n        }\\n\\n\\t  // node contains the minimum information required for segment tree to calculate a max subarray sum (that doesn\\'t contain zeros) \\n\\t  // and allow for bottom-up merging of that information\\n        static class Node{         \\n            boolean hasZero;       // true if contains some deleted elements\\n            long maxSum;           // max sum of subarray with no zeros\\n            long lSum;             // sum from left to first zero\\n            long rSum;             // sum from right to first zero\\n    \\n            Node(long val){\\n                this.hasZero= val==0;\\n                this.maxSum= this.lSum= this.rSum= val;\\n            }\\n    \\n            Node(boolean hasZero, long maxSum, long lSum, long rSum){\\n                this.hasZero= hasZero;\\n                this.maxSum= maxSum;\\n                this.lSum= lSum;\\n                this.rSum= rSum;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// node merging logic to calculate the max subarray sum (not containing zeros)\\n\\t\\t\\tstatic Node merge(Node l, Node r){\\n                if(l==null) return r;\\n                if(r==null) return l;\\n                if(!l.hasZero && !r.hasZero) return new Node(l.maxSum+r.maxSum);\\n                return new Node(true, \\n                    Math.max(l.rSum+r.lSum, Math.max(l.maxSum, r.maxSum)),\\n                    l.hasZero ? l.lSum : l.maxSum+r.lSum,\\n                    r.hasZero ? r.rSum : r.maxSum+l.rSum\\n                );\\n            }  \\t\\n        }\\n\\t\\t\\n\\t\\t// boilerplate, reusable implementation of segment tree operations follows\\n        void build(int p, int L, int R){\\n            if(L==R){\\n                st[p]= new Node(A[L]);\\n            }else{\\n                int m= (L+R)/2, lp= (p<<1), rp= lp+1;\\n                build(lp, L, m);\\n                build(rp, m+1, R);\\n                st[p]= Node.merge(st[lp], st[rp]); \\n            }\\n        }        \\n        \\n        void update(int p, int L, int R, int i, int j, int val){\\n            if(i>j) return;\\n            if((L>=i) && (R<=j)){\\n                st[p]= new Node(A[i]= val);\\n            }else{\\n                int m= (L+R)/2, lp= p*2, rp= lp+1;\\n                update(lp, L, m, i, Math.min(m,j), val);\\n                update(rp, m+1, R, Math.max(i,m+1), j, val);\\n                st[p]= Node.merge(st[lp], st[rp]);\\n            }\\n        }\\n\\n        Node rangeQuery(int p, int L, int R, int i, int j){\\n            if(i>j) return null;\\n            if((L>=i) && (R<=j)) return st[p];        // found the segment\\n            int m= (L+R)/2, lp= p*2, rp= lp+1;\\n            return Node.merge(rangeQuery(lp, L, m, i, Math.min(m,j)),\\n                              rangeQuery(rp, m+1, R, Math.max(i, m+1), j));\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t// once we have defined our segment tree node logic (see below), the implementation of the core algorithm is trivial:\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n= nums.length, k= removeQueries.length;\\n        SegmentTree st= new SegmentTree(nums);\\n        long[] ans= new long[k];\\n        for(int i=0; i<k; i++){\\n            st.setZero(removeQueries[i]);\\n            ans[i]= st.rangeQuery(0, n-1).maxSum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454867,
                "title": "bit-multiset-o-n-log-n-c-solution-that-succeeds",
                "content": "```\\nclass Solution {\\n    long long getSum(vector<long long>& BITree, int index) {\\n        long long sum = 0;\\n        index++;\\n        while (index>0) {\\n            sum += BITree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long getSum(vector<long long>& BITree, int l, int r) {\\n        return getSum(BITree, r) - getSum(BITree, l - 1);\\n    }\\n    \\n    void updateBIT(vector<long long>& BITree, int n, int index, long long val) {\\n        index++;\\n        while (index <= n) {\\n            BITree[index] += val;\\n            index += index & (-index);\\n        }\\n    }\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        multiset<long long> pq;\\n        set<long long> query;\\n        vector<long long> result;\\n        \\n        // Constructs BIT\\n        int n=nums.size();\\n        vector<long long> BITree(n+1, 0);\\n        for (int i=0; i<n; i++)\\n            updateBIT(BITree, n, i, nums[i]);\\n        \\n        for(int i=0;i<removeQueries.size();i++) {\\n            long long l=0;\\n            if (!query.empty()) {\\n                auto it = query.lower_bound(removeQueries[i]);\\n                if (it!=query.begin()) {\\n                    it--;\\n                    l = (*it);\\n                }\\n            }\\n            \\n            long long r=n-1;\\n            if (!query.empty()) {\\n                auto it = query.upper_bound(removeQueries[i]);\\n                if (it!=query.end()) r = (*it);\\n            }\\n            \\n            long long leftSum = (removeQueries[i]>0) ? getSum(BITree, l, removeQueries[i]-1) : 0;\\n            long long rightSum = (removeQueries[i]!=n-1) ? getSum(BITree, removeQueries[i]+1, r) : 0;\\n            \\n            if (pq.size()!=0) pq.erase(pq.find(leftSum+rightSum+nums[removeQueries[i]]));\\n            \\n            updateBIT(BITree, n, removeQueries[i], -nums[removeQueries[i]]);\\n            nums[removeQueries[i]]=0;\\n            \\n            pq.insert(leftSum);\\n            pq.insert(rightSum);\\n            result.push_back(*pq.rbegin());\\n            query.insert(removeQueries[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long getSum(vector<long long>& BITree, int index) {\\n        long long sum = 0;\\n        index++;\\n        while (index>0) {\\n            sum += BITree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long getSum(vector<long long>& BITree, int l, int r) {\\n        return getSum(BITree, r) - getSum(BITree, l - 1);\\n    }\\n    \\n    void updateBIT(vector<long long>& BITree, int n, int index, long long val) {\\n        index++;\\n        while (index <= n) {\\n            BITree[index] += val;\\n            index += index & (-index);\\n        }\\n    }\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        multiset<long long> pq;\\n        set<long long> query;\\n        vector<long long> result;\\n        \\n        // Constructs BIT\\n        int n=nums.size();\\n        vector<long long> BITree(n+1, 0);\\n        for (int i=0; i<n; i++)\\n            updateBIT(BITree, n, i, nums[i]);\\n        \\n        for(int i=0;i<removeQueries.size();i++) {\\n            long long l=0;\\n            if (!query.empty()) {\\n                auto it = query.lower_bound(removeQueries[i]);\\n                if (it!=query.begin()) {\\n                    it--;\\n                    l = (*it);\\n                }\\n            }\\n            \\n            long long r=n-1;\\n            if (!query.empty()) {\\n                auto it = query.upper_bound(removeQueries[i]);\\n                if (it!=query.end()) r = (*it);\\n            }\\n            \\n            long long leftSum = (removeQueries[i]>0) ? getSum(BITree, l, removeQueries[i]-1) : 0;\\n            long long rightSum = (removeQueries[i]!=n-1) ? getSum(BITree, removeQueries[i]+1, r) : 0;\\n            \\n            if (pq.size()!=0) pq.erase(pq.find(leftSum+rightSum+nums[removeQueries[i]]));\\n            \\n            updateBIT(BITree, n, removeQueries[i], -nums[removeQueries[i]]);\\n            nums[removeQueries[i]]=0;\\n            \\n            pq.insert(leftSum);\\n            pq.insert(rightSum);\\n            result.push_back(*pq.rbegin());\\n            query.insert(removeQueries[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454489,
                "title": "python-time-complexity-o-n-solution-reverse-process-and-merge-non-zero-interval",
                "content": "Don\\'t process forward like example, reverse it!\\n![image](https://assets.leetcode.com/users/images/fc85b128-f27a-4f71-9124-26e2c0f36a6b_1661012644.627654.png)\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        newNums = [0] * n\\n        \\n        # can use to merge segment sum\\n        # leftJoin is to merge right block\\n        # rightJoin is to merge left block\\n        leftJoin, rightJoin = {}, {}\\n            \\n        res = [0]\\n        nowMax = 0\\n        for i in removeQueries[::-1][:-1]:\\n            newNums[i] = nums[i]\\n            nowSum = newNums[i]\\n            leftB = rightB = i\\n            \\n            # if right block not zero, merge it!\\n            if i + 1 in leftJoin:\\n                nowSum += leftJoin[i + 1][0]\\n                rightB = leftJoin[i + 1][2]\\n                \\n            # if left block not zero, merge it!\\n            if i - 1 in rightJoin:\\n                nowSum += rightJoin[i - 1][0]\\n                leftB = rightJoin[i - 1][1]\\n                \\n            # creat new block to next merge\\n            # leftJoin and rightJoin have 3 values [nowSum, leftBound, rightBound]\\n            leftJoin[leftB] = (nowSum, leftB, rightB)\\n            rightJoin[rightB] = (nowSum, leftB, rightB)\\n            nowMax = max(nowMax, nowSum)\\n            res.append(nowMax)\\n            \\n        return res[::-1]\\n                                     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        newNums = [0] * n\\n        \\n        # can use to merge segment sum\\n        # leftJoin is to merge right block\\n        # rightJoin is to merge left block\\n        leftJoin, rightJoin = {}, {}\\n            \\n        res = [0]\\n        nowMax = 0\\n        for i in removeQueries[::-1][:-1]:\\n            newNums[i] = nums[i]\\n            nowSum = newNums[i]\\n            leftB = rightB = i\\n            \\n            # if right block not zero, merge it!\\n            if i + 1 in leftJoin:\\n                nowSum += leftJoin[i + 1][0]\\n                rightB = leftJoin[i + 1][2]\\n                \\n            # if left block not zero, merge it!\\n            if i - 1 in rightJoin:\\n                nowSum += rightJoin[i - 1][0]\\n                leftB = rightJoin[i - 1][1]\\n                \\n            # creat new block to next merge\\n            # leftJoin and rightJoin have 3 values [nowSum, leftBound, rightBound]\\n            leftJoin[leftB] = (nowSum, leftB, rightB)\\n            rightJoin[rightB] = (nowSum, leftB, rightB)\\n            nowMax = max(nowMax, nowSum)\\n            res.append(nowMax)\\n            \\n        return res[::-1]\\n                                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454186,
                "title": "dsu-c",
                "content": "**Explanation:-**\\n1. We will traverse from last and use DSU to join segments\\n2.   rank[idx] will contain sum of elements rooted at idx\\n\\n```\\nclass DSU {\\n public:\\n  vector<long> p, rank;\\n  long maxi = 0;\\n  DSU(vector<int>& nums) {\\n    int sz = nums.size();\\n    for (auto& i : nums) rank.push_back(i);\\n    p.resize(sz, 0);\\n    iota(begin(p), end(p), 0);\\n  }\\n  int find(int node) {\\n    if (p[node] == node) return node;\\n    return p[node] = find(p[node]);\\n  }\\n  void join(int x, int y) {\\n    if (x == y) {\\n      maxi = max(maxi, rank[x]);\\n      return;\\n    }\\n    int p1 = find(x), p2 = find(y);\\n    if (rank[p2] > rank[p1]) swap(p2, p1);\\n    p[p2] = p1;\\n    rank[p1] += rank[p2];\\n    maxi = max(maxi, rank[p1]);\\n  }\\n  long getMax() { return maxi; }\\n};\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n    int sz = nums.size();\\n    vector<long long> ans(sz, 0);\\n    DSU obj(nums);\\n    vector<bool> seen(sz, false);\\n    for (int i = sz - 2; i >= 0; i--) {\\n      int idx = rem[i + 1];\\n        // seen [idx] =true means we have added this element into DSU\\n      seen[idx] = true;\\n      obj.join(idx, idx);\\n        // check left and right for unions\\n      if (idx - 1 >= 0 && seen[idx - 1])\\n          obj.join(idx, idx - 1);\\n      if (idx + 1 < sz && seen[idx + 1])\\n          obj.join(idx, idx + 1);\\n      ans[i] = obj.getMax();\\n    }\\n    return ans;\\n  }\\n};\\n```\\nDo **UPVOTE** IF IT HELPS :)",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\n public:\\n  vector<long> p, rank;\\n  long maxi = 0;\\n  DSU(vector<int>& nums) {\\n    int sz = nums.size();\\n    for (auto& i : nums) rank.push_back(i);\\n    p.resize(sz, 0);\\n    iota(begin(p), end(p), 0);\\n  }\\n  int find(int node) {\\n    if (p[node] == node) return node;\\n    return p[node] = find(p[node]);\\n  }\\n  void join(int x, int y) {\\n    if (x == y) {\\n      maxi = max(maxi, rank[x]);\\n      return;\\n    }\\n    int p1 = find(x), p2 = find(y);\\n    if (rank[p2] > rank[p1]) swap(p2, p1);\\n    p[p2] = p1;\\n    rank[p1] += rank[p2];\\n    maxi = max(maxi, rank[p1]);\\n  }\\n  long getMax() { return maxi; }\\n};\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n    int sz = nums.size();\\n    vector<long long> ans(sz, 0);\\n    DSU obj(nums);\\n    vector<bool> seen(sz, false);\\n    for (int i = sz - 2; i >= 0; i--) {\\n      int idx = rem[i + 1];\\n        // seen [idx] =true means we have added this element into DSU\\n      seen[idx] = true;\\n      obj.join(idx, idx);\\n        // check left and right for unions\\n      if (idx - 1 >= 0 && seen[idx - 1])\\n          obj.join(idx, idx - 1);\\n      if (idx + 1 < sz && seen[idx + 1])\\n          obj.join(idx, idx + 1);\\n      ans[i] = obj.getMax();\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630539,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2503048,
                "title": "reverse-order",
                "content": "\\nIn this problem we keep dividing the segments till no segment remain.\\nThe largest sum will be identified at each step. No segement will increase, so we will never worry about larger after we have known the largest at any step.\\nThe easy thing is when the largest one is not touched.\\nThe trouble is when the largest one is splitted into small one, we will search the new one. \\nTo hold a sorted list of the segments will be costful. \\n\\nFortunately we know all the steps at the beginning. That mean we can reverse the process. In another word, we merge the segments instead of split them.\\nTo do so, we will always update the largest sum by compare the new one with previous largest one. That means no search is necessary.\\n\\nBased on this we could have tons of ways to record current segments. Hash map, linked list, array are all OK to do that.\\nConsider the effectiveness, array could gives better efficacy in time but worse in memory. Linked list could same some memroy but it will be too expensive to locate proper segment.\\n\\nIn the problem 10^5 let us feel free to choose array.\\n\\nSo what are the necessaary information we will hold during the process?\\n1 the segment information  (include sum, left, right)\\n2 the neighbor relationship \\n\\nTo make more sepcific, let\\'s see what is happening during a merge.\\nI would use [] to identify a segment, and () to identify number that has not been merged in any segment. I will use q as the current one to process merge.\\ncase 1: both left and right neighbor the (q) are segment. ( this is the most important one, as all other cases could be considered as this one with some special values)\\n [start1....end1]    (q)  [start....end2]  \\n after merge \\n [start1....end2]\\n the new sum = sum of left + value of q + sum of right\\n So it is clear that, remember the start, end and sum of the segment is most valueable.\\n[start, end, sum] will be the good structure for a segment.\\nuse list will be so nice in python. Tuple is also a good choose, But I have good reason explained below to pick list. \\n\\nWhere we will we store this information? Or how should the segment information be organized to allow quicker access?\\nList is the best to locate a perticular one when we know its position.\\nFurther more, at each time we are access a segment information, we indeed is trying to merge it with its neighbor. Eighther left neighbor or right one.\\nSo we will store the information in its both bounds. Aside the boundary item, other item will be useless. Though they were. So we will not maintain the lastest information in non-boundary items.\\nIt will looks like this\\n[ [start1, end1, sum1].....[start1, end1, sum1], [start2, end2, sum2] .....  ]\\nIn fact one more information is very important, the status of the position. Is it part of a segment or not.\\nBefore I make the decision, I have tried to just store that as well. \\n[ [start1, end1, sum1, is segment].....[start1, end1, sum1, is segment], [,,,, is not segment], [start2, end2, sum2] .....  ]\\nAny way, we still need to look at other cases that not both nieghbors are segment \\n\\n3 types of cases like these\\n(q2)    (q1)  [start....end2]  \\n [start1....end1]    (q1)  (q2)\\n (q2)   (q1)  (q3)\\n\\nand sepeciallly there are cases when q1 is first item  and the cases q1 is the last one\\n (q1)  [start....end2]  \\n  (q1)  (q2) \\n [start....end2]  (q1)   \\n (q2)  (q1)   \\n \\n It will be easy to just check the q and q-1 and q-2 to know the category it falls into on each step.\\n But that is costfull.\\n In stead, we will have enough tricky to pretent there is only one category.\\n Befire I do all tricky, I write down the pesudo\\n \\n ```\\n left position = left position of left neighbor\\n right position = .right position of right neighbor\\n sum = sum of left + value on merging position + sum of right\\n ```\\n \\n Now it will be clear that, I will need to pretend unmerge neighbor as a empty segment, and also there is a left neighbor on the first item, and as while the last item has a right neighbor.\\n \\n For the left of 0, we already have a very common tricky(feature) that -1 is regard as the last index of an array, so I just simplely add two items at the end of the list. One as the right of last, one as the left or the first.\\n \\n How about the non segment neighbors? While we look closely to the pseudo again\\n  ```\\n  left position = left position of left neighbor \\n  ```\\n  what is the value we expected when there is no left neighbor? \\n  It is the position of q, the current merging item.\\n  How about let the non segment neighbor has a left position like this? \\n  No problem, because no other places will use that value before it has been merged into a segment,\\n  Vice versa for the right beighbor.\\n  \\n so that is clear that I prefer initial all the item as \\n  [q + 1, q - 1, 0]\\n  which means all non segmented item is a segment start from its right and end to its left, that really means EMPTY \\n  Till now it is clear that I will not need a value to state whethere the item is in segment or not. it is juse an EMPTY segment with a ZERO sum.\\n  \\n  With this tricky I get rid of any condition check in the loop. That is almost allways be a sign of efficacy.\\n \\nA NOTE:\\nI have tried to use length of the segment, that also works and not harder to understand, but that make more add and sub operations. It finally is slower than this one. \\nAlso I have tried multiple arraies. Like left: []  right :[] sum:[] . they are proved as slow as while.\\n\\nI would like to consider this is the best solution if we do not concern about memory. Becuase there is no IF. Somehow there is ONE IF hiding insided the max(). and one IF hiding inside [-1] while I would like to say there  is no unnecesary IF.\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        b = [[_i + 1, _i - 1, 0] for _i in range(len(nums)) ]  + [[len(nums) - 1, len(nums) - 1, 0], [0, 0, 0]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):\\n\\t\\t\\t# find out new new left\\n            l = b[q - 1][0]\\n\\t\\t\\t# find out new new right\\n            r = b[q + 1][1]\\n\\t\\t\\t# mark the new left on the new right\\n            b[r][0] = l\\n\\t\\t\\t# do nothing abecause the new right has the same right with the old one\\n\\t\\t\\t# mark the new right on the new left\\n            b[l][1] = r\\n\\t\\t\\t# do nothing because the new left has the same left with the old one\\n\\t\\t\\t# assign new sum on boundary\\n            b[l][2] = b[r][2] = s = nums[q] + b[l][2] + b[r][2] \\n\\t\\t\\t# return new sum \\n            return s \\n        v = 0\\n        res = []\\n        for q in removeQueries[::-1]:\\n\\t\\t\\t# record current max sum as result\\n            res.append(v)\\n            # get new sum of the merged one \\n\\t\\t\\t# and caculate new max sum\\n            v = max(v, u(q))\\n\\t\\t# reverse the result because we have processed in the reversed order\\n        return list(res[::-1])\\n```\\n\\nThe code before optimized. This one is slower. But it clear shows different situations when merge. More understandable without tricky.\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        class M: # hold the max sum, as the max will never shrink, no need to worry about it turning smaller\\n            v = 0\\n\\n        def s(x):\\n            M.v = max(M.v, x)\\n        \\n        L_1 = len(nums) - 1# length of numbers minus 1\\n        b = [[_i, _i, _n, False] for _i, _n in enumerate(nums) ]  + [[L_1, L_1, 0, False], [0, 0, 0, False]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):                 \\n            l,r,s,_ = b[q]\\n            if b[q - 1][3]:\\n                l = b[q - 1][0]\\n                s += b[q - 1][2]\\n            if b[q + 1][3]:\\n                r = b[q + 1][1]\\n                s += b[q + 1][2]\\n            b[l][1] = r\\n            b[r][0] = l\\n            b[l][2] = b[r][2] = s\\n            b[l][3] = b[r][3] = True  \\n            return s \\n        res = []\\n        for q in removeQueries[::-1]:\\n            # get current largest sum\\n            res.append(M.v)\\n            s(u(q))\\n        return list(res[::-1])\\n        \\n        \\n        \\n         \\n```",
                "solutionTags": [],
                "code": "```\\n left position = left position of left neighbor\\n right position = .right position of right neighbor\\n sum = sum of left + value on merging position + sum of right\\n ```\n```\\n  left position = left position of left neighbor \\n  ```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        b = [[_i + 1, _i - 1, 0] for _i in range(len(nums)) ]  + [[len(nums) - 1, len(nums) - 1, 0], [0, 0, 0]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):\\n\\t\\t\\t# find out new new left\\n            l = b[q - 1][0]\\n\\t\\t\\t# find out new new right\\n            r = b[q + 1][1]\\n\\t\\t\\t# mark the new left on the new right\\n            b[r][0] = l\\n\\t\\t\\t# do nothing abecause the new right has the same right with the old one\\n\\t\\t\\t# mark the new right on the new left\\n            b[l][1] = r\\n\\t\\t\\t# do nothing because the new left has the same left with the old one\\n\\t\\t\\t# assign new sum on boundary\\n            b[l][2] = b[r][2] = s = nums[q] + b[l][2] + b[r][2] \\n\\t\\t\\t# return new sum \\n            return s \\n        v = 0\\n        res = []\\n        for q in removeQueries[::-1]:\\n\\t\\t\\t# record current max sum as result\\n            res.append(v)\\n            # get new sum of the merged one \\n\\t\\t\\t# and caculate new max sum\\n            v = max(v, u(q))\\n\\t\\t# reverse the result because we have processed in the reversed order\\n        return list(res[::-1])\\n```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        class M: # hold the max sum, as the max will never shrink, no need to worry about it turning smaller\\n            v = 0\\n\\n        def s(x):\\n            M.v = max(M.v, x)\\n        \\n        L_1 = len(nums) - 1# length of numbers minus 1\\n        b = [[_i, _i, _n, False] for _i, _n in enumerate(nums) ]  + [[L_1, L_1, 0, False], [0, 0, 0, False]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):                 \\n            l,r,s,_ = b[q]\\n            if b[q - 1][3]:\\n                l = b[q - 1][0]\\n                s += b[q - 1][2]\\n            if b[q + 1][3]:\\n                r = b[q + 1][1]\\n                s += b[q + 1][2]\\n            b[l][1] = r\\n            b[r][0] = l\\n            b[l][2] = b[r][2] = s\\n            b[l][3] = b[r][3] = True  \\n            return s \\n        res = []\\n        for q in removeQueries[::-1]:\\n            # get current largest sum\\n            res.append(M.v)\\n            s(u(q))\\n        return list(res[::-1])\\n        \\n        \\n        \\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482092,
                "title": "well-commented-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    using ll = long long;\\n    \\n    ll findSum(int start, int end, vector<ll> &prefixSum) {\\n        if (start == 0) return prefixSum[end];\\n        return prefixSum[end] - prefixSum[start-1];\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefixSum(n,nums[0]);\\n        prefixSum[0] = nums[0];\\n        \\n        // compute prefix Sum\\n        for (int i = 1; i < n; i ++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        set<pair<int,int>> segSet;\\n        multiset<ll> sumSet; // multi set as duplicate set sum possible\\n        \\n        \\n        // first Segment is full one as there are all non zero numbers\\n        segSet.insert({0,n-1}); // inserting full segment\\n        sumSet.insert(prefixSum[n-1]); \\n        \\n        vector<ll> result;\\n        // last entry will always resturn 0 so only traverse till n-1\\n        for (int i = 0; i < n-1; i++) {\\n            int rIndex = removeQueries[i];\\n            \\n            // check with set this rIndex belongs to\\n            auto it = segSet.upper_bound({rIndex,rIndex});\\n            \\n            //if this is now at end of the list ie no upper bound found\\n            if (it == segSet.end()) \\n                it--;\\n            else // else check if the landed is not part of the upper boundsegment \\n                if (it->first > rIndex) it--;\\n            \\n            // Now we found the exact set\\n            // now compute the acutal reduction\\n            auto p = *it;\\n            ll value = findSum(p.first,p.second,prefixSum);\\n            // remove this set from the segement list as it will be splitted now\\n            segSet.erase(it);\\n            \\n            //remove the sum of erased segment from set\\n            auto valueIt = sumSet.lower_bound(value);\\n            sumSet.erase(valueIt);\\n            \\n            ll value1 = -1;\\n            ll value2 = -1;\\n            \\n            // if removed index is starting the current set\\n            if (p.first == rIndex) {\\n                segSet.insert({rIndex+1,p.second});\\n                value1 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            } else if (p.second == rIndex) { \\n                // if removed index is ending the current set\\n                segSet.insert({p.first,rIndex-1});\\n                value2 = findSum(p.first,rIndex-1,prefixSum);\\n                \\n            } else {\\n                // if removed element is middle and splitting the set\\n                segSet.insert({p.first,rIndex-1});\\n                value1 = findSum(p.first,rIndex-1,prefixSum);\\n                segSet.insert({rIndex+1,p.second});\\n                value2 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            }\\n            \\n            // Insert new found segment set sum\\n            if (value1 != -1) sumSet.insert(value1);\\n            if (value2 != -1) sumSet.insert(value2);\\n            \\n            // append the last element of the sorted set which is current maxiumm\\n            // after new sets has been inserted.\\n            result.push_back(*sumSet.rbegin());\\n        }\\n        \\n        // End result is always 0\\n        result.push_back(0);\\n        return result;\\n    }\\n    \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    using ll = long long;\\n    \\n    ll findSum(int start, int end, vector<ll> &prefixSum) {\\n        if (start == 0) return prefixSum[end];\\n        return prefixSum[end] - prefixSum[start-1];\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefixSum(n,nums[0]);\\n        prefixSum[0] = nums[0];\\n        \\n        // compute prefix Sum\\n        for (int i = 1; i < n; i ++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        set<pair<int,int>> segSet;\\n        multiset<ll> sumSet; // multi set as duplicate set sum possible\\n        \\n        \\n        // first Segment is full one as there are all non zero numbers\\n        segSet.insert({0,n-1}); // inserting full segment\\n        sumSet.insert(prefixSum[n-1]); \\n        \\n        vector<ll> result;\\n        // last entry will always resturn 0 so only traverse till n-1\\n        for (int i = 0; i < n-1; i++) {\\n            int rIndex = removeQueries[i];\\n            \\n            // check with set this rIndex belongs to\\n            auto it = segSet.upper_bound({rIndex,rIndex});\\n            \\n            //if this is now at end of the list ie no upper bound found\\n            if (it == segSet.end()) \\n                it--;\\n            else // else check if the landed is not part of the upper boundsegment \\n                if (it->first > rIndex) it--;\\n            \\n            // Now we found the exact set\\n            // now compute the acutal reduction\\n            auto p = *it;\\n            ll value = findSum(p.first,p.second,prefixSum);\\n            // remove this set from the segement list as it will be splitted now\\n            segSet.erase(it);\\n            \\n            //remove the sum of erased segment from set\\n            auto valueIt = sumSet.lower_bound(value);\\n            sumSet.erase(valueIt);\\n            \\n            ll value1 = -1;\\n            ll value2 = -1;\\n            \\n            // if removed index is starting the current set\\n            if (p.first == rIndex) {\\n                segSet.insert({rIndex+1,p.second});\\n                value1 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            } else if (p.second == rIndex) { \\n                // if removed index is ending the current set\\n                segSet.insert({p.first,rIndex-1});\\n                value2 = findSum(p.first,rIndex-1,prefixSum);\\n                \\n            } else {\\n                // if removed element is middle and splitting the set\\n                segSet.insert({p.first,rIndex-1});\\n                value1 = findSum(p.first,rIndex-1,prefixSum);\\n                segSet.insert({rIndex+1,p.second});\\n                value2 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            }\\n            \\n            // Insert new found segment set sum\\n            if (value1 != -1) sumSet.insert(value1);\\n            if (value2 != -1) sumSet.insert(value2);\\n            \\n            // append the last element of the sorted set which is current maxiumm\\n            // after new sets has been inserted.\\n            result.push_back(*sumSet.rbegin());\\n        }\\n        \\n        // End result is always 0\\n        result.push_back(0);\\n        return result;\\n    }\\n    \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2476435,
                "title": "c-segment-tree-clean-code",
                "content": "This is simply how we find maximal sum segment in an array using Segment tree with slight modification. Since we want the original segment into be divided into parts, We update the division boundary by a large negative value so that this element will never be included in maximal sum segment.\\n\\n```\\n#define ll long long\\nstruct item{\\n      ll sum,pre,suf,seg;\\n};\\n \\nstruct sgmt{\\n  ll n;\\n  vector<item> st;\\n    item NEUTRAL_ELEMENT = {0,0,0,0};\\n    item single(ll v)\\n    {\\n            item ret;\\n            ret.sum = v;\\n            ret.pre = max(0ll,v);\\n            ret.suf = max(0ll,v);\\n            ret.seg = max(0ll,v);\\n            return ret;\\n    }\\n    sgmt(int _n){                                                 //update\\n            n = _n;           \\n            st.resize(4*n,NEUTRAL_ELEMENT);                    \\n    }\\n \\n    item merge(item a,item b)                                     //update \\n    {\\n           item res;\\n           res.pre = max(a.pre,a.sum + b.pre);\\n           res.suf = max(b.suf,b.sum + a.suf);\\n           res.seg = max(max(a.seg,b.seg),a.suf + b.pre);\\n           res.sum = a.sum + b.sum;\\n           return res;\\n    }\\n    \\n    void build(int si, int ei, int node, vector<ll>&v){\\n        if(si==ei){\\n            st[node] = single(v[si]);                              //check\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        build(si,mid,node*2+1,v);\\n        build(mid+1,ei,node*2+2,v);\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n \\n    item query(int si,int ei,int node, int l, int r){\\n        if(r<si or l>ei) return NEUTRAL_ELEMENT;\\n        if(l<=si and r>=ei) return st[node];\\n        int mid = (si+ei)/2;\\n        item q1 = query(si,mid,node*2+1,l,r);\\n        item q2 = query(mid+1,ei,node*2+2,l,r);\\n        return merge(q1,q2);\\n    }\\n    \\n    void update(int si, int ei,int node,int idx, ll val){\\n        if(si==ei){\\n            st[node]= single(val);                                    //update the value\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        if(idx<=mid) {\\n            update(si,mid,node*2+1,idx,val);\\n        }\\n        else{\\n            update(mid+1,ei,node*2+2,idx,val);\\n        }\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n    item query(ll l, ll r){\\n      return query(0,n-1,0,l,r);                                 //print whatever required\\n      \\n    }\\n    void build(vector<ll>&v){\\n        \\n        build(0,n-1,0,v);\\n    }\\n    void update(ll idx,ll val){\\n        update(0,n-1,0,idx,val);\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nu, vector<int>& re) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n     sgmt s(nu.size());\\n        vector<ll> nums(nu.begin(),nu.end());\\n        s.build(nums);\\n        vector<ll> ans;\\n        for(int i = 0;i<re.size();i++){\\n            s.update(re[i],-1e14+1e13);\\n            ans.push_back(s.query(0,nu.size()).seg);\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nstruct item{\\n      ll sum,pre,suf,seg;\\n};\\n \\nstruct sgmt{\\n  ll n;\\n  vector<item> st;\\n    item NEUTRAL_ELEMENT = {0,0,0,0};\\n    item single(ll v)\\n    {\\n            item ret;\\n            ret.sum = v;\\n            ret.pre = max(0ll,v);\\n            ret.suf = max(0ll,v);\\n            ret.seg = max(0ll,v);\\n            return ret;\\n    }\\n    sgmt(int _n){                                                 //update\\n            n = _n;           \\n            st.resize(4*n,NEUTRAL_ELEMENT);                    \\n    }\\n \\n    item merge(item a,item b)                                     //update \\n    {\\n           item res;\\n           res.pre = max(a.pre,a.sum + b.pre);\\n           res.suf = max(b.suf,b.sum + a.suf);\\n           res.seg = max(max(a.seg,b.seg),a.suf + b.pre);\\n           res.sum = a.sum + b.sum;\\n           return res;\\n    }\\n    \\n    void build(int si, int ei, int node, vector<ll>&v){\\n        if(si==ei){\\n            st[node] = single(v[si]);                              //check\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        build(si,mid,node*2+1,v);\\n        build(mid+1,ei,node*2+2,v);\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n \\n    item query(int si,int ei,int node, int l, int r){\\n        if(r<si or l>ei) return NEUTRAL_ELEMENT;\\n        if(l<=si and r>=ei) return st[node];\\n        int mid = (si+ei)/2;\\n        item q1 = query(si,mid,node*2+1,l,r);\\n        item q2 = query(mid+1,ei,node*2+2,l,r);\\n        return merge(q1,q2);\\n    }\\n    \\n    void update(int si, int ei,int node,int idx, ll val){\\n        if(si==ei){\\n            st[node]= single(val);                                    //update the value\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        if(idx<=mid) {\\n            update(si,mid,node*2+1,idx,val);\\n        }\\n        else{\\n            update(mid+1,ei,node*2+2,idx,val);\\n        }\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n    item query(ll l, ll r){\\n      return query(0,n-1,0,l,r);                                 //print whatever required\\n      \\n    }\\n    void build(vector<ll>&v){\\n        \\n        build(0,n-1,0,v);\\n    }\\n    void update(ll idx,ll val){\\n        update(0,n-1,0,idx,val);\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nu, vector<int>& re) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n     sgmt s(nu.size());\\n        vector<ll> nums(nu.begin(),nu.end());\\n        s.build(nums);\\n        vector<ll> ans;\\n        for(int i = 0;i<re.size();i++){\\n            s.update(re[i],-1e14+1e13);\\n            ans.push_back(s.query(0,nu.size()).seg);\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2475939,
                "title": "python-3-union-find",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [0] * n\\n        parent = [i for i in range(n)]\\n        rank = [0] * n\\n        sums = [0] * n\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if rank[i] < rank[j]:\\n                i, j = j, i       \\n            parent[j] = i\\n            rank[i] += rank[j]\\n            sums[i] += sums[j]\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        for i in range(n - 1, 0, -1):\\n            j = removeQueries[i]\\n            sums[j] = nums[j]\\n            if j and sums[j - 1]:\\n                union(j, j - 1)\\n            if j != n - 1 and sums[j + 1]:\\n                union(j, j + 1)\\n            res[i - 1] = max(res[i], sums[find(j)])\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [0] * n\\n        parent = [i for i in range(n)]\\n        rank = [0] * n\\n        sums = [0] * n\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if rank[i] < rank[j]:\\n                i, j = j, i       \\n            parent[j] = i\\n            rank[i] += rank[j]\\n            sums[i] += sums[j]\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        for i in range(n - 1, 0, -1):\\n            j = removeQueries[i]\\n            sums[j] = nums[j]\\n            if j and sums[j - 1]:\\n                union(j, j - 1)\\n            if j != n - 1 and sums[j + 1]:\\n                union(j, j + 1)\\n            res[i - 1] = max(res[i], sums[find(j)])\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2468394,
                "title": "c-sets-multiset-prefix-sum-code",
                "content": "Please find the solution to the problem below : )\\nIt was more like caring of indexes. So used prefix array of size greater than size of nums, such that not to cause confusion while finding sums between segments. \\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remQ) {\\n        int n = nums.size();\\n        vector<long long> prefSum(n+2, 0), ans;\\n        for(int i = 0; i < n;i++){\\n            prefSum[i+1] += prefSum[i] + nums[i];\\n        }\\n        set<int> s;\\n        multiset<long long> ms; // for storing max segment sum\\n        ms.insert(prefSum[n]);\\n        s.insert(0); \\n        s.insert(n+1);\\n        for(int i =0 ; i < remQ.size(); i++){\\n            long long curInd = remQ[i];\\n            curInd++;\\n            long long left = s.lower_bound(curInd) != s.begin() ? *(prev(s.lower_bound(curInd))) : *s.begin();\\n            long long right = s.lower_bound(curInd) != s.end() ? *s.lower_bound(curInd) : *s.rbegin();\\n            long long curSum = prefSum[right-1] - prefSum[left];\\n            long long leftSum = prefSum[curInd-1] - prefSum[left];\\n            long long rightSum = prefSum[right-1] - prefSum[curInd];\\n\\t\\t\\tms.erase(ms.find(curSum));\\n            ms.insert(leftSum);\\n            ms.insert(rightSum);\\n            s.insert(curInd);\\n            ans.push_back(*ms.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remQ) {\\n        int n = nums.size();\\n        vector<long long> prefSum(n+2, 0), ans;\\n        for(int i = 0; i < n;i++){\\n            prefSum[i+1] += prefSum[i] + nums[i];\\n        }\\n        set<int> s;\\n        multiset<long long> ms; // for storing max segment sum\\n        ms.insert(prefSum[n]);\\n        s.insert(0); \\n        s.insert(n+1);\\n        for(int i =0 ; i < remQ.size(); i++){\\n            long long curInd = remQ[i];\\n            curInd++;\\n            long long left = s.lower_bound(curInd) != s.begin() ? *(prev(s.lower_bound(curInd))) : *s.begin();\\n            long long right = s.lower_bound(curInd) != s.end() ? *s.lower_bound(curInd) : *s.rbegin();\\n            long long curSum = prefSum[right-1] - prefSum[left];\\n            long long leftSum = prefSum[curInd-1] - prefSum[left];\\n            long long rightSum = prefSum[right-1] - prefSum[curInd];\\n\\t\\t\\tms.erase(ms.find(curSum));\\n            ms.insert(leftSum);\\n            ms.insert(rightSum);\\n            s.insert(curInd);\\n            ans.push_back(*ms.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468095,
                "title": "python-2-solution-o-n-union-find-and-o-nlogn-sorteddict",
                "content": "(1)\\n```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.val = [0] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n\\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.val[x] += self.val[y]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans, uni, curmax = [], Uni(n), 0\\n        for idx in removeQueries[::-1]:\\n            ans.append(curmax)\\n            uni.val[idx] = nums[idx]\\n            if idx > 0 and uni.val[idx - 1]: uni.merge(idx - 1, idx)\\n            if idx + 1 < n and uni.val[idx + 1]: uni.merge(idx + 1, idx)\\n            curmax = max(curmax, uni.val[uni.find(idx)])\\n        return ans[::-1]\\n```\\n(2)\\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        presum =[0] * (n + 1)\\n        for i in range(n): presum[i + 1] = presum[i] + nums[i]\\n        rng2v, v2rng = SortedDict({(0, n - 1): presum[n]}), SortedDict({presum[n] : {(0, n - 1)}})\\n        ans = []\\n        for idx in removeQueries:\\n            pos = min(rng2v.bisect_left((idx, idx)), len(rng2v) - 1)\\n            if not (rng2v.iloc[pos][0] <= idx <= rng2v.iloc[pos][1]): pos -= 1\\n            (left, right), val = rng2v.popitem(pos)\\n            v2rng[val].remove((left, right))\\n            if not v2rng[val]: v2rng.pop(val)\\n            if left < idx:\\n                lv = presum[idx] - presum[left]\\n                rng2v[(left, idx - 1)] = lv\\n                if lv not in v2rng: v2rng[lv] = set()\\n                v2rng[lv].add((left, idx - 1))\\n            if idx < right:\\n                rv = presum[right + 1] - presum[idx + 1]\\n                rng2v[(idx + 1, right)] = rv\\n                if rv not in v2rng: v2rng[rv] = set()\\n                v2rng[rv].add((idx + 1, right))\\n            ans.append(v2rng.iloc[-1] if v2rng else 0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.val = [0] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n\\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.val[x] += self.val[y]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans, uni, curmax = [], Uni(n), 0\\n        for idx in removeQueries[::-1]:\\n            ans.append(curmax)\\n            uni.val[idx] = nums[idx]\\n            if idx > 0 and uni.val[idx - 1]: uni.merge(idx - 1, idx)\\n            if idx + 1 < n and uni.val[idx + 1]: uni.merge(idx + 1, idx)\\n            curmax = max(curmax, uni.val[uni.find(idx)])\\n        return ans[::-1]\\n```\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        presum =[0] * (n + 1)\\n        for i in range(n): presum[i + 1] = presum[i] + nums[i]\\n        rng2v, v2rng = SortedDict({(0, n - 1): presum[n]}), SortedDict({presum[n] : {(0, n - 1)}})\\n        ans = []\\n        for idx in removeQueries:\\n            pos = min(rng2v.bisect_left((idx, idx)), len(rng2v) - 1)\\n            if not (rng2v.iloc[pos][0] <= idx <= rng2v.iloc[pos][1]): pos -= 1\\n            (left, right), val = rng2v.popitem(pos)\\n            v2rng[val].remove((left, right))\\n            if not v2rng[val]: v2rng.pop(val)\\n            if left < idx:\\n                lv = presum[idx] - presum[left]\\n                rng2v[(left, idx - 1)] = lv\\n                if lv not in v2rng: v2rng[lv] = set()\\n                v2rng[lv].add((left, idx - 1))\\n            if idx < right:\\n                rv = presum[right + 1] - presum[idx + 1]\\n                rng2v[(idx + 1, right)] = rv\\n                if rv not in v2rng: v2rng[rv] = set()\\n                v2rng[rv].add((idx + 1, right))\\n            ans.append(v2rng.iloc[-1] if v2rng else 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464837,
                "title": "golang-union-find",
                "content": "```\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tN := len(nums)\\n\\n    // array for Union Find DS\\n\\tdata := make([]int, N)\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdata[i] = -1\\n\\t}\\n    // array for result\\n\\tres := make([]int64, N)\\n\\t// array for segments sizes\\n    segs := make([]int, N)\\n\\n    // current size of biggest segment\\n\\tmaxSeg := 0\\n\\n    // starting from end\\n\\tfor i := N - 1; i >= 0; i-- {\\n\\t\\tquery := removeQueries[i]\\n        // initial segment size\\n\\t\\tsegs[query] = nums[query]\\n        \\n\\t\\tdata[query] = query\\n        \\n        // check if we can join our segment from left side\\n\\t\\tif query > 0 {\\n\\t\\t\\tl := data[query-1]\\n\\t\\t\\tif l >= 0 {\\n\\t\\t\\t\\tleftSeg := find(data, query-1)\\n\\t\\t\\t\\tdata[leftSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[leftSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        // check if we can join our segment from right side\\n\\t\\tif query < N-1 {\\n\\t\\t\\tr := data[query+1]\\n\\t\\t\\tif r >= 0 {\\n\\t\\t\\t\\trightSeg := find(data, query+1)\\n\\t\\t\\t\\tdata[rightSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[rightSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tres[i] = int64(maxSeg)\\n        \\n        // increase max segment if possible\\n\\t\\tmaxSeg = max(maxSeg, segs[query])\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc find(data []int, pos int) int {\\n\\tfor data[pos] != pos {\\n\\t\\tpos = data[pos]\\n\\t}\\n\\treturn pos\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tN := len(nums)\\n\\n    // array for Union Find DS\\n\\tdata := make([]int, N)\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdata[i] = -1\\n\\t}\\n    // array for result\\n\\tres := make([]int64, N)\\n\\t// array for segments sizes\\n    segs := make([]int, N)\\n\\n    // current size of biggest segment\\n\\tmaxSeg := 0\\n\\n    // starting from end\\n\\tfor i := N - 1; i >= 0; i-- {\\n\\t\\tquery := removeQueries[i]\\n        // initial segment size\\n\\t\\tsegs[query] = nums[query]\\n        \\n\\t\\tdata[query] = query\\n        \\n        // check if we can join our segment from left side\\n\\t\\tif query > 0 {\\n\\t\\t\\tl := data[query-1]\\n\\t\\t\\tif l >= 0 {\\n\\t\\t\\t\\tleftSeg := find(data, query-1)\\n\\t\\t\\t\\tdata[leftSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[leftSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        // check if we can join our segment from right side\\n\\t\\tif query < N-1 {\\n\\t\\t\\tr := data[query+1]\\n\\t\\t\\tif r >= 0 {\\n\\t\\t\\t\\trightSeg := find(data, query+1)\\n\\t\\t\\t\\tdata[rightSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[rightSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tres[i] = int64(maxSeg)\\n        \\n        // increase max segment if possible\\n\\t\\tmaxSeg = max(maxSeg, segs[query])\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc find(data []int, pos int) int {\\n\\tfor data[pos] != pos {\\n\\t\\tpos = data[pos]\\n\\t}\\n\\treturn pos\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464491,
                "title": "javascript-union-find",
                "content": "Inspired by [hiepit\\'s Python solution](https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2461035/Python-Reverse-Union-Find-Clean-and-Concise)\\n```\\nclass UnionFind {\\n    constructor() {\\n        this.par = new Map()\\n        this.segmentSums = new Map()\\n        this.max = 0\\n    }\\n    \\n    addNumAndMergeSegments(i, num) {\\n        this.par[i] = i\\n        this.segmentSums[i] = num\\n        this.max = Math.max(this.max, num)\\n        if (i-1 in this.par)\\n            this.union(i, i-1)\\n        if (i+1 in this.par)\\n            this.union(i, i+1)\\n    }\\n    \\n    find(x) {\\n        return x == this.par[x] ? x : this.find(this.par[x])\\n    }\\n    \\n    union(x, y) {\\n        const xPar = this.find(x)\\n        const yPar = this.find(y)\\n        if (xPar == yPar) return\\n        this.segmentSums[xPar] += this.segmentSums[yPar]\\n        this.par[yPar] = this.par[xPar]\\n        this.max = Math.max(this.max, this.segmentSums[xPar])\\n    }\\n    \\n}\\n\\nconst maximumSegmentSum = (nums, removeQueries) => {\\n    const N = nums.length\\n    const uf = new UnionFind()\\n    const ans = new Array(N)\\n    \\n    for (let i = N-1; i >= 0; i--) {\\n        ans[i] = uf.max\\n        const numsIdx = removeQueries[i]\\n        uf.addNumAndMergeSegments(numsIdx, nums[numsIdx])\\n    }\\n    \\n    return ans\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "Inspired by [hiepit\\'s Python solution](https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2461035/Python-Reverse-Union-Find-Clean-and-Concise)\\n```\\nclass UnionFind {\\n    constructor() {\\n        this.par = new Map()\\n        this.segmentSums = new Map()\\n        this.max = 0\\n    }\\n    \\n    addNumAndMergeSegments(i, num) {\\n        this.par[i] = i\\n        this.segmentSums[i] = num\\n        this.max = Math.max(this.max, num)\\n        if (i-1 in this.par)\\n            this.union(i, i-1)\\n        if (i+1 in this.par)\\n            this.union(i, i+1)\\n    }\\n    \\n    find(x) {\\n        return x == this.par[x] ? x : this.find(this.par[x])\\n    }\\n    \\n    union(x, y) {\\n        const xPar = this.find(x)\\n        const yPar = this.find(y)\\n        if (xPar == yPar) return\\n        this.segmentSums[xPar] += this.segmentSums[yPar]\\n        this.par[yPar] = this.par[xPar]\\n        this.max = Math.max(this.max, this.segmentSums[xPar])\\n    }\\n    \\n}\\n\\nconst maximumSegmentSum = (nums, removeQueries) => {\\n    const N = nums.length\\n    const uf = new UnionFind()\\n    const ans = new Array(N)\\n    \\n    for (let i = N-1; i >= 0; i--) {\\n        ans[i] = uf.max\\n        const numsIdx = removeQueries[i]\\n        uf.addNumAndMergeSegments(numsIdx, nums[numsIdx])\\n    }\\n    \\n    return ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2464170,
                "title": "reverse-union-find-o-n-python",
                "content": "Instead of removing each element , create the original array by adding elements in the reverse order of removing elements.\\n```\\nclass Solution(object):\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type removeQueries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n\\t\\t\\t\\t\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        # store sum of segment having element at index i as parent\\n        segmentSum=[0]*n\\n        rank=[0]*n\\n        ans=[0]*n\\n        maxSegmentSum=0\\n        for j in range(n-1,-1,-1):\\n            # index of element to add\\n            idx=removeQueries[j]\\n            # creat a new segment with single element at idx\\n            segmentSum[idx]=nums[idx]\\n            if idx>0 and segmentSum[idx-1]>0:\\n                # element at index idx-1 has been added already so merge \\n                union(idx,idx-1)\\n            if idx<n-1 and segmentSum[idx+1]>0:\\n                # element at index idx+1 has been added already so merge \\n                union(idx,idx+1)\\n            ans[j]=maxSegmentSum\\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\\n        return ans\\n```\\nTime complexity - O(N) (since Union By Rank and Path Compression reduce time complexity of union(u,v) and findParent(i) to constant)\\nSpace complexity - O(N)",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type removeQueries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n\\t\\t\\t\\t\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        # store sum of segment having element at index i as parent\\n        segmentSum=[0]*n\\n        rank=[0]*n\\n        ans=[0]*n\\n        maxSegmentSum=0\\n        for j in range(n-1,-1,-1):\\n            # index of element to add\\n            idx=removeQueries[j]\\n            # creat a new segment with single element at idx\\n            segmentSum[idx]=nums[idx]\\n            if idx>0 and segmentSum[idx-1]>0:\\n                # element at index idx-1 has been added already so merge \\n                union(idx,idx-1)\\n            if idx<n-1 and segmentSum[idx+1]>0:\\n                # element at index idx+1 has been added already so merge \\n                union(idx,idx+1)\\n            ans[j]=maxSegmentSum\\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456815,
                "title": "c-union-find-traverse-query-from-backwards",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int find(ll i,vector<ll> &par){\\n        if(par[i]==i) return i;\\n        return par[i]=find(par[i],par);\\n    }\\n    void merge(ll a,ll b,vector<ll> &par,vector<ll> &rank){\\n        a=find(a,par);\\n        b=find(b,par);\\n        if(a==b) return;\\n        if(rank[a]>=rank[b]){\\n            rank[a]+=rank[b];\\n            par[b]=a;\\n        }else{\\n            rank[b]+=rank[a];\\n            par[a]=b;\\n        }return;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& v, vector<int>& q) {\\n        map<ll,ll> m;\\n        int n=v.size();\\n        vector<ll> ans;\\n        reverse(q.begin(),q.end());\\n        ans.push_back(0);\\n        if(n==1) return ans;\\n        ans.push_back(v[q[0]]);\\n        m[q[0]]++;\\n        vector<ll> par(n),rank(n,0);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n            rank[i]=v[i];\\n        }\\n        ll maxi=v[q[0]];\\n        for(int i=1;i<n-1;i++){\\n            ll a=q[i];\\n            if(m.find(a-1)!=m.end()){\\n                merge(a-1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            if(m.find(a+1)!=m.end()){\\n                merge(a+1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            m[a]++;\\n            maxi=max(maxi,(ll)v[q[i]]);\\n            ans.push_back(maxi);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int find(ll i,vector<ll> &par){\\n        if(par[i]==i) return i;\\n        return par[i]=find(par[i],par);\\n    }\\n    void merge(ll a,ll b,vector<ll> &par,vector<ll> &rank){\\n        a=find(a,par);\\n        b=find(b,par);\\n        if(a==b) return;\\n        if(rank[a]>=rank[b]){\\n            rank[a]+=rank[b];\\n            par[b]=a;\\n        }else{\\n            rank[b]+=rank[a];\\n            par[a]=b;\\n        }return;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& v, vector<int>& q) {\\n        map<ll,ll> m;\\n        int n=v.size();\\n        vector<ll> ans;\\n        reverse(q.begin(),q.end());\\n        ans.push_back(0);\\n        if(n==1) return ans;\\n        ans.push_back(v[q[0]]);\\n        m[q[0]]++;\\n        vector<ll> par(n),rank(n,0);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n            rank[i]=v[i];\\n        }\\n        ll maxi=v[q[0]];\\n        for(int i=1;i<n-1;i++){\\n            ll a=q[i];\\n            if(m.find(a-1)!=m.end()){\\n                merge(a-1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            if(m.find(a+1)!=m.end()){\\n                merge(a+1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            m[a]++;\\n            maxi=max(maxi,(ll)v[q[i]]);\\n            ans.push_back(maxi);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456030,
                "title": "java-treeset-treemap-o-nlogn",
                "content": "\\n\\n**Observations:**\\n1. Removing a number at index `i` from `nums` essentially partitions `nums` into two intervals -- the numbers before `i` and the numbers after `i`;\\n\\t- e.g., nums = [0,1,2,3,4,5,6,7,8]: removing `3` will result into two intervals: `[0,1,2]` and `[4,5,6,7,8]`\\n2. Since we have multiple removing operations, each removing operation will `erase` one of the existing intervals and create two new sub-intervals;\\n\\t- e.g., intervals = `[[0,1,2], [4,5,6,7,8]]`, and after removing `6` the intervals becomes `[[0,1,2],[4,5],[7,8]]`\\n3. Each index can belong to ***exactly one*** interval.\\n\\n**With these observations, we can simulate the question step by step:**\\n1. Keep track of the *boundary indices* of the `intervals` after each removal operation. \\n\\t- Initially, there should be only one interval: `[[0, n - 1]]`;\\n\\t- After removing idx `3`, the intervals will become `[[0, 2], [4, n - 1]]`\\n2. For each removal operation that to remove the num at index `i`, identify the interval, `[start, end]`, to which `i` belongs (there could be exactly one interval it belongs to);\\n3. Erase the interval `[start, end]` from `intervals`, and insert two new intervals: `[start, i -1]` and `[i + 1, end]`;\\n4. find the maximum ***range sum*** among all the `intervals` we have so far.\\n\\t- i.e., we need to find the maximum range sum amoung the intervals `[[0, a], [a + 1, b], ...., [c + 1, start - 1], [start, i - 1], [i + 1, end], [end + 1, ...], ..., [z + 1, end]]`\\n\\n\\n**Use proper algorithms and data structures to implement the simulation**:\\n1. In simulation step 2, we need to find a way to identify the interval that the current removing index, `i`, belongs to. If removing `i` is the first operation, then clearly, the interval `i` belongs to is `[0, n -1]`. On the other hand, if removing `i` is not the first operation, then the interval `i` belongs to really depends on the indices those previous operations remove. <br/>\\n**Formally, we need a way to find an index pair, `(lower, upper)`, so that `lower` is the  largest  index < i that has been removed, while `upper` is the smallest  index > i that has been removed. The interval [lower + 1,upper - 1] is then the interval that `i` belongs to**. <br/>\\nBy storing all previously-removed indices in a **TreeSet**, we can use O(logN) time to find `lower` and `upper`, respectively.\\n2. With the use of `TreeSet`, we don\\'t need to store all the intervals as specified in simulation step 3. Rather, **the intervals are the gap between every two consecutive indices in the `TreeSet`.**\\n3. Though we don\\'t need to store the actual intervals, we still need to store the range sum for all intervals and get the maximum range sum, as specified in simulation step 4. When creating a new interval, we calculate, and it\\'s range sum; When erasing an existing interval, we discard it\\'s range sum. <br/> \\nThe key is, **we don\\'t need to know the mapping between an interval and it\\'s range-sum, or vice versa**. We only want to know the *values* of the range sum, to calculate the maximum value accordingly. Also, **we will always create an interval before erasing it at some later point**. <br/>\\nNow things are clear. Our requirements are: \\n\\t- Add a range sum val when a new interval is created  -- clearly, the vals might be duplicated\\n\\t- Remove a range sum val when an existing interval is erased\\n\\t- Get maximum range sum val<br/>\\n\\n\\tBy storing all previously-created intervals\\' range sum in the `TreeMap`, we can use O(logN) time to perform all three operations above.\\n4. Don\\'t forget the corner cases:\\n- When identifying the interval that `i` belongs to, what if there is no previously-removed index, `start`, which is smaller than `i`?\\n- Similarly, when identifying the interval that `i` belongs to, what if there is no previously-removed index, `end`, which is larger than `i`?\\n- Can `start == i` or `i == end`? \\n- How about `start + 1 == i` or `i == end - 1`?<br/>\\n\\tI will leave these questions open :-) Ask yourself before jumping to my code! <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>\\n\\t\\n\\t\\n**Code**\\n\\n```java\\nclass Solution {\\n  \\n  public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n    long[] prefixSum = getPrefixSum(nums);\\n    \\n    TreeSet<Integer> removed = new TreeSet<>();\\n    TreeMap<Long, Integer> rangeSumCnts = new TreeMap<>();\\n    rangeSumCnts.put(getRangeSumInclusive(prefixSum, 0, nums.length - 1), 1);\\n    \\n    long[] res = new long[removeQueries.length];\\n    for (int i = 0; i < removeQueries.length - 1; i++) {\\n      int idx = removeQueries[i];\\n      \\n      Integer lowerBound = getLowerBound(removed, idx);\\n      Integer upperBound = getUpperBound(removed, idx);\\n\\n      updateRangeSum(rangeSumCnts, prefixSum, nums.length, lowerBound, upperBound, idx);\\n      res[i] = getMax(rangeSumCnts);\\n      \\n      removed.add(idx);\\n    }\\n    \\n    return res;\\n  }\\n  \\n  private long[] getPrefixSum(int[] nums) {\\n    long[] prefixSum = new long[nums.length + 1];\\n    for (int i = 1; i <= nums.length; i++) {\\n      prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n    }\\n    return prefixSum;\\n  }\\n  \\n  private Integer getLowerBound(TreeSet<Integer> removed, int idx) {\\n    return removed.floor(idx);\\n  }\\n  \\n  private Integer getUpperBound(TreeSet<Integer> removed, int idx) {\\n    return removed.ceiling(idx);\\n  }\\n  \\n  private void updateRangeSum(TreeMap<Long, Integer> rangeSumCnts, long[] prefixSum, int n, Integer lowerBound, Integer upperBound, int idx) {\\n    if (lowerBound == null) {\\n      lowerBound = -1;\\n    }\\n    if (upperBound == null) {\\n      upperBound = n;\\n    }\\n    // assert: rangeSum[lowerBound + 1 : upperBound - 1] must have been recored in the rangeSumCnts\\n    removeRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, upperBound - 1));\\n    \\n    if (idx - 1 >= lowerBound + 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, idx - 1));  \\n    }\\n    if (idx + 1 <= upperBound - 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, idx + 1, upperBound - 1));  \\n    }\\n  } \\n  \\n  private void removeRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.get(rangeSum) - 1);\\n    if (rangeSumCnts.get(rangeSum) == 0) {\\n      rangeSumCnts.remove(rangeSum);\\n    }\\n  }\\n  \\n  private void addRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.getOrDefault(rangeSum, 0) + 1);\\n  }\\n  \\n  private long getMax(TreeMap<Long, Integer> rangeSumCnts) {\\n    return rangeSumCnts.lastKey();\\n  }\\n  \\n  private long getRangeSumInclusive(long[] prefixSum, int i, int j) {\\n    return prefixSum[j + 1] - prefixSum[i];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```java\\nclass Solution {\\n  \\n  public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n    long[] prefixSum = getPrefixSum(nums);\\n    \\n    TreeSet<Integer> removed = new TreeSet<>();\\n    TreeMap<Long, Integer> rangeSumCnts = new TreeMap<>();\\n    rangeSumCnts.put(getRangeSumInclusive(prefixSum, 0, nums.length - 1), 1);\\n    \\n    long[] res = new long[removeQueries.length];\\n    for (int i = 0; i < removeQueries.length - 1; i++) {\\n      int idx = removeQueries[i];\\n      \\n      Integer lowerBound = getLowerBound(removed, idx);\\n      Integer upperBound = getUpperBound(removed, idx);\\n\\n      updateRangeSum(rangeSumCnts, prefixSum, nums.length, lowerBound, upperBound, idx);\\n      res[i] = getMax(rangeSumCnts);\\n      \\n      removed.add(idx);\\n    }\\n    \\n    return res;\\n  }\\n  \\n  private long[] getPrefixSum(int[] nums) {\\n    long[] prefixSum = new long[nums.length + 1];\\n    for (int i = 1; i <= nums.length; i++) {\\n      prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n    }\\n    return prefixSum;\\n  }\\n  \\n  private Integer getLowerBound(TreeSet<Integer> removed, int idx) {\\n    return removed.floor(idx);\\n  }\\n  \\n  private Integer getUpperBound(TreeSet<Integer> removed, int idx) {\\n    return removed.ceiling(idx);\\n  }\\n  \\n  private void updateRangeSum(TreeMap<Long, Integer> rangeSumCnts, long[] prefixSum, int n, Integer lowerBound, Integer upperBound, int idx) {\\n    if (lowerBound == null) {\\n      lowerBound = -1;\\n    }\\n    if (upperBound == null) {\\n      upperBound = n;\\n    }\\n    // assert: rangeSum[lowerBound + 1 : upperBound - 1] must have been recored in the rangeSumCnts\\n    removeRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, upperBound - 1));\\n    \\n    if (idx - 1 >= lowerBound + 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, idx - 1));  \\n    }\\n    if (idx + 1 <= upperBound - 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, idx + 1, upperBound - 1));  \\n    }\\n  } \\n  \\n  private void removeRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.get(rangeSum) - 1);\\n    if (rangeSumCnts.get(rangeSum) == 0) {\\n      rangeSumCnts.remove(rangeSum);\\n    }\\n  }\\n  \\n  private void addRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.getOrDefault(rangeSum, 0) + 1);\\n  }\\n  \\n  private long getMax(TreeMap<Long, Integer> rangeSumCnts) {\\n    return rangeSumCnts.lastKey();\\n  }\\n  \\n  private long getRangeSumInclusive(long[] prefixSum, int i, int j) {\\n    return prefixSum[j + 1] - prefixSum[i];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455758,
                "title": "python-3-prefix-sum-heap",
                "content": "```\\n    \\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        acc = [0]\\n        # prefix sum\\n        for num in nums:\\n            acc.append(acc[-1] + num)\\n        \\n        # current max sum with boundries\\n        q = [(-sum(nums), 0, n - 1)]\\n        # removed index\\n        rm_idx = []\\n        \\n        \\n        ans = []\\n        for idx in removeQueries:\\n            bisect.insort(rm_idx, idx)\\n            while q:\\n                _, s, e = q[0]\\n                loc = bisect.bisect_left(rm_idx, s)\\n                idx = rm_idx[min(loc, len(rm_idx) - 1)]\\n                # if removed index fall between the boundry of largest sum\\n                if idx > e or idx < s: break\\n                heappop(q)\\n                if s < idx:\\n                    heappush(q, (-(acc[idx] - acc[s]), s, idx - 1))\\n                if e > idx:\\n                    heappush(q, (-(acc[e + 1] - acc[idx + 1]), idx + 1, e))\\n            if q:\\n                ans.append(-q[0][0])\\n            else:\\n                ans.append(0)\\n            \\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\n    \\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        acc = [0]\\n        # prefix sum\\n        for num in nums:\\n            acc.append(acc[-1] + num)\\n        \\n        # current max sum with boundries\\n        q = [(-sum(nums), 0, n - 1)]\\n        # removed index\\n        rm_idx = []\\n        \\n        \\n        ans = []\\n        for idx in removeQueries:\\n            bisect.insort(rm_idx, idx)\\n            while q:\\n                _, s, e = q[0]\\n                loc = bisect.bisect_left(rm_idx, s)\\n                idx = rm_idx[min(loc, len(rm_idx) - 1)]\\n                # if removed index fall between the boundry of largest sum\\n                if idx > e or idx < s: break\\n                heappop(q)\\n                if s < idx:\\n                    heappush(q, (-(acc[idx] - acc[s]), s, idx - 1))\\n                if e > idx:\\n                    heappush(q, (-(acc[e + 1] - acc[idx + 1]), idx + 1, e))\\n            if q:\\n                ans.append(-q[0][0])\\n            else:\\n                ans.append(0)\\n            \\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2455644,
                "title": "revere-union-find-java-explaination",
                "content": "Considering array as a graph, in which we have edge from i to i + 1 for 0 <= i < n - 1.\\n\\nGiven: After performing all queries we will be left with all the nodes destroyed. So, we can consider while moving from left to right we are breaking one edge and disconnecting the graph.\\nSo, if we move from right to left, we are connecting one edge and if the edge connects two unconnected components, it will connect the components and add thier sums. And the connected components which has maximum sum will be the answer for that query.\\n\\nWe can use Union Find to solve the query by connecting the components at each query.\\n\\nInput: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\nIf we traverse removeQueries from right to left.\\n[] ans: 0\\n[1(2)] ans: 2\\n[1(2)]  [4(1)] ans: 2\\n[1(2)--2(5)]  [4(1)] ans: 7\\n[1(2)--2(5)--3(6)--4(1)] ans: 14\\nWe don\\'t need to perform the left most query.\\n\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        DSU dsu = new DSU(n);\\n        long[] ans = new long[n];\\n        for(int i = n - 1; i > 0; i--) {\\n            ans[i - 1] = dsu.add(removeQueries[i], nums[removeQueries[i]]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int[] roots;\\n    long[] sums;\\n    int[] heights;\\n    int n;\\n    long msf;\\n    \\n    DSU(int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        sums = new long[n];\\n        heights = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            roots[i] = i;\\n            heights[i] = 1;\\n        }\\n        msf = 0;\\n    }\\n    \\n    public long add(int i, int val) {\\n        sums[i] = ln(val);\\n        if(i - 1 >= 0 && sums[i - 1] > 0) connect(i, i - 1);\\n        if(i + 1 < n && sums[i + 1] > 0) connect(i, i + 1);\\n        msf = Math.max(msf, sums[i]);\\n        return msf;\\n    }\\n    \\n    private int root(int u) {\\n        if(roots[u] != u) {\\n            roots[u] = root(roots[u]);\\n        }\\n        return roots[u];\\n    }\\n    \\n    private void connect(int u, int v) {\\n        int rU = root(u);\\n        int rV = root(v);\\n        if(rU == rV) return;\\n        int hU = heights[rU];\\n        int hV = heights[rV];\\n        \\n        if(hU <= hV) {\\n            roots[rU] = rV;\\n            if(hU == hV) heights[rV]++;\\n            sums[rV] += sums[rU];\\n            msf = Math.max(msf, sums[rV]);\\n            return;\\n        }\\n        roots[rV] = rU;\\n        sums[rU] += sums[rV];\\n        msf = Math.max(msf, sums[rU]);\\n    }\\n    \\n    private long ln(int val) { return Long.valueOf(val); }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        DSU dsu = new DSU(n);\\n        long[] ans = new long[n];\\n        for(int i = n - 1; i > 0; i--) {\\n            ans[i - 1] = dsu.add(removeQueries[i], nums[removeQueries[i]]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int[] roots;\\n    long[] sums;\\n    int[] heights;\\n    int n;\\n    long msf;\\n    \\n    DSU(int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        sums = new long[n];\\n        heights = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            roots[i] = i;\\n            heights[i] = 1;\\n        }\\n        msf = 0;\\n    }\\n    \\n    public long add(int i, int val) {\\n        sums[i] = ln(val);\\n        if(i - 1 >= 0 && sums[i - 1] > 0) connect(i, i - 1);\\n        if(i + 1 < n && sums[i + 1] > 0) connect(i, i + 1);\\n        msf = Math.max(msf, sums[i]);\\n        return msf;\\n    }\\n    \\n    private int root(int u) {\\n        if(roots[u] != u) {\\n            roots[u] = root(roots[u]);\\n        }\\n        return roots[u];\\n    }\\n    \\n    private void connect(int u, int v) {\\n        int rU = root(u);\\n        int rV = root(v);\\n        if(rU == rV) return;\\n        int hU = heights[rU];\\n        int hV = heights[rV];\\n        \\n        if(hU <= hV) {\\n            roots[rU] = rV;\\n            if(hU == hV) heights[rV]++;\\n            sums[rV] += sums[rU];\\n            msf = Math.max(msf, sums[rV]);\\n            return;\\n        }\\n        roots[rV] = rU;\\n        sums[rU] += sums[rV];\\n        msf = Math.max(msf, sums[rU]);\\n    }\\n    \\n    private long ln(int val) { return Long.valueOf(val); }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455632,
                "title": "c-uinon-find",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll par[100005];\\n    ll sz[100005];\\n    ll find(int x){\\n        if(x<0) return x;\\n        if(par[x]==x) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        priority_queue<ll>pq;\\n        vector<ll>ans;\\n        for(int i=0;i<=nums.size();i++) par[i]=i,sz[i]=0;\\n        pq.push(0);\\n        for(int i=q.size()-1;i>=0;i--){\\n            int idx=q[i];\\n            ll curmax=pq.top();\\n           ///cout<<curmax<<\" \";\\n            ans.push_back(curmax);\\n            ll left=find(idx-1);\\n            ll right=find(idx+1);\\n            ll cur=find(idx);\\n            sz[cur]=nums[cur];\\n            ///cout<<idx<<endl;\\n            //cout<<sz[cur]<<\" \"<<endl;\\n            if(left!=-1 and sz[left]>0){\\n                sz[cur]+=sz[left];\\n                par[left]=cur;\\n            }\\n            if(sz[right]>0){\\n                sz[cur]+=sz[right];\\n                par[right]=cur;\\n            }\\n           // cout<<cur<<\" \";\\n            \\n            pq.push(sz[cur]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll par[100005];\\n    ll sz[100005];\\n    ll find(int x){\\n        if(x<0) return x;\\n        if(par[x]==x) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        priority_queue<ll>pq;\\n        vector<ll>ans;\\n        for(int i=0;i<=nums.size();i++) par[i]=i,sz[i]=0;\\n        pq.push(0);\\n        for(int i=q.size()-1;i>=0;i--){\\n            int idx=q[i];\\n            ll curmax=pq.top();\\n           ///cout<<curmax<<\" \";\\n            ans.push_back(curmax);\\n            ll left=find(idx-1);\\n            ll right=find(idx+1);\\n            ll cur=find(idx);\\n            sz[cur]=nums[cur];\\n            ///cout<<idx<<endl;\\n            //cout<<sz[cur]<<\" \"<<endl;\\n            if(left!=-1 and sz[left]>0){\\n                sz[cur]+=sz[left];\\n                par[left]=cur;\\n            }\\n            if(sz[right]>0){\\n                sz[cur]+=sz[right];\\n                par[right]=cur;\\n            }\\n           // cout<<cur<<\" \";\\n            \\n            pq.push(sz[cur]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454993,
                "title": "simple-java-solution-with-explanation-reverse-union-find-with-prefix-sum",
                "content": "**Approach:**\\n1. Compute the prefix sum for the input array.\\n2. We start processing deletions from right to left i.e. from the last deletion to first deletion (in the reverse order of sequence of events).\\n3. For every deletion, look to the immediate left element and the immediate right element.\\n4. If the immediate neighbours are marked as occupied (or in other words, the immediate neighbours are deleted after the current element), then the immediate neighbours will contain the left end and right end of the newly formed segment.\\n5. Also make sure to update the left end value for the right end index of the segment and the right end value for the left end index of the segment.\\n6. In between values need not be updated as their neighbours have been occupied and they will not be referenced in future.\\n7. Use the left end and right end of the current segment along with the prefix sum array to get the current segment sum.\\n8. Compare with max segment sum and update the answer array.\\n\\n**Dry Run with Sample:**\\n```\\nInput:\\n[1,2,5,6,1]\\n[0,3,2,4,1]\\n\\nPrint Format:  \\n- left end array\\n- right end array\\n- max segment sum (segment left end - segment right end)\\n\\n// Before the index 1 was deleted - [0,3,2,4,(1)]\\n0\\t1\\t0\\t0\\t0\\t\\n0\\t1\\t0\\t0\\t0\\t\\n2 (1 - 1)\\n\\n// Before the index 4 was deleted - [0,3,2,(4),1]\\n0\\t1\\t0\\t0\\t4\\t\\n0\\t1\\t0\\t0\\t4\\t\\n2 (1 - 1)\\n\\n// Before the index 2 was deleted - [0,3,(2),4,1]\\n0\\t1\\t1\\t0\\t4\\t\\n0\\t2\\t2\\t0\\t4\\t\\n7 (1 - 2)\\n\\n// Before the index 3 was deleted - [0,(3),2,4,1]\\n0\\t1\\t1\\t1\\t1\\t\\n0\\t4\\t2\\t4\\t4\\t\\n14 (1 - 4)\\n\\n// Before the index 0 was deleted - [(0),3,2,4,1]\\n0\\t1\\t1\\t1\\t0\\t\\n4\\t4\\t2\\t4\\t4\\t\\n15 (0 - 4)\\n```\\n**Solution:**\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // Compute the prefix sum for the input array\\n        long[] prefixSum = new long[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        long currentMax = 0;\\n        int[] leftEnd = new int[nums.length];\\n        int[] rightEnd = new int[nums.length];\\n        long[] ans = new long[removeQueries.length];\\n\\t\\t// We can eliminate this extra space by modifying the input array and marking visited elements as -1, but it\\'s not a good practise\\n\\t\\tboolean[] isOccupied = new boolean[nums.length]; \\n        \\n        // We start processing deletions from right to left i.e. from the last deletion to first deletion\\n        for (int i = removeQueries.length - 1; i >= 0; i--) {\\n            ans[i] = currentMax;\\n            \\n            int index = removeQueries[i];\\n            isOccupied[index] = true;\\n            \\n            // Inspiration from Union Find - find left end and right end\\n            rightEnd[index] = index;\\n            if (index < nums.length - 1 && isOccupied[index + 1] == true) {\\n                rightEnd[index] = rightEnd[index + 1]; \\n            }\\n            \\n            leftEnd[index] = index;\\n            if (index > 0 && isOccupied[index - 1] == true) {\\n                leftEnd[index] = leftEnd[index - 1];\\n            }\\n            \\n            // Get current segment sum using left end and right end of current segment on the prefix sum array\\n            int leftIndex = leftEnd[index];\\n            int rightIndex = rightEnd[index];\\n            long currSegmentSum = prefixSum[rightIndex + 1] - prefixSum[leftIndex];\\n            currentMax = Math.max(currentMax, currSegmentSum);\\n            \\n            // Also update the right end index for the left end value and the left end index for the right end value\\n            rightEnd[leftIndex] = rightIndex;\\n            leftEnd[rightIndex] = leftIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Prefix Sum"
                ],
                "code": "```\\nInput:\\n[1,2,5,6,1]\\n[0,3,2,4,1]\\n\\nPrint Format:  \\n- left end array\\n- right end array\\n- max segment sum (segment left end - segment right end)\\n\\n// Before the index 1 was deleted - [0,3,2,4,(1)]\\n0\\t1\\t0\\t0\\t0\\t\\n0\\t1\\t0\\t0\\t0\\t\\n2 (1 - 1)\\n\\n// Before the index 4 was deleted - [0,3,2,(4),1]\\n0\\t1\\t0\\t0\\t4\\t\\n0\\t1\\t0\\t0\\t4\\t\\n2 (1 - 1)\\n\\n// Before the index 2 was deleted - [0,3,(2),4,1]\\n0\\t1\\t1\\t0\\t4\\t\\n0\\t2\\t2\\t0\\t4\\t\\n7 (1 - 2)\\n\\n// Before the index 3 was deleted - [0,(3),2,4,1]\\n0\\t1\\t1\\t1\\t1\\t\\n0\\t4\\t2\\t4\\t4\\t\\n14 (1 - 4)\\n\\n// Before the index 0 was deleted - [(0),3,2,4,1]\\n0\\t1\\t1\\t1\\t0\\t\\n4\\t4\\t2\\t4\\t4\\t\\n15 (0 - 4)\\n```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // Compute the prefix sum for the input array\\n        long[] prefixSum = new long[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        long currentMax = 0;\\n        int[] leftEnd = new int[nums.length];\\n        int[] rightEnd = new int[nums.length];\\n        long[] ans = new long[removeQueries.length];\\n\\t\\t// We can eliminate this extra space by modifying the input array and marking visited elements as -1, but it\\'s not a good practise\\n\\t\\tboolean[] isOccupied = new boolean[nums.length]; \\n        \\n        // We start processing deletions from right to left i.e. from the last deletion to first deletion\\n        for (int i = removeQueries.length - 1; i >= 0; i--) {\\n            ans[i] = currentMax;\\n            \\n            int index = removeQueries[i];\\n            isOccupied[index] = true;\\n            \\n            // Inspiration from Union Find - find left end and right end\\n            rightEnd[index] = index;\\n            if (index < nums.length - 1 && isOccupied[index + 1] == true) {\\n                rightEnd[index] = rightEnd[index + 1]; \\n            }\\n            \\n            leftEnd[index] = index;\\n            if (index > 0 && isOccupied[index - 1] == true) {\\n                leftEnd[index] = leftEnd[index - 1];\\n            }\\n            \\n            // Get current segment sum using left end and right end of current segment on the prefix sum array\\n            int leftIndex = leftEnd[index];\\n            int rightIndex = rightEnd[index];\\n            long currSegmentSum = prefixSum[rightIndex + 1] - prefixSum[leftIndex];\\n            currentMax = Math.max(currentMax, currSegmentSum);\\n            \\n            // Also update the right end index for the left end value and the left end index for the right end value\\n            rightEnd[leftIndex] = rightIndex;\\n            leftEnd[rightIndex] = leftIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454850,
                "title": "java-clean-simple-union-find",
                "content": "```\\nclass Solution {\\n    class Node {\\n        Node root;\\n        long total;\\n\\n        Node(long val) {\\n            total = val;\\n        }\\n\\n        Node GetRoot() {\\n            if (root == null)\\n                return this;\\n            return root.GetRoot();\\n        }\\n    }\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] result = new long[nums.length];\\n        Node[] map = new Node[nums.length];\\n        long max = 0;\\n\\n        for (int i = removeQueries.length - 1; i >= 1; i--) {\\n            int current = removeQueries[i];\\n            map[current] = new Node(nums[current]);\\n\\n            if (current > 0 && map[current - 1] != null) { // connect left\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current - 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            if (current < nums.length - 1 && map[current + 1] != null) { // connect right\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current + 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            max = Math.max(max, map[current].total);\\n            result[i - 1] = max;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        Node root;\\n        long total;\\n\\n        Node(long val) {\\n            total = val;\\n        }\\n\\n        Node GetRoot() {\\n            if (root == null)\\n                return this;\\n            return root.GetRoot();\\n        }\\n    }\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] result = new long[nums.length];\\n        Node[] map = new Node[nums.length];\\n        long max = 0;\\n\\n        for (int i = removeQueries.length - 1; i >= 1; i--) {\\n            int current = removeQueries[i];\\n            map[current] = new Node(nums[current]);\\n\\n            if (current > 0 && map[current - 1] != null) { // connect left\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current - 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            if (current < nums.length - 1 && map[current + 1] != null) { // connect right\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current + 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            max = Math.max(max, map[current].total);\\n            result[i - 1] = max;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454603,
                "title": "segment-tree-similar-to-cses-problem",
                "content": "Cses problem:https://cses.fi/problemset/task/1190/\\n```class Solution {\\npublic:\\n    \\n    #define ll long long\\n    struct Node{\\n\\tll s;\\n\\tll pre;\\n\\tll suf;\\n\\tll re;\\n};\\n\\nvector<Node> st;\\nvector<ll> a;\\nint n,q;\\n\\nvoid buildTree(int v,int tl, int tr){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=a[tl];\\n\\t\\treturn;\\n\\t}\\n\\tll mid = (tl+tr)>>1LL;\\n\\tbuildTree(v*2,tl,mid);\\n\\tbuildTree(v*2+1,mid+1,tr);\\n\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\n}\\n\\nvoid update(ll v,ll tl, ll tr,ll pos,ll val){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=val;\\n\\t}\\n\\telse {\\n\\t\\tll mid =(tl+tr)>>1LL;\\n\\t\\tif (pos<=mid) update(v*2,tl,mid,pos,val);\\n\\t\\telse update(v*2+1,mid+1,tr,pos,val);\\n\\t\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\t\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\t\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\t\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\t\\n\\t}\\n}\\n\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        \\n    \\n\\t\\n\\tvector<ll> ans;\\n\\t\\n\\tint n=nums.size();\\n     a=vector<ll> (n,0);\\n     for(ll j=0;j<n;j++)\\n     {\\n         a[j]=nums[j];\\n     }\\n\\tst=vector<Node>(4*n,Node({0,0,0,0}));\\n\\tbuildTree(1,0,n-1);\\n\\tfor (int i=0;i<q.size();++i){\\n\\t\\tll x;\\n        x=q[i];\\n\\t\\tupdate(1,0,n-1,x,-9e13);\\n\\t\\tans.push_back(max(st[1].re,0LL));\\n\\t}\\n     return ans;\\n }\\n   \\n};```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    \\n    #define ll long long\\n    struct Node{\\n\\tll s;\\n\\tll pre;\\n\\tll suf;\\n\\tll re;\\n};\\n\\nvector<Node> st;\\nvector<ll> a;\\nint n,q;\\n\\nvoid buildTree(int v,int tl, int tr){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=a[tl];\\n\\t\\treturn;\\n\\t}\\n\\tll mid = (tl+tr)>>1LL;\\n\\tbuildTree(v*2,tl,mid);\\n\\tbuildTree(v*2+1,mid+1,tr);\\n\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\n}\\n\\nvoid update(ll v,ll tl, ll tr,ll pos,ll val){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=val;\\n\\t}\\n\\telse {\\n\\t\\tll mid =(tl+tr)>>1LL;\\n\\t\\tif (pos<=mid) update(v*2,tl,mid,pos,val);\\n\\t\\telse update(v*2+1,mid+1,tr,pos,val);\\n\\t\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\t\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\t\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\t\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\t\\n\\t}\\n}\\n\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        \\n    \\n\\t\\n\\tvector<ll> ans;\\n\\t\\n\\tint n=nums.size();\\n     a=vector<ll> (n,0);\\n     for(ll j=0;j<n;j++)\\n     {\\n         a[j]=nums[j];\\n     }\\n\\tst=vector<Node>(4*n,Node({0,0,0,0}));\\n\\tbuildTree(1,0,n-1);\\n\\tfor (int i=0;i<q.size();++i){\\n\\t\\tll x;\\n        x=q[i];\\n\\t\\tupdate(1,0,n-1,x,-9e13);\\n\\t\\tans.push_back(max(st[1].re,0LL));\\n\\t}\\n     return ans;\\n }\\n   \\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2454376,
                "title": "java-dsu",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int l = nums.length;\\n        long[] res = new long[l];\\n        \\n        UnionFind uf = new UnionFind(l, nums);\\n        \\n        long max = 0;\\n        \\n        int[] queries = new int[l];\\n        \\n        for(int i = removeQueries.length-1; i >= 0; i--){\\n            res[i] = max;\\n            \\n            int val = removeQueries[i];\\n            \\n            queries[val] = nums[val];\\n            \\n            if((val+1 < l && queries[val+1] == 0) && (val-1 >= 0 && queries[val-1] == 0)){ }\\n            else if((val+1 < l && queries[val+1] != 0) && (val-1 >= 0 && queries[val-1] != 0)){\\n                uf.union(val, val+1);\\n                uf.union(val, val-1);\\n            }\\n            else if(val+1 < l && queries[val+1] != 0){\\n                uf.union(val, val+1);\\n            }\\n            else if(val-1 >= 0 && queries[val-1] != 0){\\n                uf.union(val, val-1);\\n            }\\n            \\n            max = Math.max(max, uf.sum(val));\\n        }\\n        \\n        // res[0] = max;\\n        \\n        return res;\\n    }\\n}\\n\\n\\nclass UnionFind {\\n    int[] nums;\\n    int[] parent;\\n    int[] rank;\\n    long[] sum;\\n    int count;\\n\\n    public UnionFind(int n, int[] nums) { // for problem 200\\n        this.nums = nums;\\n        parent = new int[n];\\n        rank = new int[n];\\n        sum = new long[n];\\n        count = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n            sum[i] = nums[i];\\n        }\\n    }\\n    \\n    public long sum(int x){\\n        return sum[find(x)];\\n    }\\n\\n    public int find(int x) { // path compression\\n        // only the rank of the root matters, used in union op.\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) { // union with rank\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx != rooty) {\\n            parent[rootx] = rooty;\\n            sum[rooty] += sum[rootx];\\n            count--;\\n        }\\n    }\\n\\n    public int getCount() {\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int l = nums.length;\\n        long[] res = new long[l];\\n        \\n        UnionFind uf = new UnionFind(l, nums);\\n        \\n        long max = 0;\\n        \\n        int[] queries = new int[l];\\n        \\n        for(int i = removeQueries.length-1; i >= 0; i--){\\n            res[i] = max;\\n            \\n            int val = removeQueries[i];\\n            \\n            queries[val] = nums[val];\\n            \\n            if((val+1 < l && queries[val+1] == 0) && (val-1 >= 0 && queries[val-1] == 0)){ }\\n            else if((val+1 < l && queries[val+1] != 0) && (val-1 >= 0 && queries[val-1] != 0)){\\n                uf.union(val, val+1);\\n                uf.union(val, val-1);\\n            }\\n            else if(val+1 < l && queries[val+1] != 0){\\n                uf.union(val, val+1);\\n            }\\n            else if(val-1 >= 0 && queries[val-1] != 0){\\n                uf.union(val, val-1);\\n            }\\n            \\n            max = Math.max(max, uf.sum(val));\\n        }\\n        \\n        // res[0] = max;\\n        \\n        return res;\\n    }\\n}\\n\\n\\nclass UnionFind {\\n    int[] nums;\\n    int[] parent;\\n    int[] rank;\\n    long[] sum;\\n    int count;\\n\\n    public UnionFind(int n, int[] nums) { // for problem 200\\n        this.nums = nums;\\n        parent = new int[n];\\n        rank = new int[n];\\n        sum = new long[n];\\n        count = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n            sum[i] = nums[i];\\n        }\\n    }\\n    \\n    public long sum(int x){\\n        return sum[find(x)];\\n    }\\n\\n    public int find(int x) { // path compression\\n        // only the rank of the root matters, used in union op.\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) { // union with rank\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx != rooty) {\\n            parent[rootx] = rooty;\\n            sum[rooty] += sum[rootx];\\n            count--;\\n        }\\n    }\\n\\n    public int getCount() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454183,
                "title": "union-find-algorithm-o-n-time-and-space-solution",
                "content": "The key is to do the given exercise in a backward order, \\nso instead of remove element we will be adding elements at the given index.\\nWhile Adding we have to check if the neighbouring index are set, in case they are then group them\\n\\n<b>Golang</b>\\n```\\ntype DisJointSet struct{\\n  p []int\\n  size []int\\n  val []int\\n}\\nfunc CreateDisJointSet(n int) DisJointSet {\\n  p := make([]int , n)\\n  size := make([]int, n)\\n  val := make([]int, n)\\n  for i:= 0;i<n;i++ {\\n    p[i] = -1\\n  }\\n  return DisJointSet{p, size, val}\\n}\\n\\nfunc (s DisJointSet) IsSet(x int) bool {\\n  return s.p[x] != -1\\n}\\nfunc (s DisJointSet) Set(x, val int) {\\n  s.p[x] = x\\n  s.size[x] = 1\\n  s.val[x] = val\\n}\\nfunc (s DisJointSet) Find(x int) int{\\n  if s.p[x] == x{\\n    return s.p[x]\\n  }\\n  s.p[x] = s.Find(s.p[x])\\n  return s.p[x]\\n}\\n\\nfunc (s DisJointSet) Union(x, y int) {\\n  px, py := s.Find(x), s.Find(y)\\n  if px == py {\\n    return\\n  }\\n  if s.size[px]> s.size[py] {\\n    s.p[py] = px\\n    s.size[px] += s.size[py]\\n    s.val[px] += s.val[py]\\n  }else {\\n    s.p[px] = py\\n    s.size[py] += s.size[px]\\n    s.val[py] += s.val[px]\\n  }\\n}\\nfunc (s DisJointSet) Val(x int) int{\\n  return s.val[s.Find(s.p[x])]\\n}\\n\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  n:= len(nums)\\n  res := make([]int64, n)\\n  max := int64(0)\\n  s := CreateDisJointSet(n)\\n  for i:= n-1;i>0;i-- {\\n    rq := removeQueries[i]\\n    s.Set(rq, nums[rq])\\n    if rq>0 && s.IsSet(rq-1){\\n      s.Union(rq, rq-1)\\n    }\\n    if rq < n-1 && s.IsSet(rq+1) {\\n      s.Union(rq, rq+1)\\n    }\\n    temp := int64(s.Val(rq))\\n    if temp > max {\\n      max = temp\\n    }\\n    res[i-1] = max\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype DisJointSet struct{\\n  p []int\\n  size []int\\n  val []int\\n}\\nfunc CreateDisJointSet(n int) DisJointSet {\\n  p := make([]int , n)\\n  size := make([]int, n)\\n  val := make([]int, n)\\n  for i:= 0;i<n;i++ {\\n    p[i] = -1\\n  }\\n  return DisJointSet{p, size, val}\\n}\\n\\nfunc (s DisJointSet) IsSet(x int) bool {\\n  return s.p[x] != -1\\n}\\nfunc (s DisJointSet) Set(x, val int) {\\n  s.p[x] = x\\n  s.size[x] = 1\\n  s.val[x] = val\\n}\\nfunc (s DisJointSet) Find(x int) int{\\n  if s.p[x] == x{\\n    return s.p[x]\\n  }\\n  s.p[x] = s.Find(s.p[x])\\n  return s.p[x]\\n}\\n\\nfunc (s DisJointSet) Union(x, y int) {\\n  px, py := s.Find(x), s.Find(y)\\n  if px == py {\\n    return\\n  }\\n  if s.size[px]> s.size[py] {\\n    s.p[py] = px\\n    s.size[px] += s.size[py]\\n    s.val[px] += s.val[py]\\n  }else {\\n    s.p[px] = py\\n    s.size[py] += s.size[px]\\n    s.val[py] += s.val[px]\\n  }\\n}\\nfunc (s DisJointSet) Val(x int) int{\\n  return s.val[s.Find(s.p[x])]\\n}\\n\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  n:= len(nums)\\n  res := make([]int64, n)\\n  max := int64(0)\\n  s := CreateDisJointSet(n)\\n  for i:= n-1;i>0;i-- {\\n    rq := removeQueries[i]\\n    s.Set(rq, nums[rq])\\n    if rq>0 && s.IsSet(rq-1){\\n      s.Union(rq, rq-1)\\n    }\\n    if rq < n-1 && s.IsSet(rq+1) {\\n      s.Union(rq, rq+1)\\n    }\\n    temp := int64(s.Val(rq))\\n    if temp > max {\\n      max = temp\\n    }\\n    res[i-1] = max\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030782,
                "title": "c-use-union-find",
                "content": "# Intuition\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2. keep track the \"max segmention sum\" when doing Union\\n\\n# Code\\n```\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int group_size;\\n    long long *sum;\\n    long long MaxSum;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        sum = new long long[n];\\n        group_size = n;\\n        MaxSum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n            sum[i] = 0;\\n        }\\n    }\\n    void add (int idx, int val)\\n    {\\n        sum[idx] = val;\\n        if(sum[idx] > MaxSum) MaxSum = sum[idx];\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n                sum[rootP] += sum[rootQ];\\n                if(sum[rootP] > MaxSum) MaxSum = sum[rootP];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n                sum[rootQ] += sum[rootP];\\n                if(sum[rootQ] > MaxSum) MaxSum = sum[rootQ];\\n            }\\n        }\\n        group_size--;\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = removeQueries.size();\\n        vector<long long> vRet(n);\\n        vector<int> vTable(n, 0);\\n        UnionFind *uf = new UnionFind(n);\\n        for(int i=n-1; i>=1; i--)\\n        {\\n            int iRemoveIdx = removeQueries[i];\\n            vTable[iRemoveIdx] = nums[iRemoveIdx];\\n            uf->add(iRemoveIdx, nums[iRemoveIdx]);\\n            if(iRemoveIdx-1 >=0 && vTable[iRemoveIdx-1] >0) uf->Union(iRemoveIdx-1, iRemoveIdx);\\n            if(iRemoveIdx+1 <n && vTable[iRemoveIdx+1] >0) uf->Union(iRemoveIdx+1, iRemoveIdx);\\n            vRet[i-1] = uf->MaxSum;\\n\\n        }\\n \\n        return vRet;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int group_size;\\n    long long *sum;\\n    long long MaxSum;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        sum = new long long[n];\\n        group_size = n;\\n        MaxSum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n            sum[i] = 0;\\n        }\\n    }\\n    void add (int idx, int val)\\n    {\\n        sum[idx] = val;\\n        if(sum[idx] > MaxSum) MaxSum = sum[idx];\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n                sum[rootP] += sum[rootQ];\\n                if(sum[rootP] > MaxSum) MaxSum = sum[rootP];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n                sum[rootQ] += sum[rootP];\\n                if(sum[rootQ] > MaxSum) MaxSum = sum[rootQ];\\n            }\\n        }\\n        group_size--;\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = removeQueries.size();\\n        vector<long long> vRet(n);\\n        vector<int> vTable(n, 0);\\n        UnionFind *uf = new UnionFind(n);\\n        for(int i=n-1; i>=1; i--)\\n        {\\n            int iRemoveIdx = removeQueries[i];\\n            vTable[iRemoveIdx] = nums[iRemoveIdx];\\n            uf->add(iRemoveIdx, nums[iRemoveIdx]);\\n            if(iRemoveIdx-1 >=0 && vTable[iRemoveIdx-1] >0) uf->Union(iRemoveIdx-1, iRemoveIdx);\\n            if(iRemoveIdx+1 <n && vTable[iRemoveIdx+1] >0) uf->Union(iRemoveIdx+1, iRemoveIdx);\\n            vRet[i-1] = uf->MaxSum;\\n\\n        }\\n \\n        return vRet;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3979158,
                "title": "rust-two-ordered-sets",
                "content": "# Intuition\\n\\nUse ordered sets to keep track of each segment.\\n\\nNote that this is the \"online\" approach. Since all queries are given ahead of time, an \"offline\" approach is also possible and might be faster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\npub fn to_pref_vec(vec: Vec<u32>) -> Vec<u64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n    let mut pref_sum = u64::MIN;\\n    ret.push(pref_sum);\\n\\n    for e in vec {\\n        pref_sum += e as u64;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(vec: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        let vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n        let n = vec.len();\\n        let pref_vec = to_pref_vec(vec);\\n        // println!(\"pref_vec: {:?}\", pref_vec);\\n\\n        let queries = queries.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut ret = vec![];\\n\\n        let mut queries_set = BTreeSet::new();\\n        let mut segments_set = BTreeSet::new();\\n        segments_set.insert((pref_vec[n] - pref_vec[0], 0, n));\\n        for i in queries {\\n            let ptr_frnt = queries_set.range(..=i).rev().next().cloned()\\n                .map(|e| e + 1).unwrap_or(usize::MIN);\\n            let ptr_back = queries_set.range(i..).next().cloned()\\n                .unwrap_or(n);\\n\\n            let segment_sum = pref_vec[ptr_back] - pref_vec[ptr_frnt];\\n            segments_set.remove(&(segment_sum, ptr_frnt, ptr_back));\\n\\n            if ptr_frnt < i {\\n                let segment_sum = pref_vec[i] - pref_vec[ptr_frnt];\\n                segments_set.insert((segment_sum, ptr_frnt, i));\\n            }\\n\\n            if i + 1 < ptr_back {\\n                let segment_sum = pref_vec[ptr_back] - pref_vec[i + 1];\\n                segments_set.insert((segment_sum, i + 1, ptr_back));\\n            }\\n\\n            queries_set.insert(i);\\n\\n            let seg_max = segments_set.iter().rev().next().cloned()\\n                .map(|(e0, _, _)| e0)\\n                .unwrap_or(u64::MIN);\\n            ret.push(seg_max);\\n\\n            // println!(\"segments: {:?}\", segments_set);\\n            // println!(\"queries: {:?}\", queries_set);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```rust\\npub fn to_pref_vec(vec: Vec<u32>) -> Vec<u64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n    let mut pref_sum = u64::MIN;\\n    ret.push(pref_sum);\\n\\n    for e in vec {\\n        pref_sum += e as u64;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(vec: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        let vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n        let n = vec.len();\\n        let pref_vec = to_pref_vec(vec);\\n        // println!(\"pref_vec: {:?}\", pref_vec);\\n\\n        let queries = queries.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut ret = vec![];\\n\\n        let mut queries_set = BTreeSet::new();\\n        let mut segments_set = BTreeSet::new();\\n        segments_set.insert((pref_vec[n] - pref_vec[0], 0, n));\\n        for i in queries {\\n            let ptr_frnt = queries_set.range(..=i).rev().next().cloned()\\n                .map(|e| e + 1).unwrap_or(usize::MIN);\\n            let ptr_back = queries_set.range(i..).next().cloned()\\n                .unwrap_or(n);\\n\\n            let segment_sum = pref_vec[ptr_back] - pref_vec[ptr_frnt];\\n            segments_set.remove(&(segment_sum, ptr_frnt, ptr_back));\\n\\n            if ptr_frnt < i {\\n                let segment_sum = pref_vec[i] - pref_vec[ptr_frnt];\\n                segments_set.insert((segment_sum, ptr_frnt, i));\\n            }\\n\\n            if i + 1 < ptr_back {\\n                let segment_sum = pref_vec[ptr_back] - pref_vec[i + 1];\\n                segments_set.insert((segment_sum, i + 1, ptr_back));\\n            }\\n\\n            queries_set.insert(i);\\n\\n            let seg_max = segments_set.iter().rev().next().cloned()\\n                .map(|(e0, _, _)| e0)\\n                .unwrap_or(u64::MIN);\\n            ret.push(seg_max);\\n\\n            // println!(\"segments: {:?}\", segments_set);\\n            // println!(\"queries: {:?}\", queries_set);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971027,
                "title": "c-python-union-find-solution-with-explanation",
                "content": "we can do query backward, which means add a number to nums.\\n\\nAnd use union find to record group sum.\\n\\ntc is O(n), sc is O(n).\\n### python\\n```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.sum = [0] * size\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.sum[pp] += self.sum[pq]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        size = len(nums)\\n        seen = [False] * size\\n        dsu = DSU(size)\\n        ans = [0] * size\\n        for i in range(size - 1, 0, -1):\\n            idx = removeQueries[i]\\n            dsu.sum[idx] = nums[idx]\\n            seen[idx] = True\\n            if idx + 1 < size and seen[idx+1]:\\n                dsu.join(idx, idx+1)\\n            if idx - 1 >= 0 and seen[idx-1]:\\n                dsu.join(idx, idx-1)\\n            cur = dsu.sum[dsu.find(idx)]\\n            ans[i-1] = cur if cur > ans[i] else ans[i]\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<long long> sum;\\n    DSU (int size): parent(size), sum(size) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> sum[pp] += this -> sum[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int size = nums.size();\\n        DSU dsu (size);\\n        vector<long long> ans (size);\\n        vector<bool> seen (size);\\n        for (int i = size-1; i > 0; i-=1) {\\n            int &idx = removeQueries[i];\\n            dsu.sum[idx] = nums[idx];\\n            seen[idx] = true;\\n            if (idx + 1 < size && seen[idx + 1])\\n                dsu.join(idx, idx+1);\\n            if (idx - 1 >= 0 && seen[idx - 1])\\n                dsu.join(idx, idx-1);\\n            \\n            long long& cur = dsu.sum[dsu.find(idx)];\\n            ans[i-1] = cur > ans[i] ? cur: ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.sum = [0] * size\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.sum[pp] += self.sum[pq]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        size = len(nums)\\n        seen = [False] * size\\n        dsu = DSU(size)\\n        ans = [0] * size\\n        for i in range(size - 1, 0, -1):\\n            idx = removeQueries[i]\\n            dsu.sum[idx] = nums[idx]\\n            seen[idx] = True\\n            if idx + 1 < size and seen[idx+1]:\\n                dsu.join(idx, idx+1)\\n            if idx - 1 >= 0 and seen[idx-1]:\\n                dsu.join(idx, idx-1)\\n            cur = dsu.sum[dsu.find(idx)]\\n            ans[i-1] = cur if cur > ans[i] else ans[i]\\n        return ans\\n```\n```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<long long> sum;\\n    DSU (int size): parent(size), sum(size) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> sum[pp] += this -> sum[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int size = nums.size();\\n        DSU dsu (size);\\n        vector<long long> ans (size);\\n        vector<bool> seen (size);\\n        for (int i = size-1; i > 0; i-=1) {\\n            int &idx = removeQueries[i];\\n            dsu.sum[idx] = nums[idx];\\n            seen[idx] = true;\\n            if (idx + 1 < size && seen[idx + 1])\\n                dsu.join(idx, idx+1);\\n            if (idx - 1 >= 0 && seen[idx - 1])\\n                dsu.join(idx, idx-1);\\n            \\n            long long& cur = dsu.sum[dsu.find(idx)];\\n            ans[i-1] = cur > ans[i] ? cur: ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960253,
                "title": "python-ordered-set-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\n        values=SortedList()\\n        rang=SortedList()\\n        pre=[]\\n        last=0\\n        l=0\\n        for i in nums:\\n            pre.append(last+nums[l])\\n            last=pre[-1]\\n            l+=1\\n        values.add(pre[-1])\\n        rang.add((0,0,pre[-1]))\\n        rang.add((l-1,1,pre[-1]))\\n        ans=[]\\n\\n        for i in removeQueries:\\n\\n            K=bisect_right(rang,(i,0,0))\\n            nxt_gtr=rang[K]\\n\\n            if nxt_gtr[0]==i:\\n                if nxt_gtr[1]==0:\\n                    nn_gtr=rang[K+1]\\n                    if nxt_gtr[0]==nn_gtr[0]:\\n                        rang.discard(nn_gtr)\\n                        rang.discard(nxt_gtr)\\n                        values.discard(nxt_gtr[2])\\n                    else:\\n                        rang.discard(nxt_gtr)\\n                        rang.discard(nn_gtr)\\n                        values.discard(nxt_gtr[2])\\n                        rang.add((nxt_gtr[0]+1,0,nxt_gtr[2]-nums[i]))\\n                        rang.add((nn_gtr[0],1,nxt_gtr[2]-nums[i]))\\n                        values.add(nxt_gtr[2]-nums[i])\\n                elif nxt_gtr[1]==1:\\n                    pn_gtr=rang[K-1]\\n                    rang.discard(nxt_gtr)\\n                    rang.discard(pn_gtr)\\n                    values.discard(nxt_gtr[2])\\n                    rang.add((nxt_gtr[0]-1,1,nxt_gtr[2]-nums[i]))\\n                    rang.add((pn_gtr[0],0,nxt_gtr[2]-nums[i]))\\n                    values.add(nxt_gtr[2]-nums[i])\\n            else:\\n                pn_gtr=rang[K-1]\\n                rang.discard(nxt_gtr)\\n                rang.discard(pn_gtr)\\n                values.discard(nxt_gtr[2])\\n                rang.add((pn_gtr[0],0,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                rang.add((i-1,1,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                values.add(pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]])\\n                rang.add((i+1,0,pre[nxt_gtr[0]]-pre[i]))\\n                rang.add((nxt_gtr[0],1,pre[nxt_gtr[0]]-pre[i]))\\n                values.add(pre[nxt_gtr[0]]-pre[i])\\n            \\n            if not values:\\n                ans.append(0)\\n            else:\\n                ans.append(values[-1])\\n        return ans\\n\\n\\n\\n\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\n        values=SortedList()\\n        rang=SortedList()\\n        pre=[]\\n        last=0\\n        l=0\\n        for i in nums:\\n            pre.append(last+nums[l])\\n            last=pre[-1]\\n            l+=1\\n        values.add(pre[-1])\\n        rang.add((0,0,pre[-1]))\\n        rang.add((l-1,1,pre[-1]))\\n        ans=[]\\n\\n        for i in removeQueries:\\n\\n            K=bisect_right(rang,(i,0,0))\\n            nxt_gtr=rang[K]\\n\\n            if nxt_gtr[0]==i:\\n                if nxt_gtr[1]==0:\\n                    nn_gtr=rang[K+1]\\n                    if nxt_gtr[0]==nn_gtr[0]:\\n                        rang.discard(nn_gtr)\\n                        rang.discard(nxt_gtr)\\n                        values.discard(nxt_gtr[2])\\n                    else:\\n                        rang.discard(nxt_gtr)\\n                        rang.discard(nn_gtr)\\n                        values.discard(nxt_gtr[2])\\n                        rang.add((nxt_gtr[0]+1,0,nxt_gtr[2]-nums[i]))\\n                        rang.add((nn_gtr[0],1,nxt_gtr[2]-nums[i]))\\n                        values.add(nxt_gtr[2]-nums[i])\\n                elif nxt_gtr[1]==1:\\n                    pn_gtr=rang[K-1]\\n                    rang.discard(nxt_gtr)\\n                    rang.discard(pn_gtr)\\n                    values.discard(nxt_gtr[2])\\n                    rang.add((nxt_gtr[0]-1,1,nxt_gtr[2]-nums[i]))\\n                    rang.add((pn_gtr[0],0,nxt_gtr[2]-nums[i]))\\n                    values.add(nxt_gtr[2]-nums[i])\\n            else:\\n                pn_gtr=rang[K-1]\\n                rang.discard(nxt_gtr)\\n                rang.discard(pn_gtr)\\n                values.discard(nxt_gtr[2])\\n                rang.add((pn_gtr[0],0,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                rang.add((i-1,1,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                values.add(pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]])\\n                rang.add((i+1,0,pre[nxt_gtr[0]]-pre[i]))\\n                rang.add((nxt_gtr[0],1,pre[nxt_gtr[0]]-pre[i]))\\n                values.add(pre[nxt_gtr[0]]-pre[i])\\n            \\n            if not values:\\n                ans.append(0)\\n            else:\\n                ans.append(values[-1])\\n        return ans\\n\\n\\n\\n\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948236,
                "title": "javascript-reverse-union-find-377ms",
                "content": "\\n```\\n/////////////////////// Template /////////////////////////////\\nfunction DJSet(n) {\\n    let p = Array(n).fill(-1), s = Array(n).fill(0); // s: group prefix sum\\n    return { find, union, update, sum, par }\\n    function find(x) {\\n        return p[x] < 0 ? x : p[x] = find(p[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (p[x] < p[y]) [x, y] = [y, x];\\n        p[x] += p[y];\\n        p[y] = x;\\n        s[x] += s[y];\\n        return true;\\n    }\\n    function update(idx, v) {\\n        s[idx] = v;\\n        // s[idx] += v;\\n    }\\n    function sum() {\\n        return s;\\n    }\\n    function par() {\\n        return p;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nconst maximumSegmentSum = (a, b) => {\\n    let n = a.length, res = [0], ds = new DJSet(n), used = new Set(), max = 0;\\n    for (let i = n - 1; i >= 1; i--) {\\n        used.add(b[i]);\\n        ds.update(b[i], a[b[i]]);\\n        if (used.has(b[i] - 1)) ds.union(b[i], b[i] - 1);\\n        if (used.has(b[i] + 1)) ds.union(b[i], b[i] + 1);\\n        max = Math.max(max, ds.sum()[ds.find([b[i]])]);\\n        res.push(max);\\n    }\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Prefix Sum"
                ],
                "code": "```\\n/////////////////////// Template /////////////////////////////\\nfunction DJSet(n) {\\n    let p = Array(n).fill(-1), s = Array(n).fill(0); // s: group prefix sum\\n    return { find, union, update, sum, par }\\n    function find(x) {\\n        return p[x] < 0 ? x : p[x] = find(p[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (p[x] < p[y]) [x, y] = [y, x];\\n        p[x] += p[y];\\n        p[y] = x;\\n        s[x] += s[y];\\n        return true;\\n    }\\n    function update(idx, v) {\\n        s[idx] = v;\\n        // s[idx] += v;\\n    }\\n    function sum() {\\n        return s;\\n    }\\n    function par() {\\n        return p;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nconst maximumSegmentSum = (a, b) => {\\n    let n = a.length, res = [0], ds = new DJSet(n), used = new Set(), max = 0;\\n    for (let i = n - 1; i >= 1; i--) {\\n        used.add(b[i]);\\n        ds.update(b[i], a[b[i]]);\\n        if (used.has(b[i] - 1)) ds.union(b[i], b[i] - 1);\\n        if (used.has(b[i] + 1)) ds.union(b[i], b[i] + 1);\\n        max = Math.max(max, ds.sum()[ds.find([b[i]])]);\\n        res.push(max);\\n    }\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929372,
                "title": "java-ordered-set-treemap",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        \\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        TreeSet<int[]> s = new TreeSet<>((a,b) -> a[0] < b[0] ? -1 : 1);\\n        long[] ans = new long[n], prefix = new long[n];\\n        prefix[0] = (long) nums[0];\\n        for (int i = 1; i < n; i++) prefix[i] = (long) nums[i] + prefix[i - 1];\\n        s.add(new int[]{0, n - 1});\\n        map.put(prefix[n - 1], 1);\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = s.lower(new int[]{queries[i] + 1, queries[i] + 1});\\n            long res = prefix[curr[1]] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]);\\n            map.put(res, map.get(res) - 1);\\n            if (map.get(res) == 0) map.remove(res);\\n            if (curr[0] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1]] - prefix[curr[0]], map.getOrDefault(prefix[curr[1]] - prefix[curr[0]], 0) + 1);\\n                s.add(new int[]{curr[0] + 1, curr[1]});\\n            } else if (curr[1] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), map.getOrDefault(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), 0) + 1);\\n                s.add(new int[]{curr[0], curr[1] - 1});\\n            } else if (curr[0] != curr[1]) {\\n                long left = prefix[queries[i] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), right = prefix[curr[1]] - prefix[queries[i]];\\n                map.put(left, map.getOrDefault(left, 0) + 1);\\n                map.put(right, map.getOrDefault(right, 0) + 1);\\n                s.add(new int[]{curr[0], queries[i] - 1});\\n                s.add(new int[]{queries[i] + 1, curr[1]});\\n            }\\n            ans[i] = map.isEmpty() ? 0 : map.lastKey();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        \\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        TreeSet<int[]> s = new TreeSet<>((a,b) -> a[0] < b[0] ? -1 : 1);\\n        long[] ans = new long[n], prefix = new long[n];\\n        prefix[0] = (long) nums[0];\\n        for (int i = 1; i < n; i++) prefix[i] = (long) nums[i] + prefix[i - 1];\\n        s.add(new int[]{0, n - 1});\\n        map.put(prefix[n - 1], 1);\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = s.lower(new int[]{queries[i] + 1, queries[i] + 1});\\n            long res = prefix[curr[1]] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]);\\n            map.put(res, map.get(res) - 1);\\n            if (map.get(res) == 0) map.remove(res);\\n            if (curr[0] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1]] - prefix[curr[0]], map.getOrDefault(prefix[curr[1]] - prefix[curr[0]], 0) + 1);\\n                s.add(new int[]{curr[0] + 1, curr[1]});\\n            } else if (curr[1] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), map.getOrDefault(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), 0) + 1);\\n                s.add(new int[]{curr[0], curr[1] - 1});\\n            } else if (curr[0] != curr[1]) {\\n                long left = prefix[queries[i] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), right = prefix[curr[1]] - prefix[queries[i]];\\n                map.put(left, map.getOrDefault(left, 0) + 1);\\n                map.put(right, map.getOrDefault(right, 0) + 1);\\n                s.add(new int[]{curr[0], queries[i] - 1});\\n                s.add(new int[]{queries[i] + 1, curr[1]});\\n            }\\n            ans[i] = map.isEmpty() ? 0 : map.lastKey();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872270,
                "title": "striver-s-union-find-with-slight-modification-c",
                "content": "# Intuition\\ni got a intution of dsu by seeing that we have to take the sum of continuous subarrays like type of connected components but there was a issue in normal dsu we dont have the sum of the components so i thought of making a slight modification here and i aslo stored the sum of connected components \\n\\n# Approach\\nfirst make a dsu and add one more component here that is sum which will store sum of all connected components after making dsu lets come to the logic part we can see that if we traverse from back then that will be the only element left and so on like this basically from removing it get converted to type of adding from end and maintainng the ans in mx \\nnow one more thing was there since it has asked to take the sum of continous subarrays suppose i am on ith index and my (i-1th) or (i+1th) index is visited which means they are there so i need to add them as well in my sum so i need to take a union there and update the ans\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<long long> rank,par,sum;\\n    long long mx;\\n    DisjointSet(long long n){\\n        rank.resize(n+1,0);\\n        par.resize(n+1);\\n        sum.resize(n+1);\\n        for(long long i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    void unionByRank(long long a,long long b){\\n        long long upa=findUPar(a);\\n        long long upb=findUPar(b);\\n        if(upa==upb){\\n            return;\\n        }\\n        if(rank[upa]>rank[upb])\\n        {\\n            par[upb] = upa;\\n            sum[upa] += sum[upb];\\n            mx = max(mx, sum[upa]);\\n        }\\n        else if(rank[upb]>rank[upa])\\n        {\\n            par[upa] = upb;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n        else{\\n            par[upa] = upb;\\n            rank[upb] ++;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n    }\\n    long long findUPar(long long a){\\n        if(par[a]==a){\\n            return a;\\n        }\\n        return par[a]=findUPar(par[a]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        ds.mx=0;\\n        vector<long long> ans(n,0);\\n        vector<int> vis(n,0);\\n        \\n        for(int i=n-1; i>0; i--){\\n            int ind=q[i];\\n            ds.sum[ind]=nums[ind];\\n            vis[ind]=1;\\n            ds.mx=max(ds.mx,(long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1]){\\n                ds.unionByRank(ind,ind-1);\\n            }\\n            if(ind+1<n && vis[ind+1]){\\n                ds.unionByRank(ind,ind+1);\\n            }\\n            ans[i-1]=ds.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<long long> rank,par,sum;\\n    long long mx;\\n    DisjointSet(long long n){\\n        rank.resize(n+1,0);\\n        par.resize(n+1);\\n        sum.resize(n+1);\\n        for(long long i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    void unionByRank(long long a,long long b){\\n        long long upa=findUPar(a);\\n        long long upb=findUPar(b);\\n        if(upa==upb){\\n            return;\\n        }\\n        if(rank[upa]>rank[upb])\\n        {\\n            par[upb] = upa;\\n            sum[upa] += sum[upb];\\n            mx = max(mx, sum[upa]);\\n        }\\n        else if(rank[upb]>rank[upa])\\n        {\\n            par[upa] = upb;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n        else{\\n            par[upa] = upb;\\n            rank[upb] ++;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n    }\\n    long long findUPar(long long a){\\n        if(par[a]==a){\\n            return a;\\n        }\\n        return par[a]=findUPar(par[a]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        ds.mx=0;\\n        vector<long long> ans(n,0);\\n        vector<int> vis(n,0);\\n        \\n        for(int i=n-1; i>0; i--){\\n            int ind=q[i];\\n            ds.sum[ind]=nums[ind];\\n            vis[ind]=1;\\n            ds.mx=max(ds.mx,(long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1]){\\n                ds.unionByRank(ind,ind-1);\\n            }\\n            if(ind+1<n && vis[ind+1]){\\n                ds.unionByRank(ind,ind+1);\\n            }\\n            ans[i-1]=ds.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730577,
                "title": "simple-c-30-lines-code-multiset-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n  int n = nums.size();\\n  vector<long long>arr(n + 2), pref(n + 2);\\n  multiset<long long>idx, vals;\\n  arr[0] = 0;\\n  pref[0] = 0;\\n  for (int i = 1; i <= n; i++) arr[i] = nums[i - 1];\\n  arr[n + 1] = 0;\\n  for (int i = 1; i <= n + 1; i++) pref[i] = pref[i - 1] + arr[i];\\n  idx.insert(0);\\n  idx.insert(n + 1);\\n  vals.insert(pref[n + 1]);\\n  vector<long long>ans;\\n  for (auto q : removeQueries) {\\n    auto it = idx.lower_bound(q + 1);\\n    int y = *it;\\n    it--;\\n    int x = *it;\\n    if (vals.find(pref[y - 1] - pref[x]) != vals.end()) vals.erase(vals.find(pref[y - 1] - pref[x]));\\n    if (q <= x) vals.insert(0);\\n    else vals.insert(pref[q] - pref[x]);\\n    if (y - 1 <= q + 1) vals.insert(0);\\n    else vals.insert(pref[y - 1] - pref[q + 1]);\\n    ans.push_back(*(--vals.end()));\\n    idx.insert(q + 1);\\n  }\\n  return ans;\\n}\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n  int n = nums.size();\\n  vector<long long>arr(n + 2), pref(n + 2);\\n  multiset<long long>idx, vals;\\n  arr[0] = 0;\\n  pref[0] = 0;\\n  for (int i = 1; i <= n; i++) arr[i] = nums[i - 1];\\n  arr[n + 1] = 0;\\n  for (int i = 1; i <= n + 1; i++) pref[i] = pref[i - 1] + arr[i];\\n  idx.insert(0);\\n  idx.insert(n + 1);\\n  vals.insert(pref[n + 1]);\\n  vector<long long>ans;\\n  for (auto q : removeQueries) {\\n    auto it = idx.lower_bound(q + 1);\\n    int y = *it;\\n    it--;\\n    int x = *it;\\n    if (vals.find(pref[y - 1] - pref[x]) != vals.end()) vals.erase(vals.find(pref[y - 1] - pref[x]));\\n    if (q <= x) vals.insert(0);\\n    else vals.insert(pref[q] - pref[x]);\\n    if (y - 1 <= q + 1) vals.insert(0);\\n    else vals.insert(pref[y - 1] - pref[q + 1]);\\n    ans.push_back(*(--vals.end()));\\n    idx.insert(q + 1);\\n  }\\n  return ans;\\n}\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724131,
                "title": "easiest-c-solution-set-prefix-sum",
                "content": "# Intuition\\n<!-- Describe ywwour first thoughts on how to solve this problem. -->\\n\\n# Approach\\nprefix sum approach, to store all segments sum in a multiset in order to get highest value after every removal\\n\\n# Complexity\\n- Time comoplexity:\\no(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n       \\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        set<long long> s1;\\n        multiset<long long> s2;\\n        vector<long long> pre(n+1,0);\\n        pre[1]=nums[0];\\n        for(int i=1;i<n;i++) pre[i+1]=pre[i] +nums[i];\\n        // s1 contains all removed indexes\\n        // s2 contains all sum of segments\\n\\n        <!--  // we wanna continuosly evaluate our problem b/w removed indexes so we initially assumed -1 ans n to be our removed indexes -->\\n        s1.insert(-1);\\n        s1.insert(n);\\n        s2.insert(pre[n]);\\n        for(int i=0;i<n;i++){\\n            auto it1=s1.upper_bound(rq[i]);\\n            int a=*it1;\\n            if(it1!=s1.begin()) {\\n                auto it2=--it1;\\n                int b=*it2;\\n                // deleting the sum of the broken segment and replacing it with sum of new segments\\n                auto q=s2.find(pre[a]-pre[b+1]);\\n                s2.erase(q);\\n                s2.insert(pre[a]-pre[rq[i]+1]);\\n                s2.insert(pre[rq[i]]-pre[b+1]);\\n                s1.insert(rq[i]);\\n            }\\n            ans[i]=*s2.rbegin();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n       \\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        set<long long> s1;\\n        multiset<long long> s2;\\n        vector<long long> pre(n+1,0);\\n        pre[1]=nums[0];\\n        for(int i=1;i<n;i++) pre[i+1]=pre[i] +nums[i];\\n        // s1 contains all removed indexes\\n        // s2 contains all sum of segments\\n\\n        <!--  // we wanna continuosly evaluate our problem b/w removed indexes so we initially assumed -1 ans n to be our removed indexes -->\\n        s1.insert(-1);\\n        s1.insert(n);\\n        s2.insert(pre[n]);\\n        for(int i=0;i<n;i++){\\n            auto it1=s1.upper_bound(rq[i]);\\n            int a=*it1;\\n            if(it1!=s1.begin()) {\\n                auto it2=--it1;\\n                int b=*it2;\\n                // deleting the sum of the broken segment and replacing it with sum of new segments\\n                auto q=s2.find(pre[a]-pre[b+1]);\\n                s2.erase(q);\\n                s2.insert(pre[a]-pre[rq[i]+1]);\\n                s2.insert(pre[rq[i]]-pre[b+1]);\\n                s1.insert(rq[i]);\\n            }\\n            ans[i]=*s2.rbegin();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681602,
                "title": "segment-tree-explanation-from-scratch-c",
                "content": "# Intuition\\n- whenever i found questions involving key words like queries[i.e range/point queries] i try to check whether this question can be solved using fenwick tree/ segment tree.\\n\\n# Approach\\n\\nupdating a pos (= removeQueries[i]) as -inf so that we can maxsum from [0,n-1].\\n\\n1. this code is just basic template of segment tree where seg[id] gives info regarding totalsum,max_prefix,max_suffix,max_subarraysum in range [l,r].\\n3. explanation of combining of left seg[2*id], right seg[2*id+1] to parent seg[2*id+1];\\n  - max_prefix sum can be formed from max_prefix sum from left    segmenet or leftsegment totalsum+max_prefix sum of right segement.\\nsimilar approach for max_suffis sum.\\n - maxsubarray sum can be formed either from 1.left segemt 2. right segment 3. combining of both left and right segment[left.max_suffix+right.max_pref]\\n\\n# if you find this solution helpful please upvote :).\\n\\n# Code\\n```\\nstruct st{\\n    long long tot;\\n    long long max_prefix;\\n    long long max_suffix;\\n    long long max_sum;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    const long long inf = 8e13;\\n\\n    st combine(st left,st right)\\n    {\\n        st temp;\\n        temp.tot=left.tot+right.tot;\\n        temp.max_prefix=max(left.max_prefix,left.tot+right.max_prefix);\\n        temp.max_suffix=max(right.max_suffix,right.tot+left.max_suffix);\\n        temp.max_sum=max({left.max_sum,right.max_sum,left.max_suffix+right.max_prefix});\\n        return temp;\\n    }\\n\\n    void build(int id,int l,int r,vector<int> &nums,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=(long long)nums[l];\\n            seg[id].max_prefix=(long long)nums[l];\\n            seg[id].max_suffix=(long long)nums[l];\\n            seg[id].max_sum=(long long)nums[l];\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(2*id,l,mid,nums,seg);\\n        build(2*id+1,mid+1,r,nums,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    void update(int pos,int id,int l,int r,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=-inf;\\n            seg[id].max_prefix=-inf;\\n            seg[id].max_suffix=-inf;\\n            seg[id].max_sum=-inf;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<=mid)update(pos,2*id,l,mid,seg);\\n        else update(pos,2*id+1,mid+1,r,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        vector<st>seg(4*n+1);\\n        build(1,0,n-1,nums,seg);\\n        vector<long long>ans(n);\\n        cout<<seg[1].max_sum;\\n        for(int i=0;i<n;i++){\\n            int pos=removeQueries[i];\\n            update(pos,1,0,n-1,seg);\\n            ans[i]=max((long long)0,seg[1].max_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nstruct st{\\n    long long tot;\\n    long long max_prefix;\\n    long long max_suffix;\\n    long long max_sum;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    const long long inf = 8e13;\\n\\n    st combine(st left,st right)\\n    {\\n        st temp;\\n        temp.tot=left.tot+right.tot;\\n        temp.max_prefix=max(left.max_prefix,left.tot+right.max_prefix);\\n        temp.max_suffix=max(right.max_suffix,right.tot+left.max_suffix);\\n        temp.max_sum=max({left.max_sum,right.max_sum,left.max_suffix+right.max_prefix});\\n        return temp;\\n    }\\n\\n    void build(int id,int l,int r,vector<int> &nums,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=(long long)nums[l];\\n            seg[id].max_prefix=(long long)nums[l];\\n            seg[id].max_suffix=(long long)nums[l];\\n            seg[id].max_sum=(long long)nums[l];\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(2*id,l,mid,nums,seg);\\n        build(2*id+1,mid+1,r,nums,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    void update(int pos,int id,int l,int r,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=-inf;\\n            seg[id].max_prefix=-inf;\\n            seg[id].max_suffix=-inf;\\n            seg[id].max_sum=-inf;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<=mid)update(pos,2*id,l,mid,seg);\\n        else update(pos,2*id+1,mid+1,r,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        vector<st>seg(4*n+1);\\n        build(1,0,n-1,nums,seg);\\n        vector<long long>ans(n);\\n        cout<<seg[1].max_sum;\\n        for(int i=0;i<n;i++){\\n            int pos=removeQueries[i];\\n            update(pos,1,0,n-1,seg);\\n            ans[i]=max((long long)0,seg[1].max_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664622,
                "title": "c-union-find-modify-the-uf-class",
                "content": "# Code\\n```\\nclass UF{\\n    public:\\n    // In UF class, a group is a continuous segment\\n    // add an additional map to store the sum of that segment\\n    unordered_map<long long, long long> parent, rank, sum;\\n    long long mx;\\n    long long find (int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        long a = find(x), b = find(y);\\n        if(rank[a]>rank[b])\\n        {\\n            parent[b] = a;\\n            sum[a] += sum[b];\\n            mx = max(mx, sum[a]);\\n        }\\n        else if(rank[b]>rank[a])\\n        {\\n            parent[a] = b;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n        else{\\n            parent[a] = b;\\n            rank[b] ++;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        UF u;\\n        u.mx = 0;\\n        vector<long long> ans(q.size(), 0);\\n        vector<bool> vis(q.size(), false);\\n        // Start from the end\\n        // Assume that there are no elements available, \\n        //then start adding them one by one and perform Union\\n        for(int i=q.size()-1; i>0; i--)\\n        {\\n            int ind =q[i];\\n            u.parent[ind] = ind;\\n            u.sum[ind] = nums[ind];\\n            vis[ind] = 1;\\n            u.mx = max(u.mx, (long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1])\\n                u.merge(ind, ind-1);\\n            if(ind+1<nums.size() && vis[ind+1])\\n                u.merge(ind, ind+1);\\n            ans[i-1] = u.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass UF{\\n    public:\\n    // In UF class, a group is a continuous segment\\n    // add an additional map to store the sum of that segment\\n    unordered_map<long long, long long> parent, rank, sum;\\n    long long mx;\\n    long long find (int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        long a = find(x), b = find(y);\\n        if(rank[a]>rank[b])\\n        {\\n            parent[b] = a;\\n            sum[a] += sum[b];\\n            mx = max(mx, sum[a]);\\n        }\\n        else if(rank[b]>rank[a])\\n        {\\n            parent[a] = b;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n        else{\\n            parent[a] = b;\\n            rank[b] ++;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        UF u;\\n        u.mx = 0;\\n        vector<long long> ans(q.size(), 0);\\n        vector<bool> vis(q.size(), false);\\n        // Start from the end\\n        // Assume that there are no elements available, \\n        //then start adding them one by one and perform Union\\n        for(int i=q.size()-1; i>0; i--)\\n        {\\n            int ind =q[i];\\n            u.parent[ind] = ind;\\n            u.sum[ind] = nums[ind];\\n            vis[ind] = 1;\\n            u.mx = max(u.mx, (long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1])\\n                u.merge(ind, ind-1);\\n            if(ind+1<nums.size() && vis[ind+1])\\n                u.merge(ind, ind+1);\\n            ans[i-1] = u.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544814,
                "title": "python-union-find-think-backward-insert-from-the-last-removal-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        parent = [i for i in range(len(nums))]\\n        size = [n for n in nums]\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n                \\n            return parent[x]\\n        \\n        def union(x, y):\\n            u, v = find(x), find(y)\\n            if u != v:\\n                parent[u] = v\\n                size[v] += size[u]\\n                size[u] = 0\\n            \\n            \\n        ans = [0] * len(nums)\\n        temp = [0] * len(nums)\\n        for i in range(len(removeQueries) - 2, -1, -1):\\n            n = removeQueries[i + 1]\\n            temp[n] = nums[n]\\n            if n - 1 >= 0 and temp[n - 1] > 0:\\n                union(n - 1, n)\\n                \\n            if n + 1 < len(nums) and temp[n + 1] > 0:\\n                union(n, n + 1)\\n                \\n            ans[i] = max(ans[i + 1], size[find(n)])\\n        \\n        return ans\\n            \\n            \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        parent = [i for i in range(len(nums))]\\n        size = [n for n in nums]\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n                \\n            return parent[x]\\n        \\n        def union(x, y):\\n            u, v = find(x), find(y)\\n            if u != v:\\n                parent[u] = v\\n                size[v] += size[u]\\n                size[u] = 0\\n            \\n            \\n        ans = [0] * len(nums)\\n        temp = [0] * len(nums)\\n        for i in range(len(removeQueries) - 2, -1, -1):\\n            n = removeQueries[i + 1]\\n            temp[n] = nums[n]\\n            if n - 1 >= 0 and temp[n - 1] > 0:\\n                union(n - 1, n)\\n                \\n            if n + 1 < len(nums) and temp[n + 1] > 0:\\n                union(n, n + 1)\\n                \\n            ans[i] = max(ans[i + 1], size[find(n)])\\n        \\n        return ans\\n            \\n            \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526347,
                "title": "set-map-prefix-sum",
                "content": "# Intuition\\nEvery remove one element, remove the interval of it. And may add two intervals [left,k-1],[k+1,right]. \\none map store<sum of interval, numbers of sum>, one map store <left index,sum of interval>. That is to erase sum of interval according it\\'s left index, and get max sum of interval in O(1).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approachs\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class segement\\n    {\\n        public:\\n        set<pair<int,int>> intervals; // [left,right]\\n        map<long long,int> sum; // <sum,times>\\n        map<int, long long> lefts; // <left,sum>\\n        \\n        const int INF=1e9+1;\\n        segement(vector<long long>& presum)\\n        {            \\n            long long sum1=presum[presum.size()-1];\\n            intervals.insert({0,presum.size()-2});\\n            sum[sum1]++;\\n            lefts[0]=sum1;\\n        }\\n        void remove(vector<long long>& presum,int n)\\n        {\\n            if (intervals.empty())\\n                return;\\n            auto it=intervals.upper_bound({n,INF});\\n            if (it!=intervals.begin())\\n            {\\n                --it;\\n            }\\n            int left=it->first, right=it->second;\\n            intervals.erase(it);\\n            long long cursum=lefts[left]; \\n            lefts.erase(lefts.find(left));\\n            if (--sum[cursum]==0)\\n                sum.erase(cursum);\\n\\n            long long sum1, sum2;\\n            if (n>left)\\n            {\\n                int left1=left, right1=n-1;\\n                intervals.insert({left1,right1});\\n                sum1=presum[right1+1]-presum[left1];\\n                sum[sum1]++;\\n                lefts[left1]=sum1;   \\n            }\\n            if (n<right)\\n            {\\n                int left2=n+1, right2=right;\\n                intervals.insert({left2,right2});\\n                sum2=presum[right2+1]-presum[left2];\\n                sum[sum2]++;                 \\n                lefts[left2]=sum2;             \\n            }  \\n        }\\n        long long get() // return sum must be long long\\n        {\\n            if (sum.empty())\\n                return 0;\\n            return sum.rbegin()->first;\\n        }\\n    };\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=removeQueries.size();\\n        vector<long long> presum(n+1);        \\n        for (int i=0; i<nums.size(); i++)\\n        {\\n            presum[i+1]=presum[i]+nums[i];\\n        }\\n        vector<long long> res(n);\\n        segement s(presum);\\n        for (int i=0; i<n; i++)\\n        {\\n            int k=removeQueries[i];\\n            s.remove(presum,k);\\n            res[i]=s.get();\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    class segement\\n    {\\n        public:\\n        set<pair<int,int>> intervals; // [left,right]\\n        map<long long,int> sum; // <sum,times>\\n        map<int, long long> lefts; // <left,sum>\\n        \\n        const int INF=1e9+1;\\n        segement(vector<long long>& presum)\\n        {            \\n            long long sum1=presum[presum.size()-1];\\n            intervals.insert({0,presum.size()-2}",
                "codeTag": "Java"
            },
            {
                "id": 3450247,
                "title": "c-reverse-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjoint_set{\\n    int n;\\n    public:\\n    long long maxi=0;\\n    int* par;\\n    long long* sum;\\n    disjoint_set(int N){\\n        n=N;\\n        par=new int[n];\\n        sum=new long long[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=-1;\\n            sum[i]=0;\\n        }\\n    }\\n    int find(int i){\\n        if(par[i]<0){\\n            return i;\\n        }\\n        int res=find(par[i]);\\n        par[i]=res;\\n        return res;\\n    }\\n    bool Union(int i,int j){\\n        int i_rep=find(i);\\n        int j_rep=find(j);\\n        par[i_rep]+=par[j_rep];\\n        sum[i_rep]+=sum[j_rep];\\n        par[j_rep]=i_rep;\\n        return 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        disjoint_set* obj=new disjoint_set(n); \\n        for(int i=n-1;i>0;i--){\\n            ans[i]=obj->maxi;\\n            int sum=nums[q[i]];\\n            if(q[i]>0){\\n                int x=obj->find(q[i]-1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]-1,q[i]);\\n                }\\n            }\\n            if(q[i]<n-1){\\n                int x=obj->find(q[i]+1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]+1,q[i]);\\n                }\\n            }\\n            int i_rep=obj->find(q[i]);\\n            obj->sum[i_rep]+=sum;\\n            obj->maxi=max(obj->maxi,obj->sum[i_rep]);\\n        }\\n        ans[0]=obj->maxi;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjoint_set{\\n    int n;\\n    public:\\n    long long maxi=0;\\n    int* par;\\n    long long* sum;\\n    disjoint_set(int N){\\n        n=N;\\n        par=new int[n];\\n        sum=new long long[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=-1;\\n            sum[i]=0;\\n        }\\n    }\\n    int find(int i){\\n        if(par[i]<0){\\n            return i;\\n        }\\n        int res=find(par[i]);\\n        par[i]=res;\\n        return res;\\n    }\\n    bool Union(int i,int j){\\n        int i_rep=find(i);\\n        int j_rep=find(j);\\n        par[i_rep]+=par[j_rep];\\n        sum[i_rep]+=sum[j_rep];\\n        par[j_rep]=i_rep;\\n        return 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        disjoint_set* obj=new disjoint_set(n); \\n        for(int i=n-1;i>0;i--){\\n            ans[i]=obj->maxi;\\n            int sum=nums[q[i]];\\n            if(q[i]>0){\\n                int x=obj->find(q[i]-1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]-1,q[i]);\\n                }\\n            }\\n            if(q[i]<n-1){\\n                int x=obj->find(q[i]+1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]+1,q[i]);\\n                }\\n            }\\n            int i_rep=obj->find(q[i]);\\n            obj->sum[i_rep]+=sum;\\n            obj->maxi=max(obj->maxi,obj->sum[i_rep]);\\n        }\\n        ans[0]=obj->maxi;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435847,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n = len(nums)\\n\\n        dict1, ans = defaultdict(int), [0]*n\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n                ans[a] += ans[b]\\n\\n        result = [0]*n\\n\\n        for i in range(n-1,-1,-1):\\n            idx = removeQueries[i]\\n            ans[idx] = nums[idx]\\n\\n            if idx>0 and ans[idx-1]:\\n                union(idx,idx-1)\\n\\n            if idx<n-1 and ans[idx+1]:\\n                union(idx,idx+1)\\n\\n            if i>0:\\n                result[i-1] = max(result[i],ans[find(idx)])\\n\\n        return result\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n = len(nums)\\n\\n        dict1, ans = defaultdict(int), [0]*n\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n                ans[a] += ans[b]\\n\\n        result = [0]*n\\n\\n        for i in range(n-1,-1,-1):\\n            idx = removeQueries[i]\\n            ans[idx] = nums[idx]\\n\\n            if idx>0 and ans[idx-1]:\\n                union(idx,idx-1)\\n\\n            if idx<n-1 and ans[idx+1]:\\n                union(idx,idx+1)\\n\\n            if i>0:\\n                result[i-1] = max(result[i],ans[find(idx)])\\n\\n        return result\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327209,
                "title": "c-unionfind",
                "content": "```\\npublic class Solution {\\n    int[] parent;\\n    long[] size;\\n    long maxsize=0;\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=removeQueries.Length;\\n        parent=Enumerable.Range(0,n).ToArray();\\n        size= new long[n];\\n        \\n        long[] res =new long[n];\\n        \\n        for(int i=n-1;i>0;i--)\\n        {\\n            int j=removeQueries[i];\\n            size[j]=nums[j];\\n            \\n            if(j<n-1 && size[j+1]>0)\\n                union(j,j+1);\\n            \\n            if(j>0 && size[j-1]>0)\\n                union(j,j-1);\\n            maxsize=Math.Max(nums[j],maxsize);  \\n            res[i-1]=maxsize;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int find(int i)\\n    {\\n        if(parent[i]!=i)\\n            parent[i]=find(parent[i]);\\n        return parent[i];\\n    }\\n    \\n    void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(i==j)\\n            return;\\n        \\n        parent[pi]=parent[pj];\\n        size[pj]+=size[pi];\\n        \\n        maxsize=Math.Max(maxsize,size[pj]);\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    int[] parent;\\n    long[] size;\\n    long maxsize=0;\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=removeQueries.Length;\\n        parent=Enumerable.Range(0,n).ToArray();\\n        size= new long[n];\\n        \\n        long[] res =new long[n];\\n        \\n        for(int i=n-1;i>0;i--)\\n        {\\n            int j=removeQueries[i];\\n            size[j]=nums[j];\\n            \\n            if(j<n-1 && size[j+1]>0)\\n                union(j,j+1);\\n            \\n            if(j>0 && size[j-1]>0)\\n                union(j,j-1);\\n            maxsize=Math.Max(nums[j],maxsize);  \\n            res[i-1]=maxsize;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int find(int i)\\n    {\\n        if(parent[i]!=i)\\n            parent[i]=find(parent[i]);\\n        return parent[i];\\n    }\\n    \\n    void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(i==j)\\n            return;\\n        \\n        parent[pi]=parent[pj];\\n        size[pj]+=size[pi];\\n        \\n        maxsize=Math.Max(maxsize,size[pj]);\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114212,
                "title": "c-binarysearch-prefixsum-priorityqueue-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first there will be only 1 interval [0,n-1] and we can using PrefixSum approach to get sum of range [i,j] in O(1).\\n\\nEvery remove operation equal to get the correct interval , then split it to at most 2 new sub intervals.\\n\\nHow to get max value of all valid intervals in list?\\nWe can using PriorityQueue as max heap.\\n\\nBut there must be some out-of-date max values, we need a hashMap to ignore them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Design a List<int[]> to hold all valid intervals.\\n- Create a prefixSum long[ ] to cache sum of range [0,i]\\n- Using binary search to find the interval contain removeQueries[i]\\n- Using PriorityQueue as maxheap to get max sum of all intervals\\n- Create a Dictionary<long,int> as {maxValue, frequencies}, to avoid invalid max value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n         public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n        {\\n            int n = nums.Length;\\n            long[] res = new long[n];\\n            //list to store all intervals, sorted\\n            List<int[]> list =new List<int[]>() { new int[] { 0, n-1 } };\\n            long[] prefixSum = new long[n];//create prefixSum array\\n            long sum = 0;\\n            for(int i = 0; i<n; i++)\\n            {\\n                sum+= nums[i];\\n                prefixSum[i]= sum;\\n            }\\n            //max heap\\n            PriorityQueue<long, long> pq = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) =>\\n            {\\n                if (x>y) return -1;\\n                else if (x<y) return 1;\\n                else return 0;\\n            }));\\n\\n            //{maxValue, frequencies} pairs\\n            Dictionary<long, int> dict = new Dictionary<long, int>();\\n            dict.Add(sum,1);//if dict[k]==0, this k is invalid\\n\\n            pq.Enqueue(sum, sum);\\n\\n            int index = 0;\\n            while (index<n)\\n            {\\n                int left = 0;\\n                int right = list.Count-1;\\n                //using binary search to get correct interval\\n                while (left<right)\\n                {\\n                    int mid = (left+right)/2;\\n                    int[] curr = list[mid];\\n                    if (curr[1]<removeQueries[index])\\n                    {\\n                        left = mid+1;\\n                    }\\n                    else if (list[mid][0]>removeQueries[index])\\n                    {\\n                        right = mid;\\n                    }\\n                    else\\n                    {\\n                        left=mid;\\n                        break;\\n                    }\\n                }\\n\\n                int[] toDelete = list[left];//split this interval\\n                list.RemoveAt(left);//remove from list\\n                long total = prefixSum[toDelete[1]];\\n                if(toDelete[0]>0)\\n                    total-=prefixSum[toDelete[0]-1];\\n\\n                dict[total]--;//subtract freq\\n                //after split , right sub is valid\\n                if (toDelete[1] > removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { removeQueries[index]+1, toDelete[1] });\\n                    long sub = prefixSum[toDelete[1]]- prefixSum[removeQueries[index]];\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;//update dict\\n                    pq.Enqueue(sub, sub);\\n                }\\n                //left sub is valid\\n                if (toDelete[0] < removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { toDelete[0],removeQueries[index]-1 });\\n                    long sub = prefixSum[removeQueries[index]-1];\\n                    if (toDelete[0]>0)\\n                        sub-= prefixSum[toDelete[0]-1];\\n\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;\\n                    pq.Enqueue(sub, sub);\\n                }\\n\\n                long max = 0;\\n                while (pq.Count>0)\\n                {\\n                    long top = pq.Peek();\\n                    //if currect max is valid\\n                    if (dict.ContainsKey(top)&&dict[top]>0)\\n                    {\\n                        max=top;\\n                        break;\\n                    }\\n                    else pq.Dequeue();//discard invalid\\n                }\\n                res[index++] = max;\\n            }\\n\\n            return res;\\n        }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n         public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n        {\\n            int n = nums.Length;\\n            long[] res = new long[n];\\n            //list to store all intervals, sorted\\n            List<int[]> list =new List<int[]>() { new int[] { 0, n-1 } };\\n            long[] prefixSum = new long[n];//create prefixSum array\\n            long sum = 0;\\n            for(int i = 0; i<n; i++)\\n            {\\n                sum+= nums[i];\\n                prefixSum[i]= sum;\\n            }\\n            //max heap\\n            PriorityQueue<long, long> pq = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) =>\\n            {\\n                if (x>y) return -1;\\n                else if (x<y) return 1;\\n                else return 0;\\n            }));\\n\\n            //{maxValue, frequencies} pairs\\n            Dictionary<long, int> dict = new Dictionary<long, int>();\\n            dict.Add(sum,1);//if dict[k]==0, this k is invalid\\n\\n            pq.Enqueue(sum, sum);\\n\\n            int index = 0;\\n            while (index<n)\\n            {\\n                int left = 0;\\n                int right = list.Count-1;\\n                //using binary search to get correct interval\\n                while (left<right)\\n                {\\n                    int mid = (left+right)/2;\\n                    int[] curr = list[mid];\\n                    if (curr[1]<removeQueries[index])\\n                    {\\n                        left = mid+1;\\n                    }\\n                    else if (list[mid][0]>removeQueries[index])\\n                    {\\n                        right = mid;\\n                    }\\n                    else\\n                    {\\n                        left=mid;\\n                        break;\\n                    }\\n                }\\n\\n                int[] toDelete = list[left];//split this interval\\n                list.RemoveAt(left);//remove from list\\n                long total = prefixSum[toDelete[1]];\\n                if(toDelete[0]>0)\\n                    total-=prefixSum[toDelete[0]-1];\\n\\n                dict[total]--;//subtract freq\\n                //after split , right sub is valid\\n                if (toDelete[1] > removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { removeQueries[index]+1, toDelete[1] });\\n                    long sub = prefixSum[toDelete[1]]- prefixSum[removeQueries[index]];\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;//update dict\\n                    pq.Enqueue(sub, sub);\\n                }\\n                //left sub is valid\\n                if (toDelete[0] < removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { toDelete[0],removeQueries[index]-1 });\\n                    long sub = prefixSum[removeQueries[index]-1];\\n                    if (toDelete[0]>0)\\n                        sub-= prefixSum[toDelete[0]-1];\\n\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;\\n                    pq.Enqueue(sub, sub);\\n                }\\n\\n                long max = 0;\\n                while (pq.Count>0)\\n                {\\n                    long top = pq.Peek();\\n                    //if currect max is valid\\n                    if (dict.ContainsKey(top)&&dict[top]>0)\\n                    {\\n                        max=top;\\n                        break;\\n                    }\\n                    else pq.Dequeue();//discard invalid\\n                }\\n                res[index++] = max;\\n            }\\n\\n            return res;\\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079273,
                "title": "golang-union-find-and-process-in-reverse",
                "content": "```go\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  // We process in reverse and union segments together as we add elements.\\n  // We keep track of the maximum segment Sum and every time we add an element\\n  // (since we process in reverse, we add instead of removing) we try to add it \\n  // to a new segment or create an existing segment, or merge two existing segments.\\n  // We update the max segment sum as we do that.\\n  n := len(nums)\\n  root := make([]int, n)\\n  rank := make([]int, n)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  groupSum := make([]int64, n)\\n  grouped := make([]bool, n)\\n  res := make([]int64, n)\\n  var maxSeen int64\\n  for i := n-1; i >= 0; i-- {\\n    res[i] = maxSeen // the value at n-1 is always 0\\n    q := removeQueries[i]\\n    var leftSum, rightSum int64\\n    if q > 0 && grouped[q-1] {\\n      leftSum = groupSum[find(root, q-1)]\\n      union(root, rank, q, q-1)\\n    }\\n    if q < n-1 && grouped[q+1] {\\n      rightSum = groupSum[find(root, q+1)]\\n      union(root, rank, q, q+1)\\n    }\\n    sum := leftSum + rightSum + int64(nums[q])\\n    maxSeen = max(maxSeen, sum)\\n    groupSum[find(root, q)] = sum\\n    grouped[q] = true\\n  }\\n  return res\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```go\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  // We process in reverse and union segments together as we add elements.\\n  // We keep track of the maximum segment Sum and every time we add an element\\n  // (since we process in reverse, we add instead of removing) we try to add it \\n  // to a new segment or create an existing segment, or merge two existing segments.\\n  // We update the max segment sum as we do that.\\n  n := len(nums)\\n  root := make([]int, n)\\n  rank := make([]int, n)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  groupSum := make([]int64, n)\\n  grouped := make([]bool, n)\\n  res := make([]int64, n)\\n  var maxSeen int64\\n  for i := n-1; i >= 0; i-- {\\n    res[i] = maxSeen // the value at n-1 is always 0\\n    q := removeQueries[i]\\n    var leftSum, rightSum int64\\n    if q > 0 && grouped[q-1] {\\n      leftSum = groupSum[find(root, q-1)]\\n      union(root, rank, q, q-1)\\n    }\\n    if q < n-1 && grouped[q+1] {\\n      rightSum = groupSum[find(root, q+1)]\\n      union(root, rank, q, q+1)\\n    }\\n    sum := leftSum + rightSum + int64(nums[q])\\n    maxSeen = max(maxSeen, sum)\\n    groupSum[find(root, q)] = sum\\n    grouped[q] = true\\n  }\\n  return res\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941027,
                "title": "golang-union-find-reverse",
                "content": "```\\nfunc maximumSegmentSum(nums []int, rq []int) []int64 {\\n\\tn := len(nums)\\n\\tuf := new(UF)\\n\\tuf.r = make([]int, n)\\n\\tuf.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uf.p[i] = i }\\n\\tres := make([]int64, len(rq))\\n\\tfor i := len(rq) - 1; i >= 0; i-- {\\n\\t\\tres[i] = int64(uf.mx)\\n        uf.SetR(rq[i], nums[rq[i]])\\n\\t\\tfor ni := rq[i] + 1; ni < n; ni++ {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni-1) {\\n\\t\\t\\t\\tuf.Union(ni, ni-1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor ni := rq[i] - 1; ni >= 0; ni-- {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni+1) {\\n\\t\\t\\t\\tuf.Union(ni, ni+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n\\tmx   int\\n}\\n\\nfunc (uf *UF) SetR(e, v int) {\\n    uf.r[e] = v\\n    if uf.r[e] > uf.mx { uf.mx = uf.r[e] }\\n}\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e {\\n\\t\\treturn e\\n\\t}\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 {\\n\\t\\treturn\\n\\t}\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]:\\n\\t\\tuf.p[r1] = r2\\n\\t\\tuf.r[r2] += uf.r[r1]\\n\\t\\tif uf.r[r2] > uf.mx { uf.mx = uf.r[r2] }\\n\\tcase uf.r[r1] >= uf.r[r2]:\\n\\t\\tuf.p[r2] = r1\\n\\t\\tuf.r[r1] += uf.r[r2]\\n\\t\\tif uf.r[r1] > uf.mx { uf.mx = uf.r[r1] }\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumSegmentSum(nums []int, rq []int) []int64 {\\n\\tn := len(nums)\\n\\tuf := new(UF)\\n\\tuf.r = make([]int, n)\\n\\tuf.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uf.p[i] = i }\\n\\tres := make([]int64, len(rq))\\n\\tfor i := len(rq) - 1; i >= 0; i-- {\\n\\t\\tres[i] = int64(uf.mx)\\n        uf.SetR(rq[i], nums[rq[i]])\\n\\t\\tfor ni := rq[i] + 1; ni < n; ni++ {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni-1) {\\n\\t\\t\\t\\tuf.Union(ni, ni-1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor ni := rq[i] - 1; ni >= 0; ni-- {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni+1) {\\n\\t\\t\\t\\tuf.Union(ni, ni+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n\\tmx   int\\n}\\n\\nfunc (uf *UF) SetR(e, v int) {\\n    uf.r[e] = v\\n    if uf.r[e] > uf.mx { uf.mx = uf.r[e] }\\n}\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e {\\n\\t\\treturn e\\n\\t}\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 {\\n\\t\\treturn\\n\\t}\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]:\\n\\t\\tuf.p[r1] = r2\\n\\t\\tuf.r[r2] += uf.r[r1]\\n\\t\\tif uf.r[r2] > uf.mx { uf.mx = uf.r[r2] }\\n\\tcase uf.r[r1] >= uf.r[r2]:\\n\\t\\tuf.p[r2] = r1\\n\\t\\tuf.r[r1] += uf.r[r2]\\n\\t\\tif uf.r[r1] > uf.mx { uf.mx = uf.r[r1] }\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886056,
                "title": "union-find-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUnion Find\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2 * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int parent[100005];\\n    long long value[100005];\\n\\n    int find(int i) {\\n        if(i == parent[i]) {\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n    void unite(int i, long long& maximum, vector<int>& A) {\\n        int n = A.size();\\n        bool ok = true;\\n        value[i] = A[i];\\n        if(i + 1 < n) {\\n            int P = find(i + 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        if(i - 1 >= 0) {\\n            int P = find(i - 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        maximum = max(maximum, value[find(i)]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& A, vector<int>& Q) {\\n        int n = A.size();\\n        reverse(Q.begin(), Q.end());\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            value[i] = 0;\\n        }\\n        long long maximum = 0;\\n        vector<long long> ans(n);\\n        for(int i = 0; i + 1 < n; i++) {\\n            unite(Q[i], maximum, A);\\n            ans[i + 1] = maximum;  \\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[100005];\\n    long long value[100005];\\n\\n    int find(int i) {\\n        if(i == parent[i]) {\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n    void unite(int i, long long& maximum, vector<int>& A) {\\n        int n = A.size();\\n        bool ok = true;\\n        value[i] = A[i];\\n        if(i + 1 < n) {\\n            int P = find(i + 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        if(i - 1 >= 0) {\\n            int P = find(i - 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        maximum = max(maximum, value[find(i)]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& A, vector<int>& Q) {\\n        int n = A.size();\\n        reverse(Q.begin(), Q.end());\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            value[i] = 0;\\n        }\\n        long long maximum = 0;\\n        vector<long long> ans(n);\\n        for(int i = 0; i + 1 < n; i++) {\\n            unite(Q[i], maximum, A);\\n            ans[i + 1] = maximum;  \\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849616,
                "title": "using-sets-and-prefix-sum-array-o-nlogn",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& a, vector<int>& q) {\\n        ll n=a.size();\\n        multiset<ll> st;\\n        \\n        vector<ll> p(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            p[i]=a[i-1]+p[i-1];\\n        \\n        st.insert(p[n]);\\n        set<ll> indl,indr;\\n        indl.insert(0);\\n        indr.insert(n+1);\\n        \\n        vector<ll> ans(n,0);\\n        \\n        for(ll i=0;i<q.size();i++){\\n            auto itl=indl.lower_bound(-q[i]-1);\\n            auto itr=indr.lower_bound(q[i]+1);\\n        \\n            ll lind=-(*itl),rind=*itr;\\n            ll val=p[rind-1]-p[lind];\\n            st.erase(st.find(val));\\n            \\n            ll left=p[q[i]]-p[lind];\\n            ll right=p[rind-1]-p[q[i]+1];\\n            \\n            st.insert(left);\\n            st.insert(right);\\n            \\n            indl.insert(-q[i]-1);\\n            indr.insert(q[i]+1);\\n            \\n            auto it=st.end();\\n            --it;\\n            \\n            ans[i]=*it;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& a, vector<int>& q) {\\n        ll n=a.size();\\n        multiset<ll> st;\\n        \\n        vector<ll> p(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            p[i]=a[i-1]+p[i-1];\\n        \\n        st.insert(p[n]);\\n        set<ll> indl,indr;\\n        indl.insert(0);\\n        indr.insert(n+1);\\n        \\n        vector<ll> ans(n,0);\\n        \\n        for(ll i=0;i<q.size();i++){\\n            auto itl=indl.lower_bound(-q[i]-1);\\n            auto itr=indr.lower_bound(q[i]+1);\\n        \\n            ll lind=-(*itl),rind=*itr;\\n            ll val=p[rind-1]-p[lind];\\n            st.erase(st.find(val));\\n            \\n            ll left=p[q[i]]-p[lind];\\n            ll right=p[rind-1]-p[q[i]+1];\\n            \\n            st.insert(left);\\n            st.insert(right);\\n            \\n            indl.insert(-q[i]-1);\\n            indr.insert(q[i]+1);\\n            \\n            auto it=st.end();\\n            --it;\\n            \\n            ans[i]=*it;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829868,
                "title": "python-reverse-union-find-idea-concise-code",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        self.maxSegment = 0\\n        parent = {}\\n        total = {}\\n        \\n        def find(x):\\n            if parent[x] == x: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(u,v):\\n            U,V = find(u), find(v)\\n            if U == V: return\\n            parent[V] = parent[U]\\n            total[V] += total[U]\\n            total[U] = total[V]\\n            self.maxSegment = max(self.maxSegment, total[U])\\n            \\n        def mergeSegments(u):\\n            parent[u] = u\\n            total[u] = nums[u]\\n            self.maxSegment = max(self.maxSegment, total[u])\\n            if u-1 in parent: union(u,u-1)\\n            if u+1 in parent: union(u,u+1)\\n            \\n        ans = [0]*len(nums)\\n        for i in range(len(nums)-1, -1, -1):\\n            ans[i] = self.maxSegment\\n            removed_index = removeQueries[i]\\n            mergeSegments(removed_index)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        self.maxSegment = 0\\n        parent = {}\\n        total = {}\\n        \\n        def find(x):\\n            if parent[x] == x: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(u,v):\\n            U,V = find(u), find(v)\\n            if U == V: return\\n            parent[V] = parent[U]\\n            total[V] += total[U]\\n            total[U] = total[V]\\n            self.maxSegment = max(self.maxSegment, total[U])\\n            \\n        def mergeSegments(u):\\n            parent[u] = u\\n            total[u] = nums[u]\\n            self.maxSegment = max(self.maxSegment, total[u])\\n            if u-1 in parent: union(u,u-1)\\n            if u+1 in parent: union(u,u+1)\\n            \\n        ans = [0]*len(nums)\\n        for i in range(len(nums)-1, -1, -1):\\n            ans[i] = self.maxSegment\\n            removed_index = removeQueries[i]\\n            mergeSegments(removed_index)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803134,
                "title": "o-n-solution-using-union-find",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n\\n        UnionFind ob = new UnionFind(n);\\n        long max = 0;\\n\\n        for(int i=n-1; i>0; i--) {\\n            int index = q[i];\\n            ob.sum[index] = nums[index];\\n\\n            if(index+1<n && ob.sum[index+1] != 0) {\\n                ob.union(index, index+1);\\n            }\\n            if(index-1>-1 && ob.sum[index-1] != 0) {\\n                ob.union(index, index-1);\\n            }\\n\\n            max = Math.max(max, ob.sum[index]);\\n            ans[i-1] = max;\\n        }\\n        return ans;\\n    }\\n}\\nclass UnionFind {\\n    int[] par;\\n    long[] sum;\\n    UnionFind(int n) {\\n        par = new int[n];\\n        sum = new long[n];\\n\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int x) {\\n        if(this.par[x] == x) return x;\\n        return this.par[x] = findPar(this.par[x]);\\n    }\\n    void union(int x, int y) {\\n        int a = findPar(x);\\n        int b = findPar(y);\\n\\n        par[b] = a;\\n        sum[a]+=sum[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n\\n        UnionFind ob = new UnionFind(n);\\n        long max = 0;\\n\\n        for(int i=n-1; i>0; i--) {\\n            int index = q[i];\\n            ob.sum[index] = nums[index];\\n\\n            if(index+1<n && ob.sum[index+1] != 0) {\\n                ob.union(index, index+1);\\n            }\\n            if(index-1>-1 && ob.sum[index-1] != 0) {\\n                ob.union(index, index-1);\\n            }\\n\\n            max = Math.max(max, ob.sum[index]);\\n            ans[i-1] = max;\\n        }\\n        return ans;\\n    }\\n}\\nclass UnionFind {\\n    int[] par;\\n    long[] sum;\\n    UnionFind(int n) {\\n        par = new int[n];\\n        sum = new long[n];\\n\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int x) {\\n        if(this.par[x] == x) return x;\\n        return this.par[x] = findPar(this.par[x]);\\n    }\\n    void union(int x, int y) {\\n        int a = findPar(x);\\n        int b = findPar(y);\\n\\n        par[b] = a;\\n        sum[a]+=sum[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795891,
                "title": "c-reverse-queries-with-jump-table-o-n",
                "content": "No panic!  You don\\'t need Union-Find or Segment Tree. \\n\\nThe drawback for processing `removeQueries` in normal order is you have to maintain all of the segment sums and find out what\\'s the max at the current point from them. The advantage of the reversing approach is you are adding elements back to the `num` and the maximum segment sum will be monotonic therefore you only need to record the current maximum. \\n\\nIn the meantime, you still need to maintain the valid segments when you add in elements. Two possibilities:\\n1. the new element is alone by itself\\n2. the new element is adjacent to the `end` point of the previous segment or/and the `start` point of the segment on its right hand side.\\n\\nThe second above can be maintained with a `jump` table such that `jump[start] = end ` and `jump[end]=start` where `start` and `end` are indices of the starting point and the end point of a segment. And you don\\'t need to take care of the elements in between, since `removeQueries` are all unique so that internal elements will not be exposed once again. \\n\\nLastly, the segment sum can be calculated with a prefix sum array since all the elements within it are all continuous. \\n\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        long long sum = 0; \\n        for(int val: nums){\\n            prefix.push_back(sum);\\n            sum += val;\\n        }\\n        prefix.push_back(sum);\\n         \\n        vector<long long> ans; \\n        vector<int> jumps(n,-1);\\n         \\n        long long max_seg_sum = 0;\\n        ans.push_back(0);\\n        for(int i=n-1;i>0;i--){\\n            int start = removeQueries[i], end = removeQueries[i];\\n            if(start-1>=0 && jumps[start-1]!=-1){\\n                start = jumps[start-1]; \\n            }\\n            if(end+1<n && jumps[end+1]!=-1){\\n                end = jumps[end+1];         \\n            }\\n            jumps[end] = start;\\n            jumps[start] = end;\\n            \\n            long long curr_sum = prefix[end+1] - prefix[start];\\n            if(curr_sum > max_seg_sum){\\n                max_seg_sum = curr_sum;\\n            }\\n            ans.push_back(max_seg_sum);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        long long sum = 0; \\n        for(int val: nums){\\n            prefix.push_back(sum);\\n            sum += val;\\n        }\\n        prefix.push_back(sum);\\n         \\n        vector<long long> ans; \\n        vector<int> jumps(n,-1);\\n         \\n        long long max_seg_sum = 0;\\n        ans.push_back(0);\\n        for(int i=n-1;i>0;i--){\\n            int start = removeQueries[i], end = removeQueries[i];\\n            if(start-1>=0 && jumps[start-1]!=-1){\\n                start = jumps[start-1]; \\n            }\\n            if(end+1<n && jumps[end+1]!=-1){\\n                end = jumps[end+1];         \\n            }\\n            jumps[end] = start;\\n            jumps[start] = end;\\n            \\n            long long curr_sum = prefix[end+1] - prefix[start];\\n            if(curr_sum > max_seg_sum){\\n                max_seg_sum = curr_sum;\\n            }\\n            ans.push_back(max_seg_sum);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738541,
                "title": "c-multiset-concise-o-nlogn",
                "content": "store the sum of segments in a multiset, and store the removed index in a set.\\nalso store the prefix sum\\nFor every query, say, remove index k will cause segment A is split to B and C. \\nthe boundry of A can be found be index.upper_bound()\\nso we can get the sum of A, B, C by prefix sum.\\nerease sum of A and insert of B, C into the multiset. \\nand return the largest sum in the set.\\n\\n```\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const int n = nums.size();\\n        vector<long long> res, vsum = {0};\\n        set<int> index = {-1, n};\\n        for(auto x:nums) vsum.push_back(x+vsum.back());\\n        multiset<long long, greater<>> sums = {vsum.back()};\\n        for(int k : removeQueries){\\n            auto it = index.upper_bound(k);\\n            int a = *prev(it), b = *it;\\n            auto preSum = vsum[b] - vsum[a+1];\\n            sums.erase(sums.find(preSum));\\n            index.insert(k);\\n            auto sumLeft = vsum[k] - vsum[a+1], sumRight = vsum[b] - vsum[k+1];\\n            if(sumLeft>0) sums.insert(sumLeft);\\n            if(sumRight>0) sums.insert(sumRight);\\n            res.push_back(*sums.begin());\\n        }\\n        return res;        \\n    }",
                "solutionTags": [],
                "code": "store the sum of segments in a multiset, and store the removed index in a set.\\nalso store the prefix sum\\nFor every query, say, remove index k will cause segment A is split to B and C. \\nthe boundry of A can be found be index.upper_bound()\\nso we can get the sum of A, B, C by prefix sum.\\nerease sum of A and insert of B, C into the multiset. \\nand return the largest sum in the set.\\n\\n```\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const int n = nums.size();\\n        vector<long long> res, vsum = {0};\\n        set<int> index = {-1, n};\\n        for(auto x:nums) vsum.push_back(x+vsum.back());\\n        multiset<long long, greater<>> sums = {vsum.back()};\\n        for(int k : removeQueries){\\n            auto it = index.upper_bound(k);\\n            int a = *prev(it), b = *it;\\n            auto preSum = vsum[b] - vsum[a+1];\\n            sums.erase(sums.find(preSum));\\n            index.insert(k);\\n            auto sumLeft = vsum[k] - vsum[a+1], sumRight = vsum[b] - vsum[k+1];\\n            if(sumLeft>0) sums.insert(sumLeft);\\n            if(sumRight>0) sums.insert(sumRight);\\n            res.push_back(*sums.begin());\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2713552,
                "title": "python-relatively-simple-solution",
                "content": "Runtime: 1695 ms, faster than 83.08%\\nMemory Usage: 35.8 MB, less than 95.38%\\n\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        ans, j = [0] * len(removeQueries), -1\\n        \\n        mx = 0\\n        arr = [] #segments container\\n        for idx in reversed(removeQueries):\\n            ans[j], j = mx, j - 1\\n            \\n            i = bisect_left(arr, [idx])\\n            if i > 0 and arr[i - 1][1] == idx - 1:\\n                if i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t\\t#merging the previous segment into the current segment\\n                    arr[i][0] = arr[i - 1][0]\\n                    arr[i][2] += arr[i - 1][2] + nums[idx]\\n                    if arr[i][2] > mx: mx = arr[i][2]\\n                    del arr[i - 1]\\n                else:\\n\\t\\t\\t\\t\\t#append the idx to the previous segment\\n                    arr[i - 1][1] += 1\\n                    arr[i - 1][2] += nums[idx]\\n                    if arr[i - 1][2] > mx: mx = arr[i - 1][2]\\n                    \\n            elif i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t#append the idx to the current segment\\n                arr[i][0] -= 1\\n                arr[i][2] += nums[idx]\\n                if arr[i][2] > mx: mx = arr[i][2]\\n            \\n            else:\\n\\t\\t\\t\\t#insert a new segment\\n                arr.insert(i, [idx, idx, nums[idx]]) # segment: [start point, end point, sum]\\n                if nums[idx] > mx: mx = nums[idx]\\n                \\n        return ans\\n",
                "solutionTags": [],
                "code": "Runtime: 1695 ms, faster than 83.08%\\nMemory Usage: 35.8 MB, less than 95.38%\\n\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        ans, j = [0] * len(removeQueries), -1\\n        \\n        mx = 0\\n        arr = [] #segments container\\n        for idx in reversed(removeQueries):\\n            ans[j], j = mx, j - 1\\n            \\n            i = bisect_left(arr, [idx])\\n            if i > 0 and arr[i - 1][1] == idx - 1:\\n                if i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t\\t#merging the previous segment into the current segment\\n                    arr[i][0] = arr[i - 1][0]\\n                    arr[i][2] += arr[i - 1][2] + nums[idx]\\n                    if arr[i][2] > mx: mx = arr[i][2]\\n                    del arr[i - 1]\\n                else:\\n\\t\\t\\t\\t\\t#append the idx to the previous segment\\n                    arr[i - 1][1] += 1\\n                    arr[i - 1][2] += nums[idx]\\n                    if arr[i - 1][2] > mx: mx = arr[i - 1][2]\\n                    \\n            elif i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t#append the idx to the current segment\\n                arr[i][0] -= 1\\n                arr[i][2] += nums[idx]\\n                if arr[i][2] > mx: mx = arr[i][2]\\n            \\n            else:\\n\\t\\t\\t\\t#insert a new segment\\n                arr.insert(i, [idx, idx, nums[idx]]) # segment: [start point, end point, sum]\\n                if nums[idx] > mx: mx = nums[idx]\\n                \\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2697710,
                "title": "stuck-runtime-error",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& q) {\\n        ll n = num.size();\\n            ll m = q.size();\\n            set<int> st; //removed indexes\\n            st.insert(-1);\\n            st.insert(n);\\n            vector<int> pref(n,0);\\n            pref[0] = num[0];\\n            for(ll i=1;i<n;i++)\\n            {\\n                    pref[i] = num[i] + pref[i-1];\\n            }\\n            vector<ll> ans;\\n            multiset<ll> mst; //segment sums\\n            mst.insert(pref[n-1]);\\n            for(ll i=0;i<m;i++)\\n            {\\n                    ll k = q[i];\\n                    auto prev_itr = st.lower_bound(k);\\n                    prev_itr--;\\n                    ll L = *(prev_itr);\\n                    L++;\\n                    auto next_itr = st.upper_bound(k);\\n                    ll R = *(next_itr);\\n                    R--;\\n                    \\n                    ll y;\\n                    if(L>0){ y = pref[R] - pref[L-1]; }\\n                    else{ y = pref[R]; }\\n                    \\n                    ll y1 = 0;\\n                    if(k-1>=0){ if(L>0){y1 = pref[k-1] - pref[L-1];}else{y1 = pref[k-1];} }\\n                    ll y2 = 0;\\n                    if(k < R){ y2 = pref[R] - pref[k]; }\\n                    auto it2 = mst.find(y);\\n                    if(it2 != mst.end()){ mst.erase(it2); }\\n                    mst.insert(y1);\\n                    mst.insert(y2);\\n                    auto it = mst.end(); it--;\\n                    ans.push_back(*it);\\n                    st.insert(k);\\n            }\\n            return ans;\\n    }\\n};\\n```\\nThis solution is giving runtime error. Please help me resolve that",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& q) {\\n        ll n = num.size();\\n            ll m = q.size();\\n            set<int> st; //removed indexes\\n            st.insert(-1);\\n            st.insert(n);\\n            vector<int> pref(n,0);\\n            pref[0] = num[0];\\n            for(ll i=1;i<n;i++)\\n            {\\n                    pref[i] = num[i] + pref[i-1];\\n            }\\n            vector<ll> ans;\\n            multiset<ll> mst; //segment sums\\n            mst.insert(pref[n-1]);\\n            for(ll i=0;i<m;i++)\\n            {\\n                    ll k = q[i];\\n                    auto prev_itr = st.lower_bound(k);\\n                    prev_itr--;\\n                    ll L = *(prev_itr);\\n                    L++;\\n                    auto next_itr = st.upper_bound(k);\\n                    ll R = *(next_itr);\\n                    R--;\\n                    \\n                    ll y;\\n                    if(L>0){ y = pref[R] - pref[L-1]; }\\n                    else{ y = pref[R]; }\\n                    \\n                    ll y1 = 0;\\n                    if(k-1>=0){ if(L>0){y1 = pref[k-1] - pref[L-1];}else{y1 = pref[k-1];} }\\n                    ll y2 = 0;\\n                    if(k < R){ y2 = pref[R] - pref[k]; }\\n                    auto it2 = mst.find(y);\\n                    if(it2 != mst.end()){ mst.erase(it2); }\\n                    mst.insert(y1);\\n                    mst.insert(y2);\\n                    auto it = mst.end(); it--;\\n                    ans.push_back(*it);\\n                    st.insert(k);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696103,
                "title": "c-union-find",
                "content": "```\\n#define v vector\\n#define ll long long\\n\\nclass UnionFind {\\nprivate:\\n    v<int> root;\\n    v<int> rank;\\n    v<ll> val;\\n    int size;\\n\\npublic:\\n    UnionFind(int sz) {\\n        for(int i = 0; i < sz; i++) root.push_back(i);\\n        rank.resize(sz, 1);\\n        val.resize(sz, 0);\\n        size = sz;\\n    }\\n    \\n    void init(int index, int value) {\\n        val[index] = value;\\n    }\\n    \\n    int find(int x) {\\n        if(x == root[x]) return x;\\n        return x = find(root[x]);\\n    }\\n    \\n    void set(int x, int y) {\\n        if(x < 0 || x >= size) return;\\n        if(y < 0 || y >= size) return;\\n        \\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(!val[rootX] || !val[rootY]) return;\\n        \\n        if(rank[rootX] > rank[rootY]) {\\n            root[rootY] = rootX;\\n            val[rootX] += val[rootY];\\n        } else if(rank[rootX] < rank[rootY]) {\\n            root[rootX] = rootY;\\n            val[rootY] += val[rootX];\\n        } else {\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n            val[rootX] += val[rootY];\\n        }\\n    }\\n    \\n    ll get(int x) {\\n        int rootX = find(x);\\n        return val[rootX];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    v<ll> maximumSegmentSum(v<int>& nums, v<int>& removeQueries) {\\n        int sz = nums.size();\\n        UnionFind uf(sz);\\n        v<ll> res(sz);\\n        ll maxCur = 0;\\n        \\n        for(int i = sz - 1; i >= 0; i--) {\\n            res[i] = maxCur;\\n            \\n            int query = removeQueries[i];\\n            uf.init(query, nums[query]);\\n            \\n            uf.set(query, query - 1);\\n            uf.set(query, query + 1);\\n            maxCur = max(maxCur, uf.get(query));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define v vector\\n#define ll long long\\n\\nclass UnionFind {\\nprivate:\\n    v<int> root;\\n    v<int> rank;\\n    v<ll> val;\\n    int size;\\n\\npublic:\\n    UnionFind(int sz) {\\n        for(int i = 0; i < sz; i++) root.push_back(i);\\n        rank.resize(sz, 1);\\n        val.resize(sz, 0);\\n        size = sz;\\n    }\\n    \\n    void init(int index, int value) {\\n        val[index] = value;\\n    }\\n    \\n    int find(int x) {\\n        if(x == root[x]) return x;\\n        return x = find(root[x]);\\n    }\\n    \\n    void set(int x, int y) {\\n        if(x < 0 || x >= size) return;\\n        if(y < 0 || y >= size) return;\\n        \\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(!val[rootX] || !val[rootY]) return;\\n        \\n        if(rank[rootX] > rank[rootY]) {\\n            root[rootY] = rootX;\\n            val[rootX] += val[rootY];\\n        } else if(rank[rootX] < rank[rootY]) {\\n            root[rootX] = rootY;\\n            val[rootY] += val[rootX];\\n        } else {\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n            val[rootX] += val[rootY];\\n        }\\n    }\\n    \\n    ll get(int x) {\\n        int rootX = find(x);\\n        return val[rootX];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    v<ll> maximumSegmentSum(v<int>& nums, v<int>& removeQueries) {\\n        int sz = nums.size();\\n        UnionFind uf(sz);\\n        v<ll> res(sz);\\n        ll maxCur = 0;\\n        \\n        for(int i = sz - 1; i >= 0; i--) {\\n            res[i] = maxCur;\\n            \\n            int query = removeQueries[i];\\n            uf.init(query, nums[query]);\\n            \\n            uf.set(query, query - 1);\\n            uf.set(query, query + 1);\\n            maxCur = max(maxCur, uf.get(query));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680564,
                "title": "stl-hashmap-multiset-faster-than-60",
                "content": "#define ll long long\\n\\nclass Solution\\n{\\n    \\npublic:\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq)\\n    {\\n        \\n        int n=nums.size();\\n        vector<ll> presum(n+1);\\n        for(int i=1;i<=n;i++) presum[i]=presum[i-1]+nums[i-1];\\n        \\n        map<int,int> mp;\\n        multiset<ll> ms;\\n        \\n        mp[1]=n;\\n        ms.insert( presum[n] );\\n        vector<ll> ans;\\n        \\n        for(auto x: rq)\\n        {\\n            x++;\\n            auto it=mp.upper_bound( x );\\n            it--;\\n            int fs=it->first, sc=it->second;\\n            \\n            ll sum=presum[ sc ]-presum[ fs-1 ];\\n            ms.erase( ms.find( sum ) );\\n            mp.erase( fs );\\n            \\n            if( fs<x )\\n            {\\n                mp[fs]=x-1;\\n                ms.insert( presum[x-1]-presum[fs-1] );\\n            }\\n            \\n            if(sc>x)\\n            {\\n                mp[x+1]=sc;\\n                ms.insert( presum[sc]-presum[x] );\\n            }\\n            \\n            if(ms.size())  ans.push_back( *--ms.end() );\\n            else ans.push_back( 0 );\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    \\npublic:\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq)\\n    {\\n        \\n        int n=nums.size();\\n        vector<ll> presum(n+1);\\n        for(int i=1;i<=n;i++) presum[i]=presum[i-1]+nums[i-1];\\n        \\n        map<int,int> mp;\\n        multiset<ll> ms;\\n        \\n        mp[1]=n;\\n        ms.insert( presum[n] );\\n        vector<ll> ans;\\n        \\n        for(auto x: rq)\\n        {\\n            x++;\\n            auto it=mp.upper_bound( x );\\n            it--;\\n            int fs=it->first, sc=it->second;\\n            \\n            ll sum=presum[ sc ]-presum[ fs-1 ];\\n            ms.erase( ms.find( sum ) );\\n            mp.erase( fs );\\n            \\n            if( fs<x )\\n            {\\n                mp[fs]=x-1;\\n                ms.insert( presum[x-1]-presum[fs-1] );\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2664770,
                "title": "c-segment-tree-generic-approach",
                "content": "Use segment tree but instead of storing just sum of the range, store some more information about the range.\\nLets say we have a node that will keep information about range [L,R] then we have\\n1. st , which represents sum starting from index L having all non zero elements.\\n2. en,  which represents sum ending at index R having all non zero elements.\\n3. mx,  which represents maximum sum of any subarray between [L,R] having all non zero elements.\\n4. sum,  which represents sum of all elements in range [L,R].\\n\\nNow the important thing here is add method that will perform merge operation on two nodes.\\n\\n```\\ntypedef long long ll;\\nstruct node{\\n    ll st,en,mx,sum;\\n};\\n\\nvoid add(node& a,node& b,node& c){\\n    c.st = a.st;\\n    if(a.st == a.en && a.st == a.sum && a.st != 0)c.st += b.st;\\n\\n    c.en = b.en;\\n    if(b.en == b.st && b.sum == b.en && b.en != 0) c.en += a.en;\\n\\n    c.sum = a.sum + b.sum;\\n    c.mx = max({a.mx , b.mx, c.st , c.en , a.en + b.st});\\n}\\n\\nconst int mx = 1e5;\\nnode st[3*mx];\\n\\nvoid insert(int ss,int se,int si,const int& idx,const int& val){\\n    \\n    if(ss == se){\\n        st[si].st = st[si].en = st[si].mx = st[si].sum = val;\\n        return;\\n    }\\n    \\n    int mid = (ss + se) / 2;\\n    \\n    if(idx >= ss && idx <= mid) insert(ss,mid,2*si+1,idx,val);\\n    else insert(mid+1,se,2*si+2,idx,val);\\n    \\n    add(st[2*si+1],st[2*si+2],st[si]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long> ans(removeQueries.size());\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            insert(0 , n - 1, 0 , i , nums[i]);\\n        }\\n        for(int i = 0 ; i < removeQueries.size() ; i++){\\n            insert(0,n-1,0,removeQueries[i],0);\\n            ans[i] = st[0].mx;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nstruct node{\\n    ll st,en,mx,sum;\\n};\\n\\nvoid add(node& a,node& b,node& c){\\n    c.st = a.st;\\n    if(a.st == a.en && a.st == a.sum && a.st != 0)c.st += b.st;\\n\\n    c.en = b.en;\\n    if(b.en == b.st && b.sum == b.en && b.en != 0) c.en += a.en;\\n\\n    c.sum = a.sum + b.sum;\\n    c.mx = max({a.mx , b.mx, c.st , c.en , a.en + b.st});\\n}\\n\\nconst int mx = 1e5;\\nnode st[3*mx];\\n\\nvoid insert(int ss,int se,int si,const int& idx,const int& val){\\n    \\n    if(ss == se){\\n        st[si].st = st[si].en = st[si].mx = st[si].sum = val;\\n        return;\\n    }\\n    \\n    int mid = (ss + se) / 2;\\n    \\n    if(idx >= ss && idx <= mid) insert(ss,mid,2*si+1,idx,val);\\n    else insert(mid+1,se,2*si+2,idx,val);\\n    \\n    add(st[2*si+1],st[2*si+2],st[si]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long> ans(removeQueries.size());\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            insert(0 , n - 1, 0 , i , nums[i]);\\n        }\\n        for(int i = 0 ; i < removeQueries.size() ; i++){\\n            insert(0,n-1,0,removeQueries[i],0);\\n            ans[i] = st[0].mx;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641608,
                "title": "o-n-using-reverse-union-find-union-by-rank-path-compression-simple-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int get(int i, vector<int>&parent){\\n        \\n        return parent[i] == i ? i :  parent[i] = get(parent[i], parent);\\n    }\\n    \\n    \\n    void Union(int n1, int n2, vector<int> &parent, vector<int> &rank, vector<long long> &sum){\\n        \\n        int p1 = get(n1, parent);\\n        int p2 = get(n2, parent);\\n        \\n        if(rank[p1] == rank[p2]){\\n            sum[p1] += sum[p2];\\n            parent[p2] = p1;\\n            rank[p1]++;\\n        }\\n        else if(rank[p1]<rank[p2]) parent[p1] = p2, sum[p2] += sum[p1];\\n        \\n        else parent[p2] = p1, sum[p1] += sum[p2];\\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        \\n        long long n = nums.size(), maxi = 0; // Maxi stores current maximum segement sum\\n        vector<long long> ans(n);\\n        vector<long long> sum(n,0); // sum[i] = sum of segment whose leader is  = i\\n        vector<int> parent(n, INT_MAX);\\n        vector<int> rank(n,0);\\n        ans[n-1]=0;\\n        \\n        for(int i = n-2;i>=0; i--){\\n            \\n            int node = rq[i+1];\\n            \\n            parent[node] = node;\\n            sum[node] = nums[node];\\n            \\n            if(node-1 >= 0 and parent[node - 1] != INT_MAX)\\n                Union(node, node-1, parent, rank, sum);\\n\\n            if(node+1 < n and parent[node + 1] != INT_MAX)\\n                Union(node, node+1, parent, rank, sum);\\n            \\n            maxi = max(maxi, sum[get(node, parent)]);\\n            \\n            ans[i] = maxi;\\n        }        \\n        \\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int get(int i, vector<int>&parent){\\n        \\n        return parent[i] == i ? i :  parent[i] = get(parent[i], parent);\\n    }\\n    \\n    \\n    void Union(int n1, int n2, vector<int> &parent, vector<int> &rank, vector<long long> &sum){\\n        \\n        int p1 = get(n1, parent);\\n        int p2 = get(n2, parent);\\n        \\n        if(rank[p1] == rank[p2]){\\n            sum[p1] += sum[p2];\\n            parent[p2] = p1;\\n            rank[p1]++;\\n        }\\n        else if(rank[p1]<rank[p2]) parent[p1] = p2, sum[p2] += sum[p1];\\n        \\n        else parent[p2] = p1, sum[p1] += sum[p2];\\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        \\n        long long n = nums.size(), maxi = 0; // Maxi stores current maximum segement sum\\n        vector<long long> ans(n);\\n        vector<long long> sum(n,0); // sum[i] = sum of segment whose leader is  = i\\n        vector<int> parent(n, INT_MAX);\\n        vector<int> rank(n,0);\\n        ans[n-1]=0;\\n        \\n        for(int i = n-2;i>=0; i--){\\n            \\n            int node = rq[i+1];\\n            \\n            parent[node] = node;\\n            sum[node] = nums[node];\\n            \\n            if(node-1 >= 0 and parent[node - 1] != INT_MAX)\\n                Union(node, node-1, parent, rank, sum);\\n\\n            if(node+1 < n and parent[node + 1] != INT_MAX)\\n                Union(node, node+1, parent, rank, sum);\\n            \\n            maxi = max(maxi, sum[get(node, parent)]);\\n            \\n            ans[i] = maxi;\\n        }        \\n        \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626313,
                "title": "javascription-solution-with-hash-table",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    // prefix sum\\n    let prefix = [];\\n    let s = 0;\\n    for(let i=0; i<nums.length; i++){\\n        s += nums[i];\\n        prefix.push(s);\\n    }\\n    \\n    res.push(0);\\n    let len = nums.length;\\n    // save interval, key means left side, value means right side\\n    let map1 = new Map();\\n    // save interval, key means right side, value means left side\\n    let map2 = new Map();\\n\\t\\n    for(let i=len-1; i>0; i--){\\n        let index = removeQueries[i];\\n        let sum = 0;\\n\\t\\t// check if interval exist\\n\\t\\t// interval not exist, save directly\\n        if(!map1.has(index+1) && !map2.has(index-1)){\\n            map1.set(index, index);\\n            map2.set(index, index);\\n            sum = index-1 >= 0 ? prefix[index] - prefix[index-1] : prefix[index];\\n\\t\\t// interval exist, try to merge\\n        }else if(!map2.has(index-1)){\\n\\t\\t\\t// update right side\\n            let end = map1.get(index+1);\\n            map1.set(index, end);\\n\\t\\t\\tmap2.set(end, index);\\n\\t\\t\\t// delete old data\\n            map1.delete(index+1);\\n            map2.delete(end);\\n            sum = index-1 >= 0 ? prefix[end] - prefix[index-1] : prefix[end];\\n\\t\\t// interval exist, try to merge\\t\\n        }else if(!map1.has(index+1)){\\n\\t\\t\\t// update left side\\n            let start = map2.get(index-1);\\n            map2.set(index, start);\\n\\t\\t\\tmap1.set(start, index);\\n\\t\\t\\t// delete old data\\n            map2.delete(index-1);\\n            map1.delete(start);\\n            sum = start-1 >= 0 ? prefix[index] - prefix[start-1] : prefix[index];\\n        }else{\\n            let end = map1.get(index+1);\\n            let start = map2.get(index-1);\\n            map1.delete(index+1);\\n            map2.delete(index-1);\\n            map1.set(start,end);\\n            map2.set(end, start);\\n\\n            sum = start-1 >= 0 ? prefix[end] - prefix[start-1] : prefix[end];\\n        }\\n\\t\\t// compare and get the max one\\n        if(sum > res[res.length-1]){\\n            res.push(sum);\\n        }else{\\n            let last = res[res.length-1];\\n            res.push(last);\\n        }\\n    }\\n\\n    res = res.reverse();\\n\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    // prefix sum\\n    let prefix = [];\\n    let s = 0;\\n    for(let i=0; i<nums.length; i++){\\n        s += nums[i];\\n        prefix.push(s);\\n    }\\n    \\n    res.push(0);\\n    let len = nums.length;\\n    // save interval, key means left side, value means right side\\n    let map1 = new Map();\\n    // save interval, key means right side, value means left side\\n    let map2 = new Map();\\n\\t\\n    for(let i=len-1; i>0; i--){\\n        let index = removeQueries[i];\\n        let sum = 0;\\n\\t\\t// check if interval exist\\n\\t\\t// interval not exist, save directly\\n        if(!map1.has(index+1) && !map2.has(index-1)){\\n            map1.set(index, index);\\n            map2.set(index, index);\\n            sum = index-1 >= 0 ? prefix[index] - prefix[index-1] : prefix[index];\\n\\t\\t// interval exist, try to merge\\n        }else if(!map2.has(index-1)){\\n\\t\\t\\t// update right side\\n            let end = map1.get(index+1);\\n            map1.set(index, end);\\n\\t\\t\\tmap2.set(end, index);\\n\\t\\t\\t// delete old data\\n            map1.delete(index+1);\\n            map2.delete(end);\\n            sum = index-1 >= 0 ? prefix[end] - prefix[index-1] : prefix[end];\\n\\t\\t// interval exist, try to merge\\t\\n        }else if(!map1.has(index+1)){\\n\\t\\t\\t// update left side\\n            let start = map2.get(index-1);\\n            map2.set(index, start);\\n\\t\\t\\tmap1.set(start, index);\\n\\t\\t\\t// delete old data\\n            map2.delete(index-1);\\n            map1.delete(start);\\n            sum = start-1 >= 0 ? prefix[index] - prefix[start-1] : prefix[index];\\n        }else{\\n            let end = map1.get(index+1);\\n            let start = map2.get(index-1);\\n            map1.delete(index+1);\\n            map2.delete(index-1);\\n            map1.set(start,end);\\n            map2.set(end, start);\\n\\n            sum = start-1 >= 0 ? prefix[end] - prefix[start-1] : prefix[end];\\n        }\\n\\t\\t// compare and get the max one\\n        if(sum > res[res.length-1]){\\n            res.push(sum);\\n        }else{\\n            let last = res[res.length-1];\\n            res.push(last);\\n        }\\n    }\\n\\n    res = res.reverse();\\n\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602928,
                "title": "c-prefixsum-set-heap-tle-prefixsum-set-mulltiset-accepted",
                "content": "The two methods are similar but the first one require more constant time work. \\n```\\n// TLE\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll> res;\\n\\t\\tpriority_queue<pair<ll, pair<int, int>>> pq;\\n\\t\\tset<int> removed;\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t}\\n\\t\\tvector<ll> prefix(nums.size() + 1, 0);\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tprefix[i + 1] = prefix[i] + (ll)nums[i];\\n\\t\\t}\\n\\t\\tpq.emplace(sum, make_pair(0, nums.size() - 1));\\n\\t\\tfor (int i = 0; i < removeQueries.size() - 1; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tbool done = false;\\n\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\tauto curr = pq.top(); \\n\\t\\t\\t\\tll sum = curr.first;\\n\\t\\t\\t\\tint l = curr.second.first, r = curr.second.second;\\n\\t\\t\\t\\t// if (l > r) continue;\\n\\t\\t\\t\\tauto itr = lower_bound(removed.begin(), removed.end(), l);\\n\\t\\t\\t\\tif (itr == removed.end() || *itr > r) {\\n\\t\\t\\t\\t\\tdone = true;\\n\\t\\t\\t\\t\\tres.push_back(sum);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif (*itr == l && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[l + 1], make_pair(l + 1, r));\\n\\t\\t\\t\\t\\t} else if (*itr == r && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r] - prefix[l], make_pair(l, r - 1));\\n\\t\\t\\t\\t\\t} else if (*itr > l && *itr < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[(*itr)] - prefix[l], make_pair(l, (*itr) - 1));\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[(*itr) + 1], make_pair((*itr) + 1, r));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(0);\\n\\t\\treturn res;\\n    }\\n};\\n```\\nNeed to notice that when removing an element from the multiset, we need to remove the iterator instead of by value, the latter one will remove all element has that value. \\n```\\n// Accepted\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\tint n = nums.size();\\n        multiset<ll> valid;\\n\\t\\tset<int> removed;\\n\\t\\tvector<ll> S(n + 1, 0);\\n\\t\\tvector<ll> res;\\n\\t\\tfor (int i = 0; i < n; i++) S[i + 1] = S[i] + nums[i];\\n\\t\\tvalid.insert(S[n]);\\n\\t\\tvalid.insert(0);\\n\\t\\tremoved.insert(-1);\\n\\t\\tremoved.insert(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tauto pre = prev(removed.find(removeQueries[i]));\\n\\t\\t\\tauto ne = next(removed.find(removeQueries[i]));\\n\\t\\t\\tint l = *pre, r = *ne;\\n            valid.erase(valid.find(S[r] - S[l + 1]));\\n\\t\\t\\tif (l + 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[removeQueries[i]] - S[l + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tif (r - 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[r] - S[removeQueries[i] + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(*prev(valid.end()));\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n// TLE\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll> res;\\n\\t\\tpriority_queue<pair<ll, pair<int, int>>> pq;\\n\\t\\tset<int> removed;\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t}\\n\\t\\tvector<ll> prefix(nums.size() + 1, 0);\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tprefix[i + 1] = prefix[i] + (ll)nums[i];\\n\\t\\t}\\n\\t\\tpq.emplace(sum, make_pair(0, nums.size() - 1));\\n\\t\\tfor (int i = 0; i < removeQueries.size() - 1; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tbool done = false;\\n\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\tauto curr = pq.top(); \\n\\t\\t\\t\\tll sum = curr.first;\\n\\t\\t\\t\\tint l = curr.second.first, r = curr.second.second;\\n\\t\\t\\t\\t// if (l > r) continue;\\n\\t\\t\\t\\tauto itr = lower_bound(removed.begin(), removed.end(), l);\\n\\t\\t\\t\\tif (itr == removed.end() || *itr > r) {\\n\\t\\t\\t\\t\\tdone = true;\\n\\t\\t\\t\\t\\tres.push_back(sum);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif (*itr == l && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[l + 1], make_pair(l + 1, r));\\n\\t\\t\\t\\t\\t} else if (*itr == r && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r] - prefix[l], make_pair(l, r - 1));\\n\\t\\t\\t\\t\\t} else if (*itr > l && *itr < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[(*itr)] - prefix[l], make_pair(l, (*itr) - 1));\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[(*itr) + 1], make_pair((*itr) + 1, r));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(0);\\n\\t\\treturn res;\\n    }\\n};\\n```\n```\\n// Accepted\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\tint n = nums.size();\\n        multiset<ll> valid;\\n\\t\\tset<int> removed;\\n\\t\\tvector<ll> S(n + 1, 0);\\n\\t\\tvector<ll> res;\\n\\t\\tfor (int i = 0; i < n; i++) S[i + 1] = S[i] + nums[i];\\n\\t\\tvalid.insert(S[n]);\\n\\t\\tvalid.insert(0);\\n\\t\\tremoved.insert(-1);\\n\\t\\tremoved.insert(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tauto pre = prev(removed.find(removeQueries[i]));\\n\\t\\t\\tauto ne = next(removed.find(removeQueries[i]));\\n\\t\\t\\tint l = *pre, r = *ne;\\n            valid.erase(valid.find(S[r] - S[l + 1]));\\n\\t\\t\\tif (l + 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[removeQueries[i]] - S[l + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tif (r - 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[r] - S[removeQueries[i] + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(*prev(valid.end()));\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2584930,
                "title": "2-dimention-segment-tree-solution",
                "content": "It is kind of complicated.\\n\\nThe time complexity is O(N(logN)^2).\\nThe merge function costs (logN)^2 beacuse there is a segment tree used to maintain the interval sum in it and it executes logN times.\\nShould I call it 2D-segment tree?\\n\\nI feel incredible when it works.\\nJust want ro record something.\\nIf you can understand it , that is great.\\n```\\nclass Sgtree2{\\n    public:\\n    vector<long long> v;\\n    Sgtree2(vector<int>& input){\\n        int n = input.size();\\n        v = vector<long long>(4*n,0);\\n        build(0,n-1,0,input);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    void update(int l , int r,int node , int pos,int val){\\n        if(l==r){\\n            v[node] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    long long query(int l , int r, int L , int R, int node){\\n        if(l==L && r == R){\\n            return v[node];\\n        }\\n        int M = (L+R)/2;\\n        if( r <= M ){\\n            return query(l,r,L,M,node*2+1);\\n        }else if(l>M){\\n            return query(l,r,M+1,R,node*2+2);\\n        }else{\\n            return query(l,M,L,M,node*2+1) + query(M+1,r,M+1,R,node*2+2);\\n        }\\n    }\\n    \\n};\\nclass Sgtree{\\n    public:\\n    vector<long long> v;\\n    vector<int> left,right;//the leftmost/rightmost value of interval of v[node] \\n    vector<int> leftzero , rightzero;//leftmost/rightmost zero\\'s idx of interval of v[node].\\n    \\n    int n ;\\n    Sgtree2 *pre;\\n    Sgtree(vector<int>& arr,Sgtree2 *t){\\n        n = arr.size();\\n        v = vector<long long>(4*n,0);\\n        left = vector<int>(4*n,0);\\n        right = vector<int>(4*n,0);\\n        \\n        leftzero = vector<int>(4*n,-1);\\n        rightzero = vector<int>(4*n,-1);\\n        \\n        pre = t;\\n        build(0,n-1,0,arr);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            left[node]=arr[l];\\n            right[node]=arr[l];\\n            if(arr[l]==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        merge(l,r,node);\\n    }\\n    long long update(int l , int r , int node , int pos , int val){\\n        if(l==r){\\n            v[node] = val;\\n            left[node]=val;\\n            right[node]=val;\\n            if(val==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            pre->update(0,n-1,0,pos,val);\\n            return v[node];\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        \\n        merge(l,r,node);\\n        return v[node];\\n    }\\n    void merge(int l ,int r , int node){\\n        if(right[node*2+1] == 0 || left[node*2+2] == 0 ){\\n            v[node] = max(v[node*2+1],v[node*2+2]);\\n        }else{\\n            if(rightzero[node*2+1] == -1 && leftzero[node*2+2]==-1){\\n                v[node] = v[node*2+1]+v[node*2+2];\\n            }else if(rightzero[node*2+1] == -1){\\n                int idx = leftzero[node*2+2];\\n                v[node] = max( pre->query( l , idx ,0 ,n-1,0) , v[node*2+2] );\\n            }else if(leftzero[node*2+2]==-1){\\n                int idx = rightzero[node*2+1];\\n                v[node] = max( pre->query( idx , r ,0 ,n-1,0) , v[node*2+1] );\\n            }else{\\n                int tl = rightzero[node*2+1];\\n                int tr = leftzero[node*2+2];\\n                v[node] = max( {v[node*2+1],v[node*2+2] , pre->query( tl , tr ,0 ,n-1,0) } );\\n            }\\n        }\\n        left[node] = left[node*2+1];\\n        right[node] = right[node*2+2];\\n        if(leftzero[node*2+1]==-1){\\n            leftzero[node] = leftzero[node*2+2];\\n        }else{\\n            leftzero[node] = leftzero[node*2+1];\\n        }\\n        if(rightzero[node*2+2]==-1){\\n            rightzero[node] = rightzero[node*2+1];\\n        }else{\\n            rightzero[node] = rightzero[node*2+2];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        //time O(n(logn)^2 );\\n        int n = nums.size();\\n        vector<long long> ans;\\n        Sgtree2 * pre = new Sgtree2(nums);\\n        Sgtree *sgt = new Sgtree(nums,pre);\\n        \\n        for(auto&& i : removeQueries){\\n            ans.push_back(sgt->update(0,n-1,0,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Sgtree2{\\n    public:\\n    vector<long long> v;\\n    Sgtree2(vector<int>& input){\\n        int n = input.size();\\n        v = vector<long long>(4*n,0);\\n        build(0,n-1,0,input);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    void update(int l , int r,int node , int pos,int val){\\n        if(l==r){\\n            v[node] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    long long query(int l , int r, int L , int R, int node){\\n        if(l==L && r == R){\\n            return v[node];\\n        }\\n        int M = (L+R)/2;\\n        if( r <= M ){\\n            return query(l,r,L,M,node*2+1);\\n        }else if(l>M){\\n            return query(l,r,M+1,R,node*2+2);\\n        }else{\\n            return query(l,M,L,M,node*2+1) + query(M+1,r,M+1,R,node*2+2);\\n        }\\n    }\\n    \\n};\\nclass Sgtree{\\n    public:\\n    vector<long long> v;\\n    vector<int> left,right;//the leftmost/rightmost value of interval of v[node] \\n    vector<int> leftzero , rightzero;//leftmost/rightmost zero\\'s idx of interval of v[node].\\n    \\n    int n ;\\n    Sgtree2 *pre;\\n    Sgtree(vector<int>& arr,Sgtree2 *t){\\n        n = arr.size();\\n        v = vector<long long>(4*n,0);\\n        left = vector<int>(4*n,0);\\n        right = vector<int>(4*n,0);\\n        \\n        leftzero = vector<int>(4*n,-1);\\n        rightzero = vector<int>(4*n,-1);\\n        \\n        pre = t;\\n        build(0,n-1,0,arr);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            left[node]=arr[l];\\n            right[node]=arr[l];\\n            if(arr[l]==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        merge(l,r,node);\\n    }\\n    long long update(int l , int r , int node , int pos , int val){\\n        if(l==r){\\n            v[node] = val;\\n            left[node]=val;\\n            right[node]=val;\\n            if(val==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            pre->update(0,n-1,0,pos,val);\\n            return v[node];\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        \\n        merge(l,r,node);\\n        return v[node];\\n    }\\n    void merge(int l ,int r , int node){\\n        if(right[node*2+1] == 0 || left[node*2+2] == 0 ){\\n            v[node] = max(v[node*2+1],v[node*2+2]);\\n        }else{\\n            if(rightzero[node*2+1] == -1 && leftzero[node*2+2]==-1){\\n                v[node] = v[node*2+1]+v[node*2+2];\\n            }else if(rightzero[node*2+1] == -1){\\n                int idx = leftzero[node*2+2];\\n                v[node] = max( pre->query( l , idx ,0 ,n-1,0) , v[node*2+2] );\\n            }else if(leftzero[node*2+2]==-1){\\n                int idx = rightzero[node*2+1];\\n                v[node] = max( pre->query( idx , r ,0 ,n-1,0) , v[node*2+1] );\\n            }else{\\n                int tl = rightzero[node*2+1];\\n                int tr = leftzero[node*2+2];\\n                v[node] = max( {v[node*2+1],v[node*2+2] , pre->query( tl , tr ,0 ,n-1,0) } );\\n            }\\n        }\\n        left[node] = left[node*2+1];\\n        right[node] = right[node*2+2];\\n        if(leftzero[node*2+1]==-1){\\n            leftzero[node] = leftzero[node*2+2];\\n        }else{\\n            leftzero[node] = leftzero[node*2+1];\\n        }\\n        if(rightzero[node*2+2]==-1){\\n            rightzero[node] = rightzero[node*2+1];\\n        }else{\\n            rightzero[node] = rightzero[node*2+2];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        //time O(n(logn)^2 );\\n        int n = nums.size();\\n        vector<long long> ans;\\n        Sgtree2 * pre = new Sgtree2(nums);\\n        Sgtree *sgt = new Sgtree(nums,pre);\\n        \\n        for(auto&& i : removeQueries){\\n            ans.push_back(sgt->update(0,n-1,0,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581903,
                "title": "c-direct-simulation-multiset-prefix-sum",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    #define LL long long\\n    \\n    \\n    multiset<LL> segsum;\\n    LL prefix[100010] = {0};\\n    vector<LL> ans;\\n    set<int> qid;\\n    int n;\\n    \\n    void split(int l, int r, int at){\\n        LL ori = prefix[r-1] - prefix[l];\\n        LL n1 = prefix[at-1] - prefix[l];\\n        LL n2 = prefix[r-1] - prefix[at];\\n   \\n        segsum.erase(segsum.lower_bound(ori)); // erase only 1 element, not all element with same value\\n        segsum.insert(n1);\\n        segsum.insert(n2);\\n        \\n        ans.push_back(*prev(segsum.end()));\\n    }\\n    \\n    pair<int,int> findSegRange(int at){\\n        auto pos = qid.lower_bound(at);\\n        int lo = *prev(pos) ;\\n        int hi = *pos;\\n\\n        return {lo, hi};\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        n = nums.size();\\n        \\n        for(int i=1; i<=n; i++) prefix[i] = prefix[i-1] + nums[i-1];\\n        qid.insert(0);\\n        qid.insert(n+1);\\n        segsum.insert(prefix[n]);\\n        \\n        for(int q : removeQueries){\\n            auto range = findSegRange(q+1);\\n            split(range.first, range.second, q+1);\\n            qid.insert(q+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    #define LL long long\\n    \\n    \\n    multiset<LL> segsum;\\n    LL prefix[100010] = {0};\\n    vector<LL> ans;\\n    set<int> qid;\\n    int n;\\n    \\n    void split(int l, int r, int at){\\n        LL ori = prefix[r-1] - prefix[l];\\n        LL n1 = prefix[at-1] - prefix[l];\\n        LL n2 = prefix[r-1] - prefix[at];\\n   \\n        segsum.erase(segsum.lower_bound(ori)); // erase only 1 element, not all element with same value\\n        segsum.insert(n1);\\n        segsum.insert(n2);\\n        \\n        ans.push_back(*prev(segsum.end()));\\n    }\\n    \\n    pair<int,int> findSegRange(int at){\\n        auto pos = qid.lower_bound(at);\\n        int lo = *prev(pos) ;\\n        int hi = *pos;\\n\\n        return {lo, hi};\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        n = nums.size();\\n        \\n        for(int i=1; i<=n; i++) prefix[i] = prefix[i-1] + nums[i-1];\\n        qid.insert(0);\\n        qid.insert(n+1);\\n        segsum.insert(prefix[n]);\\n        \\n        for(int q : removeQueries){\\n            auto range = findSegRange(q+1);\\n            split(range.first, range.second, q+1);\\n            qid.insert(q+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568519,
                "title": "python-reverse-with-explantions",
                "content": "## IDEA:\\nWe start from an empty list and will add elements from the last removed one by one. \\nWe keep an array of segments with each element containing the left, right, and the sum of the segment in it. Adding a new element to the list has four different scenarios. It either adds a new segment ( meaning left and right is empty) or merges left, right, or both. A merge function merges to segment using the most left node of the left list and the rightmost node of the correct list. We first try to merge the new segment with the left segment and then merge it again with the right segment. Finally, we have a value of max from the last segments. We compare it to the new segment created and add it to the answer list. \\n\\n**if you find the solution helpful. PLEASE CONSIDER UPVOTING.\\nTHANK YOU**\\n\\n```\\nclass Solution:\\n\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        answer, segs = [0]*n, [0] * n\\n        curMax = 0\\n        index = n-2\\n        for i in range(n):\\n            segs[i] = [0, 0, 0]\\n        for i in removeQueries[::-1][:-1]:\\n            segs[i] = [i, i, nums[i]]\\n            if(i > 0 and segs[i-1][2] > 0):\\n                myMerge(segs[i-1][0], segs[i][1], segs)\\n            if(i < n-1 and segs[i+1][2] > 0):\\n                myMerge(segs[i][0], segs[i+1][1], segs)\\n            curMax = max(segs[segs[i][0]][2], curMax)\\n            answer[index] = curMax\\n            index -= 1\\n        return answer\\n\\n\\ndef myMerge(left, right, array):\\n    array[left][1] = right\\n    array[right][0] = left\\n    array[left][2] = array[right][2]+array[left][2]\\n    array[right][2] = array[left][2]\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        answer, segs = [0]*n, [0] * n\\n        curMax = 0\\n        index = n-2\\n        for i in range(n):\\n            segs[i] = [0, 0, 0]\\n        for i in removeQueries[::-1][:-1]:\\n            segs[i] = [i, i, nums[i]]\\n            if(i > 0 and segs[i-1][2] > 0):\\n                myMerge(segs[i-1][0], segs[i][1], segs)\\n            if(i < n-1 and segs[i+1][2] > 0):\\n                myMerge(segs[i][0], segs[i+1][1], segs)\\n            curMax = max(segs[segs[i][0]][2], curMax)\\n            answer[index] = curMax\\n            index -= 1\\n        return answer\\n\\n\\ndef myMerge(left, right, array):\\n    array[left][1] = right\\n    array[right][0] = left\\n    array[left][2] = array[right][2]+array[left][2]\\n    array[right][2] = array[left][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556691,
                "title": "python-o-n-solution-using-array-sum",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        length, maximum = len(nums), 0\\n        ans, sm, count = [0 for _ in range(length)], [0 for _ in range(length)], [0 for _ in range(length)]\\n        for i in range(length - 1, -1, -1):\\n            ans[i], index = maximum, removeQueries[i]\\n            leftCount = count[index - 1] if index - 1 >= 0 else 0\\n            leftSum = sm[index - 1] if index - 1 >= 0 else 0\\n            rightCount = count[index + 1] if index + 1 < length else 0\\n            rightSum = sm[index + 1] if index + 1 < length else 0\\n            count[index] = 1 + leftCount + rightCount\\n            count[index - leftCount] = 1 + leftCount + rightCount\\n            count[index + rightCount] = 1 + leftCount + rightCount\\n            sm[index] = nums[index] + leftSum + rightSum\\n            sm[index - leftCount] = nums[index] + leftSum + rightSum\\n            sm[index + rightCount] = nums[index] + leftSum + rightSum\\n            maximum = max(maximum, sm[index])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        length, maximum = len(nums), 0\\n        ans, sm, count = [0 for _ in range(length)], [0 for _ in range(length)], [0 for _ in range(length)]\\n        for i in range(length - 1, -1, -1):\\n            ans[i], index = maximum, removeQueries[i]\\n            leftCount = count[index - 1] if index - 1 >= 0 else 0\\n            leftSum = sm[index - 1] if index - 1 >= 0 else 0\\n            rightCount = count[index + 1] if index + 1 < length else 0\\n            rightSum = sm[index + 1] if index + 1 < length else 0\\n            count[index] = 1 + leftCount + rightCount\\n            count[index - leftCount] = 1 + leftCount + rightCount\\n            count[index + rightCount] = 1 + leftCount + rightCount\\n            sm[index] = nums[index] + leftSum + rightSum\\n            sm[index - leftCount] = nums[index] + leftSum + rightSum\\n            sm[index + rightCount] = nums[index] + leftSum + rightSum\\n            maximum = max(maximum, sm[index])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549943,
                "title": "100-simple-boundary-java-solution-with-just-array-sum-and-count",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n     \\n        int len=nums.length;\\n        long ans[]=new long[len];\\n        long sum[]=new long[len];\\n        int count[]=new int[len];\\n        long max=0;\\n       \\n        for(int i=len-1;i>=0;i--){\\n            ans[i]=max;\\n            int index=removeQueries[i];\\n            \\n            int leftCount=index-1>=0?count[index-1]:0;\\n            long leftSum=index-1>=0?sum[index-1]:0;\\n            \\n            int rightCount=index+1<len?count[index+1]:0; \\n            long rightSum=index+1<len?sum[index+1]:0; \\n            \\n            \\n            count[index]=1+leftCount+rightCount;\\n            count[index-leftCount]=1+leftCount+rightCount;\\n            count[index+rightCount]=1+leftCount+rightCount;\\n            \\n            sum[index]=nums[index]+leftSum+rightSum;\\n            sum[index-leftCount]=nums[index]+leftSum+rightSum;\\n            sum[index+rightCount]=nums[index]+leftSum+rightSum;\\n            \\n            max=Math.max(sum[index],max);\\n          \\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n     \\n        int len=nums.length;\\n        long ans[]=new long[len];\\n        long sum[]=new long[len];\\n        int count[]=new int[len];\\n        long max=0;\\n       \\n        for(int i=len-1;i>=0;i--){\\n            ans[i]=max;\\n            int index=removeQueries[i];\\n            \\n            int leftCount=index-1>=0?count[index-1]:0;\\n            long leftSum=index-1>=0?sum[index-1]:0;\\n            \\n            int rightCount=index+1<len?count[index+1]:0; \\n            long rightSum=index+1<len?sum[index+1]:0; \\n            \\n            \\n            count[index]=1+leftCount+rightCount;\\n            count[index-leftCount]=1+leftCount+rightCount;\\n            count[index+rightCount]=1+leftCount+rightCount;\\n            \\n            sum[index]=nums[index]+leftSum+rightSum;\\n            sum[index-leftCount]=nums[index]+leftSum+rightSum;\\n            sum[index+rightCount]=nums[index]+leftSum+rightSum;\\n            \\n            max=Math.max(sum[index],max);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2506406,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        map<long long,long long>mp;\\n        int n=nums.size();\\n        set<int>remove{-1,n};\\n        multiset<long long>temp;\\n        vector<long long>ans(n,0);\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            mp[i]=sum;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto r=(remove.lower_bound(removeQueries[i]));\\n            auto l=--(remove.lower_bound(removeQueries[i]));\\n            long long rem=mp[*(r)-1]-mp[*(l)];\\n            if(temp.find(rem)!=temp.end())\\n                temp.erase(temp.find(rem));\\n            long long t1=mp[*(r)-1]-mp[removeQueries[i]];\\n            long long t2=mp[removeQueries[i]-1]-mp[*(l)];\\n            remove.insert(removeQueries[i]);\\n            temp.insert(t1);\\n            temp.insert(t2);\\n            ans[i]=*(temp.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        map<long long,long long>mp;\\n        int n=nums.size();\\n        set<int>remove{-1,n};\\n        multiset<long long>temp;\\n        vector<long long>ans(n,0);\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            mp[i]=sum;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto r=(remove.lower_bound(removeQueries[i]));\\n            auto l=--(remove.lower_bound(removeQueries[i]));\\n            long long rem=mp[*(r)-1]-mp[*(l)];\\n            if(temp.find(rem)!=temp.end())\\n                temp.erase(temp.find(rem));\\n            long long t1=mp[*(r)-1]-mp[removeQueries[i]];\\n            long long t2=mp[removeQueries[i]-1]-mp[*(l)];\\n            remove.insert(removeQueries[i]);\\n            temp.insert(t1);\\n            temp.insert(t2);\\n            ans[i]=*(temp.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498324,
                "title": "clean-c-solution-o-n-using-dsu",
                "content": "\\n\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n\\nstruct dsu {\\n\\n    vector<int> p;\\n    vector<long long> sum;\\n    int n;\\n    dsu(int _n = -1) {if (_n >= 0) init(_n);}\\n\\n    void init(int _n) {p.assign(_n + 1, -1); n = _n;sum.assign(n+1,0LL);}\\n    int find(int x) \\n\\t{\\n\\t\\t\\treturn p[x] == x ? x : p[x] = find(p[x]);\\n\\t}\\n    bool unite(int x, int y) {\\n        x = find(x),y = find(y),sum[x] += sum[y],p[y] = x;\\n        return true;\\n    }\\n    long long  getsum(int x){\\n\\t\\t\\treturn sum[find(x)];\\n\\t}\\n};\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& qr) {\\n        vector<long long> ans;      \\n        int n=  qr.size();\\n        long long cur=0;\\n        ans.push_back(cur);\\n        reverse(qr.begin(),qr.end());\\n        qr.pop_back();\\n        dsu tr=dsu(n);\\n        for(int &x:qr)\\n        {\\n            tr.p[x]=x;\\n            tr.sum[x]=nums[x];\\n            if(x+1<n && tr.p[x+1]>x){\\n                tr.sum[x]+=tr.sum[x+1];\\n                tr.p[x+1]=x;\\n            }            \\n            if(x>0 && tr.p[x-1]>=0)tr.unite(x-1,x);\\n\\n            cur=max(cur,tr.getsum(x));\\n            ans.push_back(cur);\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n\\nstruct dsu {\\n\\n    vector<int> p;\\n    vector<long long> sum;\\n    int n;\\n    dsu(int _n = -1) {if (_n >= 0) init(_n);}",
                "codeTag": "Java"
            },
            {
                "id": 2497514,
                "title": "c",
                "content": "**Main Idea:**\\nRevert the procedure; Use root of disjoint set as the key of unordered map, similar to https://leetcode.com/submissions/detail/766337032/\\n\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        while (x != root[x]) {\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        unordered_set<int> get;\\n        unordered_map<int, long long> root_to_val;\\n        UnionFind uf(nums.size());\\n        vector<long long> ans = {0};\\n        long long prev = 0;\\n        \\n        for (int i = removeQueries.size() - 1; i >= 1; -- i){\\n            int curr = removeQueries[i];\\n            get.insert(curr);\\n            long long left_val = 0, right_val = 0;\\n            \\n            if (get.find(curr - 1) != get.end()){\\n                left_val = root_to_val[uf.find(curr - 1)];\\n                uf.unionSet(curr, curr - 1);\\n            }\\n            if (get.find(curr + 1) != get.end()){\\n                right_val = root_to_val[uf.find(curr + 1)];\\n                uf.unionSet(curr, curr + 1);\\n            }\\n            \\n            prev = max(nums[curr] + left_val + right_val, prev);\\n            root_to_val[uf.find(curr)] = nums[curr] + left_val + right_val;\\n            ans.push_back(prev);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    long long max(long long a, long long b){\\n        return a > b ? a : b;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        while (x != root[x]) {\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        unordered_set<int> get;\\n        unordered_map<int, long long> root_to_val;\\n        UnionFind uf(nums.size());\\n        vector<long long> ans = {0};\\n        long long prev = 0;\\n        \\n        for (int i = removeQueries.size() - 1; i >= 1; -- i){\\n            int curr = removeQueries[i];\\n            get.insert(curr);\\n            long long left_val = 0, right_val = 0;\\n            \\n            if (get.find(curr - 1) != get.end()){\\n                left_val = root_to_val[uf.find(curr - 1)];\\n                uf.unionSet(curr, curr - 1);\\n            }\\n            if (get.find(curr + 1) != get.end()){\\n                right_val = root_to_val[uf.find(curr + 1)];\\n                uf.unionSet(curr, curr + 1);\\n            }\\n            \\n            prev = max(nums[curr] + left_val + right_val, prev);\\n            root_to_val[uf.find(curr)] = nums[curr] + left_val + right_val;\\n            ans.push_back(prev);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    long long max(long long a, long long b){\\n        return a > b ? a : b;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496365,
                "title": "segment-tree",
                "content": "This segment tree will calculate the maximum segment sum\\nIf we seperate the segments with a very large value like -10^14. Than this tree can handle this question\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] arr = new long[nums.length];\\n        for(int i=0;i<nums.length;i++) arr[i] = (long)nums[i];\\n        MaximalSumSegmentTree maximalSumSegmentTree = new MaximalSumSegmentTree(arr);\\n        long[] answer = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            long res = maximalSumSegmentTree.updateQuery(removeQueries[i],-1_000_000_000_000_00L).maximumSegmentSum;\\n            if(res>0) answer[i] = res;\\n        }\\n        return answer;\\n    }\\n}\\nclass MaximalSumSegmentTree{\\n    int lengthOfArray;\\n    Node[] segmentArray;\\n\\n    public MaximalSumSegmentTree(long[] arr){\\n        this.lengthOfArray = arr.length;\\n        int heightOfSegmentTree = (int)Math.ceil(Math.log(lengthOfArray)/Math.log(2));\\n        int sizeOfSegmentArray = 2*(1<<heightOfSegmentTree)-1;\\n        this.segmentArray = new Node[sizeOfSegmentArray];\\n        constructorUtil(0,lengthOfArray-1,0,arr);\\n    }\\n    public Node constructorUtil(int segmentStart, int segmentEnd, int segmentIndex, long[] arr){\\n        if(segmentEnd==segmentStart){\\n            if(arr[segmentStart]>=0){\\n                return segmentArray[segmentIndex] = new Node(arr[segmentStart],arr[segmentStart],arr[segmentStart],arr[segmentStart]);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,arr[segmentStart],0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = constructorUtil(segmentStart,mid,segmentIndex*2+1,arr);\\n        Node rightChild = constructorUtil(mid+1,segmentEnd,segmentIndex*2+2,arr);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n    private int getMid(int segmentStart, int segmentEnd){\\n        return (segmentStart+segmentEnd)>>1;\\n    }\\n    public Node updateQuery(int index, long newValue){\\n        return updateUtil(0,lengthOfArray-1,0,index,newValue);\\n    }\\n    private Node updateUtil(int segmentStart, int segmentEnd, int segmentIndex, int index, long newValue){\\n        if(index<segmentStart || index>segmentEnd) return segmentArray[segmentIndex];\\n        if(index==segmentStart && index==segmentEnd) {\\n            if(newValue>=0){\\n                return segmentArray[segmentIndex] = new Node(newValue,newValue,newValue,newValue);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,newValue,0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = updateUtil(segmentStart,mid,segmentIndex*2+1,index,newValue);\\n        Node rightChild = updateUtil(mid+1,segmentEnd,segmentIndex*2+2,index,newValue);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n}\\nclass Node{\\n    long prefixSum;\\n    long suffixSum;\\n    long totalSum;\\n    long maximumSegmentSum;\\n\\n    public Node(long prefixSum, long suffixSum, long totalSum, long maximumSegmentSum) {\\n        this.prefixSum = prefixSum;\\n        this.suffixSum = suffixSum;\\n        this.totalSum = totalSum;\\n        this.maximumSegmentSum = maximumSegmentSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] arr = new long[nums.length];\\n        for(int i=0;i<nums.length;i++) arr[i] = (long)nums[i];\\n        MaximalSumSegmentTree maximalSumSegmentTree = new MaximalSumSegmentTree(arr);\\n        long[] answer = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            long res = maximalSumSegmentTree.updateQuery(removeQueries[i],-1_000_000_000_000_00L).maximumSegmentSum;\\n            if(res>0) answer[i] = res;\\n        }\\n        return answer;\\n    }\\n}\\nclass MaximalSumSegmentTree{\\n    int lengthOfArray;\\n    Node[] segmentArray;\\n\\n    public MaximalSumSegmentTree(long[] arr){\\n        this.lengthOfArray = arr.length;\\n        int heightOfSegmentTree = (int)Math.ceil(Math.log(lengthOfArray)/Math.log(2));\\n        int sizeOfSegmentArray = 2*(1<<heightOfSegmentTree)-1;\\n        this.segmentArray = new Node[sizeOfSegmentArray];\\n        constructorUtil(0,lengthOfArray-1,0,arr);\\n    }\\n    public Node constructorUtil(int segmentStart, int segmentEnd, int segmentIndex, long[] arr){\\n        if(segmentEnd==segmentStart){\\n            if(arr[segmentStart]>=0){\\n                return segmentArray[segmentIndex] = new Node(arr[segmentStart],arr[segmentStart],arr[segmentStart],arr[segmentStart]);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,arr[segmentStart],0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = constructorUtil(segmentStart,mid,segmentIndex*2+1,arr);\\n        Node rightChild = constructorUtil(mid+1,segmentEnd,segmentIndex*2+2,arr);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n    private int getMid(int segmentStart, int segmentEnd){\\n        return (segmentStart+segmentEnd)>>1;\\n    }\\n    public Node updateQuery(int index, long newValue){\\n        return updateUtil(0,lengthOfArray-1,0,index,newValue);\\n    }\\n    private Node updateUtil(int segmentStart, int segmentEnd, int segmentIndex, int index, long newValue){\\n        if(index<segmentStart || index>segmentEnd) return segmentArray[segmentIndex];\\n        if(index==segmentStart && index==segmentEnd) {\\n            if(newValue>=0){\\n                return segmentArray[segmentIndex] = new Node(newValue,newValue,newValue,newValue);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,newValue,0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = updateUtil(segmentStart,mid,segmentIndex*2+1,index,newValue);\\n        Node rightChild = updateUtil(mid+1,segmentEnd,segmentIndex*2+2,index,newValue);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n}\\nclass Node{\\n    long prefixSum;\\n    long suffixSum;\\n    long totalSum;\\n    long maximumSegmentSum;\\n\\n    public Node(long prefixSum, long suffixSum, long totalSum, long maximumSegmentSum) {\\n        this.prefixSum = prefixSum;\\n        this.suffixSum = suffixSum;\\n        this.totalSum = totalSum;\\n        this.maximumSegmentSum = maximumSegmentSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490353,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n\\n        UnionFind unionFind = new UnionFind(nums.length);\\n        long[] maxSegmentSum = new long[nums.length];\\n        long currentMax = 0;\\n\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n        }\\n        return maxSegmentSum;\\n    }\\n}\\n\\nclass UnionFind {\\n\\n    int[] parent;\\n    long[] rank;\\n\\n    UnionFind(int sizeInput) {\\n        parent = IntStream.range(0, sizeInput).toArray();\\n        rank = new long[sizeInput];\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function (nums, removeQueries) {\\n\\n    const unionFind = new UnionFind(nums.length);\\n    const maxSegmentSum = new Array(nums.length).fill(0);\\n    let currentMax = 0;\\n\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let query = removeQueries[i];\\n        maxSegmentSum[i] = currentMax;\\n        unionFind.rank[query] = nums[query];\\n\\n        if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n        }\\n        if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n        }\\n        currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n    }\\n    return maxSegmentSum;\\n};\\n\\nclass UnionFind {\\n\\n    constructor(sizeInput) {\\n        this.parent = Array.from(new Array(sizeInput).keys());\\n        this.rank = new Array(sizeInput).fill(0);\\n    }\\n\\n    findParent(index) {\\n        if (this.parent[index] !== index) {\\n            this.parent[index] = this.findParent(this.parent[index]);\\n        }\\n        return this.parent[index];\\n    }\\n\\n    joinByRank(indexOne, indexTwo) {\\n        if (this.rank[indexOne] >= this.rank[indexTwo]) {\\n            this.rank[indexOne] += this.rank[indexTwo];\\n            this.parent[indexTwo] = indexOne;\\n        } else {\\n            this.rank[indexTwo] += this.rank[indexOne];\\n            this.parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n\\n        UnionFind unionFind = new UnionFind(nums.length);\\n        long[] maxSegmentSum = new long[nums.length];\\n        long currentMax = 0;\\n\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n        }\\n        return maxSegmentSum;\\n    }\\n}\\n\\nclass UnionFind {\\n\\n    int[] parent;\\n    long[] rank;\\n\\n    UnionFind(int sizeInput) {\\n        parent = IntStream.range(0, sizeInput).toArray();\\n        rank = new long[sizeInput];\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function (nums, removeQueries) {\\n\\n    const unionFind = new UnionFind(nums.length);\\n    const maxSegmentSum = new Array(nums.length).fill(0);\\n    let currentMax = 0;\\n\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let query = removeQueries[i];\\n        maxSegmentSum[i] = currentMax;\\n        unionFind.rank[query] = nums[query];\\n\\n        if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n        }\\n        if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n        }\\n        currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n    }\\n    return maxSegmentSum;\\n};\\n\\nclass UnionFind {\\n\\n    constructor(sizeInput) {\\n        this.parent = Array.from(new Array(sizeInput).keys());\\n        this.rank = new Array(sizeInput).fill(0);\\n    }\\n\\n    findParent(index) {\\n        if (this.parent[index] !== index) {\\n            this.parent[index] = this.findParent(this.parent[index]);\\n        }\\n        return this.parent[index];\\n    }\\n\\n    joinByRank(indexOne, indexTwo) {\\n        if (this.rank[indexOne] >= this.rank[indexTwo]) {\\n            this.rank[indexOne] += this.rank[indexTwo];\\n            this.parent[indexTwo] = indexOne;\\n        } else {\\n            this.rank[indexTwo] += this.rank[indexOne];\\n            this.parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2489258,
                "title": "c-recursive-solution-bruteforce",
                "content": "```\\nclass Solution {\\n      vector<long long> ans;\\n      int i=0;\\npublic:\\n    long long Sum(vector<int>& nums){\\n        vector<long long> vec;\\n        int flag=0;\\n        long long sum=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                vec.push_back(sum);\\n                sum=0;\\n                flag=1;\\n            } \\n            else sum += x;\\n        }\\n        if(flag==1) vec.push_back(sum);\\n        return *max_element(vec.begin(),vec.end());\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n      \\n        //rec case\\n        if(i==nums.size()){\\n            return ans;\\n        }\\n        nums[removeQueries[i]] = 0;\\n        ans.push_back(Sum(nums));\\n        i++;\\n        return maximumSegmentSum(nums, removeQueries);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n      vector<long long> ans;\\n      int i=0;\\npublic:\\n    long long Sum(vector<int>& nums){\\n        vector<long long> vec;\\n        int flag=0;\\n        long long sum=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                vec.push_back(sum);\\n                sum=0;\\n                flag=1;\\n            } \\n            else sum += x;\\n        }\\n        if(flag==1) vec.push_back(sum);\\n        return *max_element(vec.begin(),vec.end());\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n      \\n        //rec case\\n        if(i==nums.size()){\\n            return ans;\\n        }\\n        nums[removeQueries[i]] = 0;\\n        ans.push_back(Sum(nums));\\n        i++;\\n        return maximumSegmentSum(nums, removeQueries);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484414,
                "title": "c-solution-using-sets-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n=nums.size();  \\n        long long int pref[n+1];\\n        pref[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pref[i+1]=pref[i]+nums[i];\\n        }\\n        \\n        set<int>idx;\\n        multiset<long long int>s;\\n        s.insert(pref[n]);\\n        idx.insert(0);\\n        idx.insert(n+1);\\n        \\n        vector<long long>ans;\\n        \\n        for(auto it:removeQueries)\\n        {\\n            it++;\\n            auto itt=idx.upper_bound(it);\\n            int sec=*itt;\\n            itt--;\\n            int f=*itt;\\n            \\n            long long int val=pref[sec-1]-pref[f];\\n           \\n            auto xi=s.find(val);\\n            if(xi!=s.end())\\n            s.erase(xi);\\n            \\n            s.insert(pref[it-1]-pref[f]);\\n            s.insert(pref[sec-1]-pref[it]);\\n            idx.insert(it);\\n            \\n            ans.push_back(*s.rbegin());    \\n        }\\n        return ans;   \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n=nums.size();  \\n        long long int pref[n+1];\\n        pref[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pref[i+1]=pref[i]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483475,
                "title": "o-nlogn-priority-queue-map-prefixsum-cpp",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    //initializing\\n    int n;\\n    vector<int>a;\\n    map<int,int>m;//indices of elements that have been removed!\\n    priority_queue<array<ll,3>>pq;//store sum as well as thier bounded range and sorting on the basis of maximum sum\\n    vector<ll>pre;//stores the prefix sum\\n    vector<ll>ans;\\n    \\n    //insertion into priority queue\\n    void insert(int l,int r){\\n        if(l<0||l>=n||r<0||r>=n||l>r)return;\\n        ll sum=pre[r+1]-pre[l];\\n        auto x={sum,(ll)l,(ll)r};\\n        pq.push({sum,l,r});\\n    }\\n\\n    //finding the highest segment sum\\n    ll fun(){\\n        if(pq.empty())return 0;\\n        auto x=pq.top();\\n        auto itr=m.lower_bound(x[1]);\\n        if(itr==m.end())\\n            return x[0];\\n        else{\\n            if(x[2]<itr->first)\\n                return x[0];\\n            else{\\n                pq.pop();\\n                return fun();\\n            }\\n        }\\n    }\\n    \\n    //main function\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        a=nums;\\n        n=a.size();\\n        \\n        //prefix sum\\n        pre.resize(n+1);\\n        pre[0]=0;\\n        for(int i=1;i<=n;i++){\\n            pre[i]=a[i-1]+pre[i-1];\\n        }\\n        \\n        //handling queries\\n        for(auto i:q){\\n            m[i]=1;\\n            \\n            //right segment\\n            auto r=m.upper_bound(i);\\n            if(r==m.end())insert(i+1,n-1);\\n            else insert(i+1,r->first-1);\\n            \\n            //left segment\\n            auto l=m.lower_bound(i);\\n            if(l==m.begin())insert(0,i-1);\\n            else insert(prev(l)->first+1,i-1);\\n\\n            //maximum among segments\\n            ans.push_back(fun());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    //initializing\\n    int n;\\n    vector<int>a;\\n    map<int,int>m;//indices of elements that have been removed!\\n    priority_queue<array<ll,3>>pq;//store sum as well as thier bounded range and sorting on the basis of maximum sum\\n    vector<ll>pre;//stores the prefix sum\\n    vector<ll>ans;\\n    \\n    //insertion into priority queue\\n    void insert(int l,int r){\\n        if(l<0||l>=n||r<0||r>=n||l>r)return;\\n        ll sum=pre[r+1]-pre[l];\\n        auto x={sum,(ll)l,(ll)r};\\n        pq.push({sum,l,r});\\n    }\\n\\n    //finding the highest segment sum\\n    ll fun(){\\n        if(pq.empty())return 0;\\n        auto x=pq.top();\\n        auto itr=m.lower_bound(x[1]);\\n        if(itr==m.end())\\n            return x[0];\\n        else{\\n            if(x[2]<itr->first)\\n                return x[0];\\n            else{\\n                pq.pop();\\n                return fun();\\n            }\\n        }\\n    }\\n    \\n    //main function\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        a=nums;\\n        n=a.size();\\n        \\n        //prefix sum\\n        pre.resize(n+1);\\n        pre[0]=0;\\n        for(int i=1;i<=n;i++){\\n            pre[i]=a[i-1]+pre[i-1];\\n        }\\n        \\n        //handling queries\\n        for(auto i:q){\\n            m[i]=1;\\n            \\n            //right segment\\n            auto r=m.upper_bound(i);\\n            if(r==m.end())insert(i+1,n-1);\\n            else insert(i+1,r->first-1);\\n            \\n            //left segment\\n            auto l=m.lower_bound(i);\\n            if(l==m.begin())insert(0,i-1);\\n            else insert(prev(l)->first+1,i-1);\\n\\n            //maximum among segments\\n            ans.push_back(fun());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482936,
                "title": "simple-set-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define pll pair<ll,ll>\\n    #define f first\\n    #define s second\\n    vector<ll>ps;\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll>v;\\n        ll ss=0;\\n        for(auto i:nums){v.push_back(i); ss+=i;}\\n        ll n=nums.size();\\n        ps=v;\\n        partial_sum(begin(v),end(v),begin(ps));\\n        map<ll,ll,greater<ll>>m;\\n        m[ss]++;\\n        m[0]++;\\n        vector<ll>ans; \\n        set<pll>s={{0,n-1}};\\n\\t   for(auto i:removeQueries){\\n\\t\\tauto ptr=s.upper_bound({i,INT_MAX});\\n\\tptr--;\\n\\tauto pp=*ptr;\\n\\ts.erase(pp);\\n\\tauto kk=ps[pp.s]-ps[pp.f]+v[pp.f];\\n\\tm[kk]--;\\n\\tif(m[kk]==0){m.erase(kk);}\\n\\tif(pp.f<i and i<pp.s){\\n\\t\\ts.insert({pp.f,i-1});\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[i-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse if(pp.f==i and pp.s==i){\\n\\n\\t}\\n\\telse if(pp.f==i){\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse {\\n\\t\\ts.insert({pp.f,pp.s-1});\\n\\t\\tss=ps[pp.s-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t}\\n\\n\\tans.push_back(begin(m)->first);\\n}\\nreturn ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define pll pair<ll,ll>\\n    #define f first\\n    #define s second\\n    vector<ll>ps;\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll>v;\\n        ll ss=0;\\n        for(auto i:nums){v.push_back(i); ss+=i;}\\n        ll n=nums.size();\\n        ps=v;\\n        partial_sum(begin(v),end(v),begin(ps));\\n        map<ll,ll,greater<ll>>m;\\n        m[ss]++;\\n        m[0]++;\\n        vector<ll>ans; \\n        set<pll>s={{0,n-1}};\\n\\t   for(auto i:removeQueries){\\n\\t\\tauto ptr=s.upper_bound({i,INT_MAX});\\n\\tptr--;\\n\\tauto pp=*ptr;\\n\\ts.erase(pp);\\n\\tauto kk=ps[pp.s]-ps[pp.f]+v[pp.f];\\n\\tm[kk]--;\\n\\tif(m[kk]==0){m.erase(kk);}\\n\\tif(pp.f<i and i<pp.s){\\n\\t\\ts.insert({pp.f,i-1});\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[i-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse if(pp.f==i and pp.s==i){\\n\\n\\t}\\n\\telse if(pp.f==i){\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse {\\n\\t\\ts.insert({pp.f,pp.s-1});\\n\\t\\tss=ps[pp.s-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t}\\n\\n\\tans.push_back(begin(m)->first);\\n}\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482723,
                "title": "c-python-dsu",
                "content": "TC : O(n)\\nSC: O(n)\\nPre-Requisites: Union-Find/DSU\\nImplement queries in reverse order and keep joining disjoint sets by checking with neighbouring indices and update size(sum of all nos in that set) in every union function call.\\n\\nC++ -> \\n\\n```\\nclass Solution {\\npublic:\\n    vector <long long> parent,size;\\n    pair<long long,long long> find(int x){\\n        if (parent[x]==x) return make_pair(parent[x],size[x]);\\n        auto res=find(parent[x]);\\n        return res;\\n    }\\n    \\n    void Union(int x,int y){\\n        auto r1=find(x);\\n        auto r2=find(y);\\n        if (r1.first!=r2.first){\\n            parent[r2.first]=r1.first;\\n            size[r1.first]+=size[r2.first];\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Q) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        vector <long long> ans(n);\\n        vector <int> seen(n,0);\\n        vector <long long> Parent(n),Size(n);\\n        vector <pair<int,int>> queries;\\n        for (int i=0;i<n;i++){\\n            Parent[i]=i;\\n            Size[i]=nums[i];\\n            queries.push_back(make_pair(i,Q[i]));\\n        }\\n        parent=Parent;\\n        size=Size;\\n        reverse(queries.begin(),queries.end());\\n        long long mmax=0;\\n        for (int k=0;k<n;k++){\\n            int idx=queries[k].first,i=queries[k].second;\\n            ans[idx]=mmax;\\n            if (i-1>=0 && seen[i-1]){\\n                Union(i-1,i);\\n                auto res=find(i-1);\\n                mmax=max(mmax,res.second);\\n            }\\n            if (i+1<n && seen[i+1]){\\n                Union(i,i+1);\\n                auto res=find(i+1);\\n                mmax=max(mmax,res.second);\\n            }\\n            mmax=max(mmax,size[i]);\\n            seen[i]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython ->\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        queries=[(i,val) for i,val in enumerate(queries)]\\n        queries=queries[::-1]\\n        ans=[-1]*n\\n        parent=[i for i in range(n)]\\n        size=[num for num in nums]\\n        def find(x):\\n            if parent[x]==x:\\n                return parent[x],size[x]\\n            parent[x],size[x]=find(parent[x])\\n            return parent[x],size[x]\\n        def union(x,y):\\n            r1,_=find(x)\\n            r2,_=find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n        mmax=0\\n        seen=[0]*n\\n        for idx,i in queries:\\n            ans[idx]=mmax\\n            if i-1>=0 and seen[i-1]:\\n                union(i-1,i)\\n                _,res=find(i-1)\\n                mmax=max(mmax,res)\\n            if i+1<n and seen[i+1]:\\n                union(i,i+1)\\n                _,res=find(i+1)\\n                mmax=max(mmax,res)\\n            mmax=max(mmax,size[i])\\n            seen[i]=1\\n        return ans\\n        \\n```\\n\\nPlz Upvote!!!",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <long long> parent,size;\\n    pair<long long,long long> find(int x){\\n        if (parent[x]==x) return make_pair(parent[x],size[x]);\\n        auto res=find(parent[x]);\\n        return res;\\n    }\\n    \\n    void Union(int x,int y){\\n        auto r1=find(x);\\n        auto r2=find(y);\\n        if (r1.first!=r2.first){\\n            parent[r2.first]=r1.first;\\n            size[r1.first]+=size[r2.first];\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Q) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        vector <long long> ans(n);\\n        vector <int> seen(n,0);\\n        vector <long long> Parent(n),Size(n);\\n        vector <pair<int,int>> queries;\\n        for (int i=0;i<n;i++){\\n            Parent[i]=i;\\n            Size[i]=nums[i];\\n            queries.push_back(make_pair(i,Q[i]));\\n        }\\n        parent=Parent;\\n        size=Size;\\n        reverse(queries.begin(),queries.end());\\n        long long mmax=0;\\n        for (int k=0;k<n;k++){\\n            int idx=queries[k].first,i=queries[k].second;\\n            ans[idx]=mmax;\\n            if (i-1>=0 && seen[i-1]){\\n                Union(i-1,i);\\n                auto res=find(i-1);\\n                mmax=max(mmax,res.second);\\n            }\\n            if (i+1<n && seen[i+1]){\\n                Union(i,i+1);\\n                auto res=find(i+1);\\n                mmax=max(mmax,res.second);\\n            }\\n            mmax=max(mmax,size[i]);\\n            seen[i]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        queries=[(i,val) for i,val in enumerate(queries)]\\n        queries=queries[::-1]\\n        ans=[-1]*n\\n        parent=[i for i in range(n)]\\n        size=[num for num in nums]\\n        def find(x):\\n            if parent[x]==x:\\n                return parent[x],size[x]\\n            parent[x],size[x]=find(parent[x])\\n            return parent[x],size[x]\\n        def union(x,y):\\n            r1,_=find(x)\\n            r2,_=find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n        mmax=0\\n        seen=[0]*n\\n        for idx,i in queries:\\n            ans[idx]=mmax\\n            if i-1>=0 and seen[i-1]:\\n                union(i-1,i)\\n                _,res=find(i-1)\\n                mmax=max(mmax,res)\\n            if i+1<n and seen[i+1]:\\n                union(i,i+1)\\n                _,res=find(i+1)\\n                mmax=max(mmax,res)\\n            mmax=max(mmax,size[i])\\n            seen[i]=1\\n        return ans\\n        \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2479603,
                "title": "python-solution-using-union-find",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        def findParent(parent,val):\\n            if parent[val]==val:\\n                return val\\n            parent[val]=findParent(parent,parent[val])\\n            return parent[val]\\n        def union(a,b,rank,parent):\\n            parentA=findParent(parent,a)\\n            parentB=findParent(parent,b)\\n            if rank[parentA] > rank[parentB]:\\n                parent[parentB]=parentA\\n            elif rank[parentB] > rank[parentA]:\\n                parent[parentA]=parentB\\n            else:\\n                rank[parentA]+=1\\n                parent[parentB]=parentA\\n        res=[0]\\n        maxx=0\\n        rank={i:0 for i in range(-1,len(nums)+1)}\\n        parent={i:i for i in range(-1,len(nums)+1)}\\n        val=rank.copy()\\n        while removeQueries:\\n            i=removeQueries.pop()\\n            v=nums[i]\\n            val[i]=v\\n            if val[i-1]!=0:\\n                parentA=findParent(parent,i-1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            if val[i+1]!=0:\\n                parentA=findParent(parent,i+1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            maxx=max(maxx,v)\\n            res.append(maxx)\\n        res.pop()\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        def findParent(parent,val):\\n            if parent[val]==val:\\n                return val\\n            parent[val]=findParent(parent,parent[val])\\n            return parent[val]\\n        def union(a,b,rank,parent):\\n            parentA=findParent(parent,a)\\n            parentB=findParent(parent,b)\\n            if rank[parentA] > rank[parentB]:\\n                parent[parentB]=parentA\\n            elif rank[parentB] > rank[parentA]:\\n                parent[parentA]=parentB\\n            else:\\n                rank[parentA]+=1\\n                parent[parentB]=parentA\\n        res=[0]\\n        maxx=0\\n        rank={i:0 for i in range(-1,len(nums)+1)}\\n        parent={i:i for i in range(-1,len(nums)+1)}\\n        val=rank.copy()\\n        while removeQueries:\\n            i=removeQueries.pop()\\n            v=nums[i]\\n            val[i]=v\\n            if val[i-1]!=0:\\n                parentA=findParent(parent,i-1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            if val[i+1]!=0:\\n                parentA=findParent(parent,i+1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            maxx=max(maxx,v)\\n            res.append(maxx)\\n        res.pop()\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479330,
                "title": "intuition-of-prefix-sums-upper-bound-multisets-c-in-hindi",
                "content": "It was a great learning experience solving this challenge. Prefix sums, C++ Multiset, Upper Bound were the concepts used.\\nMy thought process from brute to optimal below :\\nIn case you prefer video solution, please refer :https://youtu.be/lZht4j2Ux-c\\n\\n\\nNaive solution: After every remove query, find the sum to remove and add new subset sums\\nby calculating it through iteration. O(N*N)\\n\\nOptimal: If we track subset sum in one set and subset ranges in another set then for\\nevery query we can find relevant subset by using binary search and update both\\nthe segments as well as the sum values.\\nex: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\ncurrent_segments = {0, 4}\\nremove = 0 new_segments = {1, 4} sums = {14}\\nremove = 3 new_segments = {1, 2} {4, 4} sums = {7, 1}\\nremove = 2 new_segments = {1, 1} {4, 4} sums = {2 ,1}",
                "solutionTags": [],
                "code": "It was a great learning experience solving this challenge. Prefix sums, C++ Multiset, Upper Bound were the concepts used.\\nMy thought process from brute to optimal below :\\nIn case you prefer video solution, please refer :https://youtu.be/lZht4j2Ux-c\\n\\n\\nNaive solution: After every remove query, find the sum to remove and add new subset sums\\nby calculating it through iteration. O(N*N)\\n\\nOptimal: If we track subset sum in one set and subset ranges in another set then for\\nevery query we can find relevant subset by using binary search and update both\\nthe segments as well as the sum values.\\nex: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\ncurrent_segments = {0, 4}\\nremove = 0 new_segments = {1, 4} sums = {14}\\nremove = 3 new_segments = {1, 2} {4, 4} sums = {7, 1}\\nremove = 2 new_segments = {1, 1} {4, 4} sums = {2 ,1}",
                "codeTag": "Unknown"
            },
            {
                "id": 2478641,
                "title": "set-of-pairs",
                "content": "#include<bits/stdc++.h>\\nusing namespace std;\\n\\n//leetcode link : https://leetcode.com/problems/maximum-segment-sum-after-removals/\\n//approach=> is that first we find that interval in which the index lying => after that we divide that interval\\n//and this should be done in efficient time complexity that\\'s why i have used set of pairs and mulst to store sums of intervals that are present in the set\\n//time complexity = >O(nlogn)\\n//space complexity = O(n)\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n  = nums.size();\\n        //set to store intervals\\n        set<pair<int,int>>st;\\n        //multiset to store sums\\n        multiset<long long>mulst;\\n\\n        //prefix sum array\\n        vector<long long>prefix_sum(n,nums[0]);\\n        for(int i = 1;i<n;i++)\\n        prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n\\n        st.insert({0,n-1});\\n        mulst.insert(prefix_sum[n-1]);\\n        //if no element left then sum is zero\\n        mulst.insert(0);\\n         vector<long long>res;\\n        for(int i = 0;i<n;i++)\\n        {\\n             auto it = st.upper_bound({removeQueries[i],INT_MAX});\\n             it--;\\n             long long left_sum = (removeQueries[i]>0 ? prefix_sum[removeQueries[i]-1]:0)-(it->first>0?prefix_sum[it->first -1]:0);\\n             long long right_sum = prefix_sum[it->second]-prefix_sum[removeQueries[i]];\\n\\n             //push left interval\\n             if(it->first<removeQueries[i])\\n             {\\n                 st.insert({it->first,removeQueries[i]-1});\\n                 //insert left interval sum also\\n                 mulst.insert(left_sum);\\n             }\\n             //push right interval\\n             if(it->second>removeQueries[i])\\n             {\\n                 st.insert({removeQueries[i]+1,it->second});\\n                 //insert right interval sum also\\n                 mulst.insert(right_sum);\\n             }\\n             //erase the sum of the interval that we have divided\\n             long long sum = prefix_sum[it->second]-(it->first>0?prefix_sum[it->first -1]:0);\\n             mulst.erase(mulst.find(sum));\\n             //also erase the interval aslo\\n             st.erase(it);\\n             res.push_back(*mulst.rbegin());\\n        }\\n        return res;\\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n  = nums.size();\\n        //set to store intervals\\n        set<pair<int,int>>st;\\n        //multiset to store sums\\n        multiset<long long>mulst;\\n\\n        //prefix sum array\\n        vector<long long>prefix_sum(n,nums[0]);\\n        for(int i = 1;i<n;i++)\\n        prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n\\n        st.insert({0,n-1}",
                "codeTag": "Java"
            },
            {
                "id": 2477482,
                "title": "python3-o-n-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        #### reverse adding\\n        # N[i] = [s, e, sum]\\n        # where s is the start index of the segment that contains nums[i], e is the end index, and sum is the summation of segment\\n        N = defaultdict(list)\\n        ret = [0]       # result after all elements are removed\\n        max_seg = 0\\n        \\n        removeQueries.reverse()\\n        # Taking example 1 as instance: removeQueries = [1,4,2,3,0]\\n        # before iterations: [0 0 0 0 0] ==> max = 0\\n        # after iteration 0: [0 2 0 0 0] ==> max = max(0, 2) = 2                                    : sum_seg(2) = 2\\n        # after iteration 1: [0 2 0 0 1] ==> max = max(2, 1) = 2                                    : sum_seg(1) = 1\\n        # after iteration 2: [0 2 5 0 1] ==> max = max(2, sum_seg(2)+5) = 7                         : sum_seg(2,5) = 7\\n        # after iteration 3: [0 2 5 6 1] ==> max = max(7, sum_seg(2,5) + 6 + sum_seg(1)) = 14       : sum_seg(2,5,6,1) = 14\\n        # after iteration 4: [1 2 5 6 1] ==> max = max(14, 1 + sum_seg(2,5,6,1)) = 15               : sum_all = 15\\n        \\n        for i in removeQueries:\\n            # segment that only contains nums[i]\\n            cur = nums[i]\\n            N[i] = [i, i, cur]\\n            \\n            # concatenate segment(nums[i]) with its nearby segments if exist\\n            if N[i-1] != []:\\n                cur += N[i-1][2]\\n                s = N[i-1][0]\\n                e = N[i][1]\\n                # update segment\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n            \\n            if N[i+1] != []:\\n                cur += N[i+1][2]\\n                s = N[i][0]\\n                e = N[i+1][1]\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n                \\n            max_seg = max(max_seg, cur)\\n            ret.append(max_seg)\\n         \\n        ret.reverse()\\n        ret = ret[1:]\\n        return ret\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        #### reverse adding\\n        # N[i] = [s, e, sum]\\n        # where s is the start index of the segment that contains nums[i], e is the end index, and sum is the summation of segment\\n        N = defaultdict(list)\\n        ret = [0]       # result after all elements are removed\\n        max_seg = 0\\n        \\n        removeQueries.reverse()\\n        # Taking example 1 as instance: removeQueries = [1,4,2,3,0]\\n        # before iterations: [0 0 0 0 0] ==> max = 0\\n        # after iteration 0: [0 2 0 0 0] ==> max = max(0, 2) = 2                                    : sum_seg(2) = 2\\n        # after iteration 1: [0 2 0 0 1] ==> max = max(2, 1) = 2                                    : sum_seg(1) = 1\\n        # after iteration 2: [0 2 5 0 1] ==> max = max(2, sum_seg(2)+5) = 7                         : sum_seg(2,5) = 7\\n        # after iteration 3: [0 2 5 6 1] ==> max = max(7, sum_seg(2,5) + 6 + sum_seg(1)) = 14       : sum_seg(2,5,6,1) = 14\\n        # after iteration 4: [1 2 5 6 1] ==> max = max(14, 1 + sum_seg(2,5,6,1)) = 15               : sum_all = 15\\n        \\n        for i in removeQueries:\\n            # segment that only contains nums[i]\\n            cur = nums[i]\\n            N[i] = [i, i, cur]\\n            \\n            # concatenate segment(nums[i]) with its nearby segments if exist\\n            if N[i-1] != []:\\n                cur += N[i-1][2]\\n                s = N[i-1][0]\\n                e = N[i][1]\\n                # update segment\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n            \\n            if N[i+1] != []:\\n                cur += N[i+1][2]\\n                s = N[i][0]\\n                e = N[i+1][1]\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n                \\n            max_seg = max(max_seg, cur)\\n            ret.append(max_seg)\\n         \\n        ret.reverse()\\n        ret = ret[1:]\\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475496,
                "title": "c-working-backwards-well-commented-priority-queue-2d-array",
                "content": "Here is the idea of my solution:\\n->Work backwards and treat the removeQueries like an \\'add\\' queries\\n->Initialize priority queue with 0 as the sum and length as the priority to represent the final max segment of any testcase\\n->Use a 2d array to store the segment sum, left index, and right index of the segment as each row of the array\\n->Check for adjacent non-zero sums to see if the current index being added needs to merge with a segment\\n->Find left and rightmost segment indexes and add sums to then update both left and right indexes of the sum with current info\\n->Keep track of the largest segment so only the past largest segment and the current one being calculated matter\\n->Add largest segment to priority queue using the current index to represent priority\\n->Dequeue all elements of priority queue into array and return\\n\\n```\\npublic class Solution {\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // each index will store the sum, left index, and right index of given segment\\n        long[,] sumStore = new long[nums.Length, 3]; \\n        // will store highest segment sum for current query\\n        PriorityQueue<long, int> maxSum = new();\\n        // last query will always be zero\\n        // assign priority as nums length and decrement for each query because dequeue returns low to high prio\\n        maxSum.Enqueue(0L, nums.Length); \\n        long sum; \\n        long pastSum = 0; // stores past highest segment sum\\n        long lI, rI; // left index and right index for given segment\\n        for(int i = removeQueries.Length-1; i > 0; i--){ //stop at index 1 because we dont care what the first removed element is\\n            sum = nums[removeQueries[i]]; // get value at index to be \\'added\\'\\n            lI = removeQueries[i]; // before checking for adjacent segments assume this is a one element segment \\n            rI = removeQueries[i];\\n            if(removeQueries[i] > 0 && sumStore[removeQueries[i]-1, 0] != 0){ // if left adjacent segment add its sum and update left most index\\n                sum += sumStore[removeQueries[i]-1, 0];\\n                lI = sumStore[removeQueries[i]-1, 1];\\n            }\\n            if(removeQueries[i] < nums.Length-1 && sumStore[removeQueries[i]+1, 0] != 0){ // same deal but check for right segment\\n                sum += sumStore[removeQueries[i]+1, 0];\\n                rI = sumStore[removeQueries[i]+1, 2];\\n            }\\n            // update current segment with sum and index values\\n            sumStore[removeQueries[i], 0] = sum;\\n            sumStore[removeQueries[i], 1] = lI;\\n            sumStore[removeQueries[i], 2] = rI;\\n            // update leftmost and rightmost index of segment with new segment info\\n            if(lI != removeQueries[i]){\\n                sumStore[lI, 0] = sum;\\n                sumStore[lI, 1] = lI;\\n                sumStore[lI, 2] = rI;\\n            }\\n            if(rI != removeQueries[i]){\\n                sumStore[rI, 0] = sum;\\n                sumStore[rI, 1] = lI;\\n                sumStore[rI, 2] = rI;\\n            }\\n            if(sum > pastSum){ // keeps track of second largest segment in case the once currently being checked is smaller\\n                pastSum = sum;\\n                maxSum.Enqueue(sum, i);\\n            }else{\\n                 maxSum.Enqueue(pastSum, i);\\n             }\\n        }\\n        long[] sol = new long[nums.Length]; // to be returned\\n        for(int j = 0; j < nums.Length; j++){ // fill return array with max segments from priority queue\\n            sol[j] = maxSum.Dequeue();\\n        }\\n        return sol;\\n    }\\n}\\n```\\n\\nIf you have any optimization tips or other data structures I could have used please leave a comment! \\nI am always trying to learn and improve my programming skills. Hope this could help someone.\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // each index will store the sum, left index, and right index of given segment\\n        long[,] sumStore = new long[nums.Length, 3]; \\n        // will store highest segment sum for current query\\n        PriorityQueue<long, int> maxSum = new();\\n        // last query will always be zero\\n        // assign priority as nums length and decrement for each query because dequeue returns low to high prio\\n        maxSum.Enqueue(0L, nums.Length); \\n        long sum; \\n        long pastSum = 0; // stores past highest segment sum\\n        long lI, rI; // left index and right index for given segment\\n        for(int i = removeQueries.Length-1; i > 0; i--){ //stop at index 1 because we dont care what the first removed element is\\n            sum = nums[removeQueries[i]]; // get value at index to be \\'added\\'\\n            lI = removeQueries[i]; // before checking for adjacent segments assume this is a one element segment \\n            rI = removeQueries[i];\\n            if(removeQueries[i] > 0 && sumStore[removeQueries[i]-1, 0] != 0){ // if left adjacent segment add its sum and update left most index\\n                sum += sumStore[removeQueries[i]-1, 0];\\n                lI = sumStore[removeQueries[i]-1, 1];\\n            }\\n            if(removeQueries[i] < nums.Length-1 && sumStore[removeQueries[i]+1, 0] != 0){ // same deal but check for right segment\\n                sum += sumStore[removeQueries[i]+1, 0];\\n                rI = sumStore[removeQueries[i]+1, 2];\\n            }\\n            // update current segment with sum and index values\\n            sumStore[removeQueries[i], 0] = sum;\\n            sumStore[removeQueries[i], 1] = lI;\\n            sumStore[removeQueries[i], 2] = rI;\\n            // update leftmost and rightmost index of segment with new segment info\\n            if(lI != removeQueries[i]){\\n                sumStore[lI, 0] = sum;\\n                sumStore[lI, 1] = lI;\\n                sumStore[lI, 2] = rI;\\n            }\\n            if(rI != removeQueries[i]){\\n                sumStore[rI, 0] = sum;\\n                sumStore[rI, 1] = lI;\\n                sumStore[rI, 2] = rI;\\n            }\\n            if(sum > pastSum){ // keeps track of second largest segment in case the once currently being checked is smaller\\n                pastSum = sum;\\n                maxSum.Enqueue(sum, i);\\n            }else{\\n                 maxSum.Enqueue(pastSum, i);\\n             }\\n        }\\n        long[] sol = new long[nums.Length]; // to be returned\\n        for(int j = 0; j < nums.Length; j++){ // fill return array with max segments from priority queue\\n            sol[j] = maxSum.Dequeue();\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475243,
                "title": "java-hashmap-simple-solution",
                "content": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(parent,-1);\\n        long ans[] = new long[n];\\n        long max = 0;\\n        Map<Integer,Long> map = new HashMap();\\n        for(int i=n-1;i>0;i--){\\n            int r = removeQueries[i];\\n            dp[r] = 1;\\n            long temp = nums[r];\\n            if(r+1 <n && dp[r+1]==1){\\n                \\n                int index = parent[r+1];\\n                int val=r+1;\\n                if(index==-1) parent[r+1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                         parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            if(r-1>=0 && dp[r-1]==1){\\n                int index = parent[r-1];\\n                int val=r-1;\\n                if(index==-1) parent[r-1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                        parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                 \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            map.put(r,temp);\\n            max = Math.max(max,temp);\\n            ans[i-1] = max;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(parent,-1);\\n        long ans[] = new long[n];\\n        long max = 0;\\n        Map<Integer,Long> map = new HashMap();\\n        for(int i=n-1;i>0;i--){\\n            int r = removeQueries[i];\\n            dp[r] = 1;\\n            long temp = nums[r];\\n            if(r+1 <n && dp[r+1]==1){\\n                \\n                int index = parent[r+1];\\n                int val=r+1;\\n                if(index==-1) parent[r+1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                         parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            if(r-1>=0 && dp[r-1]==1){\\n                int index = parent[r-1];\\n                int val=r-1;\\n                if(index==-1) parent[r-1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                        parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                 \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            map.put(r,temp);\\n            max = Math.max(max,temp);\\n            ans[i-1] = max;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2473731,
                "title": "c-map-set-prefix-sum",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        multiset<ll>Set;\\n        map<int,int>Map;\\n        Set.insert(prefix[n-1]),Map[0]=n-1;\\n        vector<ll>res;\\n        for(auto &x:removeQueries)\\n        {\\n            auto it=Map.lower_bound(x);\\n            int l=0,r=0;\\n            if(it==Map.end())\\n            {\\n                auto cur=*Map.rbegin();\\n                l=cur.first,r=cur.second;\\n            }else\\n            {\\n                if(it->first>x)it--;\\n                l=it->first;\\n                r=it->second;\\n            }\\n            ll tot=prefix[r]-(l-1>=0 ? prefix[l-1] : 0);\\n            Set.erase(Set.find(tot));\\n            Map.erase(l);\\n            if((r-l)!=0)\\n            {\\n                if(l==x)Set.insert(prefix[r]-prefix[l]),Map[l+1]=r;\\n                else if(r==x)Set.insert(prefix[r-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=r-1;\\n                else\\n                {\\n                    Set.insert(prefix[x-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=x-1;\\n                    Set.insert(prefix[r]-prefix[x]),Map[x+1]=r;\\n                }\\n            }\\n            if(Set.size()>0)res.push_back(*Set.rbegin());\\n            else res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        multiset<ll>Set;\\n        map<int,int>Map;\\n        Set.insert(prefix[n-1]),Map[0]=n-1;\\n        vector<ll>res;\\n        for(auto &x:removeQueries)\\n        {\\n            auto it=Map.lower_bound(x);\\n            int l=0,r=0;\\n            if(it==Map.end())\\n            {\\n                auto cur=*Map.rbegin();\\n                l=cur.first,r=cur.second;\\n            }else\\n            {\\n                if(it->first>x)it--;\\n                l=it->first;\\n                r=it->second;\\n            }\\n            ll tot=prefix[r]-(l-1>=0 ? prefix[l-1] : 0);\\n            Set.erase(Set.find(tot));\\n            Map.erase(l);\\n            if((r-l)!=0)\\n            {\\n                if(l==x)Set.insert(prefix[r]-prefix[l]),Map[l+1]=r;\\n                else if(r==x)Set.insert(prefix[r-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=r-1;\\n                else\\n                {\\n                    Set.insert(prefix[x-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=x-1;\\n                    Set.insert(prefix[r]-prefix[x]),Map[x+1]=r;\\n                }\\n            }\\n            if(Set.size()>0)res.push_back(*Set.rbegin());\\n            else res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472697,
                "title": "c-prefix-sum-map-priority-queue",
                "content": "**Intuition:**\\n\\nFirstly, Create a vector dp contains `dp[i] = nums[0] + ... + nums[i-1]`, so we can use `dp[j+1] - dp[i]` to find range sum in constant time.\\n\\nWe use map to mark every range that haven\\'t been removed for every element, and update it in every `removeQueries`.\\n\\nHence, we use `priority_queue` to find the maximum, since we have already updated range in `map`, if we encounters those with different range with current range, discard that.\\n\\n**Code**\\n```\\n#define ll long long\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rmQueries) {\\n\\tint n = nums.size();\\n\\tvector<ll> dp(n+1);\\n\\tll acc = 0;\\n\\tfor(int i = 0; i < n; i++) \\n\\t\\tdp[i+1] = acc += nums[i];\\n\\n\\tvector<ll> res;\\n\\tmap<int,int> ran;\\n\\tpriority_queue<array<ll,3>> pq;\\n\\tpq.push({dp.back(), 0, n-1});\\n\\tran[0] = n-1;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tauto it = --ran.upper_bound(rmQueries[i]);\\n\\n\\t\\tif(rmQueries[i]+1 < n && ran.find(rmQueries[i]+1) == ran.end()) {\\n\\t\\t\\tran[rmQueries[i]+1] = it->second;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[rmQueries[i]+1], rmQueries[i]+1, it->second});                \\n\\t\\t}\\n\\n\\t\\tif(rmQueries[i] == it->first)\\n\\t\\t\\tran.erase(rmQueries[i]);\\n\\t\\telse {\\n\\t\\t\\tit->second = rmQueries[i]-1;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[it->first], it->first, it->second});             \\n\\t\\t}\\n\\n\\t\\twhile(!pq.empty() && (ran.find(pq.top()[1]) == ran.end() || pq.top()[2] != ran[pq.top()[1]]))\\n\\t\\t\\tpq.pop();\\n\\n\\t\\tif(pq.empty())\\n\\t\\t\\tres.push_back(0);\\n\\t\\telse\\n\\t\\t\\tres.push_back(pq.top()[0]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n**Complexity Analysis**\\n\\n**Time:** `O(n*log(n))`\\n**Space:** `O(n)`\\n\\n**If you consider this helpful, please consider upvote. It meant a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rmQueries) {\\n\\tint n = nums.size();\\n\\tvector<ll> dp(n+1);\\n\\tll acc = 0;\\n\\tfor(int i = 0; i < n; i++) \\n\\t\\tdp[i+1] = acc += nums[i];\\n\\n\\tvector<ll> res;\\n\\tmap<int,int> ran;\\n\\tpriority_queue<array<ll,3>> pq;\\n\\tpq.push({dp.back(), 0, n-1});\\n\\tran[0] = n-1;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tauto it = --ran.upper_bound(rmQueries[i]);\\n\\n\\t\\tif(rmQueries[i]+1 < n && ran.find(rmQueries[i]+1) == ran.end()) {\\n\\t\\t\\tran[rmQueries[i]+1] = it->second;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[rmQueries[i]+1], rmQueries[i]+1, it->second});                \\n\\t\\t}\\n\\n\\t\\tif(rmQueries[i] == it->first)\\n\\t\\t\\tran.erase(rmQueries[i]);\\n\\t\\telse {\\n\\t\\t\\tit->second = rmQueries[i]-1;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[it->first], it->first, it->second});             \\n\\t\\t}\\n\\n\\t\\twhile(!pq.empty() && (ran.find(pq.top()[1]) == ran.end() || pq.top()[2] != ran[pq.top()[1]]))\\n\\t\\t\\tpq.pop();\\n\\n\\t\\tif(pq.empty())\\n\\t\\t\\tres.push_back(0);\\n\\t\\telse\\n\\t\\t\\tres.push_back(pq.top()[0]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2471593,
                "title": "simple-solution-using-dsu-and-multiset-keep-on-merging-the-adjacent-segments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<long long> parent, sum;\\n    multiset<long long> mst;\\n    \\n    void make(int v){\\n        parent[v] = v;\\n        sum[v] = 0;\\n        mst.insert(0);\\n    }\\n    \\n    int find(int v){\\n        if(parent[v] == v){\\n            return v;\\n        }\\n        return find(parent[v]);\\n    }\\n    \\n    void Union(int a, int b){\\n        a = find(a); b = find(b);\\n        if(a != b){\\n            parent[b] = a;\\n            \\n            auto it = mst.find(sum[b]);\\n            mst.erase(it);\\n            it = mst.find(sum[a]);\\n            mst.erase(it);\\n            sum[a] += sum[b];\\n            mst.insert(sum[a]);\\n        }\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        parent.resize(n+1);\\n        sum.resize(n+1);\\n        mst.clear();\\n        \\n        for(int i=1; i<=n; i++){\\n            make(i);\\n        }\\n        vector<long long> ans;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int rm = removeQueries[i]+1;\\n            ans.push_back(*(--mst.end()));\\n            \\n            auto it = mst.find(sum[rm]);\\n            mst.erase(it);\\n            sum[rm] = nums[rm-1];\\n            mst.insert(sum[rm]);\\n            \\n            if(rm > 1 and sum[rm-1] != 0){\\n                Union(rm , rm-1);\\n            }\\n            if(rm < n and sum[rm+1] != 0){\\n                Union(rm, rm+1);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<long long> parent, sum;\\n    multiset<long long> mst;\\n    \\n    void make(int v){\\n        parent[v] = v;\\n        sum[v] = 0;\\n        mst.insert(0);\\n    }\\n    \\n    int find(int v){\\n        if(parent[v] == v){\\n            return v;\\n        }\\n        return find(parent[v]);\\n    }\\n    \\n    void Union(int a, int b){\\n        a = find(a); b = find(b);\\n        if(a != b){\\n            parent[b] = a;\\n            \\n            auto it = mst.find(sum[b]);\\n            mst.erase(it);\\n            it = mst.find(sum[a]);\\n            mst.erase(it);\\n            sum[a] += sum[b];\\n            mst.insert(sum[a]);\\n        }\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        parent.resize(n+1);\\n        sum.resize(n+1);\\n        mst.clear();\\n        \\n        for(int i=1; i<=n; i++){\\n            make(i);\\n        }\\n        vector<long long> ans;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int rm = removeQueries[i]+1;\\n            ans.push_back(*(--mst.end()));\\n            \\n            auto it = mst.find(sum[rm]);\\n            mst.erase(it);\\n            sum[rm] = nums[rm-1];\\n            mst.insert(sum[rm]);\\n            \\n            if(rm > 1 and sum[rm-1] != 0){\\n                Union(rm , rm-1);\\n            }\\n            if(rm < n and sum[rm+1] != 0){\\n                Union(rm, rm+1);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471155,
                "title": "c-bit-approach-difference-array",
                "content": "Algorithm: \\nAfter each operation we divide the current range to two halves left and right.\\nWe remove the range curr elements belongs to and add 2 new ranges i.e left and right\\nBut the problem is we need to know the range for each element after new updation i.e we need to do range updation\\n\\nFor range updation we can use BIT + difference array \\n\\nDS used:\\nmultisets: for maximum sum\\nmap: for information about each range i.e lowerbound upperbound and sum\\nBIT: update the new range\\n\\n\\n````\\nclass BIT {\\n    int n;\\n    vector<long long>  v;\\npublic:\\n\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n\\n    long long sum(int k) {\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n        return sum;\\n    }\\n\\n    void add(int k , int x) {\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\nint cnt = 0;\\nmap < int, vector<long long> > range;\\nmultiset<long long> s;\\n\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\n    int n = nums.size();\\n    vector<long long> diff(n + 1, 0), prefix(n + 1, 0),ans; //difference array\\n    for (int i = 0; i < n; i++) {\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n\\n    BIT T(diff.size());\\n    s.insert(-prefix[n]);   //insert negative for maximum\\n    range[0] = {1, n, prefix[n]};     //now follow one based indexing\\n\\n\\n    for (int index : removeQueries) {\\n        index++;\\n        int currRange = T.sum(index);   //curr range of element\\n\\n        //dimensions of range\\n        int start = range[currRange][0] , end = range[currRange][1];\\n        long long currSum = range[currRange][2];\\n\\n\\n        //remove that sum from set\\n        auto it = s.find(-currSum);\\n        s.erase(it);\\n\\n        //remove currrange from map\\n        range.erase(currRange);\\n\\n        //partition into two parts l to index-1 and index+1 to r\\n        if (start <= index - 1) {\\n            cnt++;//we need new range\\n            int l = start , r = index - 1;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        if (index + 1 <= end) {\\n            cnt++;//we need new range\\n            int l = index + 1 , r = end;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        auto itr = s.begin();\\n        ans.push_back(-(*itr));\\n    }\\n    \\n    return ans;\\n\\n}\\n\\n};\\n````",
                "solutionTags": [],
                "code": "````\\nclass BIT {\\n    int n;\\n    vector<long long>  v;\\npublic:\\n\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n\\n    long long sum(int k) {\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n        return sum;\\n    }\\n\\n    void add(int k , int x) {\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\nint cnt = 0;\\nmap < int, vector<long long> > range;\\nmultiset<long long> s;\\n\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\n    int n = nums.size();\\n    vector<long long> diff(n + 1, 0), prefix(n + 1, 0),ans; //difference array\\n    for (int i = 0; i < n; i++) {\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n\\n    BIT T(diff.size());\\n    s.insert(-prefix[n]);   //insert negative for maximum\\n    range[0] = {1, n, prefix[n]};     //now follow one based indexing\\n\\n\\n    for (int index : removeQueries) {\\n        index++;\\n        int currRange = T.sum(index);   //curr range of element\\n\\n        //dimensions of range\\n        int start = range[currRange][0] , end = range[currRange][1];\\n        long long currSum = range[currRange][2];\\n\\n\\n        //remove that sum from set\\n        auto it = s.find(-currSum);\\n        s.erase(it);\\n\\n        //remove currrange from map\\n        range.erase(currRange);\\n\\n        //partition into two parts l to index-1 and index+1 to r\\n        if (start <= index - 1) {\\n            cnt++;//we need new range\\n            int l = start , r = index - 1;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        if (index + 1 <= end) {\\n            cnt++;//we need new range\\n            int l = index + 1 , r = end;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        auto itr = s.begin();\\n        ans.push_back(-(*itr));\\n    }\\n    \\n    return ans;\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469670,
                "title": "disjoint-set-or-union-find-template-python3",
                "content": "The Disjoint Set(or Union-Find) class template is universal. For this specific problem, one observation is we can maintain segments from the end to the start of the queries to find the maximum segment sum.\\n\\nSince the template only gives us information about whether two elements belong to the same group, the only tricky part is how to keep track of the size information. So we need a Counter `segments` for creating a new group and merging existing groups.\\n\\n``` py\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n\\n    def find(self, x):\\n        if self.p[x]!=x: self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        self.p[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def maximumSegmentSum(self, A: List[int], Q: List[int]) -> List[int]:\\n        dsu = DSU(len(A))\\n        ans, mx, segments = [], 0, Counter()\\n        for x in reversed(Q):\\n            ans.append(mx)\\n            l, r = 0, 0\\n            if x+1<len(A):\\n                r = segments[dsu.find(x+1)]\\n                if r:\\n                    dsu.union(x, x+1)\\n                    segments.pop(dsu.find(x+1))\\n            if x-1>=0:\\n                l = segments[dsu.find(x-1)]\\n                if l:\\n                    dsu.union(x, x-1)\\n                    segments.pop(dsu.find(x-1))\\n            segments[dsu.find(x)] += l+r+A[x]\\n            mx = max(mx, segments[dsu.find(x)])\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "``` py\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n\\n    def find(self, x):\\n        if self.p[x]!=x: self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        self.p[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def maximumSegmentSum(self, A: List[int], Q: List[int]) -> List[int]:\\n        dsu = DSU(len(A))\\n        ans, mx, segments = [], 0, Counter()\\n        for x in reversed(Q):\\n            ans.append(mx)\\n            l, r = 0, 0\\n            if x+1<len(A):\\n                r = segments[dsu.find(x+1)]\\n                if r:\\n                    dsu.union(x, x+1)\\n                    segments.pop(dsu.find(x+1))\\n            if x-1>=0:\\n                l = segments[dsu.find(x-1)]\\n                if l:\\n                    dsu.union(x, x-1)\\n                    segments.pop(dsu.find(x-1))\\n            segments[dsu.find(x)] += l+r+A[x]\\n            mx = max(mx, segments[dsu.find(x)])\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468342,
                "title": "java-solution-using-treeset-and-treemap",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=nums.length;\\n        long[]prefix=new long[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                prefix[i]=nums[i];\\n            }else{\\n                prefix[i]+=(nums[i]+prefix[i-1]);\\n            }\\n        }\\n        \\n        long[]ans=new long[n];\\n        TreeSet<Integer>poppedIndex=new TreeSet();\\n        TreeMap<Long,Long>segmentSum=new TreeMap();\\n        segmentSum.put(prefix[n-1],1L);\\n        for(int i=0;i<n;i++){\\n            int idx=removeQueries[i];\\n            Integer floorIdx=poppedIndex.floor(idx);\\n            Integer ceilIdx=poppedIndex.ceiling(idx);\\n            int floor=floorIdx!=null?floorIdx+1:0;\\n            int ceil=ceilIdx!=null?ceilIdx-1:n-1;\\n            long sumInRange=getSumWithinRange(floor,ceil,prefix);\\n            long leftSum=getSumWithinRange(floor,idx-1,prefix);\\n            long rightSum=getSumWithinRange(idx+1,ceil,prefix);\\n            segmentSum.put(sumInRange,segmentSum.get(sumInRange)-1);\\n            if(segmentSum.get(sumInRange)==0){\\n                segmentSum.remove(sumInRange);\\n            }\\n            segmentSum.put(leftSum,segmentSum.getOrDefault(leftSum,0L)+1);\\n            segmentSum.put(rightSum,segmentSum.getOrDefault(rightSum,0L)+1);\\n            \\n            ans[i]=segmentSum.lastKey();\\n            poppedIndex.add(idx);\\n        }\\n        return ans;\\n    }\\n    \\n    public long  getSumWithinRange(int floor, int ceil,long[] prefix){\\n        if(floor>ceil){\\n            return 0L;\\n        }\\n        if(floor==0){\\n                return prefix[ceil];\\n            }else{\\n               return prefix[ceil]-prefix[floor-1];\\n            } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=nums.length;\\n        long[]prefix=new long[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                prefix[i]=nums[i];\\n            }else{\\n                prefix[i]+=(nums[i]+prefix[i-1]);\\n            }\\n        }\\n        \\n        long[]ans=new long[n];\\n        TreeSet<Integer>poppedIndex=new TreeSet();\\n        TreeMap<Long,Long>segmentSum=new TreeMap();\\n        segmentSum.put(prefix[n-1],1L);\\n        for(int i=0;i<n;i++){\\n            int idx=removeQueries[i];\\n            Integer floorIdx=poppedIndex.floor(idx);\\n            Integer ceilIdx=poppedIndex.ceiling(idx);\\n            int floor=floorIdx!=null?floorIdx+1:0;\\n            int ceil=ceilIdx!=null?ceilIdx-1:n-1;\\n            long sumInRange=getSumWithinRange(floor,ceil,prefix);\\n            long leftSum=getSumWithinRange(floor,idx-1,prefix);\\n            long rightSum=getSumWithinRange(idx+1,ceil,prefix);\\n            segmentSum.put(sumInRange,segmentSum.get(sumInRange)-1);\\n            if(segmentSum.get(sumInRange)==0){\\n                segmentSum.remove(sumInRange);\\n            }\\n            segmentSum.put(leftSum,segmentSum.getOrDefault(leftSum,0L)+1);\\n            segmentSum.put(rightSum,segmentSum.getOrDefault(rightSum,0L)+1);\\n            \\n            ans[i]=segmentSum.lastKey();\\n            poppedIndex.add(idx);\\n        }\\n        return ans;\\n    }\\n    \\n    public long  getSumWithinRange(int floor, int ceil,long[] prefix){\\n        if(floor>ceil){\\n            return 0L;\\n        }\\n        if(floor==0){\\n                return prefix[ceil];\\n            }else{\\n               return prefix[ceil]-prefix[floor-1];\\n            } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467942,
                "title": "c-disjoint-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<pair<int, long long>> st;\\n        public:\\n        UnionFind(int n, vector<int>& nums) {\\n            st = vector<pair<int, long long>> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i].first = i;\\n                st[i].second = nums[i];\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v].first) return v;\\n            return st[v].first = find(st[v].first);\\n        }\\n        long long findValue(int v) {\\n            int pos = find(v);\\n            return st[pos].second;\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x].first = y;\\n                st[y].second += st[x].second;\\n            }\\n        }\\n    };\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<bool> mark(n);\\n        vector<long long> sol(n);\\n        mark[removeQueries[n - 1]] = true;\\n        UnionFind uf(n, nums);\\n        set<long long> mxSegment;\\n        mxSegment.insert(nums[removeQueries[n - 1]]);\\n        for (int i = n - 2; i >= 0; i--) {\\n            long long mxValue = *prev(mxSegment.end());\\n            sol[i] = mxValue;\\n            int pos = removeQueries[i];\\n            mark[pos] = true;\\n            if (pos - 1 >= 0 && mark[pos - 1]) {\\n                uf.merge(pos, pos - 1);\\n            }\\n            if (pos + 1 < n && mark[pos + 1]) {\\n                uf.merge(pos, pos + 1);\\n            }\\n            long long segValue = uf.findValue(pos);\\n            mxSegment.insert(segValue);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<pair<int, long long>> st;\\n        public:\\n        UnionFind(int n, vector<int>& nums) {\\n            st = vector<pair<int, long long>> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i].first = i;\\n                st[i].second = nums[i];\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v].first) return v;\\n            return st[v].first = find(st[v].first);\\n        }\\n        long long findValue(int v) {\\n            int pos = find(v);\\n            return st[pos].second;\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x].first = y;\\n                st[y].second += st[x].second;\\n            }\\n        }\\n    };\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<bool> mark(n);\\n        vector<long long> sol(n);\\n        mark[removeQueries[n - 1]] = true;\\n        UnionFind uf(n, nums);\\n        set<long long> mxSegment;\\n        mxSegment.insert(nums[removeQueries[n - 1]]);\\n        for (int i = n - 2; i >= 0; i--) {\\n            long long mxValue = *prev(mxSegment.end());\\n            sol[i] = mxValue;\\n            int pos = removeQueries[i];\\n            mark[pos] = true;\\n            if (pos - 1 >= 0 && mark[pos - 1]) {\\n                uf.merge(pos, pos - 1);\\n            }\\n            if (pos + 1 < n && mark[pos + 1]) {\\n                uf.merge(pos, pos + 1);\\n            }\\n            long long segValue = uf.findValue(pos);\\n            mxSegment.insert(segValue);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467592,
                "title": "c-100-space-and-time-lower-bound-reverse-sum",
                "content": "```\\n#define max(x,y) x > y ? x : y\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& que) {\\n        const int n = nums.size();\\n        vector<ll> ans(n);\\n        map<int,ll> m;\\n        ll maxSum = 0;\\n        vector<bool> present(n,false);\\n        for(int i = n - 1;i >= 0;i--){\\n            ll sum = 0,q = que[i],cur = q;\\n            present[q] = true;\\n            if(q > 0 && present[q - 1]){\\n                sum += m[q - 1];\\n                m.erase(q-1);\\n            }\\n            if(q + 1 < n && present[q + 1]){\\n                auto it = *m.lower_bound(q);\\n                sum += it.second;\\n                cur = it.first;\\n            }\\n            m[cur] = sum + nums[q];\\n            ans[i] = maxSum;\\n            maxSum = max(m[cur],maxSum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/65166e3c-a49e-4d14-bcf9-6260bdc493a8_1661242132.6122313.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(x,y) x > y ? x : y\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& que) {\\n        const int n = nums.size();\\n        vector<ll> ans(n);\\n        map<int,ll> m;\\n        ll maxSum = 0;\\n        vector<bool> present(n,false);\\n        for(int i = n - 1;i >= 0;i--){\\n            ll sum = 0,q = que[i],cur = q;\\n            present[q] = true;\\n            if(q > 0 && present[q - 1]){\\n                sum += m[q - 1];\\n                m.erase(q-1);\\n            }\\n            if(q + 1 < n && present[q + 1]){\\n                auto it = *m.lower_bound(q);\\n                sum += it.second;\\n                cur = it.first;\\n            }\\n            m[cur] = sum + nums[q];\\n            ans[i] = maxSum;\\n            maxSum = max(m[cur],maxSum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467403,
                "title": "python-reverse-segment-union-memory-100-runtime-80-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        removeQueries = removeQueries[::-1]  #Reverse queries\\n        \\n        result = [0]                         #Add zero to result for last removal\\n        edge = {}                            #Track segment edges\\n        \\n        segmentSum = [0 for _ in range(n)]   #Store sum of each segment\\n        currMax = 0                          #Maximum sum of current segments\\n        \\n        for i in range(n-1):\\n            idx = removeQueries[i]           #Index of element to be added \\n            \\n            start = edge[idx+1] if idx+1 in edge else idx          #If next index is start of any segment then update start else current index is start of new segment\\n            end = edge[idx-1] if idx-1 in edge else idx            #If previous index is end of any segment then update end else current index is end of new segment\\n            \\n            edge[start] = end                #Update start and end after adding current element\\n            edge[end] = start\\n\\n            val = nums[idx] + segmentSum[start] + segmentSum[end]  #Update segment sum\\n            segmentSum[start] = val\\n            segmentSum[end] = val\\n\\n            currMax = max(currMax , val)     #Update current segment sum maximum\\n            \\n            result.append(currMax)           #Add maximum segment sum to result\\n        \\n        return result[::-1]                  #Return reverse of result list\\n```\\n\\nPlease Upvote if you find it helpful. My first solution post :)",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        removeQueries = removeQueries[::-1]  #Reverse queries\\n        \\n        result = [0]                         #Add zero to result for last removal\\n        edge = {}                            #Track segment edges\\n        \\n        segmentSum = [0 for _ in range(n)]   #Store sum of each segment\\n        currMax = 0                          #Maximum sum of current segments\\n        \\n        for i in range(n-1):\\n            idx = removeQueries[i]           #Index of element to be added \\n            \\n            start = edge[idx+1] if idx+1 in edge else idx          #If next index is start of any segment then update start else current index is start of new segment\\n            end = edge[idx-1] if idx-1 in edge else idx            #If previous index is end of any segment then update end else current index is end of new segment\\n            \\n            edge[start] = end                #Update start and end after adding current element\\n            edge[end] = start\\n\\n            val = nums[idx] + segmentSum[start] + segmentSum[end]  #Update segment sum\\n            segmentSum[start] = val\\n            segmentSum[end] = val\\n\\n            currMax = max(currMax , val)     #Update current segment sum maximum\\n            \\n            result.append(currMax)           #Add maximum segment sum to result\\n        \\n        return result[::-1]                  #Return reverse of result list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467238,
                "title": "python-solved-by-reversed-and-tow-dict-with-explain-runtime-83-memory-100",
                "content": "**Explain:**\\n\\nnums = [1, 2, 5, 6, 1] \\nremoveQueries = [0, 3, 2, 4, 1] \\n\\nReverse as : \\nnums = [0, 0, 0, 0, 0]\\naddQueries  [1, 4, 2, 3, 0]\\n\\n\\nAdd addQueries one by one, and confirm whether it is connected to the left or right\\n\\naddQ = 1 \\n* nums : [0,0,0,0,0] -> [0,[2],0,0,0]  \\n* this round max = max(2,0) = 2\\n\\naddQ = 4\\n* nums : [0,[2],0,0,0] -> [0,[2],0,0,[1]] \\n* this round max = max(1,pre round max) = 2\\n\\naddQ = 2 \\n* nums : [0,[2],0,0,[1]] -> [0,[2,5],0,[1]] \\n* this round max = max(7,pre round max) = 7\\n\\naddQ = 3\\n* nums :  [0,[2,5],0,[1]]  -> [0,[2,5,6,1]] \\n* this round max = max(14,pre round max) = 14\\n\\n\\n\\n**Solution**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\t\\t\\tres = [0]\\n\\n\\t\\t\\tse_d = dict()  # use to find end or start of segment\\n\\t\\t\\tseg_d = dict()  # segment sum dict\\n\\t\\t\\tmx = 0\\n\\t\\t\\tfor addQ in removeQueries[:0:-1]:\\n\\t\\t\\t\\tsum = nums[addQ]\\n\\t\\t\\t\\tstart = end = addQ\\n\\n\\t\\t\\t\\t#Check if there are connected segment\\n\\t\\t\\t\\tif addQ + 1 in se_d.keys():\\n\\t\\t\\t\\t\\tend = se_d.pop(addQ + 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((addQ + 1, end))\\n\\n\\t\\t\\t\\tif addQ - 1 in se_d.keys():\\n\\t\\t\\t\\t\\tstart = se_d.pop(addQ - 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((start, addQ - 1))\\n\\n\\t\\t\\t\\t#save start,end,sum of segment\\n\\t\\t\\t\\tse_d[start] = end\\n\\t\\t\\t\\tse_d[end] = start\\n\\t\\t\\t\\tseg_d[(start, end)] = sum\\n\\n\\t\\t\\t\\t#check this segment sum is maximum or not\\n\\t\\t\\t\\tmx = max(mx, sum)\\n\\t\\t\\t\\tres.append(mx)\\n\\n\\t\\t\\treturn res[::-1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Explain:**\\n\\nnums = [1, 2, 5, 6, 1] \\nremoveQueries = [0, 3, 2, 4, 1] \\n\\nReverse as : \\nnums = [0, 0, 0, 0, 0]\\naddQueries  [1, 4, 2, 3, 0]\\n\\n\\nAdd addQueries one by one, and confirm whether it is connected to the left or right\\n\\naddQ = 1 \\n* nums : [0,0,0,0,0] -> [0,[2],0,0,0]  \\n* this round max = max(2,0) = 2\\n\\naddQ = 4\\n* nums : [0,[2],0,0,0] -> [0,[2],0,0,[1]] \\n* this round max = max(1,pre round max) = 2\\n\\naddQ = 2 \\n* nums : [0,[2],0,0,[1]] -> [0,[2,5],0,[1]] \\n* this round max = max(7,pre round max) = 7\\n\\naddQ = 3\\n* nums :  [0,[2,5],0,[1]]  -> [0,[2,5,6,1]] \\n* this round max = max(14,pre round max) = 14\\n\\n\\n\\n**Solution**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\t\\t\\tres = [0]\\n\\n\\t\\t\\tse_d = dict()  # use to find end or start of segment\\n\\t\\t\\tseg_d = dict()  # segment sum dict\\n\\t\\t\\tmx = 0\\n\\t\\t\\tfor addQ in removeQueries[:0:-1]:\\n\\t\\t\\t\\tsum = nums[addQ]\\n\\t\\t\\t\\tstart = end = addQ\\n\\n\\t\\t\\t\\t#Check if there are connected segment\\n\\t\\t\\t\\tif addQ + 1 in se_d.keys():\\n\\t\\t\\t\\t\\tend = se_d.pop(addQ + 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((addQ + 1, end))\\n\\n\\t\\t\\t\\tif addQ - 1 in se_d.keys():\\n\\t\\t\\t\\t\\tstart = se_d.pop(addQ - 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((start, addQ - 1))\\n\\n\\t\\t\\t\\t#save start,end,sum of segment\\n\\t\\t\\t\\tse_d[start] = end\\n\\t\\t\\t\\tse_d[end] = start\\n\\t\\t\\t\\tseg_d[(start, end)] = sum\\n\\n\\t\\t\\t\\t#check this segment sum is maximum or not\\n\\t\\t\\t\\tmx = max(mx, sum)\\n\\t\\t\\t\\tres.append(mx)\\n\\n\\t\\t\\treturn res[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2464509,
                "title": "swift-segment-tree",
                "content": "```\\nclass Solution {\\n    class SgTree {\\n        var l: Int // left bound\\n        var r: Int // right bound\\n        var left: SgTree?\\n        var right: SgTree?\\n        \\n        var hasZero = false\\n        var maxVal: Int // max sum of subarray without zero\\n        var prefix: Int // sum from left to 1st zero\\n        var suffix: Int // sum from right to 1st zero\\n        \\n        init(_ nums: [Int], _ l: Int, _ r: Int) {\\n            self.l = l\\n            self.r = r\\n            if l == r {\\n                maxVal = nums[l]\\n                prefix = nums[l]\\n                suffix = nums[l]\\n            } else {\\n                let mid = (l + r) / 2\\n                let n1 = SgTree(nums, l, mid)\\n                let n2 = SgTree(nums, mid + 1, r)\\n                (left, right) = (n1, n2)\\n                maxVal = n1.maxVal + n2.maxVal\\n                prefix = n1.maxVal + n2.maxVal\\n                suffix = n1.maxVal + n2.maxVal\\n            }\\n        }\\n        \\n        func setZero(at i: Int) {\\n            if l == r {\\n                hasZero = true\\n                maxVal = 0\\n                prefix = 0\\n                suffix = 0\\n            } else if let n1 = left, let n2 = right {\\n                if i <= n1.r {\\n                    n1.setZero(at: i)\\n                } else {\\n                    n2.setZero(at: i)\\n                }\\n                if !n1.hasZero && !n2.hasZero {\\n                    maxVal = n1.maxVal + n2.maxVal\\n                    prefix = n1.maxVal + n2.maxVal\\n                    suffix = n1.maxVal + n2.maxVal\\n                } else {\\n                    hasZero = true\\n                    maxVal = max(n1.suffix + n2.prefix, n1.maxVal, n2.maxVal)\\n                    prefix = n1.hasZero ? n1.prefix : n1.maxVal + n2.prefix\\n                    suffix = n2.hasZero ? n2.suffix : n1.suffix + n2.maxVal\\n                }\\n            }\\n        }\\n    }\\n    func maximumSegmentSum(_ nums: [Int], _ removeQueries: [Int]) -> [Int] {\\n        let n = nums.count\\n        let sgTree = SgTree(nums, 0, n - 1)\\n        var res: [Int] = []\\n        for i in removeQueries {\\n            sgTree.setZero(at: i)\\n            res.append(sgTree.maxVal)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class SgTree {\\n        var l: Int // left bound\\n        var r: Int // right bound\\n        var left: SgTree?\\n        var right: SgTree?\\n        \\n        var hasZero = false\\n        var maxVal: Int // max sum of subarray without zero\\n        var prefix: Int // sum from left to 1st zero\\n        var suffix: Int // sum from right to 1st zero\\n        \\n        init(_ nums: [Int], _ l: Int, _ r: Int) {\\n            self.l = l\\n            self.r = r\\n            if l == r {\\n                maxVal = nums[l]\\n                prefix = nums[l]\\n                suffix = nums[l]\\n            } else {\\n                let mid = (l + r) / 2\\n                let n1 = SgTree(nums, l, mid)\\n                let n2 = SgTree(nums, mid + 1, r)\\n                (left, right) = (n1, n2)\\n                maxVal = n1.maxVal + n2.maxVal\\n                prefix = n1.maxVal + n2.maxVal\\n                suffix = n1.maxVal + n2.maxVal\\n            }\\n        }\\n        \\n        func setZero(at i: Int) {\\n            if l == r {\\n                hasZero = true\\n                maxVal = 0\\n                prefix = 0\\n                suffix = 0\\n            } else if let n1 = left, let n2 = right {\\n                if i <= n1.r {\\n                    n1.setZero(at: i)\\n                } else {\\n                    n2.setZero(at: i)\\n                }\\n                if !n1.hasZero && !n2.hasZero {\\n                    maxVal = n1.maxVal + n2.maxVal\\n                    prefix = n1.maxVal + n2.maxVal\\n                    suffix = n1.maxVal + n2.maxVal\\n                } else {\\n                    hasZero = true\\n                    maxVal = max(n1.suffix + n2.prefix, n1.maxVal, n2.maxVal)\\n                    prefix = n1.hasZero ? n1.prefix : n1.maxVal + n2.prefix\\n                    suffix = n2.hasZero ? n2.suffix : n1.suffix + n2.maxVal\\n                }\\n            }\\n        }\\n    }\\n    func maximumSegmentSum(_ nums: [Int], _ removeQueries: [Int]) -> [Int] {\\n        let n = nums.count\\n        let sgTree = SgTree(nums, 0, n - 1)\\n        var res: [Int] = []\\n        for i in removeQueries {\\n            sgTree.setZero(at: i)\\n            res.append(sgTree.maxVal)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464455,
                "title": "c-map-set",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll pre[100100];\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        pre[0]=nums[0];\\n        for(ll i=1;i<nums.size();i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        set<tuple<ll,ll,ll>>s;\\n        map<ll,ll>m;\\n        ll jhc=0;\\n        for(ll i:nums)\\n        {\\n            jhc+=i;\\n        }\\n        ll n=nums.size();\\n        s.insert(make_tuple(n-1,0,jhc));\\n        cout<<jhc<<\"=jhc\\\\n\";\\n        m[-1*jhc]+=1;\\n        vector<ll>ans;\\n        for(ll i:removeQueries)\\n        {\\n            auto it=s.lower_bound(make_tuple(i,-1,0));\\n            ll sum=(get<2>(*it));\\n            ll sind=get<1>(*it);\\n            ll eind=get<0>(*it);\\n            s.erase(*it);\\n            m[-1*sum]-=1;\\n            if(m[-1*sum]==0)\\n            {\\n                m.erase(-1*sum);\\n            }\\n            ll sum1=pre[i]-pre[sind]+nums[sind]-nums[i];\\n            ll sum2=pre[eind]-pre[i];\\n            m[-1*sum1]+=1;\\n            m[-1*sum2]+=1;\\n            if(sind<=i-1)\\n            {\\n                s.insert(make_tuple(i-1,sind,sum1));\\n            }\\n            if(i+1<=eind)\\n            {\\n                s.insert(make_tuple(eind,i+1,sum2));                \\n            }\\n            auto kk=m.begin();\\n            ans.push_back(-1*(kk->first));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll pre[100100];\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        pre[0]=nums[0];\\n        for(ll i=1;i<nums.size();i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        set<tuple<ll,ll,ll>>s;\\n        map<ll,ll>m;\\n        ll jhc=0;\\n        for(ll i:nums)\\n        {\\n            jhc+=i;\\n        }\\n        ll n=nums.size();\\n        s.insert(make_tuple(n-1,0,jhc));\\n        cout<<jhc<<\"=jhc\\\\n\";\\n        m[-1*jhc]+=1;\\n        vector<ll>ans;\\n        for(ll i:removeQueries)\\n        {\\n            auto it=s.lower_bound(make_tuple(i,-1,0));\\n            ll sum=(get<2>(*it));\\n            ll sind=get<1>(*it);\\n            ll eind=get<0>(*it);\\n            s.erase(*it);\\n            m[-1*sum]-=1;\\n            if(m[-1*sum]==0)\\n            {\\n                m.erase(-1*sum);\\n            }\\n            ll sum1=pre[i]-pre[sind]+nums[sind]-nums[i];\\n            ll sum2=pre[eind]-pre[i];\\n            m[-1*sum1]+=1;\\n            m[-1*sum2]+=1;\\n            if(sind<=i-1)\\n            {\\n                s.insert(make_tuple(i-1,sind,sum1));\\n            }\\n            if(i+1<=eind)\\n            {\\n                s.insert(make_tuple(eind,i+1,sum2));                \\n            }\\n            auto kk=m.begin();\\n            ans.push_back(-1*(kk->first));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2464052,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        set<int> used;\\n        vector<long long> res;\\n        multiset<long long> val;\\n        vector<long long> pre(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + nums[i-1];\\n        }\\n        used.insert(-1);\\n        used.insert(n);\\n        val.insert(pre[n]);\\n        for(auto idx : removeQueries) {\\n            long long hi = *used.upper_bound(idx);\\n            long long lo = *(--used.lower_bound(idx));\\n            long long sum = pre[hi] - pre[lo+1];\\n            long long sump1 = pre[idx]-pre[lo+1];\\n            long long sump2 = pre[hi] - pre[idx+1];\\n            used.insert(idx);\\n            val.insert(sump1);\\n            val.insert(sump2);\\n            val.erase(val.lower_bound(sum));\\n            res.push_back(*(--val.end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        set<int> used;\\n        vector<long long> res;\\n        multiset<long long> val;\\n        vector<long long> pre(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + nums[i-1];\\n        }\\n        used.insert(-1);\\n        used.insert(n);\\n        val.insert(pre[n]);\\n        for(auto idx : removeQueries) {\\n            long long hi = *used.upper_bound(idx);\\n            long long lo = *(--used.lower_bound(idx));\\n            long long sum = pre[hi] - pre[lo+1];\\n            long long sump1 = pre[idx]-pre[lo+1];\\n            long long sump2 = pre[hi] - pre[idx+1];\\n            used.insert(idx);\\n            val.insert(sump1);\\n            val.insert(sump2);\\n            val.erase(val.lower_bound(sum));\\n            res.push_back(*(--val.end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463413,
                "title": "c-map-multiset-prefix-sum-commented-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& que) {\\n        int n=num.size();\\n        vector<long long> ans;\\n        vector<long long> nums(n);\\n        nums[0]=num[0];\\n        for(int i=1;i<n;i++)  //store prefix sum in nums (prefix sum is used to calculate sum of a segment)\\n            nums[i]=nums[i-1]+num[i];\\n\\t\\t\\t\\n\\t\\t//define and initialize map and set\\n        map<pair<int,int>,long long> m;  //pair is for starting and end indices of a segment and sum for that segment is stored as value\\n        m[{0,n-1}]=nums[n-1];\\n        multiset<long long> s;  //sum of all current segments are stored in set\\n        s.insert(nums[n-1]);\\n\\t\\t\\n        for(int i=0;i<n-1;i++){\\n            long long id=que[i];\\n            auto it=m.lower_bound({id,0});  //find in which segment the index(to be removed) is present\\n            if(it==m.end() || id<(*it).first.first) it--;\\n            \\n            auto p=*it;\\n            int a=p.first.first,b=id-1,c=id+1,d=p.first.second;  //break that segment into two segments\\n            \\n            m.erase(it);   //delete current segment\\n            \\n            auto it2=s.find(p.second);\\n            s.erase(it2);      //delete the value of current segment from set\\n            \\n            if(b>=a){     // if end index > starting index of new segment, then add the segment in map and set\\n                long long s1=nums[b]-(a>0?nums[a-1]:0);\\n                m[{a,b}]=s1;\\n                s.insert(s1);\\n            }\\n            if(d>=c){     // same for the second new segment\\n                long long s2=nums[d]-(c>0?nums[c-1]:0);\\n                m[{c,d}]=s2;\\n                s.insert(s2);\\n            }\\n            ans.push_back(*s.rbegin());    //store the maximum value of current segments in the answer array\\n        }\\n        ans.push_back(0);   //last value will be 0 when all the indices are removed\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& que) {\\n        int n=num.size();\\n        vector<long long> ans;\\n        vector<long long> nums(n);\\n        nums[0]=num[0];\\n        for(int i=1;i<n;i++)  //store prefix sum in nums (prefix sum is used to calculate sum of a segment)\\n            nums[i]=nums[i-1]+num[i];\\n\\t\\t\\t\\n\\t\\t//define and initialize map and set\\n        map<pair<int,int>,long long> m;  //pair is for starting and end indices of a segment and sum for that segment is stored as value\\n        m[{0,n-1}]=nums[n-1];\\n        multiset<long long> s;  //sum of all current segments are stored in set\\n        s.insert(nums[n-1]);\\n\\t\\t\\n        for(int i=0;i<n-1;i++){\\n            long long id=que[i];\\n            auto it=m.lower_bound({id,0});  //find in which segment the index(to be removed) is present\\n            if(it==m.end() || id<(*it).first.first) it--;\\n            \\n            auto p=*it;\\n            int a=p.first.first,b=id-1,c=id+1,d=p.first.second;  //break that segment into two segments\\n            \\n            m.erase(it);   //delete current segment\\n            \\n            auto it2=s.find(p.second);\\n            s.erase(it2);      //delete the value of current segment from set\\n            \\n            if(b>=a){     // if end index > starting index of new segment, then add the segment in map and set\\n                long long s1=nums[b]-(a>0?nums[a-1]:0);\\n                m[{a,b}]=s1;\\n                s.insert(s1);\\n            }\\n            if(d>=c){     // same for the second new segment\\n                long long s2=nums[d]-(c>0?nums[c-1]:0);\\n                m[{c,d}]=s2;\\n                s.insert(s2);\\n            }\\n            ans.push_back(*s.rbegin());    //store the maximum value of current segments in the answer array\\n        }\\n        ans.push_back(0);   //last value will be 0 when all the indices are removed\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463259,
                "title": "art-of-coding-o-n-reverse-coding-no-pre-requisite",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& val) {\\n        reverse(val.begin(),val.end());\\n        vector<long long>ans;\\n        map<long long,pair<pair<long long,long long>,long long>>m;\\n        for(int i = 0; i < nums.size(); ++ i){\\n            m[i] = {{i,i},0};\\n        }\\n        long long pre = 0;\\n        ans.push_back(pre);\\n        for(auto a:val){\\n            long long cur = nums[a];\\n            long long left = -1, right = -1;\\n            if(a>0){\\n                left = m[a-1].first.first;\\n                cur += m[a-1].second;\\n            }\\n            if(a<nums.size()-1){\\n                right = m[a+1].first.second;\\n                cur += m[a+1].second;\\n            }\\n            if(left == -1){\\n                m[a] = {{0,right},cur};\\n                m[right-1] = {{0,right},cur};\\n            }else if(right == -1){\\n                m[a] = {{left,nums.size()-1},cur};\\n                m[left+1] = {{left,nums.size()-1},cur};\\n            }else{\\n                m[a] = {{left,right},cur};\\n                m[left+1] = {{left,right},cur};\\n                m[right-1] ={{left,right},cur};\\n            }\\n            pre = max(cur,pre);\\n            ans.push_back(pre);\\n        }\\n        ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& val) {\\n        reverse(val.begin(),val.end());\\n        vector<long long>ans;\\n        map<long long,pair<pair<long long,long long>,long long>>m;\\n        for(int i = 0; i < nums.size(); ++ i){\\n            m[i] = {{i,i},0};\\n        }\\n        long long pre = 0;\\n        ans.push_back(pre);\\n        for(auto a:val){\\n            long long cur = nums[a];\\n            long long left = -1, right = -1;\\n            if(a>0){\\n                left = m[a-1].first.first;\\n                cur += m[a-1].second;\\n            }\\n            if(a<nums.size()-1){\\n                right = m[a+1].first.second;\\n                cur += m[a+1].second;\\n            }\\n            if(left == -1){\\n                m[a] = {{0,right},cur};\\n                m[right-1] = {{0,right},cur};\\n            }else if(right == -1){\\n                m[a] = {{left,nums.size()-1},cur};\\n                m[left+1] = {{left,nums.size()-1},cur};\\n            }else{\\n                m[a] = {{left,right},cur};\\n                m[left+1] = {{left,right},cur};\\n                m[right-1] ={{left,right},cur};\\n            }\\n            pre = max(cur,pre);\\n            ans.push_back(pre);\\n        }\\n        ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461904,
                "title": "python-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        s = SortedList(); n = len(nums)\\n        sumList = SortedList()\\n        p = [0]*(len(nums)+1)\\n        for i in range(len(nums)):\\n            p[i+1] += p[i] + nums[i]\\n        s.add([0,n-1,p[-1]])\\n        sumList.add(p[-1])\\n        ans = []\\n        for i in removeQueries:\\n            idx = s.bisect_left([i,-1,-1])\\n            if idx==len(s) or s[idx][0]>i:\\n                idx-=1\\n            start,end,segSum = s[idx]\\n            sumList.remove(segSum)\\n            leftSum = p[i]-p[start]\\n            rightSum = p[end+1] - p[i+1]\\n            s.remove(s[idx])\\n            if i!=start:\\n                sumList.add(leftSum)\\n                s.add([start,i-1,leftSum])\\n            if i!=end:\\n                sumList.add(rightSum)\\n                s.add([i+1,end,rightSum])\\n            if not sumList:\\n                ans.append(0)\\n            else:\\n                ans.append(sumList[-1])\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        s = SortedList(); n = len(nums)\\n        sumList = SortedList()\\n        p = [0]*(len(nums)+1)\\n        for i in range(len(nums)):\\n            p[i+1] += p[i] + nums[i]\\n        s.add([0,n-1,p[-1]])\\n        sumList.add(p[-1])\\n        ans = []\\n        for i in removeQueries:\\n            idx = s.bisect_left([i,-1,-1])\\n            if idx==len(s) or s[idx][0]>i:\\n                idx-=1\\n            start,end,segSum = s[idx]\\n            sumList.remove(segSum)\\n            leftSum = p[i]-p[start]\\n            rightSum = p[end+1] - p[i+1]\\n            s.remove(s[idx])\\n            if i!=start:\\n                sumList.add(leftSum)\\n                s.add([start,i-1,leftSum])\\n            if i!=end:\\n                sumList.add(rightSum)\\n                s.add([i+1,end,rightSum])\\n            if not sumList:\\n                ans.append(0)\\n            else:\\n                ans.append(sumList[-1])\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460857,
                "title": "python-reverse-union-find",
                "content": "A simple good solution for starting from back and then merging the chains.\\n\\n```\\ndef find_parent(j, ds):\\n    if ds[j] < 0:\\n        return j\\n    # it might be possible that we have a chain, so we need to\\n    # recurse\\n    parent_index = find_parent(ds[j], ds)\\n    # to optimise the chain, we save the final parent:)\\n    ds[j] = parent_index\\n    return parent_index\\n\\ndef merge(left, b, ds):\\n    # Make the left chain the parent chain\\n    p_left = find_parent(left, ds)\\n    p2 = find_parent(b, ds)\\n    # add the right chain value to the left chain\\n    ds[p_left] += ds[p2]\\n    # connect the right chain to point to the parent of left chain\\n    ds[p2] = p_left\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        N = len(nums)\\n        res = [0] * N\\n        INT_MAX = float(\\'inf\\')\\n        ds = [INT_MAX]*N\\n        \\n        for i in range(N-1, 0, -1):\\n            j = removeQueries[i]\\n            # create a single node chain\\n            ds[j] = -nums[j]\\n            # if there is a chain to the left, then merge them\\n            if (j > 0 and ds[j - 1] != INT_MAX):\\n                merge(j-1, j, ds)\\n            # if there is the chain to the right then merge them\\n            if (j < N - 1 and ds[j + 1] != INT_MAX):\\n                merge(j, j + 1, ds)\\n            # check if the merged chain are bigger than existing biggest\\n            res[i - 1] = max(res[i], -ds[find_parent(j, ds)]);\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef find_parent(j, ds):\\n    if ds[j] < 0:\\n        return j\\n    # it might be possible that we have a chain, so we need to\\n    # recurse\\n    parent_index = find_parent(ds[j], ds)\\n    # to optimise the chain, we save the final parent:)\\n    ds[j] = parent_index\\n    return parent_index\\n\\ndef merge(left, b, ds):\\n    # Make the left chain the parent chain\\n    p_left = find_parent(left, ds)\\n    p2 = find_parent(b, ds)\\n    # add the right chain value to the left chain\\n    ds[p_left] += ds[p2]\\n    # connect the right chain to point to the parent of left chain\\n    ds[p2] = p_left\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        N = len(nums)\\n        res = [0] * N\\n        INT_MAX = float(\\'inf\\')\\n        ds = [INT_MAX]*N\\n        \\n        for i in range(N-1, 0, -1):\\n            j = removeQueries[i]\\n            # create a single node chain\\n            ds[j] = -nums[j]\\n            # if there is a chain to the left, then merge them\\n            if (j > 0 and ds[j - 1] != INT_MAX):\\n                merge(j-1, j, ds)\\n            # if there is the chain to the right then merge them\\n            if (j < N - 1 and ds[j + 1] != INT_MAX):\\n                merge(j, j + 1, ds)\\n            # check if the merged chain are bigger than existing biggest\\n            res[i - 1] = max(res[i], -ds[find_parent(j, ds)]);\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460255,
                "title": "why-my-solution-using-multiset-giving-tle",
                "content": "can somebody tell me why my code is giving TLE???\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n        long long n=nums.size();\\n        set<long long> st;\\n        // st.insert(-1);\\n        multiset<long long> values;\\n        // st.insert(n);\\n        vector<long long> pref(n); \\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i];\\n            pref[i]+=pref[i-1];\\n        }\\n        values.insert(pref[n-1]);\\n        values.insert(0);\\n        vector<long long> ret;\\n        for(int i=0;i<rem.size();i++){\\n            long long ind=rem[i];\\n            auto it=upper_bound(st.begin(),st.end(),ind);\\n            long long last=n-1;\\n            long long stt=0;\\n            if(it!=st.end()){\\n                last=(*it)-1;\\n            }\\n            if(it!=st.begin()){\\n                it--;\\n                stt=(*it)+1;\\n            }\\n            long long val=pref[last];\\n            if((stt-1)>=0)val-=pref[stt-1];\\n            values.erase(values.lower_bound(val));\\n            if((ind-1)>=stt){\\n                long long val1=pref[ind-1];\\n                if(stt-1>=0)val1-=pref[stt-1];\\n                values.insert(val1);\\n            }\\n            if((ind+1)<=last){\\n                long long val2=pref[last];\\n                val2-=pref[ind];\\n                values.insert(val2);\\n            }\\n            st.insert(ind);\\n            ret.push_back(*values.rbegin());\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n        long long n=nums.size();\\n        set<long long> st;\\n        // st.insert(-1);\\n        multiset<long long> values;\\n        // st.insert(n);\\n        vector<long long> pref(n); \\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i];\\n            pref[i]+=pref[i-1];\\n        }\\n        values.insert(pref[n-1]);\\n        values.insert(0);\\n        vector<long long> ret;\\n        for(int i=0;i<rem.size();i++){\\n            long long ind=rem[i];\\n            auto it=upper_bound(st.begin(),st.end(),ind);\\n            long long last=n-1;\\n            long long stt=0;\\n            if(it!=st.end()){\\n                last=(*it)-1;\\n            }\\n            if(it!=st.begin()){\\n                it--;\\n                stt=(*it)+1;\\n            }\\n            long long val=pref[last];\\n            if((stt-1)>=0)val-=pref[stt-1];\\n            values.erase(values.lower_bound(val));\\n            if((ind-1)>=stt){\\n                long long val1=pref[ind-1];\\n                if(stt-1>=0)val1-=pref[stt-1];\\n                values.insert(val1);\\n            }\\n            if((ind+1)<=last){\\n                long long val2=pref[last];\\n                val2-=pref[ind];\\n                values.insert(val2);\\n            }\\n            st.insert(ind);\\n            ret.push_back(*values.rbegin());\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459970,
                "title": "binary-search-copied-credit-codingmohan",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        \\n        multiset<long long> segment;\\n        set<int> range;\\n        \\n        vector<long long> pref(n+1,0);\\n        for(int i=1;i<=n;i++)\\n            pref[i]=pref[i-1]+nums[i-1];\\n        \\n        segment.insert(pref[n]);\\n        segment.insert(0);\\n        \\n        \\n        vector<long long> res;\\n        \\n        for(auto ind : removeQueries)\\n        {\\n            ind++;\\n            \\n            int start=1;\\n            int end=n;\\n            \\n            auto next_itr=range.upper_bound(ind);\\n            \\n            if(next_itr!=range.end())\\n            {\\n                end=*next_itr-1;\\n            }\\n            if(next_itr!=range.begin())\\n            {\\n                --next_itr;\\n                start=*next_itr+1;\\n            }\\n            \\n            long long rangesum=pref[end]-pref[start-1];\\n            segment.erase(segment.find(rangesum));\\n            \\n            if(ind-1>=start)\\n                segment.insert(pref[ind-1]-pref[start-1]);\\n            if(ind+1<=end)\\n                segment.insert(pref[end]-pref[ind]);\\n            \\n            range.insert(ind);\\n            \\n            res.push_back(*segment.rbegin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        \\n        multiset<long long> segment;\\n        set<int> range;\\n        \\n        vector<long long> pref(n+1,0);\\n        for(int i=1;i<=n;i++)\\n            pref[i]=pref[i-1]+nums[i-1];\\n        \\n        segment.insert(pref[n]);\\n        segment.insert(0);\\n        \\n        \\n        vector<long long> res;\\n        \\n        for(auto ind : removeQueries)\\n        {\\n            ind++;\\n            \\n            int start=1;\\n            int end=n;\\n            \\n            auto next_itr=range.upper_bound(ind);\\n            \\n            if(next_itr!=range.end())\\n            {\\n                end=*next_itr-1;\\n            }\\n            if(next_itr!=range.begin())\\n            {\\n                --next_itr;\\n                start=*next_itr+1;\\n            }\\n            \\n            long long rangesum=pref[end]-pref[start-1];\\n            segment.erase(segment.find(rangesum));\\n            \\n            if(ind-1>=start)\\n                segment.insert(pref[ind-1]-pref[start-1]);\\n            if(ind+1<=end)\\n                segment.insert(pref[end]-pref[ind]);\\n            \\n            range.insert(ind);\\n            \\n            res.push_back(*segment.rbegin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459572,
                "title": "array-data-structure-only-o-n-time-o-n-space",
                "content": "While going in reverse order of the queries, numbers are inserted at ```index``` and all we have to check is whether adding the number makes it a part of already existing group(segment) or not.\\nThere are 4 cases for this:\\n1: At  both ```index```-1 and ```index```+1 there is a group.\\n2: Only at ```index```-1 there is a group.\\n3: Only at ```index```+1 there is a group.\\n4: No groups at ```index```-1 and ```index```+1.\\nFor a group three values are needed the ```startingIndex```, ```endingIndex``` and ```sum```.\\nAs we can notice in the above cases we need these values to be present only at the ends of the group and not everywhere in the group as we are not going to make an insertion inside an existing group.\\nSo maintain this information and for every new insertion we can update the values in O(1) time.\\nFor the maximum segment sum as the numbers are positive the max is always increasing so curr_max is max(curr_max , sum of new group which is formed)\\nat start ```curr_max``` is ```0```\\nCases:\\n1. At  both ```index```-1 and ```index```+1 there is a group.\\n\\tThese two groups will be merged to one with the current insertion so, values are updated only at the starting index of ```index```-1 group and ending index of ```index```+1 group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index-1].sum + groupinfo[index+1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```groupinfo[index-1].startingIndex```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```groupinfo[index+1].endingIndex```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex``` \\n\\t```curr_max = max(curr_max,newSum)```\\n2. Only at ```index```-1 there is a group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index-1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```groupinfo[index-1].startingIndex```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```index```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex```\\n\\t```groupinfo[newEndingIndex].endingindex = newEndingIndex```\\n\\t```curr_max = max(curr_max,newSum)```\\n3. Only at ```index```+1 there is a group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index+1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```index```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```groupinfo[index+1].endingIndex```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].startingIndex = newStartingindex``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex```\\n\\t```curr_max = max(curr_max,newSum)```\\n4. No groups at ```index```-1 and ```index```+1.\\n\\t```newSum``` of new group is \\n\\t```nums[index]```\\n\\t\\n\\tboth ```newStartingIndex``` and ```newEndingIndex``` is```index```\\n\\t\\n\\t```groupinfo[index].sum = newSum``` \\n\\t```groupinfo[index].startingIndex = newStartingindex``` \\n\\t```groupinfo[index].endingIndex = newEndingIndex```\\n\\t```curr_max = max(curr_max,newSum)```\\n\\t\\nC++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const long long n=nums.size();\\n        vector<vector<long long>>groupinfo(n,{-1,-1,-1});\\n\\t\\t//for i\\'th index\\n\\t\\t// groupinfo[i][0] is startingIndex\\n\\t\\t// groupinfo[i][1] is endingIndex\\n\\t\\t// groupinfo[i][2] is sum\\n        vector<long long>res(n);\\n        long long mx=0;\\n        for(long long i=n-1;i>=0;--i){\\n            res[i]=mx;\\n            long long index=removeQueries[i];\\n            long long l,r,sum;\\n            if(index!=0 && index!=n-1 && groupinfo[index-1][0]!=-1 && groupinfo[index+1][0]!=-1){\\n                sum=groupinfo[index-1][2]+groupinfo[index+1][2]+nums[index];\\n                l=groupinfo[index-1][0];\\n                r=groupinfo[index+1][1];\\n                groupinfo[l][1]=r;\\n                groupinfo[l][2]=sum;\\n                groupinfo[r][0]=l;\\n                groupinfo[r][2]=sum;\\n            }else if(index!=0 && groupinfo[index-1][0]!=-1){\\n                l=groupinfo[index-1][0];\\n                sum=groupinfo[l][2]+nums[index];\\n                groupinfo[l][1]=index;\\n                groupinfo[l][2]=sum;\\n                groupinfo[index][0]=l;\\n                groupinfo[index][1]=index;\\n                groupinfo[index][2]=sum;\\n            }else if(index!=n-1 && groupinfo[index+1][0]!=-1){\\n                r=groupinfo[index+1][1];\\n                sum=groupinfo[r][2]+nums[index];\\n                groupinfo[r][0]=index;\\n                groupinfo[r][2]=sum;\\n                groupinfo[index][0]=index;\\n                groupinfo[index][1]=r;\\n                groupinfo[index][2]=sum;\\n            }else{\\n                groupinfo[index][0]=groupinfo[index][1]=index;\\n                groupinfo[index][2]=nums[index];\\n                sum=nums[index];\\n            }\\n            mx=max(mx,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```index```\n```index```\n```index```\n```index```\n```index```\n```index```\n```index```\n```startingIndex```\n```endingIndex```\n```sum```\n```curr_max```\n```0```\n```index```\n```index```\n```index```\n```index```\n```newSum```\n```groupinfo[index-1].sum + groupinfo[index+1].sum + nums[index]```\n```newStartingIndex```\n```groupinfo[index-1].startingIndex```\n```newEndingIndex```\n```groupinfo[index+1].endingIndex```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```newSum```\n```groupinfo[index-1].sum + nums[index]```\n```newStartingIndex```\n```groupinfo[index-1].startingIndex```\n```newEndingIndex```\n```index```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```groupinfo[newEndingIndex].endingindex = newEndingIndex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```newSum```\n```groupinfo[index+1].sum + nums[index]```\n```newStartingIndex```\n```index```\n```newEndingIndex```\n```groupinfo[index+1].endingIndex```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].startingIndex = newStartingindex```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```index```\n```newSum```\n```nums[index]```\n```newStartingIndex```\n```newEndingIndex```\n```index```\n```groupinfo[index].sum = newSum```\n```groupinfo[index].startingIndex = newStartingindex```\n```groupinfo[index].endingIndex = newEndingIndex```\n```curr_max = max(curr_max,newSum)```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const long long n=nums.size();\\n        vector<vector<long long>>groupinfo(n,{-1,-1,-1});\\n\\t\\t//for i\\'th index\\n\\t\\t// groupinfo[i][0] is startingIndex\\n\\t\\t// groupinfo[i][1] is endingIndex\\n\\t\\t// groupinfo[i][2] is sum\\n        vector<long long>res(n);\\n        long long mx=0;\\n        for(long long i=n-1;i>=0;--i){\\n            res[i]=mx;\\n            long long index=removeQueries[i];\\n            long long l,r,sum;\\n            if(index!=0 && index!=n-1 && groupinfo[index-1][0]!=-1 && groupinfo[index+1][0]!=-1){\\n                sum=groupinfo[index-1][2]+groupinfo[index+1][2]+nums[index];\\n                l=groupinfo[index-1][0];\\n                r=groupinfo[index+1][1];\\n                groupinfo[l][1]=r;\\n                groupinfo[l][2]=sum;\\n                groupinfo[r][0]=l;\\n                groupinfo[r][2]=sum;\\n            }else if(index!=0 && groupinfo[index-1][0]!=-1){\\n                l=groupinfo[index-1][0];\\n                sum=groupinfo[l][2]+nums[index];\\n                groupinfo[l][1]=index;\\n                groupinfo[l][2]=sum;\\n                groupinfo[index][0]=l;\\n                groupinfo[index][1]=index;\\n                groupinfo[index][2]=sum;\\n            }else if(index!=n-1 && groupinfo[index+1][0]!=-1){\\n                r=groupinfo[index+1][1];\\n                sum=groupinfo[r][2]+nums[index];\\n                groupinfo[r][0]=index;\\n                groupinfo[r][2]=sum;\\n                groupinfo[index][0]=index;\\n                groupinfo[index][1]=r;\\n                groupinfo[index][2]=sum;\\n            }else{\\n                groupinfo[index][0]=groupinfo[index][1]=index;\\n                groupinfo[index][2]=nums[index];\\n                sum=nums[index];\\n            }\\n            mx=max(mx,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458882,
                "title": "intuitive-solution-using-map-and-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    long long su(int l,int r,vector<long long> &v){ //prefix sum function for fast range sum calculation\\n        if(l==0) return v[r];\\n        else return v[r]-v[l-1];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remo) {\\n        map<pair<long long,long long>,long long> mp;\\n        int n=nums.size();\\n        vector<long long> v(n,0);v[0]=nums[0];\\n        for(int i=1;i<n;i++) v[i]=v[i-1]+nums[i];\\n        multiset<long long> mt;\\n        mp[{0,n-1}]=su(0,n-1,v);\\n        mt.insert(su(0,n-1,v));\\n        vector<long long> ans;\\n        for(int i=0;i<n;i++){\\n            int x=remo[i];\\n            auto it = mp.upper_bound({x,1e9}); //finding in which segment the x is\\n            it--;\\n            int l=it->first.first,r=it->first.second;\\n            long long val=it->second;\\n            mt.erase(mt.find(val));\\n            mp.erase(it);\\n            if(l==r){}                  // do nothing if segment is single value\\n            else if(x==l){              //only add right segment after partion\\n                int l2=x+1,r2=r;\\n                if(l2<=r2){\\n                    mt.insert(su(l2,r2,v));\\n                    mp[{l2,r2}]=su(l2,r2,v);\\n                }\\n            }else if(x==r){              //only add left segment\\n                int l1=l,r1=x-1;\\n                if(l1<=r1){\\n                    mt.insert(su(l1,r1,v));\\n                    mp[{l1,r1}]=su(l1,r1,v);\\n                }\\n            }else{                         //otherwise\\n                int l1=l,r1=x-1,l2=x+1,r2=r;\\n                if(l1<=r1){\\n                    mt.insert(su(l1,r1,v));\\n                    mp[{l1,r1}]=su(l1,r1,v);\\n                }\\n                if(l2<=r2){\\n                    mt.insert(su(l2,r2,v));\\n                    mp[{l2,r2}]=su(l2,r2,v);\\n                }\\n            }\\n            auto it1=mt.end();\\n            if(!mt.empty()){it1--;ans.push_back(*it1);}\\n        }\\n        ans.push_back(0);     //adding 0 for the last element\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long su(int l,int r,vector<long long> &v){ //prefix sum function for fast range sum calculation\\n        if(l==0) return v[r];\\n        else return v[r]-v[l-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2458735,
                "title": "segment-tree-approach",
                "content": "There are multiple approachs to this problem, however I feel only segment tree approach more intuitive. \\n\\n```\\nclass Solution {\\n    \\n    class SegTree{\\n        \\n        long maxSeg;\\n        long pmaxSeg;\\n        long smaxSeg;\\n        \\n        int pPointer;\\n        int sPointer;\\n        \\n        int left;\\n        int right;\\n        \\n        SegTree leftChild;\\n        SegTree rightChild;\\n        \\n        public SegTree(int[] a, int l, int r){\\n            \\n            pPointer = -1;\\n            sPointer = -1;\\n            left = l;\\n            right = r;\\n\\n            if(l==r){\\n                maxSeg = a[l];\\n                pmaxSeg = a[l];\\n                smaxSeg = a[l];\\n                return;\\n            }\\n            \\n            int m = l+(r-l)/2;\\n            leftChild = new SegTree(a, l, m);\\n            rightChild = new SegTree(a, m+1, r);\\n            recalc();\\n            \\n        }\\n        \\n        public void update(int x){\\n            if(left==right){\\n                maxSeg = 0;\\n                pmaxSeg = 0;\\n                smaxSeg = 0;\\n                pPointer = left;\\n                sPointer = left;\\n                return;\\n            }\\n            if(x<=leftChild.right){\\n                leftChild.update(x);\\n            }else{\\n                rightChild.update(x);\\n            }\\n            recalc();\\n        }\\n        \\n        private void recalc(){\\n            \\n            pmaxSeg = leftChild.pmaxSeg;\\n            if(leftChild.pPointer == -1){\\n                pmaxSeg = rightChild.pmaxSeg + leftChild.pmaxSeg;\\n            }\\n            \\n            smaxSeg = rightChild.smaxSeg;\\n            if(rightChild.sPointer == -1){\\n                smaxSeg = leftChild.smaxSeg + rightChild.smaxSeg;\\n            }\\n            \\n            pPointer = leftChild.pPointer;\\n            if(leftChild.pPointer == -1) pPointer = rightChild.pPointer;\\n            \\n            sPointer = rightChild.sPointer;\\n            if(rightChild.sPointer == -1) sPointer = leftChild.sPointer;\\n            \\n            maxSeg = Math.max(leftChild.maxSeg, rightChild.maxSeg);\\n            \\n            //check if maxSeg lies half left and half right\\n            if(leftChild.pPointer == -1){\\n                maxSeg = Math.max(maxSeg, leftChild.maxSeg + rightChild.pmaxSeg);\\n            }\\n            \\n            if(rightChild.sPointer == -1){\\n                maxSeg = Math.max(maxSeg, rightChild.maxSeg + leftChild.smaxSeg);\\n            }\\n            \\n            maxSeg = Math.max(maxSeg, leftChild.smaxSeg + rightChild.pmaxSeg);\\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    boolean debug = false;\\n    \\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        \\n        int n = nums.length;\\n        SegTree seg = new SegTree(nums, 0, n-1);\\n        \\n        if(debug){\\n            \\n            System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n            \\n        }\\n        \\n        int m = removeQueries.length;\\n        long[] ans = new long[m];\\n        int i = 0;\\n        \\n        for(int x: removeQueries){\\n            \\n            seg.update(x);\\n            if(debug){\\n                System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n                System.out.println(seg.leftChild.smaxSeg+\" \"+seg.rightChild.pmaxSeg);\\n                System.out.println(\"----\");\\n            }\\n            long y = seg.maxSeg;\\n            ans[i++] = y;\\n        }\\n        \\n        return ans;\\n                \\n    }\\n    \\n    \\n    \\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class SegTree{\\n        \\n        long maxSeg;\\n        long pmaxSeg;\\n        long smaxSeg;\\n        \\n        int pPointer;\\n        int sPointer;\\n        \\n        int left;\\n        int right;\\n        \\n        SegTree leftChild;\\n        SegTree rightChild;\\n        \\n        public SegTree(int[] a, int l, int r){\\n            \\n            pPointer = -1;\\n            sPointer = -1;\\n            left = l;\\n            right = r;\\n\\n            if(l==r){\\n                maxSeg = a[l];\\n                pmaxSeg = a[l];\\n                smaxSeg = a[l];\\n                return;\\n            }\\n            \\n            int m = l+(r-l)/2;\\n            leftChild = new SegTree(a, l, m);\\n            rightChild = new SegTree(a, m+1, r);\\n            recalc();\\n            \\n        }\\n        \\n        public void update(int x){\\n            if(left==right){\\n                maxSeg = 0;\\n                pmaxSeg = 0;\\n                smaxSeg = 0;\\n                pPointer = left;\\n                sPointer = left;\\n                return;\\n            }\\n            if(x<=leftChild.right){\\n                leftChild.update(x);\\n            }else{\\n                rightChild.update(x);\\n            }\\n            recalc();\\n        }\\n        \\n        private void recalc(){\\n            \\n            pmaxSeg = leftChild.pmaxSeg;\\n            if(leftChild.pPointer == -1){\\n                pmaxSeg = rightChild.pmaxSeg + leftChild.pmaxSeg;\\n            }\\n            \\n            smaxSeg = rightChild.smaxSeg;\\n            if(rightChild.sPointer == -1){\\n                smaxSeg = leftChild.smaxSeg + rightChild.smaxSeg;\\n            }\\n            \\n            pPointer = leftChild.pPointer;\\n            if(leftChild.pPointer == -1) pPointer = rightChild.pPointer;\\n            \\n            sPointer = rightChild.sPointer;\\n            if(rightChild.sPointer == -1) sPointer = leftChild.sPointer;\\n            \\n            maxSeg = Math.max(leftChild.maxSeg, rightChild.maxSeg);\\n            \\n            //check if maxSeg lies half left and half right\\n            if(leftChild.pPointer == -1){\\n                maxSeg = Math.max(maxSeg, leftChild.maxSeg + rightChild.pmaxSeg);\\n            }\\n            \\n            if(rightChild.sPointer == -1){\\n                maxSeg = Math.max(maxSeg, rightChild.maxSeg + leftChild.smaxSeg);\\n            }\\n            \\n            maxSeg = Math.max(maxSeg, leftChild.smaxSeg + rightChild.pmaxSeg);\\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    boolean debug = false;\\n    \\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        \\n        int n = nums.length;\\n        SegTree seg = new SegTree(nums, 0, n-1);\\n        \\n        if(debug){\\n            \\n            System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n            \\n        }\\n        \\n        int m = removeQueries.length;\\n        long[] ans = new long[m];\\n        int i = 0;\\n        \\n        for(int x: removeQueries){\\n            \\n            seg.update(x);\\n            if(debug){\\n                System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n                System.out.println(seg.leftChild.smaxSeg+\" \"+seg.rightChild.pmaxSeg);\\n                System.out.println(\"----\");\\n            }\\n            long y = seg.maxSeg;\\n            ans[i++] = y;\\n        }\\n        \\n        return ans;\\n                \\n    }\\n    \\n    \\n    \\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458208,
                "title": "brute-force-approach-to-think",
                "content": "This is the inutitive first easy approach that you may start with.\\n\\n\\n\\n\\n\\n\\n        \\n    vector<long long> maximumSegmentSum(vector<int>& nums,vector<int>& removeQueries) {\\n        vector<long long> ans;  \\n        \\n        vector<int> temp(nums.size()) ;\\n        for(int i = 0 ; i<nums.size() ; i++)       temp[i] = nums[i] ;\\n        \\n        for(int i = 0 ; i<removeQueries.size() ; i++){\\n            \\n           \\n            temp[removeQueries[i]] = 0 ;\\n            \\n             long long curr_sum = 0 ;\\n             long long max_sum_till_now = INT_MIN ;\\n        \\n        \\n          for(int i = 0 ; i<temp.size() ; i++){\\n            \\n            curr_sum += temp[i] ;\\n            max_sum_till_now = max(max_sum_till_now, curr_sum) ;\\n            \\n           if(temp[i]==0)   curr_sum = 0 ;\\n        }\\n            \\n            ans.push_back(max_sum_till_now) ;\\n        }\\n        \\n        \\n        \\n        return ans ;\\n        \\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t//29 test cases are passed . this is how yoou can start.",
                "solutionTags": [
                    "C"
                ],
                "code": "This is the inutitive first easy approach that you may start with.\\n\\n\\n\\n\\n\\n\\n        \\n    vector<long long> maximumSegmentSum(vector<int>& nums,vector<int>& removeQueries) {\\n        vector<long long> ans;  \\n        \\n        vector<int> temp(nums.size()) ;\\n        for(int i = 0 ; i<nums.size() ; i++)       temp[i] = nums[i] ;\\n        \\n        for(int i = 0 ; i<removeQueries.size() ; i++){\\n            \\n           \\n            temp[removeQueries[i]] = 0 ;\\n            \\n             long long curr_sum = 0 ;\\n             long long max_sum_till_now = INT_MIN ;\\n        \\n        \\n          for(int i = 0 ; i<temp.size() ; i++){\\n            \\n            curr_sum += temp[i] ;\\n            max_sum_till_now = max(max_sum_till_now, curr_sum) ;\\n            \\n           if(temp[i]==0)   curr_sum = 0 ;\\n        }\\n            \\n            ans.push_back(max_sum_till_now) ;\\n        }\\n        \\n        \\n        \\n        return ans ;\\n        \\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t//29 test cases are passed . this is how yoou can start.",
                "codeTag": "Unknown"
            },
            {
                "id": 2457314,
                "title": "python-go-c-c-merge-segments-reversely-for-split-playback-o-n",
                "content": "*Python* w/ prefix sum\\n\\n```python\\ndef maximumSegmentSum(self, nums, removeQueries):\\n    res, seen, psum = [0], {}, list(itertools.accumulate(nums, initial=0))\\n    for i in removeQueries[:0:-1]:                      # iterate reversely\\n        l, r = seen.get(i - 1, i), seen.get(i + 1, i)   # find leftmost and rightmost for current conjuntion\\n        seen[l], seen[r] = r, l                         # mark and merge segments from leftmost to rightmost\\n        res.append(max(res[-1], psum[r + 1] - psum[l])) # maximize segment sum from leftmost to rightmost\\n    return res[::-1]\\n```\\n\\n*Go* w/ prefix sum\\n\\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tvar (\\n\\t\\tn    = len(nums)\\n\\t\\tres  = make([]int64, n)\\n\\t\\tseen = make(map[int]int)\\n\\t\\tpsum = make([]int64, 1)\\n\\t)\\n\\tfor i, num := range nums {\\n\\t\\tpsum = append(psum, psum[i]+int64(num))\\n\\t}\\n\\tfor i := n - 1; i > 0; i-- {\\n\\t\\tj := removeQueries[i]\\n\\t\\tl, r := j, j\\n\\t\\tif k, ok := seen[j-1]; ok {\\n\\t\\t\\tl = k\\n\\t\\t}\\n\\t\\tif k, ok := seen[j+1]; ok {\\n\\t\\t\\tr = k\\n\\t\\t}\\n\\t\\tseen[l], seen[r] = r, l\\n\\t\\tres[i-1] = max(res[i], psum[r+1]-psum[l])\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*C++* w/ prefix sum\\n\\n```c++\\nvector<long long> maximumSegmentSum(vector<int> &nums, vector<int> &removeQueries) {\\n    int n = nums.size();\\n    vector<long long> res(n, 0), psum(1, 0);\\n    unordered_map<int, int> seen;\\n    for (int i = 0; i < n; ++i) psum.push_back(*rbegin(psum) + nums[i]);\\n    for (int i = n - 1; i > 0; --i) {\\n        int j = removeQueries[i], l = seen.count(j - 1) ? seen[j - 1] : j, r = seen.count(j + 1) ? seen[j + 1] : j;\\n        seen[l] = r, seen[r] = l;\\n        res[i - 1] = max(res[i], psum[r + 1] - psum[l]);\\n    }\\n    return res;\\n}\\n```\\n\\n*C* w/ prefix sum\\n\\n```c\\ntypedef long long ll;\\nll max(ll x, ll y) { return x > y ? x : y; }\\nint or(int x, int y) { return x ? x : y; }\\n\\nlong long *maximumSegmentSum(int *nums, int numsSize, int *removeQueries, int removeQueriesSize, int *returnSize) {\\n    \\n    ll *res = (ll *)calloc(numsSize, sizeof(ll));\\n    int *vis = (int *)calloc(numsSize + 2, sizeof(int));\\n    ll *psum = (ll *)calloc(numsSize + 1, sizeof(ll));\\n    \\n    for (int i = 0; i < numsSize; ++i) psum[i + 1] = psum[i] + nums[i];\\n    \\n    for (int i = numsSize - 1; i > 0; --i) {\\n        int j = removeQueries[i] + 1, l = or(vis[j - 1], j), r = or(vis[j + 1], j);\\n        vis[l] = r, vis[r] = l;\\n        res[i - 1] = max(res[i], psum[r] - psum[l - 1]);\\n    }\\n    \\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumSegmentSum(self, nums, removeQueries):\\n    res, seen, psum = [0], {}, list(itertools.accumulate(nums, initial=0))\\n    for i in removeQueries[:0:-1]:                      # iterate reversely\\n        l, r = seen.get(i - 1, i), seen.get(i + 1, i)   # find leftmost and rightmost for current conjuntion\\n        seen[l], seen[r] = r, l                         # mark and merge segments from leftmost to rightmost\\n        res.append(max(res[-1], psum[r + 1] - psum[l])) # maximize segment sum from leftmost to rightmost\\n    return res[::-1]\\n```\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tvar (\\n\\t\\tn    = len(nums)\\n\\t\\tres  = make([]int64, n)\\n\\t\\tseen = make(map[int]int)\\n\\t\\tpsum = make([]int64, 1)\\n\\t)\\n\\tfor i, num := range nums {\\n\\t\\tpsum = append(psum, psum[i]+int64(num))\\n\\t}\\n\\tfor i := n - 1; i > 0; i-- {\\n\\t\\tj := removeQueries[i]\\n\\t\\tl, r := j, j\\n\\t\\tif k, ok := seen[j-1]; ok {\\n\\t\\t\\tl = k\\n\\t\\t}\\n\\t\\tif k, ok := seen[j+1]; ok {\\n\\t\\t\\tr = k\\n\\t\\t}\\n\\t\\tseen[l], seen[r] = r, l\\n\\t\\tres[i-1] = max(res[i], psum[r+1]-psum[l])\\n\\t}\\n\\treturn res\\n}\\n```\n```c++\\nvector<long long> maximumSegmentSum(vector<int> &nums, vector<int> &removeQueries) {\\n    int n = nums.size();\\n    vector<long long> res(n, 0), psum(1, 0);\\n    unordered_map<int, int> seen;\\n    for (int i = 0; i < n; ++i) psum.push_back(*rbegin(psum) + nums[i]);\\n    for (int i = n - 1; i > 0; --i) {\\n        int j = removeQueries[i], l = seen.count(j - 1) ? seen[j - 1] : j, r = seen.count(j + 1) ? seen[j + 1] : j;\\n        seen[l] = r, seen[r] = l;\\n        res[i - 1] = max(res[i], psum[r + 1] - psum[l]);\\n    }\\n    return res;\\n}\\n```\n```c\\ntypedef long long ll;\\nll max(ll x, ll y) { return x > y ? x : y; }\\nint or(int x, int y) { return x ? x : y; }\\n\\nlong long *maximumSegmentSum(int *nums, int numsSize, int *removeQueries, int removeQueriesSize, int *returnSize) {\\n    \\n    ll *res = (ll *)calloc(numsSize, sizeof(ll));\\n    int *vis = (int *)calloc(numsSize + 2, sizeof(int));\\n    ll *psum = (ll *)calloc(numsSize + 1, sizeof(ll));\\n    \\n    for (int i = 0; i < numsSize; ++i) psum[i + 1] = psum[i] + nums[i];\\n    \\n    for (int i = numsSize - 1; i > 0; --i) {\\n        int j = removeQueries[i] + 1, l = or(vis[j - 1], j), r = or(vis[j + 1], j);\\n        vis[l] = r, vis[r] = l;\\n        res[i - 1] = max(res[i], psum[r] - psum[l - 1]);\\n    }\\n    \\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2456272,
                "title": "easy-c-solution-range-splitting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Queries) {\\n        set<pair<int,int>> range;\\n        multiset<long long> ms;\\n        ms.insert(0);\\n        vector<long long> a(nums.size());\\n        a[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++) a[i] = nums[i] + a[i-1];\\n        vector<long long> ans;\\n        ms.insert(a.back());  // sum of range [0,n-1]\\n        range.insert({0,nums.size()-1});  // range [0..n-1]\\n        for(int q : Queries) {\\n            auto pos = range.upper_bound({q,2e9});\\n            if(pos == range.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            pos--;\\n            \\n            long long Left = (q ? a[q - 1] : 0) - (pos->first ? a[pos->first - 1] : 0);\\n            long long Right = a[pos->second] - a[q];\\n            long long cur = a[pos->second] - (pos->first ? a[pos->first - 1] : 0);\\n            \\n            \\n            // range [1...4] , erase q = 3 , split into => range[1..2] & range[4..4]     \\n            \\n            if(pos->first<=q-1) {\\n                 range.insert({pos->first,q-1});   // left split\\n                 ms.insert(Left);\\n            }\\n            if(pos->second>=q+1) {\\n                 range.insert({q+1,pos->second});   // rightsplit\\n                 ms.insert(Right);\\n            }\\n            \\n            ms.erase(ms.find(cur));  // erase the sum of range \\n            \\n            range.erase(pos);  // erase the range\\n         \\n            ans.push_back(*ms.rbegin());   // maximum range sum\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Queries) {\\n        set<pair<int,int>> range;\\n        multiset<long long> ms;\\n        ms.insert(0);\\n        vector<long long> a(nums.size());\\n        a[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++) a[i] = nums[i] + a[i-1];\\n        vector<long long> ans;\\n        ms.insert(a.back());  // sum of range [0,n-1]\\n        range.insert({0,nums.size()-1});  // range [0..n-1]\\n        for(int q : Queries) {\\n            auto pos = range.upper_bound({q,2e9});\\n            if(pos == range.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            pos--;\\n            \\n            long long Left = (q ? a[q - 1] : 0) - (pos->first ? a[pos->first - 1] : 0);\\n            long long Right = a[pos->second] - a[q];\\n            long long cur = a[pos->second] - (pos->first ? a[pos->first - 1] : 0);\\n            \\n            \\n            // range [1...4] , erase q = 3 , split into => range[1..2] & range[4..4]     \\n            \\n            if(pos->first<=q-1) {\\n                 range.insert({pos->first,q-1});   // left split\\n                 ms.insert(Left);\\n            }\\n            if(pos->second>=q+1) {\\n                 range.insert({q+1,pos->second});   // rightsplit\\n                 ms.insert(Right);\\n            }\\n            \\n            ms.erase(ms.find(cur));  // erase the sum of range \\n            \\n            range.erase(pos);  // erase the range\\n         \\n            ans.push_back(*ms.rbegin());   // maximum range sum\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456230,
                "title": "python-easy-solution-o-n",
                "content": "segments[q] contains two informations curv and cur_len which is the value of the interval that contains q and length of the interval, respectively.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        segments = defaultdict(lambda:(0,0))\\n        cur_max = 0\\n        res = []\\n        for q in reversed(removeQueries):\\n            lv, left_len = segments[q-1]\\n            rv, right_len = segments[q+1]\\n            curv, cur_len = lv+rv+nums[q], left_len+right_len+1 \\n            segments[q-left_len] = (curv, cur_len)\\n            segments[q+right_len] = (curv, cur_len)\\n            cur_max = max(cur_max, curv)\\n            res.append(cur_max)\\n        res.pop()\\n        res.reverse()\\n        res.append(0)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "segments[q] contains two informations curv and cur_len which is the value of the interval that contains q and length of the interval, respectively.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        segments = defaultdict(lambda:(0,0))\\n        cur_max = 0\\n        res = []\\n        for q in reversed(removeQueries):\\n            lv, left_len = segments[q-1]\\n            rv, right_len = segments[q+1]\\n            curv, cur_len = lv+rv+nums[q], left_len+right_len+1 \\n            segments[q-left_len] = (curv, cur_len)\\n            segments[q+right_len] = (curv, cur_len)\\n            cur_max = max(cur_max, curv)\\n            res.append(cur_max)\\n        res.pop()\\n        res.reverse()\\n        res.append(0)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2456219,
                "title": "typescript-solution-bst-and-pq",
                "content": "class LinkedList {\\n      constructor(\\n        public key = 0,\\n        public color = \"B\",\\n        public left: LinkedList | null = null,\\n        public right: LinkedList | null = null,\\n        public p: LinkedList | null = null\\n      ) {}\\n    }\\n\\n    class BST {\\n      private root: LinkedList | null;\\n      constructor() {\\n        this.root = null;\\n      }\\n\\n      private rotateLeft = function (x: LinkedList) {\\n        let y = x.right!;\\n        y.p = x.p;\\n\\n        if (x.p === null) this.root = y;\\n        else if (x.p.left === x) x.p.left = y;\\n        else x.p.right = y;\\n\\n        x.right = y.left;\\n        if (x.right !== null) x.right.p = x;\\n\\n        y.left = x;\\n        x.p = y;\\n      };\\n      private rotateRight = function (y: LinkedList) {\\n        let x = y.left!;\\n        x.p = y.p;\\n\\n        if (y.p === null) this.root = x;\\n        else if (y.p.left === y) y.p.left = x;\\n        else y.p.right = x;\\n\\n        y.left = x.right;\\n        if (y.left !== null) y.left.p = y;\\n\\n        x.right = y;\\n        y.p = x;\\n      };\\n      private insertFixUp = function (x: LinkedList | null) {\\n        while (x && x.p !== null && x.p.color === \"R\" && x.p.p) {\\n          if (x.p === x.p.p.left) {\\n            let y = x.p.p.right;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.right) {\\n                x = x.p;\\n                this.rotateLeft(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateRight(x.p!.p);\\n            }\\n          } else {\\n            let y = x.p.p.left;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.left) {\\n                x = x.p;\\n                this.rotateRight(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateLeft(x.p!.p);\\n            }\\n          }\\n        }\\n        this.root.color = \"B\";\\n      };\\n      insertNode = function (key: number) : number {\\n        let t: LinkedList | null = this.root;\\n        let y = t;\\n        let node = new LinkedList(key, \"R\");\\n        let min = -1;\\n        while (t !== null) {\\n          y = t;\\n          if (key < t.key) t = t.left;\\n          else {\\n            min = t.key;\\n            t = t.right;\\n          }\\n        }\\n\\n        if (y === null) this.root = y = node;\\n        else {\\n          t = node;\\n          if (key < y.key) {\\n            y.left = t;\\n          } else y.right = t;\\n          t.p = y;\\n        }\\n\\n        this.insertFixUp(node);\\n        return min;\\n      };\\n    }\\n\\n    class PriorityQueue {\\n        private pQueue : {sum: number, lowerRangeIndex: number}[];\\n        private lowerRngIndexPair: Map<number, number>;\\n        private heapSize : number;\\n        constructor() {\\n            this.pQueue = [];\\n            this.heapSize = 0;    \\n            this.lowerRngIndexPair = new Map<number, number>();\\n        }\\n        heapMax = function () : number {\\n            return (this.pQueue[0] as {sum: number, lowerRangeIndex: number}).sum;\\n        }\\n        pop = function (lwrRngIndex: number) : number {\\n            let hpIdx = (this.lowerRngIndexPair as Map<number, number>).get(lwrRngIndex)!;\\n            let max = (this.pQueue[hpIdx] as {sum: number, lowerRangeIndex: number}).sum;\\n            this.swapElements(hpIdx, this.heapSize - 1);\\n            (this.lowerRngIndexPair as Map<number, number>).delete(lwrRngIndex);\\n            this.heapSize--;\\n            \\n            let i = hpIdx;\\n            let parent = Math.ceil(i / 2) - 1;\\n            if (parent >= 0 && i > 0 && this.pQueue[i].sum >= this.pQueue[parent].sum) {\\n              while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                  this.swapElements(i, parent);\\n                  i = parent;\\n                  parent = Math.ceil(i / 2) - 1;\\n                } else break;\\n              }\\n            }\\n            else this.maxHeap(hpIdx);\\n            return max;\\n\\n        }\\n        insert = function (sum : number, lowerRangeIndex: number) {\\n            this.heapSize++;\\n            this.pQueue[this.heapSize - 1] = { sum: sum, lowerRangeIndex: lowerRangeIndex };\\n            (this.lowerRngIndexPair as Map<number, number>).set(lowerRangeIndex, this.heapSize - 1);\\n            if (this.heapSize === 1)\\n                return;\\n\\n            let i = this.heapSize - 1;\\n            let parent = Math.ceil(i / 2) - 1;\\n\\n            while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                    this.swapElements(i, parent);\\n                    i = parent;\\n                    parent = Math.ceil(i / 2) - 1;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        private swapElements(i : number, j : number) {\\n            let temp = this.pQueue[i];\\n            this.pQueue[i] = this.pQueue[j];\\n            this.lowerRngIndexPair.set(this.pQueue[i].lowerRangeIndex, i);\\n            this.pQueue[j] = temp;\\n            this.lowerRngIndexPair.set(this.pQueue[j].lowerRangeIndex, j);\\n        }\\n        private maxHeap(i: number) {\\n            let leftChildIndex = 2 * i + 1;\\n            if (leftChildIndex >= this.heapSize)\\n                return;\\n    \\n            let rightChildIndex = leftChildIndex + 1;\\n            if (rightChildIndex >= this.heapSize) {\\n                if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum)\\n                    this.swapElements(i, leftChildIndex);\\n            }\\n            else if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum || this.pQueue[i].sum < this.pQueue[rightChildIndex].sum) {\\n                if (this.pQueue[leftChildIndex].sum <= this.pQueue[rightChildIndex].sum) {\\n                    this.swapElements(i, rightChildIndex);\\n                    this.maxHeap(rightChildIndex);\\n                }\\n                else if (this.pQueue[rightChildIndex].sum < this.pQueue[leftChildIndex].sum) {\\n                    this.swapElements(i, leftChildIndex);\\n                    this.maxHeap(leftChildIndex);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function maximumSegmentSum(nums: number[], removeQueries: number[]): number[] {\\n\\n     if(nums.length === 1) return [0];\\n      const sumNums : number[] = [nums[0]];\\n      const maxSegSum : number[] = [];\\n      for(let i = 1; i< nums.length; i++) {\\n        sumNums[i] = sumNums[i - 1] + nums[i];\\n      }\\n\\n      const calcRangeSum = (l1:number, l2:number) : number => {\\n        let res = sumNums[l2];\\n        res -= ((l1 === 0) ? 0 : sumNums[l1 - 1]);\\n        return res;\\n      }\\n\\n      const tree = new BST();\\n      const pq = new PriorityQueue();\\n      {\\n        let upperRIndx = removeQueries[0];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        if(upperRIndx !== 0) {\\n          let rSum = calcRangeSum(lowerRIndx + 1, upperRIndx - 1);\\n          pq.insert(rSum, lowerRIndx);\\n        }\\n        if(upperRIndx != nums.length - 1) {\\n          let rSum = calcRangeSum(upperRIndx + 1, nums.length - 1);\\n          pq.insert(rSum, upperRIndx);\\n        }\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      for (let i = 1; i < removeQueries.length - 1; i++) {\\n        let upperRIndx = removeQueries[i];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        let totalSum = pq.pop(lowerRIndx);\\n        let lSum = (lowerRIndx < upperRIndx - 1) ? calcRangeSum(lowerRIndx + 1, upperRIndx - 1) : 0;\\n        let rSum = totalSum - lSum - nums[removeQueries[i]];\\n        if (lSum) pq.insert(lSum, lowerRIndx);\\n        if (rSum) pq.insert(rSum, upperRIndx);\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      maxSegSum.push(0);\\n      return maxSegSum;\\n    };",
                "solutionTags": [
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "class LinkedList {\\n      constructor(\\n        public key = 0,\\n        public color = \"B\",\\n        public left: LinkedList | null = null,\\n        public right: LinkedList | null = null,\\n        public p: LinkedList | null = null\\n      ) {}\\n    }\\n\\n    class BST {\\n      private root: LinkedList | null;\\n      constructor() {\\n        this.root = null;\\n      }\\n\\n      private rotateLeft = function (x: LinkedList) {\\n        let y = x.right!;\\n        y.p = x.p;\\n\\n        if (x.p === null) this.root = y;\\n        else if (x.p.left === x) x.p.left = y;\\n        else x.p.right = y;\\n\\n        x.right = y.left;\\n        if (x.right !== null) x.right.p = x;\\n\\n        y.left = x;\\n        x.p = y;\\n      };\\n      private rotateRight = function (y: LinkedList) {\\n        let x = y.left!;\\n        x.p = y.p;\\n\\n        if (y.p === null) this.root = x;\\n        else if (y.p.left === y) y.p.left = x;\\n        else y.p.right = x;\\n\\n        y.left = x.right;\\n        if (y.left !== null) y.left.p = y;\\n\\n        x.right = y;\\n        y.p = x;\\n      };\\n      private insertFixUp = function (x: LinkedList | null) {\\n        while (x && x.p !== null && x.p.color === \"R\" && x.p.p) {\\n          if (x.p === x.p.p.left) {\\n            let y = x.p.p.right;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.right) {\\n                x = x.p;\\n                this.rotateLeft(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateRight(x.p!.p);\\n            }\\n          } else {\\n            let y = x.p.p.left;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.left) {\\n                x = x.p;\\n                this.rotateRight(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateLeft(x.p!.p);\\n            }\\n          }\\n        }\\n        this.root.color = \"B\";\\n      };\\n      insertNode = function (key: number) : number {\\n        let t: LinkedList | null = this.root;\\n        let y = t;\\n        let node = new LinkedList(key, \"R\");\\n        let min = -1;\\n        while (t !== null) {\\n          y = t;\\n          if (key < t.key) t = t.left;\\n          else {\\n            min = t.key;\\n            t = t.right;\\n          }\\n        }\\n\\n        if (y === null) this.root = y = node;\\n        else {\\n          t = node;\\n          if (key < y.key) {\\n            y.left = t;\\n          } else y.right = t;\\n          t.p = y;\\n        }\\n\\n        this.insertFixUp(node);\\n        return min;\\n      };\\n    }\\n\\n    class PriorityQueue {\\n        private pQueue : {sum: number, lowerRangeIndex: number}[];\\n        private lowerRngIndexPair: Map<number, number>;\\n        private heapSize : number;\\n        constructor() {\\n            this.pQueue = [];\\n            this.heapSize = 0;    \\n            this.lowerRngIndexPair = new Map<number, number>();\\n        }\\n        heapMax = function () : number {\\n            return (this.pQueue[0] as {sum: number, lowerRangeIndex: number}).sum;\\n        }\\n        pop = function (lwrRngIndex: number) : number {\\n            let hpIdx = (this.lowerRngIndexPair as Map<number, number>).get(lwrRngIndex)!;\\n            let max = (this.pQueue[hpIdx] as {sum: number, lowerRangeIndex: number}).sum;\\n            this.swapElements(hpIdx, this.heapSize - 1);\\n            (this.lowerRngIndexPair as Map<number, number>).delete(lwrRngIndex);\\n            this.heapSize--;\\n            \\n            let i = hpIdx;\\n            let parent = Math.ceil(i / 2) - 1;\\n            if (parent >= 0 && i > 0 && this.pQueue[i].sum >= this.pQueue[parent].sum) {\\n              while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                  this.swapElements(i, parent);\\n                  i = parent;\\n                  parent = Math.ceil(i / 2) - 1;\\n                } else break;\\n              }\\n            }\\n            else this.maxHeap(hpIdx);\\n            return max;\\n\\n        }\\n        insert = function (sum : number, lowerRangeIndex: number) {\\n            this.heapSize++;\\n            this.pQueue[this.heapSize - 1] = { sum: sum, lowerRangeIndex: lowerRangeIndex };\\n            (this.lowerRngIndexPair as Map<number, number>).set(lowerRangeIndex, this.heapSize - 1);\\n            if (this.heapSize === 1)\\n                return;\\n\\n            let i = this.heapSize - 1;\\n            let parent = Math.ceil(i / 2) - 1;\\n\\n            while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                    this.swapElements(i, parent);\\n                    i = parent;\\n                    parent = Math.ceil(i / 2) - 1;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        private swapElements(i : number, j : number) {\\n            let temp = this.pQueue[i];\\n            this.pQueue[i] = this.pQueue[j];\\n            this.lowerRngIndexPair.set(this.pQueue[i].lowerRangeIndex, i);\\n            this.pQueue[j] = temp;\\n            this.lowerRngIndexPair.set(this.pQueue[j].lowerRangeIndex, j);\\n        }\\n        private maxHeap(i: number) {\\n            let leftChildIndex = 2 * i + 1;\\n            if (leftChildIndex >= this.heapSize)\\n                return;\\n    \\n            let rightChildIndex = leftChildIndex + 1;\\n            if (rightChildIndex >= this.heapSize) {\\n                if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum)\\n                    this.swapElements(i, leftChildIndex);\\n            }\\n            else if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum || this.pQueue[i].sum < this.pQueue[rightChildIndex].sum) {\\n                if (this.pQueue[leftChildIndex].sum <= this.pQueue[rightChildIndex].sum) {\\n                    this.swapElements(i, rightChildIndex);\\n                    this.maxHeap(rightChildIndex);\\n                }\\n                else if (this.pQueue[rightChildIndex].sum < this.pQueue[leftChildIndex].sum) {\\n                    this.swapElements(i, leftChildIndex);\\n                    this.maxHeap(leftChildIndex);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function maximumSegmentSum(nums: number[], removeQueries: number[]): number[] {\\n\\n     if(nums.length === 1) return [0];\\n      const sumNums : number[] = [nums[0]];\\n      const maxSegSum : number[] = [];\\n      for(let i = 1; i< nums.length; i++) {\\n        sumNums[i] = sumNums[i - 1] + nums[i];\\n      }\\n\\n      const calcRangeSum = (l1:number, l2:number) : number => {\\n        let res = sumNums[l2];\\n        res -= ((l1 === 0) ? 0 : sumNums[l1 - 1]);\\n        return res;\\n      }\\n\\n      const tree = new BST();\\n      const pq = new PriorityQueue();\\n      {\\n        let upperRIndx = removeQueries[0];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        if(upperRIndx !== 0) {\\n          let rSum = calcRangeSum(lowerRIndx + 1, upperRIndx - 1);\\n          pq.insert(rSum, lowerRIndx);\\n        }\\n        if(upperRIndx != nums.length - 1) {\\n          let rSum = calcRangeSum(upperRIndx + 1, nums.length - 1);\\n          pq.insert(rSum, upperRIndx);\\n        }\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      for (let i = 1; i < removeQueries.length - 1; i++) {\\n        let upperRIndx = removeQueries[i];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        let totalSum = pq.pop(lowerRIndx);\\n        let lSum = (lowerRIndx < upperRIndx - 1) ? calcRangeSum(lowerRIndx + 1, upperRIndx - 1) : 0;\\n        let rSum = totalSum - lSum - nums[removeQueries[i]];\\n        if (lSum) pq.insert(lSum, lowerRIndx);\\n        if (rSum) pq.insert(rSum, upperRIndx);\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      maxSegSum.push(0);\\n      return maxSegSum;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2455931,
                "title": "c-reverse-seg-merge-100",
                "content": "Inspired by https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2454208/Reverse-Union-Find\\n**Time O(n) space O(n)**\\nOne more improvement is we actually don\\u2019t need union find. \\nFor calculate a rang sum , use prefix sum array. \\nFor handle segment merge use the start and end point of the range to store length of a segment, this would  and make everything **strictly O(n)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    vector<int> segs;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        ans = vector<long long>(n);\\n        prefix = vector<long long>(n + 1, 0);\\n        segs = vector<int>(n, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        long long pre = 0;\\n        ans[n -1] = 0;\\n        for (int i = n -1; i>= 1; i--) {\\n            int q = rq[i];\\n            int cur = 1;\\n            int lr = q - 1;\\n            int ll = lr >= 0 ? lr - segs[lr] + 1 : lr + 1;\\n            long long ls = getsum(ll, lr);\\n            \\n            int rl = q + 1;\\n            int rr = rl < n ? rl + segs[rl] - 1 : rl - 1;\\n            long long rs = getsum(rl, rr);\\n            ans[i - 1] = max(pre, ls + rs + nums[q]);\\n            pre = ans[i - 1];\\n            \\n            int a = (ll <= lr) ? ll : q;\\n            int b = (rl <= rr) ? rr : q;\\n            int l = b - a + 1;\\n            segs[a] = l;\\n            segs[b] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOption 2, use multiset , forward simulation O(nlog(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    multiset<long long> mp;\\n    set<int> seg;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    // sum by seg\\n    long long getsum1(int l, int r) {\\n        return getsum(l + 1, r -1);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        prefix = vector<long long>(n + 1, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        mp.insert(prefix[n]);\\n        seg.insert(n);\\n        seg.insert(-1);\\n        for (auto& q : rq) {\\n            auto r = seg.upper_bound(q);\\n            int b = *r;\\n            r--;\\n            int a = *r;\\n            //cout << q << \",\" << a << \",\" << b << endl;\\n            long long s = getsum1(a, b);\\n            auto iter = mp.find(s);\\n            mp.erase(iter);\\n            \\n            long long ls = getsum1(a, q);\\n            long long rs = getsum1(q, b);\\n            if (ls > 0) mp.insert(ls);\\n            if (rs > 0) mp.insert(rs);\\n            long long cur = mp.empty() ? 0 : *mp.rbegin();\\n            //cout << q << \",\" << ls << \",\" << rs << \",\" << cur << endl;\\n            ans.push_back(cur);\\n            seg.insert(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    vector<int> segs;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        ans = vector<long long>(n);\\n        prefix = vector<long long>(n + 1, 0);\\n        segs = vector<int>(n, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        long long pre = 0;\\n        ans[n -1] = 0;\\n        for (int i = n -1; i>= 1; i--) {\\n            int q = rq[i];\\n            int cur = 1;\\n            int lr = q - 1;\\n            int ll = lr >= 0 ? lr - segs[lr] + 1 : lr + 1;\\n            long long ls = getsum(ll, lr);\\n            \\n            int rl = q + 1;\\n            int rr = rl < n ? rl + segs[rl] - 1 : rl - 1;\\n            long long rs = getsum(rl, rr);\\n            ans[i - 1] = max(pre, ls + rs + nums[q]);\\n            pre = ans[i - 1];\\n            \\n            int a = (ll <= lr) ? ll : q;\\n            int b = (rl <= rr) ? rr : q;\\n            int l = b - a + 1;\\n            segs[a] = l;\\n            segs[b] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    multiset<long long> mp;\\n    set<int> seg;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    // sum by seg\\n    long long getsum1(int l, int r) {\\n        return getsum(l + 1, r -1);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        prefix = vector<long long>(n + 1, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        mp.insert(prefix[n]);\\n        seg.insert(n);\\n        seg.insert(-1);\\n        for (auto& q : rq) {\\n            auto r = seg.upper_bound(q);\\n            int b = *r;\\n            r--;\\n            int a = *r;\\n            //cout << q << \",\" << a << \",\" << b << endl;\\n            long long s = getsum1(a, b);\\n            auto iter = mp.find(s);\\n            mp.erase(iter);\\n            \\n            long long ls = getsum1(a, q);\\n            long long rs = getsum1(q, b);\\n            if (ls > 0) mp.insert(ls);\\n            if (rs > 0) mp.insert(rs);\\n            long long cur = mp.empty() ? 0 : *mp.rbegin();\\n            //cout << q << \",\" << ls << \",\" << rs << \",\" << cur << endl;\\n            ans.push_back(cur);\\n            seg.insert(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455910,
                "title": "o-nlogn-merging-intervals-and-sum-values-using-hash-map-example-illustration",
                "content": "**Main Idea**:\\n+ The problem changes to **find maximum segment sum** after **inserting elements** with positions **from last to begin** of removeQueries.\\n+ Data structure for intervals **(ai, bi)** where **hs[ai]=bi**, **he[bi]=ai**, with sum values **s[(ai, bi)]** and sorted set **seg[(si, (ai, bi))]**\\n\\n**Examples**:\\n```\\n[1, 2, 5, 6, 1] [0, 3, 2, 4, 1]\\n+ 1 sums: [2] - s: [(2, (1, 1))] - hs: {1: 1} - he: {1: 1} - ans: [0, 2]\\n+ 4 sums: [2, 1] - s: [(1, (4, 4)), (2, (1, 1))] - hs: {1: 1, 4: 4} - he: {1: 1, 4: 4} - ans: [0, 2, 2]\\n+ 2 sums: [1, 7] - s: [(1, (4, 4)), (7, (1, 2))] - hs: {1: 2, 4: 4} - he: {4: 4, 2: 1} - ans: [0, 2, 2, 7]\\n+ 3 sums: [14] - s: [(14, (1, 4))] - hs: {1: 4} - he: {4: 1} - ans: [0, 2, 2, 7, 14]\\nans: [14, 7, 2, 2, 0]\\n====================\\n\\n[3, 2, 11, 1] [3, 2, 1, 0]\\n+ 0 sums: [3] - s: [(3, (0, 0))] - hs: {0: 0} - he: {0: 0} - ans: [0, 3]\\n+ 1 sums: [5] - s: [(5, (0, 1))] - hs: {0: 1} - he: {1: 0} - ans: [0, 3, 5]\\n+ 2 sums: [16] - s: [(16, (0, 2))] - hs: {0: 2} - he: {2: 0} - ans: [0, 3, 5, 16]\\nans: [16, 5, 3, 0]\\n====================\\n```\\n**Code**:\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        seg = SortedSet([])\\n        hs = {}\\n        he = {}\\n        s = {}\\n        ans = [0]\\n        cnt = 0\\n        removeQueries = removeQueries[::-1][:-1]\\n        for pi in removeQueries:\\n            ai, bi, si = pi, pi, nums[pi]\\n            if hs.get(bi+1) is not None:\\n                ki = (bi+1, hs[bi+1])\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                bi = hs.pop(bi+1)\\n                si += ti\\n            if he.get(ai-1) is not None:\\n                ki = (he[ai-1], ai-1)\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                ai = he.pop(ai-1)\\n                si += ti\\n            hs[ai], he[bi] = bi, ai\\n            s[(ai, bi)] = si\\n            seg.add((si, (ai, bi)))\\n            ans.append(seg[-1][0])\\n            print(\"+\", pi, \"sums:\", list(s.values()), \"- s:\", list(seg), \"- hs:\", hs, \"- he:\", he, \"- ans:\", ans)\\n        \\n        ans = ans[::-1]\\n        print(\"ans:\", ans)\\n        print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "solutionTags": [],
                "code": "```\\n[1, 2, 5, 6, 1] [0, 3, 2, 4, 1]\\n+ 1 sums: [2] - s: [(2, (1, 1))] - hs: {1: 1} - he: {1: 1} - ans: [0, 2]\\n+ 4 sums: [2, 1] - s: [(1, (4, 4)), (2, (1, 1))] - hs: {1: 1, 4: 4} - he: {1: 1, 4: 4} - ans: [0, 2, 2]\\n+ 2 sums: [1, 7] - s: [(1, (4, 4)), (7, (1, 2))] - hs: {1: 2, 4: 4} - he: {4: 4, 2: 1} - ans: [0, 2, 2, 7]\\n+ 3 sums: [14] - s: [(14, (1, 4))] - hs: {1: 4} - he: {4: 1} - ans: [0, 2, 2, 7, 14]\\nans: [14, 7, 2, 2, 0]\\n====================\\n\\n[3, 2, 11, 1] [3, 2, 1, 0]\\n+ 0 sums: [3] - s: [(3, (0, 0))] - hs: {0: 0} - he: {0: 0} - ans: [0, 3]\\n+ 1 sums: [5] - s: [(5, (0, 1))] - hs: {0: 1} - he: {1: 0} - ans: [0, 3, 5]\\n+ 2 sums: [16] - s: [(16, (0, 2))] - hs: {0: 2} - he: {2: 0} - ans: [0, 3, 5, 16]\\nans: [16, 5, 3, 0]\\n====================\\n```\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        seg = SortedSet([])\\n        hs = {}\\n        he = {}\\n        s = {}\\n        ans = [0]\\n        cnt = 0\\n        removeQueries = removeQueries[::-1][:-1]\\n        for pi in removeQueries:\\n            ai, bi, si = pi, pi, nums[pi]\\n            if hs.get(bi+1) is not None:\\n                ki = (bi+1, hs[bi+1])\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                bi = hs.pop(bi+1)\\n                si += ti\\n            if he.get(ai-1) is not None:\\n                ki = (he[ai-1], ai-1)\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                ai = he.pop(ai-1)\\n                si += ti\\n            hs[ai], he[bi] = bi, ai\\n            s[(ai, bi)] = si\\n            seg.add((si, (ai, bi)))\\n            ans.append(seg[-1][0])\\n            print(\"+\", pi, \"sums:\", list(s.values()), \"- s:\", list(seg), \"- hs:\", hs, \"- he:\", he, \"- ans:\", ans)\\n        \\n        ans = ans[::-1]\\n        print(\"ans:\", ans)\\n        print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455907,
                "title": "log-n-update-query-sum-segment-tree",
                "content": "```\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {     \\n      int n=nums.size();\\n      long long maxi=-1;\\n      int a[n];\\n      for(int i=0;i<n;i++){\\n        a[i]=nums[i];\\n         if(maxi<nums[i])\\n            maxi=nums[i];\\n      }\\n      build(a, 0, n - 1, 0);\\n      \\n       vector<long long> ans;\\n      \\n      for(int i=0;i<n;i++){\\n        \\n        \\tint index = removeQueries[i];\\n\\t        long long value = -((n/2)*maxi);\\n\\t        a[index] = value;\\n        \\tupdate(a, 0, 0, n - 1, index, value);\\n           long long res=1ll*(query(a, 0, 0, n - 1, 0 , n- 1).maxsum);\\n            if(res<=0)res=0;\\n          ans.push_back(res); \\n  }\\n    \\n     return ans;\\n      \\n    }\\n\\n  \\n  \\n  \\n  \\nstruct node {\\n  long long  sum, prefixsum, suffixsum, maxsum;\\n};\\n\\n\\nnode tree[4 * 100005];\\n\\nvoid build(int arr[], int low, int high, int index)\\n{\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = arr[low];\\n\\t\\ttree[index].prefixsum = arr[low];\\n\\t\\ttree[index].suffixsum = arr[low];\\n\\t\\ttree[index].maxsum = arr[low];\\n\\t}\\n\\telse {\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tbuild(arr, low, mid, 2 * index + 1);\\n\\t\\t\\n\\n\\t\\tbuild(arr, mid + 1, high, 2 * index + 2);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\t\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nvoid update(int arr[], int index, int low, int high,\\n\\t\\t\\tint idx, long long value)\\n{\\n\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = value;\\n\\t\\ttree[index].prefixsum = value;\\n\\t\\ttree[index].suffixsum = value;\\n\\t\\ttree[index].maxsum = value;\\n\\t}\\n\\telse {\\n\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tif (idx <= mid)\\n\\t\\t\\tupdate(arr, 2 * index + 1, low, mid, idx, value);\\n\\t\\t\\n\\n\\t\\telse\\n\\t\\t\\tupdate(arr, 2 * index + 2, mid + 1,\\n\\t\\t\\t\\thigh, idx, value);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\t\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nnode query(int arr[], int index, int low,\\n\\t\\tint high, int l, int r)\\n{\\n\\t// initially all the values are INT_MIN\\n\\tnode result;\\n\\tresult.sum = result.prefixsum =\\n\\t\\t\\t\\tresult.suffixsum =\\n\\t\\t\\t\\tresult.maxsum = INT_MIN;\\n\\n\\n\\tif (r < low || high < l)\\n\\t\\treturn result;\\n\\n\\t// complete overlap of range\\n\\tif (l <= low && high <= r)\\n\\t\\treturn tree[index];\\n\\n\\tint mid = (low + high) / 2;\\n\\n\\n\\tif (l > mid)\\n\\t\\treturn query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\tif (r <= mid)\\n\\t\\treturn query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\n\\tnode left = query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\tnode right = query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\n\\tresult.sum = left.sum + right.sum;\\n\\tresult.prefixsum = max(left.prefixsum, left.sum +\\n\\t\\t\\t\\t\\t\\tright.prefixsum);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\tresult.suffixsum = max(right.suffixsum,\\n\\t\\t\\t\\t\\tright.sum + left.suffixsum);\\n\\tresult.maxsum = max(result.prefixsum,\\n\\t\\t\\t\\t\\tmax(result.suffixsum,\\n\\t\\t\\t\\t\\tmax(left.maxsum,\\n\\t\\t\\t\\t\\tmax(right.maxsum,\\n\\t\\t\\t\\t\\tleft.suffixsum + right.prefixsum))));\\n\\t\\t\\t\\t\\t\\n\\treturn result;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {     \\n      int n=nums.size();\\n      long long maxi=-1;\\n      int a[n];\\n      for(int i=0;i<n;i++){\\n        a[i]=nums[i];\\n         if(maxi<nums[i])\\n            maxi=nums[i];\\n      }\\n      build(a, 0, n - 1, 0);\\n      \\n       vector<long long> ans;\\n      \\n      for(int i=0;i<n;i++){\\n        \\n        \\tint index = removeQueries[i];\\n\\t        long long value = -((n/2)*maxi);\\n\\t        a[index] = value;\\n        \\tupdate(a, 0, 0, n - 1, index, value);\\n           long long res=1ll*(query(a, 0, 0, n - 1, 0 , n- 1).maxsum);\\n            if(res<=0)res=0;\\n          ans.push_back(res); \\n  }\\n    \\n     return ans;\\n      \\n    }\\n\\n  \\n  \\n  \\n  \\nstruct node {\\n  long long  sum, prefixsum, suffixsum, maxsum;\\n};\\n\\n\\nnode tree[4 * 100005];\\n\\nvoid build(int arr[], int low, int high, int index)\\n{\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = arr[low];\\n\\t\\ttree[index].prefixsum = arr[low];\\n\\t\\ttree[index].suffixsum = arr[low];\\n\\t\\ttree[index].maxsum = arr[low];\\n\\t}\\n\\telse {\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tbuild(arr, low, mid, 2 * index + 1);\\n\\t\\t\\n\\n\\t\\tbuild(arr, mid + 1, high, 2 * index + 2);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\t\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nvoid update(int arr[], int index, int low, int high,\\n\\t\\t\\tint idx, long long value)\\n{\\n\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = value;\\n\\t\\ttree[index].prefixsum = value;\\n\\t\\ttree[index].suffixsum = value;\\n\\t\\ttree[index].maxsum = value;\\n\\t}\\n\\telse {\\n\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tif (idx <= mid)\\n\\t\\t\\tupdate(arr, 2 * index + 1, low, mid, idx, value);\\n\\t\\t\\n\\n\\t\\telse\\n\\t\\t\\tupdate(arr, 2 * index + 2, mid + 1,\\n\\t\\t\\t\\thigh, idx, value);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\t\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nnode query(int arr[], int index, int low,\\n\\t\\tint high, int l, int r)\\n{\\n\\t// initially all the values are INT_MIN\\n\\tnode result;\\n\\tresult.sum = result.prefixsum =\\n\\t\\t\\t\\tresult.suffixsum =\\n\\t\\t\\t\\tresult.maxsum = INT_MIN;\\n\\n\\n\\tif (r < low || high < l)\\n\\t\\treturn result;\\n\\n\\t// complete overlap of range\\n\\tif (l <= low && high <= r)\\n\\t\\treturn tree[index];\\n\\n\\tint mid = (low + high) / 2;\\n\\n\\n\\tif (l > mid)\\n\\t\\treturn query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\tif (r <= mid)\\n\\t\\treturn query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\n\\tnode left = query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\tnode right = query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\n\\tresult.sum = left.sum + right.sum;\\n\\tresult.prefixsum = max(left.prefixsum, left.sum +\\n\\t\\t\\t\\t\\t\\tright.prefixsum);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\tresult.suffixsum = max(right.suffixsum,\\n\\t\\t\\t\\t\\tright.sum + left.suffixsum);\\n\\tresult.maxsum = max(result.prefixsum,\\n\\t\\t\\t\\t\\tmax(result.suffixsum,\\n\\t\\t\\t\\t\\tmax(left.maxsum,\\n\\t\\t\\t\\t\\tmax(right.maxsum,\\n\\t\\t\\t\\t\\tleft.suffixsum + right.prefixsum))));\\n\\t\\t\\t\\t\\t\\n\\treturn result;\\n}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455870,
                "title": "javascript-solution-using-union-and-find",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    const res = Array(nums.length).fill(0) \\n    const ds = Array(nums.length).fill(Number.MAX_VALUE);\\n    for (let i = removeQueries.length - 1; i > 0; --i) {\\n        let j = removeQueries[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] !== Number.MAX_VALUE)\\n            merge(j, j - 1, ds);\\n        if (j < nums.length - 1 && ds[j + 1] !== Number.MAX_VALUE)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = Math.max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n};\\n\\nfunction find(i, ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\n\\nfunction merge(s1, s2, ds) {\\n    let p1 = find(s1, ds);\\n    let p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    const res = Array(nums.length).fill(0) \\n    const ds = Array(nums.length).fill(Number.MAX_VALUE);\\n    for (let i = removeQueries.length - 1; i > 0; --i) {\\n        let j = removeQueries[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] !== Number.MAX_VALUE)\\n            merge(j, j - 1, ds);\\n        if (j < nums.length - 1 && ds[j + 1] !== Number.MAX_VALUE)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = Math.max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n};\\n\\nfunction find(i, ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\n\\nfunction merge(s1, s2, ds) {\\n    let p1 = find(s1, ds);\\n    let p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455785,
                "title": "c-map-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        multiset<long long> s;\\n        map<int,long long> m;\\n        vector<long long> dp(n);\\n        \\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i]=dp[i-1]+nums[i];    \\n        }\\n        s.insert(dp[n-1]);\\n        \\n        m[-1]=0;\\n        m[n]=dp[n-1];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it=m.lower_bound(removeQueries[i]);\\n            auto it1=prev(it);\\n            \\n\\n            s.erase(s.find(dp[it->first-1]-it1->second));\\n            if(it->first-1>removeQueries[i])\\n                s.insert(dp[it->first-1]-dp[removeQueries[i]]);\\n            if(removeQueries[i]-1>it1->first)\\n                s.insert(dp[removeQueries[i]-1]-it1->second);\\n            \\n            m[removeQueries[i]]=dp[removeQueries[i]];\\n            ans[i]=(s.empty() ? 0 : *s.rbegin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        multiset<long long> s;\\n        map<int,long long> m;\\n        vector<long long> dp(n);\\n        \\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i]=dp[i-1]+nums[i];    \\n        }\\n        s.insert(dp[n-1]);\\n        \\n        m[-1]=0;\\n        m[n]=dp[n-1];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it=m.lower_bound(removeQueries[i]);\\n            auto it1=prev(it);\\n            \\n\\n            s.erase(s.find(dp[it->first-1]-it1->second));\\n            if(it->first-1>removeQueries[i])\\n                s.insert(dp[it->first-1]-dp[removeQueries[i]]);\\n            if(removeQueries[i]-1>it1->first)\\n                s.insert(dp[removeQueries[i]-1]-it1->second);\\n            \\n            m[removeQueries[i]]=dp[removeQueries[i]];\\n            ans[i]=(s.empty() ? 0 : *s.rbegin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455752,
                "title": "java-reverse-union-find-100-time-14-space",
                "content": "```java\\nclass Solution {\\n    \\n    class UF {\\n        int[] root;\\n        long[] sum;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            Arrays.fill(this.root, -1);\\n            this.sum = new long[n];\\n        }\\n        \\n        \\n        public void insert(int x, int value){\\n            if(root[x] != -1 || sum[x] != 0) return;\\n            \\n            this.root[x] = x;\\n            this.sum[x] = (long)value;\\n        }\\n        \\n        public int find(int x){\\n            while(root[x] != x){\\n                int fa = root[x];\\n                int ga = root[fa];\\n                root[x] = ga;\\n                x = fa;\\n            }\\n            \\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(x == y) return;\\n            \\n            root[rx] = ry;\\n            sum[ry] += sum[rx];\\n        }\\n        \\n        public boolean has(int x){\\n            return root[x] != -1 || sum[x] != 0;\\n        }\\n    }\\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = removeQueries.length;\\n        long[] ret = new long[n];\\n        long max = 0L;\\n        UF uf = new UF(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int u = removeQueries[i];\\n            uf.insert(u, nums[u]);\\n            for(int v = u - 1; v <= u + 1; v += 2){\\n                if(v >= 0 && v < n && uf.has(v)){\\n                    uf.union(v, u);\\n                }\\n            }\\n            \\n            ret[i] = max;\\n            int ru = uf.find(u);\\n            max = Math.max(max, uf.sum[ru]);\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    class UF {\\n        int[] root;\\n        long[] sum;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            Arrays.fill(this.root, -1);\\n            this.sum = new long[n];\\n        }\\n        \\n        \\n        public void insert(int x, int value){\\n            if(root[x] != -1 || sum[x] != 0) return;\\n            \\n            this.root[x] = x;\\n            this.sum[x] = (long)value;\\n        }\\n        \\n        public int find(int x){\\n            while(root[x] != x){\\n                int fa = root[x];\\n                int ga = root[fa];\\n                root[x] = ga;\\n                x = fa;\\n            }\\n            \\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(x == y) return;\\n            \\n            root[rx] = ry;\\n            sum[ry] += sum[rx];\\n        }\\n        \\n        public boolean has(int x){\\n            return root[x] != -1 || sum[x] != 0;\\n        }\\n    }\\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = removeQueries.length;\\n        long[] ret = new long[n];\\n        long max = 0L;\\n        UF uf = new UF(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int u = removeQueries[i];\\n            uf.insert(u, nums[u]);\\n            for(int v = u - 1; v <= u + 1; v += 2){\\n                if(v >= 0 && v < n && uf.has(v)){\\n                    uf.union(v, u);\\n                }\\n            }\\n            \\n            ret[i] = max;\\n            int ru = uf.find(u);\\n            max = Math.max(max, uf.sum[ru]);\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455731,
                "title": "c-simple-simulation-o-nlogn",
                "content": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries)\\n{\\n    vector<long long> ans;\\n    vector<int64_t> pref(nums.size() + 1);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        pref[i + 1] = pref[i] + nums[i];\\n    }\\n    map<int, int> ranges;\\n    multiset<int64_t> max_sum = { 0 };\\n    auto add = [&](int l, int r) {\\n        if (l < r) {\\n            ranges[r] = l;\\n            max_sum.insert(pref[r] - pref[l]);\\n        }\\n    };\\n    add(0, nums.size());\\n    for (int i = 0; i < removeQueries.size(); ++i) {\\n        int j = removeQueries[i];\\n        auto [r, l] = *ranges.lower_bound(j);\\n        max_sum.erase(max_sum.find(pref[r] - pref[l]));\\n        add(l, j);\\n        add(j + 1, r);\\n        ans.push_back(*max_sum.rbegin());\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries)\\n{\\n    vector<long long> ans;\\n    vector<int64_t> pref(nums.size() + 1);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        pref[i + 1] = pref[i] + nums[i];\\n    }\\n    map<int, int> ranges;\\n    multiset<int64_t> max_sum = { 0 };\\n    auto add = [&](int l, int r) {\\n        if (l < r) {\\n            ranges[r] = l;\\n            max_sum.insert(pref[r] - pref[l]);\\n        }\\n    };\\n    add(0, nums.size());\\n    for (int i = 0; i < removeQueries.size(); ++i) {\\n        int j = removeQueries[i];\\n        auto [r, l] = *ranges.lower_bound(j);\\n        max_sum.erase(max_sum.find(pref[r] - pref[l]));\\n        add(l, j);\\n        add(j + 1, r);\\n        ans.push_back(*max_sum.rbegin());\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455691,
                "title": "leetcode-1970-803",
                "content": "This problem is basically LeetCode [#1970](https://leetcode.com/problems/last-day-where-you-can-still-cross/) and[ #803](https://leetcode.com/problems/bricks-falling-when-hit/), in which we reverse the process and use union find.\\n\\nThe below is an implementation that uses **Union By Rank** and **Path Compression**.\\n`RunTime 35ms`\\n`Time O(N)`\\n`Space O(N)`\\n```Java\\nclass Solution { // Java\\n    int[] A;\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        A = nums;\\n        UF uf = new UF(nums.length);\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = ans.length-1; i >= 0; i--){\\n            ans[i] = uf.max;\\n            int j = removeQueries[i];\\n            uf.union(j, j+1);\\n            uf.union(j, j-1);\\n        }\\n        return ans;\\n    }\\n    \\n    private class UF{\\n        int[] rank;\\n        int[] parent;\\n        long[] weight;\\n        long max = 0;\\n        \\n        UF (int n){\\n            rank = new int[n];\\n            weight = new long[n];\\n            parent = IntStream.range(0, n).toArray();\\n        }\\n        \\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n        \\n        void union(int x, int y){\\n            weight[x] = A[x];\\n            max = Math.max(A[x], max);\\n            if (y < 0 || y == rank.length){\\n                return;\\n            }\\n            x = find(x); y = find(y);\\n            if (x == y || weight[y] == 0){\\n                return;\\n            }\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n                weight[x] += weight[y];\\n            }else{\\n                parent[x] = y;\\n                weight[y] += weight[x];\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n            max = Math.max(max, weight[x]);\\n            max = Math.max(max, weight[y]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```Java\\nclass Solution { // Java\\n    int[] A;\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        A = nums;\\n        UF uf = new UF(nums.length);\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = ans.length-1; i >= 0; i--){\\n            ans[i] = uf.max;\\n            int j = removeQueries[i];\\n            uf.union(j, j+1);\\n            uf.union(j, j-1);\\n        }\\n        return ans;\\n    }\\n    \\n    private class UF{\\n        int[] rank;\\n        int[] parent;\\n        long[] weight;\\n        long max = 0;\\n        \\n        UF (int n){\\n            rank = new int[n];\\n            weight = new long[n];\\n            parent = IntStream.range(0, n).toArray();\\n        }\\n        \\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n        \\n        void union(int x, int y){\\n            weight[x] = A[x];\\n            max = Math.max(A[x], max);\\n            if (y < 0 || y == rank.length){\\n                return;\\n            }\\n            x = find(x); y = find(y);\\n            if (x == y || weight[y] == 0){\\n                return;\\n            }\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n                weight[x] += weight[y];\\n            }else{\\n                parent[x] = y;\\n                weight[y] += weight[x];\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n            max = Math.max(max, weight[x]);\\n            max = Math.max(max, weight[y]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455510,
                "title": "c-version-of-solution-by-user9591",
                "content": "Original Python solution - https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2454397/Do-it-backwards-O(N)\\n\\n```\\npublic class Solution\\n{\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n    {\\n        var mp = new Dictionary<int, (long, int)>();\\n        var cur = 0L;\\n        var res = new List<long>();\\n\\n        foreach (var q in removeQueries[1..].Reverse())\\n        {\\n            mp.Add(q, (nums[q], 1));\\n            \\n            (long rv, int rLen) = mp.TryGetValue(q + 1, out var value) ? value : (0, 0);\\n            (long lv, int lLen) = mp.TryGetValue(q - 1, out value) ? value : (0, 0);\\n            \\n            var total = nums[q] + rv + lv;\\n            mp[q + rLen] = (total, lLen + rLen + 1);\\n            mp[q - lLen] = (total, lLen + rLen + 1);\\n\\n            cur = Math.Max(cur, total);\\n            res.Add(cur);\\n        }\\n\\n        res.Reverse();\\n        res.Add(0);\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n    {\\n        var mp = new Dictionary<int, (long, int)>();\\n        var cur = 0L;\\n        var res = new List<long>();\\n\\n        foreach (var q in removeQueries[1..].Reverse())\\n        {\\n            mp.Add(q, (nums[q], 1));\\n            \\n            (long rv, int rLen) = mp.TryGetValue(q + 1, out var value) ? value : (0, 0);\\n            (long lv, int lLen) = mp.TryGetValue(q - 1, out value) ? value : (0, 0);\\n            \\n            var total = nums[q] + rv + lv;\\n            mp[q + rLen] = (total, lLen + rLen + 1);\\n            mp[q - lLen] = (total, lLen + rLen + 1);\\n\\n            cur = Math.Max(cur, total);\\n            res.Add(cur);\\n        }\\n\\n        res.Reverse();\\n        res.Add(0);\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455464,
                "title": "rust-solution-using-btreeset-hashset",
                "content": "~~~\\n// The idea is \\n// 1) to use s as an order set for tracking the  segments\\n// 2) to use the ordered set cuts is for tracking all the cuts made so far. \\n// Therefore, for a new cut, we can easily determine which segment gets cut\\n//  what new segments are created\\n  \\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(nums: Vec<i32>, remove_queries: Vec<i32>) -> Vec<i64> {\\n        let n = nums.len();\\n        let mut sum = vec![0i64; n + 1];\\n        for i in 0..n {\\n            sum[i + 1] = sum[i] + nums[i] as i64;\\n        }\\n\\t\\t\\n\\t\\tlet mut cuts = BTreeSet::<i32>::new();\\n        let mut s = BTreeSet::<(i64, i32, i32)>::new();\\n        let mut ret: Vec<i64> = vec![];\\n\\t\\t\\n        cuts.insert(-1);\\n        cuts.insert(n as i32);\\n        s.insert((sum[n], -1, n as i32));\\n        \\n        for r in remove_queries {\\n            let left = if let Some(a) = cuts.range(..r).rev().next() { *a } else { 0 };\\n            let right = if let Some(a) = cuts.range(r..).next() { *a } else { n as i32 };\\n            let total = sum[right as usize] - sum[(left + 1) as  usize];\\n            \\n            //println![\"r: {}, left: {}, right: {}. total: {}\", r, left, right, total];  \\n            s.remove(&(total, left,  right));\\n            cuts.insert(r);\\n            \\n            if left + 1 < r {\\n                let total = sum[r as usize] - sum[left as usize + 1];\\n                s.insert((total, left, r));\\n            }\\n            \\n            if r + 1 < right {\\n                let total = sum[right as usize] - sum[r as usize + 1];\\n                s.insert((total, r, right));\\n            }\\n            \\n            if let Some((val, _, _)) = s.iter().next_back() {\\n                ret.push(*val);\\n            } else {\\n                ret.push(0);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\n// The idea is \\n// 1) to use s as an order set for tracking the  segments\\n// 2) to use the ordered set cuts is for tracking all the cuts made so far. \\n// Therefore, for a new cut, we can easily determine which segment gets cut\\n//  what new segments are created\\n  \\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(nums: Vec<i32>, remove_queries: Vec<i32>) -> Vec<i64> {\\n        let n = nums.len();\\n        let mut sum = vec![0i64; n + 1];\\n        for i in 0..n {\\n            sum[i + 1] = sum[i] + nums[i] as i64;\\n        }\\n\\t\\t\\n\\t\\tlet mut cuts = BTreeSet::<i32>::new();\\n        let mut s = BTreeSet::<(i64, i32, i32)>::new();\\n        let mut ret: Vec<i64> = vec![];\\n\\t\\t\\n        cuts.insert(-1);\\n        cuts.insert(n as i32);\\n        s.insert((sum[n], -1, n as i32));\\n        \\n        for r in remove_queries {\\n            let left = if let Some(a) = cuts.range(..r).rev().next() { *a } else { 0 };\\n            let right = if let Some(a) = cuts.range(r..).next() { *a } else { n as i32 };\\n            let total = sum[right as usize] - sum[(left + 1) as  usize];\\n            \\n            //println![\"r: {}, left: {}, right: {}. total: {}\", r, left, right, total];  \\n            s.remove(&(total, left,  right));\\n            cuts.insert(r);\\n            \\n            if left + 1 < r {\\n                let total = sum[r as usize] - sum[left as usize + 1];\\n                s.insert((total, left, r));\\n            }\\n            \\n            if r + 1 < right {\\n                let total = sum[right as usize] - sum[r as usize + 1];\\n                s.insert((total, r, right));\\n            }\\n            \\n            if let Some((val, _, _)) = s.iter().next_back() {\\n                ret.push(*val);\\n            } else {\\n                ret.push(0);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2455384,
                "title": "c-prefix-sum-segment-tree-o-n-logn-time",
                "content": "**Logic:**\\nFor every input query, you want to find the segment to which it belongs. Due to removal of this query, your segment splits into two new segments. \\nI have maintained two segment tree to get the segment the query belongs to, namely, st_seg_tree and en_seg_tree.\\n\\ngetRightMost -> returns you the right most element in the st_seg_tree which corresponds to the starting indices of all the segments created\\ngetLeftMost -> returns you the left most element in the en_seg_tree which corresponds to the ending indices of all the segments created\\n*range passed in the argument is a function of the index which is being removed*\\n\\nOnce you have the segment to which your query belongs to, you have to update the set structure by removing the current segment sum and adding the new segment sums. For this purpose, you can use a prefix sum array to get the segment sum in O(1) time. \\n\\nOverall time complexity of the code is O(N logN)\\n\\n```\\nclass Solution {\\npublic:\\n    void updateStartSegTree(int i, int idx, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"updateStartSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            st_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r) >> 1;\\n        if(i<=mid)\\n            updateStartSegTree(i, 2*idx+1, l, mid, st_seg_tree);\\n        else\\n            updateStartSegTree(i, 2*idx+2, mid+1, r, st_seg_tree);\\n        \\n        if(st_seg_tree[2*idx+2] != -1)\\n            st_seg_tree[idx] = st_seg_tree[2*idx+2];\\n        else\\n            st_seg_tree[idx] = st_seg_tree[2*idx+1];\\n        \\n        return;\\n    }\\n    void updateEndSegTree(int i, int idx, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"updateEndSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            en_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r)>>1;\\n        if(i<=mid)\\n            updateEndSegTree(i, 2*idx+1, l, mid, en_seg_tree);\\n        else\\n            updateEndSegTree(i, 2*idx+2, mid+1, r, en_seg_tree);\\n        \\n        if(en_seg_tree[2*idx+1] != -1)\\n            en_seg_tree[idx] = en_seg_tree[2*idx+1];\\n        else\\n            en_seg_tree[idx] = en_seg_tree[2*idx+2];\\n        \\n        return;\\n    }\\n    int getRightMost(int idx, int ql, int qr, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"getRightMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return st_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr <= mid)\\n            return getRightMost(2*idx+1, ql, qr, l, mid, st_seg_tree);\\n        if(ql>mid)\\n            return getRightMost(2*idx+2, ql, qr, mid+1, r, st_seg_tree);\\n        \\n        int ans_l = getRightMost(2*idx+1, ql, mid, l, mid, st_seg_tree);\\n        int ans_r = getRightMost(2*idx+2, mid+1, qr, mid+1, r, st_seg_tree);\\n        if(ans_r != -1)\\n            return ans_r;\\n        return ans_l;\\n    }\\n    int getLeftMost(int idx, int ql, int qr, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"getLeftMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return en_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr<=mid)\\n            return getLeftMost(2*idx+1, ql, qr, l, mid, en_seg_tree);\\n        if(ql>mid)\\n            return getLeftMost(2*idx+2, ql, qr, mid+1, r, en_seg_tree);\\n        \\n        int ans_l = getLeftMost(2*idx+1, ql, mid, l, mid, en_seg_tree);\\n        int ans_r = getLeftMost(2*idx+2, mid+1, qr, mid+1, r, en_seg_tree);\\n        \\n        if(ans_l != -1)\\n            return ans_l;\\n        return ans_r;\\n    }\\n    void printSet(set<tuple<long long, int, int>>& s)\\n    {\\n        auto it = s.begin();\\n        cout << \"printing set\" << endl;\\n        while(it != s.end())\\n        {\\n            cout << get<0>(*it) << \", \" << get<1>(*it) << \", \" << get<2>(*it) << endl;\\n            it++;\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        // Approach 1 - My own idea using segment tree\\n        int n = nums.size();\\n        vector<int> st_seg_tree(4*n, -1);\\n        vector<int> en_seg_tree(4*n, -1);\\n        updateStartSegTree(0, 0, 0, n-1, st_seg_tree);\\n        updateEndSegTree(n-1, 0, 0, n-1, en_seg_tree);\\n        \\n        vector<long long> pref_sum(n, 0);\\n        \\n        for(int i= 0; i< n; i++)\\n        {\\n            pref_sum[i] = nums[i];\\n            if(i-1>=0)\\n                pref_sum[i] += pref_sum[i-1];\\n        }\\n        \\n        set<tuple<long long,int,int>> s; // <-sum, st, en> for every segment is stored\\n        s.insert({-pref_sum[n-1], 0, n-1});\\n        vector<long long> ans;\\n        vector<int> rem(n, 0);\\n        \\n        for(int i= 0; i< n-1; i++)\\n        {\\n            int idx = removeQueries[i];\\n            int st_idx = getRightMost(0, 0, idx, 0, n-1, st_seg_tree);\\n            int en_idx = getLeftMost(0, idx, n-1, 0, n-1, en_seg_tree);\\n            \\n            rem[idx] = 1;\\n            if(idx-1>=0 && rem[idx-1] == 0)\\n                updateEndSegTree(idx-1, 0, 0, n-1, en_seg_tree);\\n            if(idx+1<n && rem[idx+1] == 0)\\n                updateStartSegTree(idx+1, 0, 0, n-1, st_seg_tree);\\n            \\n            long long curr_sum = pref_sum[en_idx];\\n            if(st_idx-1 >= 0) curr_sum -= pref_sum[st_idx-1];\\n            s.erase({-curr_sum, st_idx, en_idx});\\n\\n            if(idx-1 >= st_idx)\\n            {\\n                long long val = pref_sum[idx-1];\\n                if(st_idx-1 >= 0) val -= pref_sum[st_idx-1];\\n                s.insert({-val, st_idx, idx-1});\\n            }\\n            \\n            if(idx+1 <= en_idx)\\n            {\\n                long long val = pref_sum[en_idx];\\n                if(idx >= 0) val -= pref_sum[idx];\\n                s.insert({-val, idx+1, en_idx});\\n            }\\n            \\n            auto it = s.begin();\\n            ans.push_back(-1*get<0>(*it));\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void updateStartSegTree(int i, int idx, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"updateStartSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            st_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r) >> 1;\\n        if(i<=mid)\\n            updateStartSegTree(i, 2*idx+1, l, mid, st_seg_tree);\\n        else\\n            updateStartSegTree(i, 2*idx+2, mid+1, r, st_seg_tree);\\n        \\n        if(st_seg_tree[2*idx+2] != -1)\\n            st_seg_tree[idx] = st_seg_tree[2*idx+2];\\n        else\\n            st_seg_tree[idx] = st_seg_tree[2*idx+1];\\n        \\n        return;\\n    }\\n    void updateEndSegTree(int i, int idx, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"updateEndSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            en_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r)>>1;\\n        if(i<=mid)\\n            updateEndSegTree(i, 2*idx+1, l, mid, en_seg_tree);\\n        else\\n            updateEndSegTree(i, 2*idx+2, mid+1, r, en_seg_tree);\\n        \\n        if(en_seg_tree[2*idx+1] != -1)\\n            en_seg_tree[idx] = en_seg_tree[2*idx+1];\\n        else\\n            en_seg_tree[idx] = en_seg_tree[2*idx+2];\\n        \\n        return;\\n    }\\n    int getRightMost(int idx, int ql, int qr, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"getRightMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return st_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr <= mid)\\n            return getRightMost(2*idx+1, ql, qr, l, mid, st_seg_tree);\\n        if(ql>mid)\\n            return getRightMost(2*idx+2, ql, qr, mid+1, r, st_seg_tree);\\n        \\n        int ans_l = getRightMost(2*idx+1, ql, mid, l, mid, st_seg_tree);\\n        int ans_r = getRightMost(2*idx+2, mid+1, qr, mid+1, r, st_seg_tree);\\n        if(ans_r != -1)\\n            return ans_r;\\n        return ans_l;\\n    }\\n    int getLeftMost(int idx, int ql, int qr, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"getLeftMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return en_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr<=mid)\\n            return getLeftMost(2*idx+1, ql, qr, l, mid, en_seg_tree);\\n        if(ql>mid)\\n            return getLeftMost(2*idx+2, ql, qr, mid+1, r, en_seg_tree);\\n        \\n        int ans_l = getLeftMost(2*idx+1, ql, mid, l, mid, en_seg_tree);\\n        int ans_r = getLeftMost(2*idx+2, mid+1, qr, mid+1, r, en_seg_tree);\\n        \\n        if(ans_l != -1)\\n            return ans_l;\\n        return ans_r;\\n    }\\n    void printSet(set<tuple<long long, int, int>>& s)\\n    {\\n        auto it = s.begin();\\n        cout << \"printing set\" << endl;\\n        while(it != s.end())\\n        {\\n            cout << get<0>(*it) << \", \" << get<1>(*it) << \", \" << get<2>(*it) << endl;\\n            it++;\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        // Approach 1 - My own idea using segment tree\\n        int n = nums.size();\\n        vector<int> st_seg_tree(4*n, -1);\\n        vector<int> en_seg_tree(4*n, -1);\\n        updateStartSegTree(0, 0, 0, n-1, st_seg_tree);\\n        updateEndSegTree(n-1, 0, 0, n-1, en_seg_tree);\\n        \\n        vector<long long> pref_sum(n, 0);\\n        \\n        for(int i= 0; i< n; i++)\\n        {\\n            pref_sum[i] = nums[i];\\n            if(i-1>=0)\\n                pref_sum[i] += pref_sum[i-1];\\n        }\\n        \\n        set<tuple<long long,int,int>> s; // <-sum, st, en> for every segment is stored\\n        s.insert({-pref_sum[n-1], 0, n-1});\\n        vector<long long> ans;\\n        vector<int> rem(n, 0);\\n        \\n        for(int i= 0; i< n-1; i++)\\n        {\\n            int idx = removeQueries[i];\\n            int st_idx = getRightMost(0, 0, idx, 0, n-1, st_seg_tree);\\n            int en_idx = getLeftMost(0, idx, n-1, 0, n-1, en_seg_tree);\\n            \\n            rem[idx] = 1;\\n            if(idx-1>=0 && rem[idx-1] == 0)\\n                updateEndSegTree(idx-1, 0, 0, n-1, en_seg_tree);\\n            if(idx+1<n && rem[idx+1] == 0)\\n                updateStartSegTree(idx+1, 0, 0, n-1, st_seg_tree);\\n            \\n            long long curr_sum = pref_sum[en_idx];\\n            if(st_idx-1 >= 0) curr_sum -= pref_sum[st_idx-1];\\n            s.erase({-curr_sum, st_idx, en_idx});\\n\\n            if(idx-1 >= st_idx)\\n            {\\n                long long val = pref_sum[idx-1];\\n                if(st_idx-1 >= 0) val -= pref_sum[st_idx-1];\\n                s.insert({-val, st_idx, idx-1});\\n            }\\n            \\n            if(idx+1 <= en_idx)\\n            {\\n                long long val = pref_sum[en_idx];\\n                if(idx >= 0) val -= pref_sum[idx];\\n                s.insert({-val, idx+1, en_idx});\\n            }\\n            \\n            auto it = s.begin();\\n            ans.push_back(-1*get<0>(*it));\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455319,
                "title": "reverse-union-find-java-version",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int length = nums.length;\\n        long[] res= new long[length];\\n        UnionFind uf=new UnionFind(length);\\n        \\n        TreeSet<Long> set = new TreeSet<>();\\n        \\n        for(int i=length-1;i>=0;i--){\\n            uf.sum[removeQueries[i]]=nums[removeQueries[i]];\\n            if(removeQueries[i]+1<length&&uf.sum[removeQueries[i]+1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]+1);\\n            }\\n            \\n             if(removeQueries[i]>0&&uf.sum[removeQueries[i]-1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]-1);\\n            }\\n            set.add(uf.sum[uf.find(removeQueries[i])]);\\n            \\n            if(i>0)\\n                res[i-1]=set.last();\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n\\nclass UnionFind{\\n    int[] f;\\n    long[] sum;\\n    public UnionFind(int size){\\n        f = new int[size];\\n        sum = new long[size];\\n        for(int i = 0; i < size; i++){\\n            f[i] = i;\\n        }\\n    }\\n    public int find(int x){\\n        if (f[x] != x){\\n            f[x] = find(f[x]);\\n        }\\n        return f[x];\\n    }\\n    public void union(int x, int y){\\n        int fx = find(x);\\n        int fy = find(y);\\n        f[f[y]] = fx;\\n        sum[fx]+=sum[fy];\\n    }    \\n}``\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int length = nums.length;\\n        long[] res= new long[length];\\n        UnionFind uf=new UnionFind(length);\\n        \\n        TreeSet<Long> set = new TreeSet<>();\\n        \\n        for(int i=length-1;i>=0;i--){\\n            uf.sum[removeQueries[i]]=nums[removeQueries[i]];\\n            if(removeQueries[i]+1<length&&uf.sum[removeQueries[i]+1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]+1);\\n            }\\n            \\n             if(removeQueries[i]>0&&uf.sum[removeQueries[i]-1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]-1);\\n            }\\n            set.add(uf.sum[uf.find(removeQueries[i])]);\\n            \\n            if(i>0)\\n                res[i-1]=set.last();\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n\\nclass UnionFind{\\n    int[] f;\\n    long[] sum;\\n    public UnionFind(int size){\\n        f = new int[size];\\n        sum = new long[size];\\n        for(int i = 0; i < size; i++){\\n            f[i] = i;\\n        }\\n    }\\n    public int find(int x){\\n        if (f[x] != x){\\n            f[x] = find(f[x]);\\n        }\\n        return f[x];\\n    }\\n    public void union(int x, int y){\\n        int fx = find(x);\\n        int fy = find(y);\\n        f[f[y]] = fx;\\n        sum[fx]+=sum[fy];\\n    }    \\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455279,
                "title": "c-easy-solution-with-set-and-multiset-easy-to-understand-readable-code",
                "content": "```class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n = nums.size();\\n        vector<long long> pre = {0};\\n        for(int i = 0; i < n; i++) pre.push_back(pre.back() + nums[i]);\\n\\n        set <pair<long long, long long>> st;\\n        st.insert({n - 1, 0});//only valid ones that are not removed or queried values will be present here\\n        \\n        multiset<long long>s = {0};\\n        s.insert(pre.back());\\n        \\n        vector<long long>ans;\\n        \\n        for(auto &x : removeQueries)\\n        {\\n            auto bound = *st.lower_bound({x, 0});\\n            st.erase(bound);\\n            long long leftidx = bound.second, rightidx = bound.first;\\n            \\n            long long toremove = pre[rightidx + 1] - pre[leftidx];\\n            \\n            s.erase(s.find(pre[rightidx + 1] - pre[leftidx]));\\n            \\n            if(x != leftidx)\\n            {\\n                long long leftseg = pre[x] - pre[leftidx];\\n                s.insert(leftseg);\\n                st.insert({x - 1, leftidx});\\n            }\\n            if(x != rightidx)\\n            {\\n                long long rightseg = pre[rightidx + 1] - pre[x + 1];\\n                s.insert(rightseg);\\n                st.insert({rightidx, x + 1});\\n            }\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n = nums.size();\\n        vector<long long> pre = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2455247,
                "title": "c-set-map-binary-search",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\n    \\n    ll get_sum(int l, int r, vector<ll> &sum) {\\n        return l == 0 ? sum[r] : sum[r] - sum[l-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        vector<ll> ans(n); \\n        \\n        map<ll, int> mp;\\n        set<pair<pair<int, int>, ll>> ranges;\\n        \\n        vector<ll> psum(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = nums[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n        ranges.insert({{0, n-1}, psum[n-1]});\\n        mp[0] += 1;\\n        mp[psum[n-1]] += 1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            pair<pair<int, int>, ll> pi = {{q[i], 1e9}, -1};\\n            auto it = --ranges.upper_bound(pi);\\n            \\n            if(it == ranges.end()) {\\n                ans[i] = 0;\\n                cout << i << endl;\\n                continue;\\n            }\\n            \\n            int l = it->first.first;\\n            int r = it->first.second;\\n            ll sum = it->second;\\n            \\n            //remove from range\\n            ranges.erase(it);\\n            \\n            // remove from map;\\n            mp[sum] -= 1;\\n            if(mp[sum] <= 0) \\n                mp.erase(sum);\\n            \\n            if(l == r) {\\n                // do nothing\\n            }\\n            else if(l == q[i]) {\\n                sum = get_sum(l+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l+1, r}, sum});\\n            } \\n            else if(r == q[i]) {\\n                sum = get_sum(l, r-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, r-1}, sum});\\n            }\\n            else {\\n                sum = get_sum(l, q[i]-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, q[i]-1}, sum});\\n                \\n                sum = get_sum(q[i]+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{q[i]+1, r}, sum});\\n            }\\n            \\n            if(mp.size() == 0) \\n                ans[i] = 0;\\n            else {\\n                auto tmp = --mp.end();\\n                ans[i] = tmp->first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\n    \\n    ll get_sum(int l, int r, vector<ll> &sum) {\\n        return l == 0 ? sum[r] : sum[r] - sum[l-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        vector<ll> ans(n); \\n        \\n        map<ll, int> mp;\\n        set<pair<pair<int, int>, ll>> ranges;\\n        \\n        vector<ll> psum(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = nums[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n        ranges.insert({{0, n-1}, psum[n-1]});\\n        mp[0] += 1;\\n        mp[psum[n-1]] += 1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            pair<pair<int, int>, ll> pi = {{q[i], 1e9}, -1};\\n            auto it = --ranges.upper_bound(pi);\\n            \\n            if(it == ranges.end()) {\\n                ans[i] = 0;\\n                cout << i << endl;\\n                continue;\\n            }\\n            \\n            int l = it->first.first;\\n            int r = it->first.second;\\n            ll sum = it->second;\\n            \\n            //remove from range\\n            ranges.erase(it);\\n            \\n            // remove from map;\\n            mp[sum] -= 1;\\n            if(mp[sum] <= 0) \\n                mp.erase(sum);\\n            \\n            if(l == r) {\\n                // do nothing\\n            }\\n            else if(l == q[i]) {\\n                sum = get_sum(l+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l+1, r}, sum});\\n            } \\n            else if(r == q[i]) {\\n                sum = get_sum(l, r-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, r-1}, sum});\\n            }\\n            else {\\n                sum = get_sum(l, q[i]-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, q[i]-1}, sum});\\n                \\n                sum = get_sum(q[i]+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{q[i]+1, r}, sum});\\n            }\\n            \\n            if(mp.size() == 0) \\n                ans[i] = 0;\\n            else {\\n                auto tmp = --mp.end();\\n                ans[i] = tmp->first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455150,
                "title": "video-explanation-both-with-and-without-dsu",
                "content": "https://www.youtube.com/watch?v=L_EU1nxzFKg",
                "solutionTags": [
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "https://www.youtube.com/watch?v=L_EU1nxzFKg",
                "codeTag": "Unknown"
            },
            {
                "id": 2455146,
                "title": "segment-tree",
                "content": "```\\n//Link->https://leetcode.com/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/\\n//same concept like this ->https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\\n//Author: Rohit Kumar\\n//Status: Accepted\\n//Time_complexity: O(nlongn)\\n//Space_complexity: O(n)\\n//Submission_date: 20/08/2022\\n//idea-> used segment tree to find the maximum subsegmet sum of a segment of the array\\n//whenver we remove an element from the array we update the segment tree\\n//we have to find maxium seb_segement sum of the array after removing an element which will lead\\n//us to divide the array into two parts ..... removedelement ......\\n//so how to handle this situation using segement tree\\n//so we no how to find subsegment sum of the array \\n// if we have to part  exampale [1,2,3,-4] [2,3,4,-5];\\n// so if we add this segement so the we have many senario like the max_sum is sum of both array\\n//or maxvalue is sum of first_arrray and max_prefix of second array\\n//or max_suffix of first array and sum of second array\\n//so we have to consider all these senario and find the max value\\n//also we have to update the prefix and suffix of the array for merging the interval\\n\\n#include<bits/stdc++.h>\\n#define ll long long int\\nstruct node{\\n        ll maxvalue;\\n        ll prefix,suffix,sum;\\n};\\n    \\n    \\n    \\nvector<node> seg_tree;\\nvoid assign(int index){\\n    seg_tree[index].maxvalue=max(seg_tree[2*index+1].maxvalue,seg_tree[2*index+2].maxvalue);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].sum);\\n         seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].prefix=max(seg_tree[2*index+1].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].prefix=max(seg_tree[index].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].suffix=max(seg_tree[2*index+2].suffix,seg_tree[2*index+2].sum+seg_tree[2*index+1].suffix);\\n        seg_tree[index].suffix=max(seg_tree[index].suffix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        ll sm=-1e14;\\n        seg_tree[index].sum=max(sm,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n}\\n\\n    void build_tree(vector<int>&nums,int left,int right,int index){\\n        if(left>right){\\n            return;\\n        }\\n        if(left==right){\\n            seg_tree[index].maxvalue=nums[left];\\n            seg_tree[index].prefix=nums[left];\\n            seg_tree[index].suffix=nums[left];\\n            seg_tree[index].sum=nums[left];\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        build_tre(nums,left,mid,2*index+1);\\n        build_tre(nums,mid+1,right,2*index+2);\\n        assign(index);\\n       \\n    }\\n    void update(int pos,int left,int right,int index){\\n        if(left>pos||right<pos){\\n            return;\\n        }\\n        if(left==right&&left==pos){\\n            seg_tree[index].maxvalue=-1e14;\\n            seg_tree[index].prefix=-1e14;\\n            seg_tree[index].suffix=-1e14;\\n            seg_tree[index].sum=-1e14;\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        update(pos,left,mid,2*index+1);\\n        update(pos,mid+1,right,2*index+2);\\n        assign(index);\\n        \\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n       int n=nums.size();\\n        seg_tree.resize(4*n);\\n        build_tree(nums,0,n-1,0);\\n        vector<ll> ans;\\n        for(int i=0;i<n-1;i++){\\n            update(removeQueries[i],0,n-1,0);\\n            ans.push_back(seg_tree[0].maxvalue);\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n//Link->https://leetcode.com/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/\\n//same concept like this ->https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\\n//Author: Rohit Kumar\\n//Status: Accepted\\n//Time_complexity: O(nlongn)\\n//Space_complexity: O(n)\\n//Submission_date: 20/08/2022\\n//idea-> used segment tree to find the maximum subsegmet sum of a segment of the array\\n//whenver we remove an element from the array we update the segment tree\\n//we have to find maxium seb_segement sum of the array after removing an element which will lead\\n//us to divide the array into two parts ..... removedelement ......\\n//so how to handle this situation using segement tree\\n//so we no how to find subsegment sum of the array \\n// if we have to part  exampale [1,2,3,-4] [2,3,4,-5];\\n// so if we add this segement so the we have many senario like the max_sum is sum of both array\\n//or maxvalue is sum of first_arrray and max_prefix of second array\\n//or max_suffix of first array and sum of second array\\n//so we have to consider all these senario and find the max value\\n//also we have to update the prefix and suffix of the array for merging the interval\\n\\n#include<bits/stdc++.h>\\n#define ll long long int\\nstruct node{\\n        ll maxvalue;\\n        ll prefix,suffix,sum;\\n};\\n    \\n    \\n    \\nvector<node> seg_tree;\\nvoid assign(int index){\\n    seg_tree[index].maxvalue=max(seg_tree[2*index+1].maxvalue,seg_tree[2*index+2].maxvalue);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].sum);\\n         seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].prefix=max(seg_tree[2*index+1].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].prefix=max(seg_tree[index].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].suffix=max(seg_tree[2*index+2].suffix,seg_tree[2*index+2].sum+seg_tree[2*index+1].suffix);\\n        seg_tree[index].suffix=max(seg_tree[index].suffix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        ll sm=-1e14;\\n        seg_tree[index].sum=max(sm,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n}\\n\\n    void build_tree(vector<int>&nums,int left,int right,int index){\\n        if(left>right){\\n            return;\\n        }\\n        if(left==right){\\n            seg_tree[index].maxvalue=nums[left];\\n            seg_tree[index].prefix=nums[left];\\n            seg_tree[index].suffix=nums[left];\\n            seg_tree[index].sum=nums[left];\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        build_tre(nums,left,mid,2*index+1);\\n        build_tre(nums,mid+1,right,2*index+2);\\n        assign(index);\\n       \\n    }\\n    void update(int pos,int left,int right,int index){\\n        if(left>pos||right<pos){\\n            return;\\n        }\\n        if(left==right&&left==pos){\\n            seg_tree[index].maxvalue=-1e14;\\n            seg_tree[index].prefix=-1e14;\\n            seg_tree[index].suffix=-1e14;\\n            seg_tree[index].sum=-1e14;\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        update(pos,left,mid,2*index+1);\\n        update(pos,mid+1,right,2*index+2);\\n        assign(index);\\n        \\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n       int n=nums.size();\\n        seg_tree.resize(4*n);\\n        build_tree(nums,0,n-1,0);\\n        vector<ll> ans;\\n        for(int i=0;i<n-1;i++){\\n            update(removeQueries[i],0,n-1,0);\\n            ans.push_back(seg_tree[0].maxvalue);\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455138,
                "title": "c-dsu-iterate-from-back",
                "content": "Build the array from reverse order and combine the adjacent components and keep updating max sum. \\n```\\nclass Solution {\\npublic:\\n    long long re = INT_MIN;\\n    int find(vector<vector<long long>>& nums,int i){\\n        if(nums[i][0]==-1) return i;\\n        else return nums[i][0] = find(nums,nums[i][0]);\\n    }\\n    void union_(vector<vector<long long>>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j){ nums[j][0] = i; nums[i][1]+=nums[j][1]; re = max(re,nums[i][1]); }\\n            else{ nums[i][0] = j; nums[j][1]+=nums[i][1]; re = max(re,nums[j][1]); }\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& arr, vector<int>& q) {\\n        int n = arr.size();\\n        vector<vector<long long>> nums(n,vector<long long>(2,-1));\\n        vector<long long> ans = {0};\\n        for(int i = n-1; i>0; --i){\\n            int j = q[i];\\n            nums[j][1] = arr[j]; \\n            re = max(re,(long long)arr[j]);\\n            if(j+1<n && nums[j+1][1]!=-1) union_(nums,j,j+1);\\n            if(j-1>=0 && nums[j-1][1]!=-1) union_(nums,j,j-1);\\n            ans.push_back(re);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long re = INT_MIN;\\n    int find(vector<vector<long long>>& nums,int i){\\n        if(nums[i][0]==-1) return i;\\n        else return nums[i][0] = find(nums,nums[i][0]);\\n    }\\n    void union_(vector<vector<long long>>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j){ nums[j][0] = i; nums[i][1]+=nums[j][1]; re = max(re,nums[i][1]); }\\n            else{ nums[i][0] = j; nums[j][1]+=nums[i][1]; re = max(re,nums[j][1]); }\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& arr, vector<int>& q) {\\n        int n = arr.size();\\n        vector<vector<long long>> nums(n,vector<long long>(2,-1));\\n        vector<long long> ans = {0};\\n        for(int i = n-1; i>0; --i){\\n            int j = q[i];\\n            nums[j][1] = arr[j]; \\n            re = max(re,(long long)arr[j]);\\n            if(j+1<n && nums[j+1][1]!=-1) union_(nums,j,j+1);\\n            if(j-1>=0 && nums[j-1][1]!=-1) union_(nums,j,j-1);\\n            ans.push_back(re);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455102,
                "title": "segment-tree-naive-approach",
                "content": "# This problem is similar to subarray sum for updates and queries using segment tree.\\n\\n\\nclass Solution {\\npublic:\\n    long long sum[400001];\\n    long long prefix_sum[400001];\\n    long long suffix_sum[400001];\\n    long long subarray_sum[400001];\\n    void build(int i,int l,int r,int index,long long num)\\n    {\\n        if(i<l or i>r)\\n            return;\\n        \\n        if(l == r && i == l)\\n        {\\n            sum[index] = num;\\n            prefix_sum[index] = num;\\n            suffix_sum[index] = num;\\n            subarray_sum[index] = num;\\n            return;\\n        }\\n        \\n        if(l>=r)\\n            return;\\n        \\n        int mid =(l+r)/2;\\n        \\n        build(i,l,mid,2*index+1,num);\\n        build(i,mid+1,r,2*index+2,num);\\n        \\n        long long buf = -1e18;\\n        sum[index] = max(buf,sum[2*index+1]+sum[2*index+2]);\\n        prefix_sum[index] = max(prefix_sum[2*index+1],sum[2*index+1]+prefix_sum[2*index+2]);\\n        suffix_sum[index] = max(suffix_sum[2*index+2],sum[2*index+2]+suffix_sum[2*index+1]);\\n        subarray_sum[index] = max(subarray_sum[2*index+1],subarray_sum[2*index+2]);\\n        subarray_sum[index] = max(subarray_sum[index],prefix_sum[2*index+2]+suffix_sum[2*index+1]);\\n        \\n    }\\n    \\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        long long n = nums.size();\\n        vector<long long> dp(n,0);\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            build(i,0,n-1,0,nums[i]);\\n        }\\n        \\n        long long arr = -1e18;\\n        for(int i = 0;i<n-1;i++)\\n        {\\n            build(removeQueries[i],0,n-1,0,arr);\\n            dp[i] = subarray_sum[0];\\n        }\\n        dp[n-1] = 0;\\n        \\n        return dp;\\n          \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long sum[400001];\\n    long long prefix_sum[400001];\\n    long long suffix_sum[400001];\\n    long long subarray_sum[400001];\\n    void build(int i,int l,int r,int index,long long num)\\n    {\\n        if(i<l or i>r)\\n            return;\\n        \\n        if(l == r && i == l)\\n        {\\n            sum[index] = num;\\n            prefix_sum[index] = num;\\n            suffix_sum[index] = num;\\n            subarray_sum[index] = num;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455021,
                "title": "my-solutions",
                "content": "**1. Use the map and the multiset**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    presums[0] = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n    \\n    map<int, int> intervals;\\n    multiset<long long> interval_sums;\\n    intervals[0] = n;\\n    interval_sums.emplace(presums[n] - presums[0]);\\n    vector<long long> ret(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int remove = removeQueries[i];\\n      auto itr = prev(intervals.upper_bound(remove));\\n      const auto [left, right] = *itr;\\n      intervals.erase(itr);\\n      const long long sum = presums[right] - presums[left];\\n      auto itr_sum = interval_sums.find(sum);\\n      interval_sums.erase(itr_sum);\\n      vector<pair<int, int>> segments;\\n      segments.emplace_back(left, remove);\\n      segments.emplace_back(remove + 1, right);\\n      for (const auto [begin, end] : segments) {\\n        if (begin < end) {\\n          intervals[begin] = end;\\n          interval_sums.emplace(presums[end] - presums[begin]);\\n        }\\n      }\\n      ret[i] = interval_sums.empty() ? 0 : *interval_sums.rbegin();\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the Disjoint Set**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const vector<int> &nums)\\n      : parents_(nums.size(), -1), ranks_(nums.size(), 0), sums_(nums.size()), max_sum_(0LL) {\\n        copy(nums.begin(), nums.end(), sums_.begin());\\n    }\\n    \\n    long long insert(const int index) {\\n      const int n = static_cast<int>(parents_.size());\\n      parents_[index] = index;\\n      max_sum_ = max(max_sum_, sums_[index]);\\n      if (index > 0 && parents_[index - 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index - 1, index));\\n      }\\n      if (index + 1 < n && parents_[index + 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index, index + 1));\\n      }\\n      return max_sum_;\\n    }\\n    \\n   private:\\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    long long do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return sums_[parent_i];\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n        sums_[parent_i] += sums_[parent_j];\\n        sums_[parent_j] = 0;\\n      } else {\\n        // ranks_[parent_i] == ranks_[parent_j]\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      }\\n      return max(sums_[parent_i], sums_[parent_j]);\\n    }\\n    \\n    vector<int> parents_;\\n    vector<int> ranks_;\\n    vector<long long> sums_;\\n    long long max_sum_;\\n  };\\n  \\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    DisjointSet ds(nums);\\n    vector<long long> ret(n);\\n    ret.back() = 0;\\n    for (int i = n - 1; i > 0; --i) {\\n      ret[i - 1] = ds.insert(removeQueries[i]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    presums[0] = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n    \\n    map<int, int> intervals;\\n    multiset<long long> interval_sums;\\n    intervals[0] = n;\\n    interval_sums.emplace(presums[n] - presums[0]);\\n    vector<long long> ret(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int remove = removeQueries[i];\\n      auto itr = prev(intervals.upper_bound(remove));\\n      const auto [left, right] = *itr;\\n      intervals.erase(itr);\\n      const long long sum = presums[right] - presums[left];\\n      auto itr_sum = interval_sums.find(sum);\\n      interval_sums.erase(itr_sum);\\n      vector<pair<int, int>> segments;\\n      segments.emplace_back(left, remove);\\n      segments.emplace_back(remove + 1, right);\\n      for (const auto [begin, end] : segments) {\\n        if (begin < end) {\\n          intervals[begin] = end;\\n          interval_sums.emplace(presums[end] - presums[begin]);\\n        }\\n      }\\n      ret[i] = interval_sums.empty() ? 0 : *interval_sums.rbegin();\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const vector<int> &nums)\\n      : parents_(nums.size(), -1), ranks_(nums.size(), 0), sums_(nums.size()), max_sum_(0LL) {\\n        copy(nums.begin(), nums.end(), sums_.begin());\\n    }\\n    \\n    long long insert(const int index) {\\n      const int n = static_cast<int>(parents_.size());\\n      parents_[index] = index;\\n      max_sum_ = max(max_sum_, sums_[index]);\\n      if (index > 0 && parents_[index - 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index - 1, index));\\n      }\\n      if (index + 1 < n && parents_[index + 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index, index + 1));\\n      }\\n      return max_sum_;\\n    }\\n    \\n   private:\\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    long long do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return sums_[parent_i];\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n        sums_[parent_i] += sums_[parent_j];\\n        sums_[parent_j] = 0;\\n      } else {\\n        // ranks_[parent_i] == ranks_[parent_j]\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      }\\n      return max(sums_[parent_i], sums_[parent_j]);\\n    }\\n    \\n    vector<int> parents_;\\n    vector<int> ranks_;\\n    vector<long long> sums_;\\n    long long max_sum_;\\n  };\\n  \\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    DisjointSet ds(nums);\\n    vector<long long> ret(n);\\n    ret.back() = 0;\\n    for (int i = n - 1; i > 0; --i) {\\n      ret[i - 1] = ds.insert(removeQueries[i]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454794,
                "title": "python-3-o-n-2-solution-that-succeeds",
                "content": "As far as N=1E5 problems go, Python O(N^2) solutions generally don\\'t work. However, a list insertion in the inner loop is sometimes okay, and then it depends on the complexity of the test cases. This is not a winning approach, but having no good ideas, I went with a brute-force algorithm. This clocked in at under 7 seconds (out of 10 seconds maximum):\\n\\n```\\ndef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\tpsums = [0]  # Left-pad psums.\\n\\tfor num in nums:\\n\\t\\tpsums.append(psums[-1] + num)\\n\\tn = len(nums)            \\n\\tans = []\\n\\tremovals = [-1, n]  # Pad removals.\\n\\tsegmentHeap = []  # Store -score, start, end.\\n\\n\\tdef addSegmentToHeap(startIncl, endIncl):\\n\\t\\tif startIncl <= endIncl:\\n\\t\\t\\tscore = psums[endIncl + 1] - psums[startIncl]\\n\\t\\t\\theapq.heappush(segmentHeap, (-score, startIncl, endIncl))\\n\\n\\tfor i in range(n):\\n\\t\\tremoval = removeQueries[i]\\n\\t\\tiRem = bisect.bisect_left(removals, removal)\\n\\t\\tremovals.insert(iRem, removal)  # Fast O(N) operation.\\n\\t\\t# Removal splits a segment. Add both new segments to heap.\\n\\t\\taddSegmentToHeap(removals[iRem - 1] + 1, removal - 1)\\n\\t\\taddSegmentToHeap(removal + 1, removals[iRem + 1] - 1)\\n\\t\\tfound = False\\n\\t\\twhile segmentHeap:\\n\\t\\t\\tnegScore, topLo, topHi = segmentHeap[0]\\n\\t\\t\\tiTopLo = bisect.bisect_left(removals, topLo - 1)\\n\\t\\t\\t# Return top segment if it is fresh. If it is stale (due to\\n\\t\\t\\t# a split) pop it and continue.\\n\\t\\t\\tif removals[iTopLo + 1] == topHi + 1:\\n\\t\\t\\t\\tans.append(-negScore)\\n\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theapq.heappop(segmentHeap)\\n\\t\\tif not found:\\n\\t\\t\\tans.append(0)\\n\\n\\treturn ans\\n```\\n\\nThis may not be a solution that will get you hired, but if you point out that the constant on `removals.insert(iRem, removal)` is very small, a good interviewer will consider that your ability to think beyond just runtime complexity makes you a decent candidate.\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\tpsums = [0]  # Left-pad psums.\\n\\tfor num in nums:\\n\\t\\tpsums.append(psums[-1] + num)\\n\\tn = len(nums)            \\n\\tans = []\\n\\tremovals = [-1, n]  # Pad removals.\\n\\tsegmentHeap = []  # Store -score, start, end.\\n\\n\\tdef addSegmentToHeap(startIncl, endIncl):\\n\\t\\tif startIncl <= endIncl:\\n\\t\\t\\tscore = psums[endIncl + 1] - psums[startIncl]\\n\\t\\t\\theapq.heappush(segmentHeap, (-score, startIncl, endIncl))\\n\\n\\tfor i in range(n):\\n\\t\\tremoval = removeQueries[i]\\n\\t\\tiRem = bisect.bisect_left(removals, removal)\\n\\t\\tremovals.insert(iRem, removal)  # Fast O(N) operation.\\n\\t\\t# Removal splits a segment. Add both new segments to heap.\\n\\t\\taddSegmentToHeap(removals[iRem - 1] + 1, removal - 1)\\n\\t\\taddSegmentToHeap(removal + 1, removals[iRem + 1] - 1)\\n\\t\\tfound = False\\n\\t\\twhile segmentHeap:\\n\\t\\t\\tnegScore, topLo, topHi = segmentHeap[0]\\n\\t\\t\\tiTopLo = bisect.bisect_left(removals, topLo - 1)\\n\\t\\t\\t# Return top segment if it is fresh. If it is stale (due to\\n\\t\\t\\t# a split) pop it and continue.\\n\\t\\t\\tif removals[iTopLo + 1] == topHi + 1:\\n\\t\\t\\t\\tans.append(-negScore)\\n\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theapq.heappop(segmentHeap)\\n\\t\\tif not found:\\n\\t\\t\\tans.append(0)\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2454674,
                "title": "trieset-based-sln-o-n-log-n-with-prefix-sums",
                "content": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    const int n = size(nums);\\n    using ll = long long;\\n    vector<ll> sums(n + 1);\\n    for (int i = 0; i < n; ++i) {\\n        sums[i + 1] = sums[i] + nums[i];\\n    }\\n    set<pair<int, int>> segments;\\n    segments.emplace(0, n - 1);\\n    multiset<ll> segmentSums;\\n    segmentSums.insert(sums[n]);\\n    vector<ll> ans;\\n    for (const auto v : removeQueries) {\\n        const auto it = prev(segments.upper_bound({ v, numeric_limits<int>::max() }));\\n        int l = it->first, r = it->second;\\n        segments.erase(it);\\n        segmentSums.erase(segmentSums.find(sums[r + 1] - sums[l]));\\n        if (l != v) {\\n            segments.emplace(l, v - 1);\\n            segmentSums.insert(sums[v] - sums[l]);\\n        }\\n        if (r != v) {\\n            segments.emplace(v + 1, r);\\n            segmentSums.insert(sums[r + 1] - sums[v + 1]);\\n        }\\n        ans.push_back(empty(segmentSums) ? 0 : *prev(end(segmentSums)));\\n    }\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    const int n = size(nums);\\n    using ll = long long;\\n    vector<ll> sums(n + 1);\\n    for (int i = 0; i < n; ++i) {\\n        sums[i + 1] = sums[i] + nums[i];\\n    }\\n    set<pair<int, int>> segments;\\n    segments.emplace(0, n - 1);\\n    multiset<ll> segmentSums;\\n    segmentSums.insert(sums[n]);\\n    vector<ll> ans;\\n    for (const auto v : removeQueries) {\\n        const auto it = prev(segments.upper_bound({ v, numeric_limits<int>::max() }));\\n        int l = it->first, r = it->second;\\n        segments.erase(it);\\n        segmentSums.erase(segmentSums.find(sums[r + 1] - sums[l]));\\n        if (l != v) {\\n            segments.emplace(l, v - 1);\\n            segmentSums.insert(sums[v] - sums[l]);\\n        }\\n        if (r != v) {\\n            segments.emplace(v + 1, r);\\n            segmentSums.insert(sums[r + 1] - sums[v + 1]);\\n        }\\n        ans.push_back(empty(segmentSums) ? 0 : *prev(end(segmentSums)));\\n    }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2454651,
                "title": "simple-reverse-traversing-o-n-c",
                "content": "```\\n\\nPrerequisite :- https://leetcode.com/problems/longest-consecutive-sequence/\\n\\nvector<long long> maximumSegmentSum(vector<int>& v,vector<int>& q){\\n        long long cur=0,n=v.size();\\n        vector<long long>sum(n,0),count(n,0),ans(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]=cur;\\n            int x=q[i];\\n            \\n            long long leftsum=0,leftcount=0;\\n            if(x!=0) leftsum=sum[x-1],leftcount=count[x-1];\\n            \\n            long long rightsum=0,rightcount=0;\\n            if(x!=n-1) rightsum=sum[x+1],rightcount=count[x+1];\\n            \\n            long long cursum,curcount;\\n            cursum=v[x]+leftsum+rightsum;\\n            curcount=1+leftcount+rightcount;\\n            \\n            if(x!=0) sum[x-leftcount]=cursum,count[x-leftcount]=curcount;\\n            if(x!=n-1) sum[x+rightcount]=cursum,count[x+rightcount]=curcount;\\n            \\n            cur=max(cur,cursum);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nPrerequisite :- https://leetcode.com/problems/longest-consecutive-sequence/\\n\\nvector<long long> maximumSegmentSum(vector<int>& v,vector<int>& q){\\n        long long cur=0,n=v.size();\\n        vector<long long>sum(n,0),count(n,0),ans(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]=cur;\\n            int x=q[i];\\n            \\n            long long leftsum=0,leftcount=0;\\n            if(x!=0) leftsum=sum[x-1],leftcount=count[x-1];\\n            \\n            long long rightsum=0,rightcount=0;\\n            if(x!=n-1) rightsum=sum[x+1],rightcount=count[x+1];\\n            \\n            long long cursum,curcount;\\n            cursum=v[x]+leftsum+rightsum;\\n            curcount=1+leftcount+rightcount;\\n            \\n            if(x!=0) sum[x-leftcount]=cursum,count[x-leftcount]=curcount;\\n            if(x!=n-1) sum[x+rightcount]=cursum,count[x+rightcount]=curcount;\\n            \\n            cur=max(cur,cursum);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454617,
                "title": "c-set-and-prefix-sum-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<long long> ans, prefixSum(n + 1);\\n\\t\\t\\tfor(int i = 1; i <= n; i++) \\n\\t\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\tset<pair<int, int>> setIndex;\\n\\t\\t\\tsetIndex.insert({0, n - 1});\\n\\t\\t\\t\\n\\t\\t\\tmultiset<long long> setSum;\\n\\t\\t\\tsetSum.insert(0);\\n\\t\\t\\tsetSum.insert(prefixSum[n]);\\n\\t\\t\\t\\n\\t\\t\\tfor(auto& index : removeQueries) {\\n\\t\\t\\t\\tauto it = setIndex.upper_bound({index, n});\\n\\t\\t\\t\\tit--;\\n\\t\\t\\t\\tauto [start, end] = *it;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlong long currSum = prefixSum[end + 1] - prefixSum[start];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsetIndex.erase(it);\\n\\t\\t\\t\\tsetSum.erase(setSum.find(currSum));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(end > index) {\\n\\t\\t\\t\\t\\tsetIndex.insert({index + 1, end});\\n\\t\\t\\t\\t\\tsetSum.insert(prefixSum[end + 1] - prefixSum[index + 1]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(start < index) {\\n\\t\\t\\t\\t\\tsetIndex.insert({start, index - 1});\\n\\t\\t\\t\\t\\tsetSum.insert(prefixSum[index] - prefixSum[start]);               \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlong long currMax = *setSum.rbegin();\\n\\t\\t\\t\\tans.push_back(currMax);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<long long> ans, prefixSum(n + 1);\\n\\t\\t\\tfor(int i = 1; i <= n; i++) \\n\\t\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\tset<pair<int, int>> setIndex;\\n\\t\\t\\tsetIndex.insert({0, n - 1}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2053313,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            },
            {
                "id": 1960982,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            },
            {
                "id": 1746302,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Hours of Training to Win a Competition",
        "question_content": "<p>You are entering a competition, and are given two <strong>positive</strong> integers <code>initialEnergy</code> and <code>initialExperience</code> denoting your initial energy and initial experience respectively.</p>\n\n<p>You are also given two <strong>0-indexed</strong> integer arrays <code>energy</code> and <code>experience</code>, both of length <code>n</code>.</p>\n\n<p>You will face <code>n</code> opponents <strong>in order</strong>. The energy and experience of the <code>i<sup>th</sup></code> opponent is denoted by <code>energy[i]</code> and <code>experience[i]</code> respectively. When you face an opponent, you need to have both <strong>strictly</strong> greater experience and energy to defeat them and move to the next opponent if available.</p>\n\n<p>Defeating the <code>i<sup>th</sup></code> opponent <strong>increases</strong> your experience by <code>experience[i]</code>, but <strong>decreases</strong> your energy by <code>energy[i]</code>.</p>\n\n<p>Before starting the competition, you can train for some number of hours. After each hour of training, you can <strong>either</strong> choose to increase your initial experience by one, or increase your initial energy by one.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of training hours required to defeat all </em><code>n</code><em> opponents</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0<sup>th</sup> opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1<sup>st</sup> opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2<sup>nd</sup> opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3<sup>rd</sup> opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> You do not need any additional energy or experience to win the competition, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2456694,
                "title": "easy-understanding-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ig, vector<int>& energy, vector<int>& experience) \\n    {\\n        int hours = 0;\\n        for (int i = 0; i < energy.size(); i++)\\n        {\\n            if (energy[i] >= ie)\\n            {\\n                hours += energy[i] - ie + 1;\\n                ie += energy[i] - ie + 1;\\n            }\\n            if (experience[i] >= ig)\\n            {\\n                hours += experience[i] - ig + 1;\\n                ig += experience[i] - ig + 1;\\n            }\\n\\t\\t\\t// At the end increase the experience by experience[i] and decrease the energy by energy[i].\\n            ie -= energy[i];\\n            ig += experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ig, vector<int>& energy, vector<int>& experience) \\n    {\\n        int hours = 0;\\n        for (int i = 0; i < energy.size(); i++)\\n        {\\n            if (energy[i] >= ie)\\n            {\\n                hours += energy[i] - ie + 1;\\n                ie += energy[i] - ie + 1;\\n            }\\n            if (experience[i] >= ig)\\n            {\\n                hours += experience[i] - ig + 1;\\n                ig += experience[i] - ig + 1;\\n            }\\n\\t\\t\\t// At the end increase the experience by experience[i] and decrease the energy by energy[i].\\n            ie -= energy[i];\\n            ig += experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456630,
                "title": "c-easy-self-explanatory-faster-than-100-00",
                "content": "**Do UPVOTE if it helps :)**\\n\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457243,
                "title": "easy-c-train-and-fight-clean-fast-and-friendly-code-tc-o-n-sc-o-1",
                "content": "The main idea here is to arrange the \" **if\\'s** \" properly. The first \\' if \\' will check if we have enough **Energy** and **Experience** , we train accordingly and then we move on to fight the opponent.\\nNext is losing energy and gaining experience after fighting every opponent.\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size();     // since energy and experience arrays are of same size\\n        int trainingHours = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\t// TRAIN if needed\\n            if (initialEnergy <= energy[i]) {\\n                int difference = energy[i] - initialEnergy;\\n                initialEnergy += difference + 1;\\n                trainingHours += difference + 1;\\n            }\\n            if (initialExperience <= experience[i]) {\\n                int difference = experience[i] - initialExperience;\\n                initialExperience += difference + 1;\\n                trainingHours += difference + 1;\\n            }\\n            \\n\\t\\t\\t// FIGHT because you got to!\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return trainingHours;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size();     // since energy and experience arrays are of same size\\n        int trainingHours = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\t// TRAIN if needed\\n            if (initialEnergy <= energy[i]) {\\n                int difference = energy[i] - initialEnergy;\\n                initialEnergy += difference + 1;\\n                trainingHours += difference + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2456744,
                "title": "java-easy-to-understand-solution-with-explanation-o-n",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int sum = 0;\\n        int res = 0;\\n\\t\\t//the energy needed is the total sum \\n        for (int i : energy) {\\n            sum += i;\\n        }\\n        res += sum - initialEnergy >= 0 ? sum - initialEnergy + 1: 0;\\n        // if curExp < opponents\\u2018 exp, we need to study to earn more\\n        for (int i : experience) {\\n            if (initialExperience <= i) {\\n                res += i - initialExperience + 1;\\n                initialExperience = i + 1;\\n            }\\n            initialExperience += i;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int sum = 0;\\n        int res = 0;\\n\\t\\t//the energy needed is the total sum \\n        for (int i : energy) {\\n            sum += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464962,
                "title": "prefix-sum",
                "content": "The energy is simple - we just need the sum of energy of all opponents, plus one.\\n\\nThe experience is trickier, as it depends on the order of opponents.\\n\\n**C++**\\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n    int need_exp = 0, cur_exp = initialExperience;\\n    for (int i = 0; i < experience.size();  cur_exp += experience[i++])\\n        need_exp += max(experience[i] - need_exp - cur_exp + 1, 0);\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + need_exp;\\n}\\n```\\n\\nNo raw loops version, just for fun. It\\'s neither shorter nor more efficient, just wanted to see if it can be done.\\n\\nWe use prefix sum (partial sum) and transform to compute additional experience we need for each opponent.\\n\\n**C++**\\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExp, vector<int>& energy, vector<int>& exp) {\\n    vector<int> ps;\\n    partial_sum(begin(exp), end(exp), back_inserter(ps));\\n    transform(begin(ps) + 1, end(ps), begin(ps), begin(exp) + 1, [](int pa, int pb) { return max(pa - 2 * pb, 0); });\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + \\n        max(accumulate(begin(exp), end(exp), 0, [](int need, int delta) { return need + max(delta - need + 1, 0); }) - initialExp, 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n    int need_exp = 0, cur_exp = initialExperience;\\n    for (int i = 0; i < experience.size();  cur_exp += experience[i++])\\n        need_exp += max(experience[i] - need_exp - cur_exp + 1, 0);\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + need_exp;\\n}\\n```\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExp, vector<int>& energy, vector<int>& exp) {\\n    vector<int> ps;\\n    partial_sum(begin(exp), end(exp), back_inserter(ps));\\n    transform(begin(ps) + 1, end(ps), begin(ps), begin(exp) + 1, [](int pa, int pb) { return max(pa - 2 * pb, 0); });\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + \\n        max(accumulate(begin(exp), end(exp), 0, [](int need, int delta) { return need + max(delta - need + 1, 0); }) - initialExp, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456759,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        ans = 0\\n        n = len(energy)\\n\\n        for i in range(n):\\n            while initialEnergy <= energy[i] or initialExperience <= experience[i]:\\n                if initialEnergy <= energy[i]:\\n                    initialEnergy += 1\\n                    ans += 1\\n                if initialExperience <= experience[i]:\\n                    initialExperience += 1\\n                    ans += 1\\n            initialEnergy -= energy[i]\\n            initialExperience += experience[i]\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        ans = 0\\n        n = len(energy)\\n\\n        for i in range(n):\\n            while initialEnergy <= energy[i] or initialExperience <= experience[i]:\\n                if initialEnergy <= energy[i]:\\n                    initialEnergy += 1\\n                    ans += 1\\n                if initialExperience <= experience[i]:\\n                    initialExperience += 1\\n                    ans += 1\\n            initialEnergy -= energy[i]\\n            initialExperience += experience[i]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459984,
                "title": "simulation",
                "content": "##### Java\\n```java\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.length; opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n            \\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n            \\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.size(); opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n\\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n\\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.length; opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n            \\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n            \\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```\n```c++\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.size(); opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n\\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n\\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456773,
                "title": "python-greedy-o-n",
                "content": "Explained the variable names in code with comment.\\n<hr />\\n\\nThe idea is to just greedily simulate the process.\\n\\nWhenever we don\\'t have enough energy to move to the next stage, we add the minimum required to have +1 energy, and the same for experience.\\n\\nThen we add the experience from the current stage, and reduce the enery from the current stage as required by the problem.\\n\\nAt the end, we added X energy, and Y experience. So we return the sum, minus the initial starting values we had. \\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        en = 0 # Energy\\n        ex = 0 # Experience\\n        \\n        an = 0 # Added energy\\n        ax = 0 # Added experience\\n       \\n        for ener, exp in zip(energy, experience):\\n            if ener >= en:\\n                an += (ener - en + 1)\\n                en += (ener - en + 1)\\n            if exp >= ex:\\n                ax += (exp - ex + 1)\\n                ex += (exp - ex + 1)\\n            \\n            en -= ener\\n            ex += exp\\n            \\n        return max(0, (an - initialEnergy)) + max(0, (ax - initialExperience))\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        en = 0 # Energy\\n        ex = 0 # Experience\\n        \\n        an = 0 # Added energy\\n        ax = 0 # Added experience\\n       \\n        for ener, exp in zip(energy, experience):\\n            if ener >= en:\\n                an += (ener - en + 1)\\n                en += (ener - en + 1)\\n            if exp >= ex:\\n                ax += (exp - ex + 1)\\n                ex += (exp - ex + 1)\\n            \\n            en -= ener\\n            ex += exp\\n            \\n        return max(0, (an - initialEnergy)) + max(0, (ax - initialExperience))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456645,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int currentEnergy = initialEnergy;\\n        int currentExperience = initialExperience;\\n        int result = 0;\\n        int diff = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            if (energy[i] >= currentEnergy) {   \\n                diff = energy[i] - currentEnergy + 1;\\n                result = result + diff;\\n                currentEnergy = currentEnergy + diff;\\n            }\\n            currentEnergy = currentEnergy - energy[i];\\n            if (experience[i] >= currentExperience) {\\n                diff = experience[i] - currentExperience + 1;\\n                result = result + diff;\\n                currentExperience = currentExperience + diff;\\n            }\\n            currentExperience = currentExperience + experience[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int currentEnergy = initialEnergy;\\n        int currentExperience = initialExperience;\\n        int result = 0;\\n        int diff = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            if (energy[i] >= currentEnergy) {   \\n                diff = energy[i] - currentEnergy + 1;\\n                result = result + diff;\\n                currentEnergy = currentEnergy + diff;\\n            }\\n            currentEnergy = currentEnergy - energy[i];\\n            if (experience[i] >= currentExperience) {\\n                diff = experience[i] - currentExperience + 1;\\n                result = result + diff;\\n                currentExperience = currentExperience + diff;\\n            }\\n            currentExperience = currentExperience + experience[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456624,
                "title": "c-simple-efficient-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minNumberOfHours(int i, int e, vector<int>& ener, vector<int>& exp) \\n    {\\n        int cnt=0, diff;\\n        for(int k=0; k<ener.size(); k++)\\n        {\\n            if(i<=ener[k])\\n            {\\n                diff = (ener[k]-i+1);\\n                i += diff;\\n                cnt += diff;\\n            }\\n            if(e<=exp[k])\\n            {\\n                diff = (exp[k]-e+1);\\n                e += diff;\\n                cnt += diff;\\n            }\\n            \\n            i -= ener[k];\\n            e += exp[k];\\n                \\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minNumberOfHours(int i, int e, vector<int>& ener, vector<int>& exp) \\n    {\\n        int cnt=0, diff;\\n        for(int k=0; k<ener.size(); k++)\\n        {\\n            if(i<=ener[k])\\n            {\\n                diff = (ener[k]-i+1);\\n                i += diff;\\n                cnt += diff;\\n            }\\n            if(e<=exp[k])\\n            {\\n                diff = (exp[k]-e+1);\\n                e += diff;\\n                cnt += diff;\\n            }\\n            \\n            i -= ener[k];\\n            e += exp[k];\\n                \\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722230,
                "title": "python-java-elegant-short-one-pass",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minNumberOfHours(self, energy: int, experience: int, energies: List[int], experiences: List[int]) -> int:\\n        hours = 0\\n\\n        for eng, exp in zip(energies, experiences):\\n            # Adding the missing amount of energy\\n            extra_en = max(0, eng - energy + 1)\\n            energy += extra_en\\n\\n            # Adding the missing amount of experience\\n            extra_ex = max(0, exp - experience + 1)\\n            experience += extra_ex\\n\\n            energy -= eng\\n            experience += exp\\n            hours += extra_en + extra_ex\\n\\n        return hours\\n```\\n\\n```\\npublic class Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(1)\\n     */\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minNumberOfHours(self, energy: int, experience: int, energies: List[int], experiences: List[int]) -> int:\\n        hours = 0\\n\\n        for eng, exp in zip(energies, experiences):\\n            # Adding the missing amount of energy\\n            extra_en = max(0, eng - energy + 1)\\n            energy += extra_en\\n\\n            # Adding the missing amount of experience\\n            extra_ex = max(0, exp - experience + 1)\\n            experience += extra_ex\\n\\n            energy -= eng\\n            experience += exp\\n            hours += extra_en + extra_ex\\n\\n        return hours\\n```\n```\\npublic class Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(1)\\n     */\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600984,
                "title": "python-c-java-beginner-level-simple-short-solution-greedy-approach",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2383. Minimum Hours of Training to Win a Competition***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        traning = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            traning += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                traning += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return traning\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n    \\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        traning = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            traning += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                traning += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return traning\\n```\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460220,
                "title": "python-solution",
                "content": "- for energy:\\n\\t- get sum of opponent energy and calculate hours needed to have at least one more energy\\n- for experience\\n\\t- iterate through each opponentj\\n\\t\\t- if experience is not greater\\n\\t\\t\\t- add hours so experience is one greater\\n\\t\\t- add opponent experience\\n\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        hours = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            hours += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                hours += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return hours\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        hours = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            hours += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                hours += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456641,
                "title": "c-greedy-approach-o-n",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. at each step gaining just enough energy & experience to win over current opponent\\n2. in end, if initialEnergy > 1, we can reduce \\' initialEnergy -1 \\' amount of training time \\n```\\nclass Solution {\\npublic:\\n\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        \\n        int time=0;\\n        for(int i=0;i<n;i++){\\n            int d1 = initialEnergy-energy[i], d2 = initialExperience-experience[i];\\n            \\n            time += (d1<=0 ? abs(d1)+1:0) + (d2<=0 ? abs(d2)+1:0); // adding \\' +1\\' as we need strictly greater energy & experience\\n            \\n            initialEnergy = max(initialEnergy-energy[i],1);\\n            initialExperience += experience[i] + (d2<=0 ? abs(d2)+1:0);\\n        }\\n        \\n        time -= (initialEnergy-1);\\n        \\n        return max(time,0);\\n    }\\n};\\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        \\n        int time=0;\\n        for(int i=0;i<n;i++){\\n            int d1 = initialEnergy-energy[i], d2 = initialExperience-experience[i];\\n            \\n            time += (d1<=0 ? abs(d1)+1:0) + (d2<=0 ? abs(d2)+1:0); // adding \\' +1\\' as we need strictly greater energy & experience\\n            \\n            initialEnergy = max(initialEnergy-energy[i],1);\\n            initialExperience += experience[i] + (d2<=0 ? abs(d2)+1:0);\\n        }\\n        \\n        time -= (initialEnergy-1);\\n        \\n        return max(time,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504679,
                "title": "c-solution-greedy-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iniEne, int iniExp, vector<int>& ene, vector<int>& exp) {\\n        int sumEne=0;\\n        int ans=0;\\n        for(int i=0;i<size(ene);i++)\\n        {\\n            sumEne+=ene[i];\\n        }\\n        if(sumEne>=iniEne)\\n        {\\n            ans+=(sumEne-iniEne)+1;\\n        }\\n        for(int i=0;i<size(exp);i++)\\n        {\\n            if(iniExp>exp[i])\\n                iniExp+=exp[i];\\n            else\\n            {\\n                ans+=(exp[i]-iniExp)+1;\\n                iniExp+=((exp[i]-iniExp)+1)+exp[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iniEne, int iniExp, vector<int>& ene, vector<int>& exp) {\\n        int sumEne=0;\\n        int ans=0;\\n        for(int i=0;i<size(ene);i++)\\n        {\\n            sumEne+=ene[i];\\n        }\\n        if(sumEne>=iniEne)\\n        {\\n            ans+=(sumEne-iniEne)+1;\\n        }\\n        for(int i=0;i<size(exp);i++)\\n        {\\n            if(iniExp>exp[i])\\n                iniExp+=exp[i];\\n            else\\n            {\\n                ans+=(exp[i]-iniExp)+1;\\n                iniExp+=((exp[i]-iniExp)+1)+exp[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465034,
                "title": "easy-java-solution",
                "content": "# Minimum Hours of Training to Win a Competition\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //Variable to store ans\\n        int ans=0;\\n        int energysum=0;\\n        //Variable to store the total energy require\\n        for(int num:energy){\\n            energysum+=num;\\n        }\\n        //If initialEnergy is less than totalEnergy require so adding the difference among the two energy + 1 to initalEnergy\\n        if(initialEnergy<(energysum+1)){\\n            ans+=energysum-initialEnergy+1;\\n            initialEnergy=energysum+1;\\n        }\\n        int i=0;\\n        //Variable add keeps track of the experience require to be added to initialExperience\\n        int add=0;\\n        while(i<experience.length){\\n            //If initialExperience is less then the require experience than computing the differnce among the two experiences + 1, and storing the max of this computed value and value in variable add in add\\n            if(initialExperience<=experience[i]){\\n                add=Math.max(add,experience[i]-initialExperience+1);\\n            }\\n            //Decreasing energy\\n            initialEnergy-=energy[i];\\n            //Adding experience\\n            initialExperience+=experience[i];\\n            ++i;\\n        }\\n        //Adding the required experience to be added to ans variable\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //Variable to store ans\\n        int ans=0;\\n        int energysum=0;\\n        //Variable to store the total energy require\\n        for(int num:energy){\\n            energysum+=num;\\n        }\\n        //If initialEnergy is less than totalEnergy require so adding the difference among the two energy + 1 to initalEnergy\\n        if(initialEnergy<(energysum+1)){\\n            ans+=energysum-initialEnergy+1;\\n            initialEnergy=energysum+1;\\n        }\\n        int i=0;\\n        //Variable add keeps track of the experience require to be added to initialExperience\\n        int add=0;\\n        while(i<experience.length){\\n            //If initialExperience is less then the require experience than computing the differnce among the two experiences + 1, and storing the max of this computed value and value in variable add in add\\n            if(initialExperience<=experience[i]){\\n                add=Math.max(add,experience[i]-initialExperience+1);\\n            }\\n            //Decreasing energy\\n            initialEnergy-=energy[i];\\n            //Adding experience\\n            initialExperience+=experience[i];\\n            ++i;\\n        }\\n        //Adding the required experience to be added to ans variable\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461087,
                "title": "java-this-problem-is-actually-very-easy",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimum Hours of Training to Win a Competition.\\nMemory Usage: 41.9 MB, less than 57.14% of Java online submissions for Minimum Hours of Training to Win a Competition.**\\n\\nJava code:\\n```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int training = 0;  // keep track of how many hours needed to train\\n        int energyNum = initialEnergy;\\n        int experienceNum = initialExperience;\\n        for(int i = 0; i<energy.length; i++) { // loop through all the opponents\\n            if (energyNum <= energy[i]) {                // if you don\\'t have enough energy\\n                training += (energy[i] + 1) - energyNum; // , then spend the min amount of hours needed to get enough energy\\n                energyNum= energy[i] + 1;                //  to beat the opponent\\n            }\\n            if(experienceNum <= experience[i]) {                 // if you don\\'t have enough experience\\n                training += (experience[i] + 1) - experienceNum; // , then spend the min amount of hours needed to get enough\\n                experienceNum = experience[i] + 1;               // experience to beat the opponent\\n            }\\n            energyNum -= energy[i]; // after beating the opponent, your energy decreases\\n            experienceNum += experience[i]; // after beating the opponent, your experience increases\\n        }\\n        return training;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int training = 0;  // keep track of how many hours needed to train\\n        int energyNum = initialEnergy;\\n        int experienceNum = initialExperience;\\n        for(int i = 0; i<energy.length; i++) { // loop through all the opponents\\n            if (energyNum <= energy[i]) {                // if you don\\'t have enough energy\\n                training += (energy[i] + 1) - energyNum; // , then spend the min amount of hours needed to get enough energy\\n                energyNum= energy[i] + 1;                //  to beat the opponent\\n            }\\n            if(experienceNum <= experience[i]) {                 // if you don\\'t have enough experience\\n                training += (experience[i] + 1) - experienceNum; // , then spend the min amount of hours needed to get enough\\n                experienceNum = experience[i] + 1;               // experience to beat the opponent\\n            }\\n            energyNum -= energy[i]; // after beating the opponent, your energy decreases\\n            experienceNum += experience[i]; // after beating the opponent, your experience increases\\n        }\\n        return training;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457041,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        need = 0\\n        for i in range(len(energy)):\\n            if initialExperience <= experience[i]:\\n                need += experience[i] + 1 - initialExperience\\n                initialExperience = experience[i] + 1 \\n            initialExperience += experience[i]\\n            initialEnergy -= energy[i]\\n        if initialEnergy <= 0:\\n            need -= initialEnergy - 1\\n        return need",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        need = 0\\n        for i in range(len(energy)):\\n            if initialExperience <= experience[i]:\\n                need += experience[i] + 1 - initialExperience\\n                initialExperience = experience[i] + 1 \\n            initialExperience += experience[i]\\n            initialEnergy -= energy[i]\\n        if initialEnergy <= 0:\\n            need -= initialEnergy - 1\\n        return need",
                "codeTag": "Java"
            },
            {
                "id": 2456579,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience)\\n    {\\n        int op=0;\\n        int n = energy.size();\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(initialEnergy<=energy[i])\\n            {\\n                diff = (energy[i]-initialEnergy+1);\\n                initialEnergy += diff;\\n                op += diff;\\n            }\\n            if(initialExperience<=experience[i])\\n            {\\n                diff = (experience[i]-initialExperience+1);\\n                initialExperience += diff;\\n                op += diff;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n \\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience)\\n    {\\n        int op=0;\\n        int n = energy.size();\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(initialEnergy<=energy[i])\\n            {\\n                diff = (energy[i]-initialEnergy+1);\\n                initialEnergy += diff;\\n                op += diff;\\n            }\\n            if(initialExperience<=experience[i])\\n            {\\n                diff = (experience[i]-initialExperience+1);\\n                initialExperience += diff;\\n                op += diff;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n \\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466541,
                "title": "minimum-hours-of-training-to-win-a-competition-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int i, flag=1, ans=0;\\n        for(i=0 ; i<energy.size() ; i++)\\n        {\\n            if(experience[i]<initialExperience)\\n            {\\n                initialExperience += experience[i];\\n            }\\n            else if(experience[i]>=initialExperience)\\n            {\\n                ans += experience[i] - initialExperience + 1;\\n                initialExperience += 2*experience[i] - initialExperience + 1;\\n            }\\n            if(energy[i]<initialEnergy)\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            else if(energy[i]>=initialEnergy)\\n            {\\n                ans += energy[i] - initialEnergy + 1;\\n                initialEnergy = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0f95901e-4be5-4d52-b6bb-1df2ff572fc4_1682781377.0021822.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int i, flag=1, ans=0;\\n        for(i=0 ; i<energy.size() ; i++)\\n        {\\n            if(experience[i]<initialExperience)\\n            {\\n                initialExperience += experience[i];\\n            }\\n            else if(experience[i]>=initialExperience)\\n            {\\n                ans += experience[i] - initialExperience + 1;\\n                initialExperience += 2*experience[i] - initialExperience + 1;\\n            }\\n            if(energy[i]<initialEnergy)\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            else if(energy[i]>=initialEnergy)\\n            {\\n                ans += energy[i] - initialEnergy + 1;\\n                initialEnergy = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656873,
                "title": "java-easy-solution-o-n",
                "content": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res =0;\\n        int n= energy.length;\\n        int energySum =0;\\n        for(int i=0;i<n;i++){\\n            energySum+=energy[i];\\n            \\n        }\\n        res=energySum-initialEnergy>=0 ? energySum-initialEnergy+1:0;\\n        \\n        \\n         for(int i=0;i<n;i++){\\n           if(initialExperience<=experience[i]){\\n               res+=experience[i]-initialExperience+1;\\n               initialExperience = experience[i]+1;\\n           }\\n             initialExperience+=experience[i];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res =0;\\n        int n= energy.length;\\n        int energySum =0;\\n        for(int i=0;i<n;i++){\\n            energySum+=energy[i];\\n            \\n        }\\n        res=energySum-initialEnergy>=0 ? energySum-initialEnergy+1:0;\\n        \\n        \\n         for(int i=0;i<n;i++){\\n           if(initialExperience<=experience[i]){\\n               res+=experience[i]-initialExperience+1;\\n               initialExperience = experience[i]+1;\\n           }\\n             initialExperience+=experience[i];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2499445,
                "title": "c-o-n-soluion",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int en , int xp, vector<int>& energy, vector<int>& exp) {\\n        \\n        int timer = 0 ;\\n        for(int i = 0 ; i < energy.size() ; ++i ){\\n            if(en <= energy[i]) timer += energy[i] - en + 1 , en += energy[i] - en + 1 ;\\n            if(xp <= exp[i]) timer += exp[i] - xp + 1, xp += exp[i] - xp + 1 ;\\n            \\n            en -= energy[i] ;  //energy will reduce\\n            xp += exp[i] ;     //xp will increase\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int en , int xp, vector<int>& energy, vector<int>& exp) {\\n        \\n        int timer = 0 ;\\n        for(int i = 0 ; i < energy.size() ; ++i ){\\n            if(en <= energy[i]) timer += energy[i] - en + 1 , en += energy[i] - en + 1 ;\\n            if(xp <= exp[i]) timer += exp[i] - xp + 1, xp += exp[i] - xp + 1 ;\\n            \\n            en -= energy[i] ;  //energy will reduce\\n            xp += exp[i] ;     //xp will increase\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473401,
                "title": "easy-understanding-o-n-c",
                "content": "```\\n int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= energy.size();\\n        int energy_sum=1;\\n        int curr_exp=initialExperience;\\n\\t\\t\\n\\t\\t// let training hours needed in maintaining experience and initiate as 0\\n        int training_hours=0;\\n        for (int i=0; i<n; i++)\\n        {\\n            energy_sum+=energy[i];\\n            \\n\\t\\t\\t// if current experience is greater than experience needed to kill ith task\\n            if (curr_exp>experience[i])\\n            {\\n               curr_exp+=experience[i];\\n            }\\n            else {\\n\\t\\t\\t// training hours to increase experience to complete ith task\\n                training_hours+=experience[i]+1-curr_exp;\\n                curr_exp= experience[i]+1+ experience[i];\\n               \\n            }\\n            \\n        }\\n        int s=energy_sum-initialEnergy;\\n\\t\\t\\n\\t\\t//if energy sum is lesser than initial energy\\n        if(s<=0)\\n        {\\n            s=0;\\n        }\\n        return s+training_hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= energy.size();\\n        int energy_sum=1;\\n        int curr_exp=initialExperience;\\n\\t\\t\\n\\t\\t// let training hours needed in maintaining experience and initiate as 0\\n        int training_hours=0;\\n        for (int i=0; i<n; i++)\\n        {\\n            energy_sum+=energy[i];\\n            \\n\\t\\t\\t// if current experience is greater than experience needed to kill ith task\\n            if (curr_exp>experience[i])\\n            {\\n               curr_exp+=experience[i];\\n            }\\n            else {\\n\\t\\t\\t// training hours to increase experience to complete ith task\\n                training_hours+=experience[i]+1-curr_exp;\\n                curr_exp= experience[i]+1+ experience[i];\\n               \\n            }\\n            \\n        }\\n        int s=energy_sum-initialEnergy;\\n\\t\\t\\n\\t\\t//if energy sum is lesser than initial energy\\n        if(s<=0)\\n        {\\n            s=0;\\n        }\\n        return s+training_hours;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473024,
                "title": "java-beginner-friendly-well-commented-code-explanation",
                "content": "Below is commented Java code -\\n\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int i;\\n        int n = energy.length;\\n        // \\'ans\\' will track minimum number of training hours\\n        int ans = 0;\\n        for(i=0;i<n;i++){\\n            // If initial energy is more then we simply take a portion of this\\n            // i.e. we decrement it by energy[i]\\n            if(initialEnergy > energy[i]){\\n                initialEnergy -= energy[i];\\n            }\\n            else{\\n                // (initialEnergy <= energy[i])\\n                // if we had less or equal initial energy, then how much more energy do we need?\\n                // we need (energy[i] - initialEnergy + 1) more initial energy. Because only then\\n                // our initial energy will be more than energy[i]\\n                // For example, if energy[i] = 4 and initialEnergy = 3, then we need\\n                // 2 more energy units i.e. (4 - 3 + 1) units more are needed in initialEnergy\\n                // so we add this amount in the answer\\n                ans += (energy[i] - initialEnergy + 1);\\n                // add this to initial energy because that much amount more is needed\\n                initialEnergy += (energy[i] - initialEnergy + 1);\\n                // now we consumed energy[i] so decrement it from initial energy\\n                initialEnergy -= energy[i];\\n            }\\n            \\n            if(initialExperience > experience[i]){\\n                // If initial experience is more then we simply add it to experience[i]\\n                initialExperience += experience[i];\\n            }\\n            else {\\n                // (initialExperience <= experience[i])\\n                // In case we had less than or equal experience, then how much more initial\\n                // experience do we need?\\n                // We will need (experience[i] - initialExperience) + 1.\\n                // Same example as given in above comments (this time for experience)\\n                ans += (experience[i] - initialExperience) + 1;\\n                // add this to initial experience because that much amount more is needed\\n                initialExperience += (experience[i] - initialExperience) + 1;\\n                // now our experience will increase because \\n                // condition of -> initialExperience > experience[i] is now satisfied\\n                initialExperience += experience[i];\\n            }\\n        }\\n        \\n        // return minimum number of hours\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n*Kindly upvote if this solution has helped you.\\nThanks for reading! :)*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int i;\\n        int n = energy.length;\\n        // \\'ans\\' will track minimum number of training hours\\n        int ans = 0;\\n        for(i=0;i<n;i++){\\n            // If initial energy is more then we simply take a portion of this\\n            // i.e. we decrement it by energy[i]\\n            if(initialEnergy > energy[i]){\\n                initialEnergy -= energy[i];\\n            }\\n            else{\\n                // (initialEnergy <= energy[i])\\n                // if we had less or equal initial energy, then how much more energy do we need?\\n                // we need (energy[i] - initialEnergy + 1) more initial energy. Because only then\\n                // our initial energy will be more than energy[i]\\n                // For example, if energy[i] = 4 and initialEnergy = 3, then we need\\n                // 2 more energy units i.e. (4 - 3 + 1) units more are needed in initialEnergy\\n                // so we add this amount in the answer\\n                ans += (energy[i] - initialEnergy + 1);\\n                // add this to initial energy because that much amount more is needed\\n                initialEnergy += (energy[i] - initialEnergy + 1);\\n                // now we consumed energy[i] so decrement it from initial energy\\n                initialEnergy -= energy[i];\\n            }\\n            \\n            if(initialExperience > experience[i]){\\n                // If initial experience is more then we simply add it to experience[i]\\n                initialExperience += experience[i];\\n            }\\n            else {\\n                // (initialExperience <= experience[i])\\n                // In case we had less than or equal experience, then how much more initial\\n                // experience do we need?\\n                // We will need (experience[i] - initialExperience) + 1.\\n                // Same example as given in above comments (this time for experience)\\n                ans += (experience[i] - initialExperience) + 1;\\n                // add this to initial experience because that much amount more is needed\\n                initialExperience += (experience[i] - initialExperience) + 1;\\n                // now our experience will increase because \\n                // condition of -> initialExperience > experience[i] is now satisfied\\n                initialExperience += experience[i];\\n            }\\n        }\\n        \\n        // return minimum number of hours\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467893,
                "title": "python-o-n",
                "content": "```class Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        sol=0\\n        for i in range(len(energy)):\\n            if(initialEnergy<=energy[i]):  \\n                sol+=(energy[i]-initialEnergy+1)\\n                initialEnergy+=(energy[i]-initialEnergy+1)\\n            if(initialExperience<=experience[i]):\\n                sol+=(experience[i]-initialExperience+1)\\n                initialExperience+=(experience[i]-initialExperience+1)\\n            initialEnergy-=energy[i]\\n            initialExperience+=experience[i]\\n        return sol\\n```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```class Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        sol=0\\n        for i in range(len(energy)):\\n            if(initialEnergy<=energy[i]):  \\n                sol+=(energy[i]-initialEnergy+1)\\n                initialEnergy+=(energy[i]-initialEnergy+1)\\n            if(initialExperience<=experience[i]):\\n                sol+=(experience[i]-initialExperience+1)\\n                initialExperience+=(experience[i]-initialExperience+1)\\n            initialEnergy-=energy[i]\\n            initialExperience+=experience[i]\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460663,
                "title": "c-simulate-easy-to-understand-0ms-100-fast-o-n-time-o-1-space",
                "content": "We can just simluate this. I have renamed the method arguments to make the code a bit more terse.\\n\\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n        for (int i = 0; i < size(energies); ++i) {\\n            // Energy.\\n            if (energy <= energies[i]) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += energies[i] + 1 - energy;\\n                energy = energies[i] + 1;\\n            }\\n            energy -= energies[i];\\n            \\n            // Experience.\\n            if (experience <= experiences[i]) {\\n                // Same here.\\n                training += experiences[i] + 1 - experience;\\n                experience = experiences[i] + 1;\\n            }\\n            experience += experiences[i];\\n        }\\n        return training;\\n    }\\n```\\n\\nTime complexity: ```O(n)``` we look at each of the ```energies``` and ```experiences``` element onces.\\nSpace complexity: ```O(1)``` only a loop variable and one integer for the result\\n\\nWe could also simluate energy and experience independently, this allows use to use structured loop.\\n\\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n\\n        // Energy.\\n        for (int eng : energies) {\\n            if (energy <= eng) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += eng + 1 - energy;\\n                energy = eng + 1;\\n            }\\n            energy -= eng;\\n        }\\n            \\n        // Experience.\\n        for (int exp : experiences) {\\n            if (experience <= exp) {\\n                // Same here.\\n                training += exp + 1 - experience;\\n                experience = exp + 1;\\n            }\\n            experience += exp;\\n        }\\n\\n        return training;\\n    }\\n```\\n\\nTime and space complexity is the same. The actual runtime seem to be a bit slower, maybe because we have more loop overhead, but I guess without proper microbench marks this is hard to compare.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n        for (int i = 0; i < size(energies); ++i) {\\n            // Energy.\\n            if (energy <= energies[i]) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += energies[i] + 1 - energy;\\n                energy = energies[i] + 1;\\n            }\\n            energy -= energies[i];\\n            \\n            // Experience.\\n            if (experience <= experiences[i]) {\\n                // Same here.\\n                training += experiences[i] + 1 - experience;\\n                experience = experiences[i] + 1;\\n            }\\n            experience += experiences[i];\\n        }\\n        return training;\\n    }\\n```\n```O(n)```\n```energies```\n```experiences```\n```O(1)```\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n\\n        // Energy.\\n        for (int eng : energies) {\\n            if (energy <= eng) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += eng + 1 - energy;\\n                energy = eng + 1;\\n            }\\n            energy -= eng;\\n        }\\n            \\n        // Experience.\\n        for (int exp : experiences) {\\n            if (experience <= exp) {\\n                // Same here.\\n                training += exp + 1 - experience;\\n                experience = exp + 1;\\n            }\\n            experience += exp;\\n        }\\n\\n        return training;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459272,
                "title": "100-easy-approach-c-basic-for-loop-o-n",
                "content": "**Please Upvote**\\n\\n```\\nint minNumberOfHours(int e, int ex, vector<int>& energy, vector<int>& experience) {\\n        int count=0;\\n        for(int i=0;i<energy.size();i++){\\n            if(energy[i]>=e){\\n                while(e<=energy[i]){\\n                    e++;\\n                    count++;\\n                }\\n            }\\n            if(experience[i]>=ex){\\n                while(ex<=experience[i]){\\n                    ex++;\\n                    count++;\\n                }\\n            }\\n            ex+=experience[i];\\n            e-=energy[i];\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nint minNumberOfHours(int e, int ex, vector<int>& energy, vector<int>& experience) {\\n        int count=0;\\n        for(int i=0;i<energy.size();i++){\\n            if(energy[i]>=e){\\n                while(e<=energy[i]){\\n                    e++;\\n                    count++;\\n                }\\n            }\\n            if(experience[i]>=ex){\\n                while(ex<=experience[i]){\\n                    ex++;\\n                    count++;\\n                }\\n            }\\n            ex+=experience[i];\\n            e-=energy[i];\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458603,
                "title": "fastest-c-solution-2-4-ms-with-full-explaination-every-details-of-what-and-why-with-how",
                "content": "**Problem**: In this problem it have been asking for number of minimum training hours required to win the competition. Winning competition meaning you have your Energy and Experience should be strictly greater than whatever given in Energy and Experience array.\\n\\n![image](https://assets.leetcode.com/users/images/fb2d4ab2-030c-4fc6-8d00-f3f50635b208_1661079758.4140139.png)\\n\\n**The following variety you may observe while solving it:**\\n\\n1.> Your initial energy and initial experience is greater than other opponents and in this you really don\\'t have to do anything you can simply return zero.\\n\\n2.> Your initial energy and experience is not greater than other opponents than you require to train and increase your experience and energy. Yes its a bit confusing that am saying to training and also increasing the energy here i mean your required energy that you need to be more than other competents obviously while doing competition your energy will decrease.\\n\\nNow come to the approach here what we can observe your energy should remain 1 more than the complete energy array sum. So you can just add the energy array sum and your training hours will become (for energy not for experience) sum_energy - initial energy + 1.\\n\\nThis can\\'t be valid for experience and for experience you need to do differently.\\n\\nFor experience you have to check your experience from next opponent there will be two following case:\\n1. InitialExperience is more than opponents directly add the initialExperience and opponents experience as you WON.\\n2. InitialExperience is less now you need training so you do opponentExp - initialExperience +1 this should be added in your trianing hours after this training procedure you can move on and add opponent Exp with your Exp + training hours.\\n\\nOnly this thing you need to do and return the trainig hours at the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n\\t    \\n            int tr_energy = 0, tr_exp = initialExperience ,tr_hrs=0;\\n            \\n            for(int i=0;i<energy.size();i++) { tr_energy += energy[i] ; }\\n            if(initialEnergy > tr_energy) return 0; //Base case when you have more initial Energy then all the opponents.\\n            \\n            for( int i=0; i<energy.size(); i++) \\n            { \\n               if(tr_exp<=experience[i])\\n                 {\\n                   tr_hrs += (experience[i] - tr_exp) + 1;\\n                   tr_exp += experience[i] + tr_hrs;\\n                 }            \\n               else\\n                 {\\n                   tr_exp += experience[i];\\n                 }\\n            }\\n\\t\\t\\t//till this step we have tr_hrs for experience now add tr_hrs required for energy\\n            tr_hrs += (tr_energy + 1) - initialEnergy;\\n         \\n            return tr_hrs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n\\t    \\n            int tr_energy = 0, tr_exp = initialExperience ,tr_hrs=0;\\n            \\n            for(int i=0;i<energy.size();i++) { tr_energy += energy[i] ; }\\n            if(initialEnergy > tr_energy) return 0; //Base case when you have more initial Energy then all the opponents.\\n            \\n            for( int i=0; i<energy.size(); i++) \\n            { \\n               if(tr_exp<=experience[i])\\n                 {\\n                   tr_hrs += (experience[i] - tr_exp) + 1;\\n                   tr_exp += experience[i] + tr_hrs;\\n                 }            \\n               else\\n                 {\\n                   tr_exp += experience[i];\\n                 }\\n            }\\n\\t\\t\\t//till this step we have tr_hrs for experience now add tr_hrs required for energy\\n            tr_hrs += (tr_energy + 1) - initialEnergy;\\n         \\n            return tr_hrs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458412,
                "title": "c-soln-100-faster-brute-force-approach-soln-with-full-explanation",
                "content": "\\tint energySum = accumulate(energy.begin(),energy.end(),0);\\n       int playerEnergyGain = 0;\\n       int playerExperienceGain = 0;\\n        \\n        \\n        if(energySum >= initialEnergy)\\n             playerEnergyGain = energySum - initialEnergy + 1;\\n       \\n        for(int i = 0; i < experience.size();i++){\\n            if(initialExperience <= experience[i]){\\n                int temp = initialExperience;\\n                initialExperience = (initialExperience*(experience[i]/initialExperience)) + (experience[i] % initialExperience) + 1;\\n                playerExperienceGain += initialExperience - temp;\\n                 }\\n            if(initialExperience > experience[i])\\n                initialExperience += experience[i];\\n        }\\n        \\n            return playerEnergyGain + playerExperienceGain;    \\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint energySum = accumulate(energy.begin(),energy.end(),0);\\n       int playerEnergyGain = 0;\\n       int playerExperienceGain = 0;\\n        \\n        \\n        if(energySum >= initialEnergy)\\n             playerEnergyGain = energySum - initialEnergy + 1;\\n       \\n        for(int i = 0; i < experience.size();i++){\\n            if(initialExperience <= experience[i]){\\n                int temp = initialExperience;\\n                initialExperience = (initialExperience*(experience[i]/initialExperience)) + (experience[i] % initialExperience) + 1;\\n                playerExperienceGain += initialExperience - temp;\\n                 }\\n            if(initialExperience > experience[i])\\n                initialExperience += experience[i];\\n        }\\n        \\n            return playerEnergyGain + playerExperienceGain;    \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458305,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hrs = 0;\\n        int ine = initialEnergy;\\n        int inex = initialExperience;\\n        int n = energy.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                if(energy[i]>=ine)\\n                {\\n                    hrs += energy[i]+1-ine;\\n                    \\n                    ine=energy[i]+1;\\n                }\\n                if(experience[i]>=inex)\\n                {\\n                    hrs += experience[i]+1-inex;\\n                    \\n                    inex=experience[i]+1;\\n                }\\n                ine=ine-energy[i];\\n                inex=inex+experience[i];\\n            \\n        }\\n        return hrs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hrs = 0;\\n        int ine = initialEnergy;\\n        int inex = initialExperience;\\n        int n = energy.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                if(energy[i]>=ine)\\n                {\\n                    hrs += energy[i]+1-ine;\\n                    \\n                    ine=energy[i]+1;\\n                }\\n                if(experience[i]>=inex)\\n                {\\n                    hrs += experience[i]+1-inex;\\n                    \\n                    inex=experience[i]+1;\\n                }\\n                ine=ine-energy[i];\\n                inex=inex+experience[i];\\n            \\n        }\\n        return hrs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457962,
                "title": "100-faster-java-ac-o-n",
                "content": "\\n\\t \\n\\t class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int sum=0;\\n        for(int i:energy)\\n            sum+=i;\\n        int hours = sum>=initialEnergy?sum-initialEnergy+1:0;\\n        for(int i=0;i<experience.length;i++)\\n        {\\n            if(experience[i]<initialExperience)\\n                initialExperience+=experience[i];\\n            else{\\n                hours+= experience[i]-initialExperience + 1;\\n                initialExperience+= experience[i]-initialExperience + 1 + experience[i];\\n                \\n            }\\n        }\\n        return hours;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int sum=0;\\n        for(int i:energy)\\n            sum+=i;\\n        int hours = sum>=initialEnergy?sum-initialEnergy+1:0;\\n        for(int i=0;i<experience.length;i++)\\n        {\\n            if(experience[i]<initialExperience)\\n                initialExperience+=experience[i];\\n            else{\\n                hours+= experience[i]-initialExperience + 1;\\n                initialExperience+= experience[i]-initialExperience + 1 + experience[i];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457442,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        \\n        int total_energy = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_energy += energy[i];\\n        }\\n        \\n        // cal. the exercise req for get sufficient energy\\n        \\n        int exercise_for_energy = 0;\\n        \\n        if(initialEnergy <= total_energy)\\n        {\\n            exercise_for_energy += total_energy + 1 - initialEnergy;\\n        }\\n        \\n        // cal. the exercise req for get sufficient experience\\n        \\n        int exercise_for_experience = 0;\\n        \\n        int curr_experience = initialExperience;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_experience > experience[i])\\n            {\\n                curr_experience += experience[i];\\n            }\\n            else\\n            {\\n                int req_experience = experience[i] + 1 - curr_experience;\\n                \\n                exercise_for_experience += req_experience;\\n                \\n                curr_experience +=  req_experience + experience[i];\\n            }\\n        }\\n    \\n        return exercise_for_energy + exercise_for_experience;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        \\n        int total_energy = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_energy += energy[i];\\n        }\\n        \\n        // cal. the exercise req for get sufficient energy\\n        \\n        int exercise_for_energy = 0;\\n        \\n        if(initialEnergy <= total_energy)\\n        {\\n            exercise_for_energy += total_energy + 1 - initialEnergy;\\n        }\\n        \\n        // cal. the exercise req for get sufficient experience\\n        \\n        int exercise_for_experience = 0;\\n        \\n        int curr_experience = initialExperience;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_experience > experience[i])\\n            {\\n                curr_experience += experience[i];\\n            }\\n            else\\n            {\\n                int req_experience = experience[i] + 1 - curr_experience;\\n                \\n                exercise_for_experience += req_experience;\\n                \\n                curr_experience +=  req_experience + experience[i];\\n            }\\n        }\\n    \\n        return exercise_for_energy + exercise_for_experience;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456854,
                "title": "c-greedy-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int Energyy, int Exp, vector<int>& Energy, vector<int>& experience) {\\n        int exp=0;\\n        int energy=0;\\n        for(int i=0;i<experience.size();i++){\\n            if(Exp>experience[i]){\\n                Exp+=experience[i];\\n            } \\n            else{\\n                int temp=experience[i]+1;\\n                exp+=temp-Exp;\\n                Exp=temp+experience[i];\\n            }\\n        }\\n        int sum=1;\\n        for(auto i:Energy) sum+=i;\\n        if(sum>Energyy){\\n            energy=sum-Energyy;\\n        }\\n        return exp+energy;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int Energyy, int Exp, vector<int>& Energy, vector<int>& experience) {\\n        int exp=0;\\n        int energy=0;\\n        for(int i=0;i<experience.size();i++){\\n            if(Exp>experience[i]){\\n                Exp+=experience[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2456798,
                "title": "c-o-n-0ms-intuition-solution-with-explanation",
                "content": "There are three key things here\\n1. strictly greater [most important]\\n2. energy will be deducted always\\n3. exp will gain\\n\\nBased on the first key, we need to add additional 1 to guarantee `strictly greater`.\\nBased on the second key, we know that our initialEnergy will always be exhausted. Therefore, it is intuitive to sum them up. BUT!!! We only add it up when our initialEnergy failed to exhaust the energy cost.\\nLastly, this one is very straightforward in combat with the monster of the experience array. If exp[i] is great or equal to the initialExperience, we should add up the diff with an additional one. \\nThat\\'s all. Interesting question. Best.\\n\\n```cpp\\nint minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& exp) {\\n  int ans = 0, su=-initialEnergy+1;\\n  for (auto n: energy) su+=n;\\n  ans += su>0?su:0;\\n\\n  for (int i=0;i<exp.size()&&ie<100;i++) {\\n\\tif (exp[i]>=ie) {\\n\\t  ans+=exp[i]-ie+1;\\n\\t  ie=exp[i]+1;\\n\\t}\\n\\tie+=exp[i];\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& exp) {\\n  int ans = 0, su=-initialEnergy+1;\\n  for (auto n: energy) su+=n;\\n  ans += su>0?su:0;\\n\\n  for (int i=0;i<exp.size()&&ie<100;i++) {\\n\\tif (exp[i]>=ie) {\\n\\t  ans+=exp[i]-ie+1;\\n\\t  ie=exp[i]+1;\\n\\t}\\n\\tie+=exp[i];\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456615,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nHere, we can simply run a simulation to progressively check each energy and experience. If the current energy or experience value is not enough to win. Adjust the value and update the answer. \\n\\n**Analysis**\\nTime complexity O(N)\\nSpace complexity O(1) \\n```\\nclass Solution: \\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ans = 0 \\n        for x, y in zip(energy, experience): \\n            if initialEnergy <= x: \\n                ans += x + 1 - initialEnergy\\n                initialEnergy = x + 1\\n            if initialExperience <= y: \\n                ans += y + 1 - initialExperience\\n                initialExperience = y + 1\\n            initialEnergy -= x\\n            initialExperience += y \\n        return ans \\n```\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ans = 0 \\n        for x, y in zip(energy, experience): \\n            if initialEnergy <= x: \\n                ans += x + 1 - initialEnergy\\n                initialEnergy = x + 1\\n            if initialExperience <= y: \\n                ans += y + 1 - initialExperience\\n                initialExperience = y + 1\\n            initialEnergy -= x\\n            initialExperience += y \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456585,
                "title": "java-simplest-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int a, int b, int[] A, int[] B) {\\n        int maxA = 0;\\n        int maxB = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            maxA = Math.max(maxA, A[i]-a+1);\\n            maxB = Math.max(maxB, B[i]-b+1);\\n            a -= A[i];\\n            b += B[i];            \\n        }\\n        return maxA + maxB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int a, int b, int[] A, int[] B) {\\n        int maxA = 0;\\n        int maxB = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            maxA = Math.max(maxA, A[i]-a+1);\\n            maxB = Math.max(maxB, B[i]-b+1);\\n            a -= A[i];\\n            b += B[i];            \\n        }\\n        return maxA + maxB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348101,
                "title": "python-easy-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072049,
                "title": "c-simple-solution-plus-1-liner-linq-bonus-70ms-100",
                "content": "More intuitive for experience diff (code optimized below)\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = initialExperience - current;\\n\\n            diff = diff > 0 ? 0 : 1 - diff;\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\nwith some refactoring for diff\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience-current);\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\n# \"1-liner\" with Linq\\n(Not exactly pure 1-liner. Maybe Linq\\'s guru could turn it to true 1-liner)\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience - exp);\\n\\n            initialExperience += diff + exp;\\n\\n            return diff;\\n        });\\n}\\n```\\nThis is like true 1-liner if re-use optional diff=0 parameter in method\\'s singnature\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience, int diff = 0) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n         new {\\n            diffForSum = (diff = 1-Math.Min(1, initialExperience - exp)),\\n            _ = (initialExperience += diff + exp)\\n        }.diffForSum);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = initialExperience - current;\\n\\n            diff = diff > 0 ? 0 : 1 - diff;\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience-current);\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience - exp);\\n\\n            initialExperience += diff + exp;\\n\\n            return diff;\\n        });\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience, int diff = 0) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n         new {\\n            diffForSum = (diff = 1-Math.Min(1, initialExperience - exp)),\\n            _ = (initialExperience += diff + exp)\\n        }.diffForSum);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641714,
                "title": "calculate-energy-and-exp-hours-seperately",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iEn, int iEx, vector<int>& en, vector<int>& ex) {\\n        for(int i=1;i<en.size();i++){\\n            en[i] += en[i-1];\\n        }\\n        int EnHours = en[en.size()-1] - iEn+1;\\n        EnHours = (EnHours<0)?0:EnHours;\\n        int ExHours=0;\\n        for(int i=0;i<ex.size();){\\n            if(iEx > ex[i]){\\n                iEx += ex[i];\\n                i++;\\n            }else{\\n                ExHours += ex[i]-iEx+1;\\n                iEx = ex[i]+1;\\n            }\\n        }\\n        cout<<EnHours<<\" \"<<ExHours<<\" \";\\n        return EnHours + ExHours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iEn, int iEx, vector<int>& en, vector<int>& ex) {\\n        for(int i=1;i<en.size();i++){\\n            en[i] += en[i-1];\\n        }\\n        int EnHours = en[en.size()-1] - iEn+1;\\n        EnHours = (EnHours<0)?0:EnHours;\\n        int ExHours=0;\\n        for(int i=0;i<ex.size();){\\n            if(iEx > ex[i]){\\n                iEx += ex[i];\\n                i++;\\n            }else{\\n                ExHours += ex[i]-iEx+1;\\n                iEx = ex[i]+1;\\n            }\\n        }\\n        cout<<EnHours<<\" \"<<ExHours<<\" \";\\n        return EnHours + ExHours;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2641077,
                "title": "simple-python-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        N = len(energy)\\n        currEnergy, currExp = initialEnergy, initialExperience\\n        enNeeded, expNeeded = 0, 0\\n        for i in range(N):\\n            enNeeded = max(1 + energy[i] - currEnergy, enNeeded)\\n            expNeeded = max(1 + experience[i] - currExp, expNeeded)\\n            currEnergy -= energy[i]\\n            currExp += experience[i]\\n        return enNeeded + expNeeded\\n    # Time: O(n) where n is the length of energy\\n    # Space: O(1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        N = len(energy)\\n        currEnergy, currExp = initialEnergy, initialExperience\\n        enNeeded, expNeeded = 0, 0\\n        for i in range(N):\\n            enNeeded = max(1 + energy[i] - currEnergy, enNeeded)\\n            expNeeded = max(1 + experience[i] - currExp, expNeeded)\\n            currEnergy -= energy[i]\\n            currExp += experience[i]\\n        return enNeeded + expNeeded\\n    # Time: O(n) where n is the length of energy\\n    # Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630548,
                "title": "c-100-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2599533,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = energy[energy.length - 1] + 1;\\n        int exp = experience[energy.length - 1] + 1;\\n        for (int i = energy.length - 2; i >= 0; i--) {\\n            ene = ene + energy[i];\\n            exp = Math.max(exp - experience[i], experience[i] + 1);\\n        }\\n        return Math.max(ene - initialEnergy, 0) + Math.max(exp - initialExperience, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = energy[energy.length - 1] + 1;\\n        int exp = experience[energy.length - 1] + 1;\\n        for (int i = energy.length - 2; i >= 0; i--) {\\n            ene = ene + energy[i];\\n            exp = Math.max(exp - experience[i], experience[i] + 1);\\n        }\\n        return Math.max(ene - initialEnergy, 0) + Math.max(exp - initialExperience, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532842,
                "title": "java-iterative-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = initialEnergy;\\n        int exp = initialExperience;\\n        int res=0,diff=0;\\n        for (int i=0;i<energy.length;i++) {\\n            if (energy[i]>=ene) {   \\n                diff = energy[i]-ene+1;\\n                res = res+diff;\\n                ene = ene+diff;\\n            }\\n            ene = ene-energy[i];\\n            if (experience[i]>=exp) {\\n                diff = experience[i]-exp+1;\\n                res = res+diff;\\n                exp = exp+diff;\\n            }\\n            exp = exp+experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = initialEnergy;\\n        int exp = initialExperience;\\n        int res=0,diff=0;\\n        for (int i=0;i<energy.length;i++) {\\n            if (energy[i]>=ene) {   \\n                diff = energy[i]-ene+1;\\n                res = res+diff;\\n                ene = ene+diff;\\n            }\\n            ene = ene-energy[i];\\n            if (experience[i]>=exp) {\\n                diff = experience[i]-exp+1;\\n                res = res+diff;\\n                exp = exp+diff;\\n            }\\n            exp = exp+experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512273,
                "title": "basic-practice-linear-traversal-python",
                "content": "1- Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        res = 0\\n        cur_eng, cur_epe = initialEnergy, initialExperience\\n        \\n        for E, e in zip(energy, experience):\\n            if cur_eng < E + 1:\\n                res += E + 1 - cur_eng\\n                cur_eng = E + 1\\n            if cur_epe < e + 1:\\n                res += e + 1 - cur_epe\\n                cur_epe = e + 1\\n            cur_eng, cur_epe = cur_eng - E, cur_epe + e\\n        \\n        return res\\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/JaE7uegBikY;)\\n\\n3- Analysis\\n\\n\"\"\"\\nMethod: linear traversal\\n\\nIdea:\\n\\n- During the linear traversal, we check the cur_energy and cur_experience\\nwith the opponent_energy, opponent_experience\\n\\n- If the cur_engery > opponent_energy and cur_experience > oppenent_experience,\\nno training is needed.\\n- Else:\\n  the training hours needed are:\\n       if cur_energy < opponent_enery:  \\n          opponent_energy + 1 - cur_energy\\n          We can reset the cur_energy = opponent_energy + 1 after traning\\n       if cur_experience < opponent_experience:\\n          opponent_experience + 1 - cur_experience\\n          We can reset the cur_experience = opponent_experience + 1 after traning\\n\\n  As we have done the reset, after beating current opponent, the energy and experience\\n  before meeting next opponent are:\\n        cur_energy - current opponent_energy\\n        cur_experience + current opponent_experience.\\n        \\n        \\nWalkthrough\\n\\ninitialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\\n\\nBefore beat opponent 0: cur_energy 5, cur_epe 3, res: 0\\nAfter beat opponent 0: cur_energy 4, cur_epe 5, res: 0\\n\\nBefore beat opponent 1: cur_energy 4, cur_epe 5, res: 0\\nAfter beat opponent 1: cur_energy 1, cur_epe 13, res: 3\\n\\nBefore beat opponent 2: cur_energy 1, cur_epe 13, res: 3\\nAfter beat opponent 2: cur_energy 1, cur_epe 16, res: 6\\n\\nBefore beat opponent 3: cur_energy 1, cur_epe 16, res: 6\\nAfter beat opponent 3: cur_energy 1, cur_epe 17, res: 8\\n    \\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        res = 0\\n        cur_eng, cur_epe = initialEnergy, initialExperience\\n        \\n        for E, e in zip(energy, experience):\\n            if cur_eng < E + 1:\\n                res += E + 1 - cur_eng\\n                cur_eng = E + 1\\n            if cur_epe < e + 1:\\n                res += e + 1 - cur_epe\\n                cur_epe = e + 1\\n            cur_eng, cur_epe = cur_eng - E, cur_epe + e\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510651,
                "title": "c-solution-easy-to-understand",
                "content": "{\\n        int hours=0,p=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            hours = energy[i] + hours; \\n        }\\n        hours = hours-initialEnergy+1;\\n        if(hours<0)\\n        {hours=0;}\\n        while(p<energy.size())\\n        {\\n            if(initialExperience<=experience[p])\\n            {\\n                int diff=experience[p]-initialExperience+1;\\n                hours += diff;\\n                initialExperience+= diff;\\n            }\\n            initialExperience=initialExperience+experience[p];\\n            p++;\\n        }\\n        return hours;\\n    }",
                "solutionTags": [],
                "code": "{\\n        int hours=0,p=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            hours = energy[i] + hours; \\n        }\\n        hours = hours-initialEnergy+1;\\n        if(hours<0)\\n        {hours=0;}\\n        while(p<energy.size())\\n        {\\n            if(initialExperience<=experience[p])\\n            {\\n                int diff=experience[p]-initialExperience+1;\\n                hours += diff;\\n                initialExperience+= diff;\\n            }\\n            initialExperience=initialExperience+experience[p];\\n            p++;\\n        }\\n        return hours;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2508105,
                "title": "2383-minimum-hours-of-training-to-win-a-competition",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        t=0\\n        e=0\\n        exp=0\\n        if sum(energy)>=initialEnergy:\\n            e=sum(energy)-initialEnergy+1\\n        else:\\n            e=0\\n        #e=e-initialEnergy\\n        #print(e)\\n        for i in range(len(experience)):\\n            if experience[i]>=initialExperience:\\n                exp+=experience[i]-initialExperience+1\\n                initialExperience=experience[i]+1\\n            initialExperience+=experience[i]\\n        #print(exp)\\n        t=e+exp\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        t=0\\n        e=0\\n        exp=0\\n        if sum(energy)>=initialEnergy:\\n            e=sum(energy)-initialEnergy+1\\n        else:\\n            e=0\\n        #e=e-initialEnergy\\n        #print(e)\\n        for i in range(len(experience)):\\n            if experience[i]>=initialExperience:\\n                exp+=experience[i]-initialExperience+1\\n                initialExperience=experience[i]+1\\n            initialExperience+=experience[i]\\n        #print(exp)\\n        t=e+exp\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497519,
                "title": "simple-python-solution-full-explanation",
                "content": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \"\"\"\\n        This function calculates the minimum number of training hours required for \\n        the outcome. The function first initialises the required_energy at 0, after \\n        which the energy requirement is calculated, relative to initialEnergy. The\\n        player must end with positive energy, hence the +1. After this, the\\n        experience component is handled, by evaluating and modifying the\\n        initialExperience inplace, based on the experience values required. If\\n        the player cannot win, the required_experience is added as the experience\\n        required minus the initialExperience, the initialExperience is then modified \\n        inplace to reflect this requirement.\\n        \\n        :param initialEnergy: the energy of the player. (int)\\n        :param initialExperience: the experience of the player. (int)\\n        :param energy: the energy profiles of the other players. (List[int])\\n        :param experience: the experience profiles of the other players. (List[int])\\n        :return: the required training time. (int)\\n        \"\"\"\\n        required_experience = 0\\n        if sum(energy) >= initialEnergy:\\n            required_energy = sum(energy) - initialEnergy + 1\\n        else:\\n            required_energy = 0\\n            \\n        for i in range(len(experience)):\\n            if initialExperience > experience[i]:\\n                initialExperience += experience[i]\\n            else:\\n                required_experience += (experience[i] - initialExperience + 1)\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i]\\n        return (required_energy + required_experience)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \"\"\"\\n        This function calculates the minimum number of training hours required for \\n        the outcome. The function first initialises the required_energy at 0, after \\n        which the energy requirement is calculated, relative to initialEnergy. The\\n        player must end with positive energy, hence the +1. After this, the\\n        experience component is handled, by evaluating and modifying the\\n        initialExperience inplace, based on the experience values required. If\\n        the player cannot win, the required_experience is added as the experience\\n        required minus the initialExperience, the initialExperience is then modified \\n        inplace to reflect this requirement.\\n        \\n        :param initialEnergy: the energy of the player. (int)\\n        :param initialExperience: the experience of the player. (int)\\n        :param energy: the energy profiles of the other players. (List[int])\\n        :param experience: the experience profiles of the other players. (List[int])\\n        :return: the required training time. (int)\\n        \"\"\"\\n        required_experience = 0\\n        if sum(energy) >= initialEnergy:\\n            required_energy = sum(energy) - initialEnergy + 1\\n        else:\\n            required_energy = 0\\n            \\n        for i in range(len(experience)):\\n            if initialExperience > experience[i]:\\n                initialExperience += experience[i]\\n            else:\\n                required_experience += (experience[i] - initialExperience + 1)\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i]\\n        return (required_energy + required_experience)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2490725,
                "title": "java-hand-written-explaination-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/491f7c03-2a26-4362-9757-26600e21b398_1661612155.9461555.jpeg)\\n```\\n\\t\\t\\nint n=energy.length;\\n        int ene=initialEnergy;\\n        int exp=initialExperience;\\n        int c=0,i=0;\\n        while(i<n){\\n            if(exp>experience[i] && ene>energy[i]){\\n                exp=exp+experience[i];\\n                ene=ene-energy[i];\\n                i++;\\n            }\\n            else{\\n                if(exp<=experience[i]){\\n                    c++;\\n                    exp++;\\n                }\\n                if(ene<=energy[i]){\\n                    c++;\\n                    ene++;\\n                }\\n            }\\n        }\\n        return c;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\nint n=energy.length;\\n        int ene=initialEnergy;\\n        int exp=initialExperience;\\n        int c=0,i=0;\\n        while(i<n){\\n            if(exp>experience[i] && ene>energy[i]){\\n                exp=exp+experience[i];\\n                ene=ene-energy[i];\\n                i++;\\n            }\\n            else{\\n                if(exp<=experience[i]){\\n                    c++;\\n                    exp++;\\n                }\\n                if(ene<=energy[i]){\\n                    c++;\\n                    ene++;\\n                }\\n            }\\n        }\\n        return c;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484839,
                "title": "kotlin-python-lazy-training",
                "content": "Kotlin\\n```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        var training = 0\\n        var curEn = initialEnergy\\n        var curEx = initialExperience\\n        for ((en, ex) in (energy zip experience)) {\\n            if (curEn <= en) {\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            }\\n            if (curEx <= ex) {\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            }\\n            curEn -= en\\n            curEx += ex\\n        }\\n        return training\\n    }\\n}\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        training = 0\\n        curEn = initialEnergy\\n        curEx = initialExperience\\n        for en, ex in zip(energy, experience):\\n            if curEn <= en:\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            \\n            if curEx <= ex:\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            \\n            curEn -= en\\n            curEx += ex\\n        return training\\n```",
                "solutionTags": [
                    "Python",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        var training = 0\\n        var curEn = initialEnergy\\n        var curEx = initialExperience\\n        for ((en, ex) in (energy zip experience)) {\\n            if (curEn <= en) {\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            }\\n            if (curEx <= ex) {\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            }\\n            curEn -= en\\n            curEx += ex\\n        }\\n        return training\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        training = 0\\n        curEn = initialEnergy\\n        curEx = initialExperience\\n        for en, ex in zip(energy, experience):\\n            if curEn <= en:\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            \\n            if curEx <= ex:\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            \\n            curEn -= en\\n            curEx += ex\\n        return training\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482454,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ix,vector<int>& en, vector<int>& ex) {\\n        int n=en.size();\\n        int val=0; //total hours needed\\n        for(int i=0;i<n;i++){\\n            if(en[i]>=ie){\\n                val+=en[i]-ie+1; // adding additional hours in energy\\n                ie+=en[i]-ie+1;\\n            }\\n            if(ex[i]>=ix){\\n                val+=ex[i]-ix+1; // adding additional hours in experience\\n                ix+=ex[i]-ix+1;\\n            }\\n            ie-=en[i];\\n            ix+=ex[i];\\n            \\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ix,vector<int>& en, vector<int>& ex) {\\n        int n=en.size();\\n        int val=0; //total hours needed\\n        for(int i=0;i<n;i++){\\n            if(en[i]>=ie){\\n                val+=en[i]-ie+1; // adding additional hours in energy\\n                ie+=en[i]-ie+1;\\n            }\\n            if(ex[i]>=ix){\\n                val+=ex[i]-ix+1; // adding additional hours in experience\\n                ix+=ex[i]-ix+1;\\n            }\\n            ie-=en[i];\\n            ix+=ex[i];\\n            \\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480239,
                "title": "the-easiest-and-concise-o-n-solution-beats-100",
                "content": "**Code:-**\\n\\n```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n    {\\n        int count=0;\\n        for (int i = 0; i < energy.length; i++)\\n        {\\n            if (initialExperience <= experience[i])\\n            {\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;     // if current experience < required experience, then we first bridge the gap and make the current experience more than the required experience      \\n            }\\n            initialEnergy-= energy[i];     // decrementing energy           \\n            initialExperience+= experience[i];     // incrementing experience\\n        }\\n        if (initialEnergy < 1)\\n            count+= 1-initialEnergy;     // if energy is still greater than 0, then no need of training \\n        return count;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n    {\\n        int count=0;\\n        for (int i = 0; i < energy.length; i++)\\n        {\\n            if (initialExperience <= experience[i])\\n            {\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;     // if current experience < required experience, then we first bridge the gap and make the current experience more than the required experience      \\n            }\\n            initialEnergy-= energy[i];     // decrementing energy           \\n            initialExperience+= experience[i];     // incrementing experience\\n        }\\n        if (initialEnergy < 1)\\n            count+= 1-initialEnergy;     // if energy is still greater than 0, then no need of training \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479755,
                "title": "javascript-faster-than-100-memory-less-than-100",
                "content": "```\\nvar minNumberOfHours = function(power, knowledge, energy, experience) {\\n    let hours = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (power <= energy[i] || knowledge <= experience[i]) {\\n            while (power <= energy[i]) {\\n                power++;\\n                hours++;\\n            } while (knowledge <= experience[i]) {\\n                knowledge++;\\n                hours++;\\n            }\\n        } if (power > energy[i] && knowledge > experience[i]) {\\n            power -= energy[i]\\n            knowledge += experience[i]\\n        }\\n    } return hours\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3685a266-8f80-4a6f-bc3d-19195d9c21ab_1661448842.9609663.png)",
                "solutionTags": [],
                "code": "```\\nvar minNumberOfHours = function(power, knowledge, energy, experience) {\\n    let hours = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (power <= energy[i] || knowledge <= experience[i]) {\\n            while (power <= energy[i]) {\\n                power++;\\n                hours++;\\n            } while (knowledge <= experience[i]) {\\n                knowledge++;\\n                hours++;\\n            }\\n        } if (power > energy[i] && knowledge > experience[i]) {\\n            power -= energy[i]\\n            knowledge += experience[i]\\n        }\\n    } return hours\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464029,
                "title": "javascript-solution",
                "content": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let count = 0\\n    for (let i=0; i<energy.length; i++) {\\n        if (energy[i]>=initialEnergy) {\\n            count+=energy[i]-initialEnergy+1\\n            initialEnergy = 1\\n        } else {\\n            initialEnergy -= energy[i]\\n        } \\n        if (experience[i]<initialExperience) {\\n            initialExperience += experience[i]\\n        } else {\\n            count+=experience[i]-initialExperience+1\\n            initialExperience += experience[i]+experience[i]-initialExperience+1       \\n        }\\n       \\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let count = 0\\n    for (let i=0; i<energy.length; i++) {\\n        if (energy[i]>=initialEnergy) {\\n            count+=energy[i]-initialEnergy+1\\n            initialEnergy = 1\\n        } else {\\n            initialEnergy -= energy[i]\\n        } \\n        if (experience[i]<initialExperience) {\\n            initialExperience += experience[i]\\n        } else {\\n            count+=experience[i]-initialExperience+1\\n            initialExperience += experience[i]+experience[i]-initialExperience+1       \\n        }\\n       \\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459112,
                "title": "time-o-n-space-o-1-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ene, int exp, vector<int>& a, vector<int>& b) {\\n        //calculating energy\\n        int energy;\\n        for(auto it:a)\\n            ene-=it;\\n        energy=(ene>0)?0:abs(ene)+1;\\n        \\n        //calculating exp\\n        int experience =0;\\n        for(auto it:b)\\n            if(exp>it)exp+=it;\\n            else experience +=it-exp+1,exp+=it+experience ;\\n        \\n        return energy+experience ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ene, int exp, vector<int>& a, vector<int>& b) {\\n        //calculating energy\\n        int energy;\\n        for(auto it:a)\\n            ene-=it;\\n        energy=(ene>0)?0:abs(ene)+1;\\n        \\n        //calculating exp\\n        int experience =0;\\n        for(auto it:b)\\n            if(exp>it)exp+=it;\\n            else experience +=it-exp+1,exp+=it+experience ;\\n        \\n        return energy+experience ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458414,
                "title": "easy-to-understand-python-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/947cdd5a-5dd0-487e-b98e-364b937a6be9_1661076362.0836651.png)\\n\\n...\\nclass Solution:\\n\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        #Base Case\\n        if sum(energy) < initialEnergy and sum(experience) < initialExperience:\\n            return 0\\n        \\n        \\n        z = []\\n        count = 0\\n        y = 0\\n        \\n        # initial check\\n        z.append(initialExperience)\\n        if z[0] < experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + z[0]\\n            \\n            \\n        if z[0] == experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + experience[0]\\n            \\n\\n        z[0] = z[0]+experience[0]\\n        \\n\\n        if len(experience)==1 and sum(energy) < initialEnergy:\\n            return y\\n\\n        \\n        # number of hours to get sufficient experience   \\n        for i in range(1,len(experience)):\\n            if z[0] < experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] = t + z[0]\\n                \\n            if z[0] == experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] =t + experience[1]\\n            \\n            z[0] = z[0]+experience[i]\\n            \\n            \\n        \\n        # calculating number of hours to fulfill energy requirement \\n        x = sum(energy) - initialEnergy + 1\\n        \\n        # returning total number of hours\\n        return x+y\\n\\t\\t\\n...",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/947cdd5a-5dd0-487e-b98e-364b937a6be9_1661076362.0836651.png)\\n\\n...\\nclass Solution:\\n\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        #Base Case\\n        if sum(energy) < initialEnergy and sum(experience) < initialExperience:\\n            return 0\\n        \\n        \\n        z = []\\n        count = 0\\n        y = 0\\n        \\n        # initial check\\n        z.append(initialExperience)\\n        if z[0] < experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + z[0]\\n            \\n            \\n        if z[0] == experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + experience[0]\\n            \\n\\n        z[0] = z[0]+experience[0]\\n        \\n\\n        if len(experience)==1 and sum(energy) < initialEnergy:\\n            return y\\n\\n        \\n        # number of hours to get sufficient experience   \\n        for i in range(1,len(experience)):\\n            if z[0] < experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] = t + z[0]\\n                \\n            if z[0] == experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] =t + experience[1]\\n            \\n            z[0] = z[0]+experience[i]\\n            \\n            \\n        \\n        # calculating number of hours to fulfill energy requirement \\n        x = sum(energy) - initialEnergy + 1\\n        \\n        # returning total number of hours\\n        return x+y\\n\\t\\t\\n...",
                "codeTag": "Java"
            },
            {
                "id": 2458169,
                "title": "cpp-simple-solution",
                "content": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int energyHour = 0;\\n        int expHour = 0;\\n        for(int i = 0; i < energy.size(); i++)\\n        {\\n            int diffEnergy = abs(initialEnergy - energy[i]);\\n            if(initialEnergy - energy[i] < 1)\\n            {\\n                initialEnergy += diffEnergy + 1 - energy[i];\\n                energyHour += diffEnergy + 1;\\n                diffEnergy = 0;\\n            }\\n            else\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            int diffExp = abs(initialExperience - experience[i]);\\n            if(initialExperience - experience[i] < 1)\\n            {\\n                initialExperience += experience[i] + diffExp + 1;\\n                expHour += diffExp + 1;\\n                diffExp = 0;\\n            }\\n            else\\n            {\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return expHour + energyHour;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int energyHour = 0;\\n        int expHour = 0;\\n        for(int i = 0; i < energy.size(); i++)\\n        {\\n            int diffEnergy = abs(initialEnergy - energy[i]);\\n            if(initialEnergy - energy[i] < 1)\\n            {\\n                initialEnergy += diffEnergy + 1 - energy[i];\\n                energyHour += diffEnergy + 1;\\n                diffEnergy = 0;\\n            }\\n            else\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            int diffExp = abs(initialExperience - experience[i]);\\n            if(initialExperience - experience[i] < 1)\\n            {\\n                initialExperience += experience[i] + diffExp + 1;\\n                expHour += diffExp + 1;\\n                diffExp = 0;\\n            }\\n            else\\n            {\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return expHour + energyHour;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458079,
                "title": "java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        \\n        int hrs=0;\\n\\n         int sumEne=0;\\n\\n         for(int x:energy){\\n             sumEne+=x;\\n         }\\n\\n     \\n        if(sumEne>=initialEnergy) {\\n            hrs = sumEne - initialEnergy + 1;\\n        }\\n\\n\\n        int tempHrs=0;\\n\\t\\t\\n         for(int i=0;i<experience.length;i++){\\n\\n             if(initialExperience<=experience[i]){\\n\\n                 tempHrs+=experience[i]-initialExperience+1;\\n                 initialExperience+=experience[i]+tempHrs;\\n             }else{\\n                 initialExperience+=experience[i];\\n             }\\n         }\\n        \\n        return hrs+tempHrs;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        \\n        int hrs=0;\\n\\n         int sumEne=0;\\n\\n         for(int x:energy){\\n             sumEne+=x;\\n         }\\n\\n     \\n        if(sumEne>=initialEnergy) {\\n            hrs = sumEne - initialEnergy + 1;\\n        }\\n\\n\\n        int tempHrs=0;\\n\\t\\t\\n         for(int i=0;i<experience.length;i++){\\n\\n             if(initialExperience<=experience[i]){\\n\\n                 tempHrs+=experience[i]-initialExperience+1;\\n                 initialExperience+=experience[i]+tempHrs;\\n             }else{\\n                 initialExperience+=experience[i];\\n             }\\n         }\\n        \\n        return hrs+tempHrs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458037,
                "title": "leetcode-the-hard-way-solution-with-explaination",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            // if initialEnergy is not enough, then we need to add some training hours\\n            if (initialEnergy <= energy[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = energy[i] - initialEnergy + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain energy\\n                initialEnergy += need;\\n            }\\n            // similarly for experience\\n            // if initialExperience is not enough, then we need to add some training hours\\n            if (initialExperience <= experience[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = experience[i] - initialExperience + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain experience\\n                initialExperience += need;\\n            }\\n            // start a competition\\n            // increases your experience by experience[i]\\n            initialEnergy -= energy[i];\\n            // and decreases your energy by energy[i]\\n            initialExperience += experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            // if initialEnergy is not enough, then we need to add some training hours\\n            if (initialEnergy <= energy[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = energy[i] - initialEnergy + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain energy\\n                initialEnergy += need;\\n            }\\n            // similarly for experience\\n            // if initialExperience is not enough, then we need to add some training hours\\n            if (initialExperience <= experience[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = experience[i] - initialExperience + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain experience\\n                initialExperience += need;\\n            }\\n            // start a competition\\n            // increases your experience by experience[i]\\n            initialEnergy -= energy[i];\\n            // and decreases your energy by energy[i]\\n            initialExperience += experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457856,
                "title": "easy-python-solution",
                "content": "```\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        energyHours = max(0, sum(energy) - initialEnergy + 1)\\n        \\n        experHours = max(0, experience[0] + 1 - initialExperience)\\n        preSum = experience[0] + initialExperience\\n        \\n        for i in range(1, len(experience)):\\n            experHours = max(experHours, 1 + experience[i] - preSum)\\n            preSum += experience[i]\\n            \\n        return energyHours + experHours\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        energyHours = max(0, sum(energy) - initialEnergy + 1)\\n        \\n        experHours = max(0, experience[0] + 1 - initialExperience)\\n        preSum = experience[0] + initialExperience\\n        \\n        for i in range(1, len(experience)):\\n            experHours = max(experHours, 1 + experience[i] - preSum)\\n            preSum += experience[i]\\n            \\n        return energyHours + experHours\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2457787,
                "title": "java-solution-o-n",
                "content": "### ***Please Upvote !!!***\\n#### Weekly Contest 307\\n##### (21 August, 2022)\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int n = energy.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (initialEnergy <= energy[i]) {\\n                int tempEnergy = energy[i] + 1 - initialEnergy;\\n                ans += tempEnergy;\\n                initialEnergy += tempEnergy;\\n            }\\n            \\n            if (initialExperience <= experience[i]) {\\n                int tempExperience = experience[i] + 1 - initialExperience;\\n                ans += tempExperience;\\n                initialExperience += tempExperience;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int n = energy.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (initialEnergy <= energy[i]) {\\n                int tempEnergy = energy[i] + 1 - initialEnergy;\\n                ans += tempEnergy;\\n                initialEnergy += tempEnergy;\\n            }\\n            \\n            if (initialExperience <= experience[i]) {\\n                int tempExperience = experience[i] + 1 - initialExperience;\\n                ans += tempExperience;\\n                initialExperience += tempExperience;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457728,
                "title": "java-easy-faster-than-100",
                "content": "```\\n\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int sum = 0, exp =0;\\n        \\n        for(int n : energy){\\n            sum += n;  //total energy \\n        }\\n           int totalEnergy = (initialEnergy>sum) ? 0: (sum-initialEnergy) + 1 ; //total energy required\\n              \\n        for(int n : experience){\\n            if(initialExperience > n){\\n                initialExperience += n;\\n            } else{\\n                exp += (n - initialExperience) + 1; //exp holds additional experience required for particular itertion\\n                initialExperience += exp+n;  //upadate initial experience for next iteration\\n            }\\n        }\\n        return totalEnergy + exp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int sum = 0, exp =0;\\n        \\n        for(int n : energy){\\n            sum += n;  //total energy \\n        }\\n           int totalEnergy = (initialEnergy>sum) ? 0: (sum-initialEnergy) + 1 ; //total energy required\\n              \\n        for(int n : experience){\\n            if(initialExperience > n){\\n                initialExperience += n;\\n            } else{\\n                exp += (n - initialExperience) + 1; //exp holds additional experience required for particular itertion\\n                initialExperience += exp+n;  //upadate initial experience for next iteration\\n            }\\n        }\\n        return totalEnergy + exp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457598,
                "title": "easy-to-understand-100-faster-solution-o-n-approach",
                "content": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= experience.size();\\n        int count =0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int diff = energy[i]-initialEnergy;\\n                initialEnergy += diff+1;\\n                count += diff+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int diff = experience[i]-initialExperience;\\n                initialExperience += diff+1;\\n                count += diff+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= experience.size();\\n        int count =0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int diff = energy[i]-initialEnergy;\\n                initialEnergy += diff+1;\\n                count += diff+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457248,
                "title": "easy-efficient-solution-with-explanation-100-faster",
                "content": "* **Approach :**\\n\\t* There are three cases for this problem -\\n\\t\\ti) Training for Energy gain.\\n\\t\\tii) Traing for Experience gain.\\n\\t\\tiii) Defeating the opponents\\n\\t* For case - i :\\n\\t\\t* Training hours required, hours += energy[i] - initialEnergy + 1\\n\\t\\t* Energy gained, initialEnergy +=  .energy[i] - initialEnergy + 1\\n\\t* For case - ii :\\n\\t\\t* Training hours required, hours += experience[i] - initialExperience + 1\\n\\t\\t* Experience gained, initialExperience += experience[i] - initialExperience + 1\\n\\t* For case - iii :\\n\\t\\t* Experience will increase, initialExperience += experience[i]\\n\\t\\t* Energy will decrease, initialEnergy -= energy[i]\\n\\t* Finally return the ans (hours).\\n\\n* **Code :**\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        int hours = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            // Case : 1\\n            if(initialEnergy <= energy[i])\\n            {\\n                hours += energy[i] - initialEnergy + 1;\\n                initialEnergy += energy[i] - initialEnergy + 1;\\n            }    \\n            \\n            // Case : 2\\n            if(initialExperience <= experience[i])\\n            {\\n                hours += experience[i] - initialExperience + 1;\\n                initialExperience += experience[i] - initialExperience + 1;\\n            }\\n            \\n            // Case : 3\\n            initialExperience += experience[i] ;\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n```\\n\\n* **Complexity Analysis :**\\n\\t* Time Complexity : O(n)\\n\\t* Space Complexity : O(1)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        int hours = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            // Case : 1\\n            if(initialEnergy <= energy[i])\\n            {\\n                hours += energy[i] - initialEnergy + 1;\\n                initialEnergy += energy[i] - initialEnergy + 1;\\n            }    \\n            \\n            // Case : 2\\n            if(initialExperience <= experience[i])\\n            {\\n                hours += experience[i] - initialExperience + 1;\\n                initialExperience += experience[i] - initialExperience + 1;\\n            }\\n            \\n            // Case : 3\\n            initialExperience += experience[i] ;\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457232,
                "title": "o-n-approach-c-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n=energy.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int dif=energy[i]-initialEnergy;\\n                initialEnergy+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int dif=experience[i]-initialExperience;\\n                initialExperience+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n=energy.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int dif=energy[i]-initialEnergy;\\n                initialEnergy+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int dif=experience[i]-initialExperience;\\n                initialExperience+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457188,
                "title": "c-easy-simple-and-fast-code-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        int sum=0 ;\\n        int reqEnergy=1;\\n        for(int i=0 ; i<n ; i++){\\n            int temp=experience[i];\\n            experience[i]=experience[i]-sum;\\n            sum+=temp;\\n            reqEnergy+=energy[i];\\n        }\\n        int ans1=0;\\n        if(reqEnergy>initialEnergy){\\n            ans1=reqEnergy-initialEnergy;\\n        }\\n        else{\\n            ans1=0;\\n        }\\n        // cout<<reqEnergy;\\n        \\n        sum=*max_element(experience.begin(),experience.end())+1;\\n        \\n        if(sum>=initialExperience){\\n            sum=sum-initialExperience;\\n        }\\n        else{\\n            sum=0;\\n        }\\n        \\n        int ans=ans1+sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        int sum=0 ;\\n        int reqEnergy=1;\\n        for(int i=0 ; i<n ; i++){\\n            int temp=experience[i];\\n            experience[i]=experience[i]-sum;\\n            sum+=temp;\\n            reqEnergy+=energy[i];\\n        }\\n        int ans1=0;\\n        if(reqEnergy>initialEnergy){\\n            ans1=reqEnergy-initialEnergy;\\n        }\\n        else{\\n            ans1=0;\\n        }\\n        // cout<<reqEnergy;\\n        \\n        sum=*max_element(experience.begin(),experience.end())+1;\\n        \\n        if(sum>=initialExperience){\\n            sum=sum-initialExperience;\\n        }\\n        else{\\n            sum=0;\\n        }\\n        \\n        int ans=ans1+sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457125,
                "title": "c-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int p=0,q=0;\\n        int curr=initialExperience;\\n        for(auto x:energy)\\n            p+=x;\\n        for(int i=0;i<experience.size();i++)\\n        {\\n            if(curr<=experience[i])\\n            {\\n                q+=experience[i]-curr+1;\\n                curr=experience[i]+1;\\n            }\\n            curr+=experience[i];\\n        }\\n        if(p>=initialEnergy)\\n            p=p-initialEnergy+1;\\n        else\\n            p=0;\\n        \\n        int res=0;\\n        if(p>0)\\n            res+=p;\\n        if(q>0)\\n            res+=q;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int p=0,q=0;\\n        int curr=initialExperience;\\n        for(auto x:energy)\\n            p+=x;\\n        for(int i=0;i<experience.size();i++)\\n        {\\n            if(curr<=experience[i])\\n            {\\n                q+=experience[i]-curr+1;\\n                curr=experience[i]+1;\\n            }\\n            curr+=experience[i];\\n        }\\n        if(p>=initialEnergy)\\n            p=p-initialEnergy+1;\\n        else\\n            p=0;\\n        \\n        int res=0;\\n        if(p>0)\\n            res+=p;\\n        if(q>0)\\n            res+=q;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456845,
                "title": "easy-beginners-solutions-explained-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int TotalEnemyEnergy=0 , myExp=initialExperience , expTraining=0;\\n        \\n        for(int e:energy) TotalEnemyEnergy += e;  //total energy required to defeat enemy.\\n        \\n        //for experience training.\\n        for(int i=0;i<experience.size();i++){  //check enemies in order.\\n            if(myExp<=experience[i]){  //if training required to fight ith enemy.\\n                expTraining += experience[i] - myExp + 1;  //calculate how much to train.\\n                myExp += expTraining;  //increase exp after training.\\n            }\\n            myExp += experience[i];  //increase exp after defeating enemy.\\n        }\\n        if(initialEnergy>TotalEnemyEnergy) return expTraining;//iniatially energy is more than enough..check training required only for exp. \\n        return (TotalEnemyEnergy-initialEnergy+1 + expTraining);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int TotalEnemyEnergy=0 , myExp=initialExperience , expTraining=0;\\n        \\n        for(int e:energy) TotalEnemyEnergy += e;  //total energy required to defeat enemy.\\n        \\n        //for experience training.\\n        for(int i=0;i<experience.size();i++){  //check enemies in order.\\n            if(myExp<=experience[i]){  //if training required to fight ith enemy.\\n                expTraining += experience[i] - myExp + 1;  //calculate how much to train.\\n                myExp += expTraining;  //increase exp after training.\\n            }\\n            myExp += experience[i];  //increase exp after defeating enemy.\\n        }\\n        if(initialEnergy>TotalEnemyEnergy) return expTraining;//iniatially energy is more than enough..check training required only for exp. \\n        return (TotalEnemyEnergy-initialEnergy+1 + expTraining);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456821,
                "title": "binary-search-sol",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int exp, vector<int> &ene) {\\n        for (auto i: ene) {\\n            if (i >= exp) {\\n                return false;\\n            } else {\\n                exp += i;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minNumberOfHours(int initialEnergy, int exp, vector<int>& energy, vector<int>& experience) {\\n        int ans = 0;\\n        for (auto &x: energy) {\\n            ans += x;\\n        }\\n        ans = max(0, ans + 1 - initialEnergy);\\n        \\n        int lo = 0, hi = 100000, mid;\\n        \\n        while (lo < hi) {\\n            mid = (lo + hi) >> 1;\\n            if (check(mid + exp, experience)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans + lo;\\n    }\\n};\\n```\\n\\nspent too much time on question 1 so directly doing binary search sol.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int exp, vector<int> &ene) {\\n        for (auto i: ene) {\\n            if (i >= exp) {\\n                return false;\\n            } else {\\n                exp += i;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minNumberOfHours(int initialEnergy, int exp, vector<int>& energy, vector<int>& experience) {\\n        int ans = 0;\\n        for (auto &x: energy) {\\n            ans += x;\\n        }\\n        ans = max(0, ans + 1 - initialEnergy);\\n        \\n        int lo = 0, hi = 100000, mid;\\n        \\n        while (lo < hi) {\\n            mid = (lo + hi) >> 1;\\n            if (check(mid + exp, experience)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans + lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456761,
                "title": "c",
                "content": "```\\npublic class Solution\\n    {\\n        public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n        {\\n            var result = 0;\\n            for (int index = 0; index < energy.Length; index++)\\n            {\\n                if (initialEnergy <= energy[index])\\n                {\\n                    var minVal = energy[index] + 1 - initialEnergy;\\n                    result += minVal;\\n                    initialEnergy += minVal;\\n                }\\n                initialEnergy -= energy[index];\\n                if (initialExperience <= experience[index])\\n                {\\n                    var minVal = experience[index] + 1 - initialExperience;\\n                    result += minVal;\\n                    initialExperience += minVal;\\n                }\\n                initialExperience += experience[index];\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n        {\\n            var result = 0;\\n            for (int index = 0; index < energy.Length; index++)\\n            {\\n                if (initialEnergy <= energy[index])\\n                {\\n                    var minVal = energy[index] + 1 - initialEnergy;\\n                    result += minVal;\\n                    initialEnergy += minVal;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2456681,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int enSum = 0;\\n        for(int en : energy) {\\n            enSum += en;\\n        }\\n        int ans1 = enSum >= initialEnergy ? Math.abs(enSum - initialEnergy) + 1 : 0;\\n        int ans2 = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(initialExperience <= experience[i]) {\\n                ans2 += (experience[i] - initialExperience) + 1;\\n                initialExperience += (ans2 + experience[i]);\\n            }\\n            else {\\n                initialExperience += experience[i];\\n            }\\n            \\n            System.out.println(initialExperience);\\n        }\\n        System.out.println(ans1 + \" \" + ans2);\\n        return ans1 + ans2;\\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int enSum = 0;\\n        for(int en : energy) {\\n            enSum += en;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456671,
                "title": "java-o-n-easy",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res = 0, n = energy.length, sum=0;\\n        for(int i=0; i<n-1; i++){\\n            sum+=energy[i];\\n        }\\n        res+=Math.max(0, energy[n-1]+1+sum-initialEnergy);\\n        for(int i=0; i<n; i++){\\n            if(experience[i]>=initialExperience){\\n                res += experience[i]+1-initialExperience;\\n                initialExperience = experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res = 0, n = energy.length, sum=0;\\n        for(int i=0; i<n-1; i++){\\n            sum+=energy[i];\\n        }\\n        res+=Math.max(0, energy[n-1]+1+sum-initialEnergy);\\n        for(int i=0; i<n; i++){\\n            if(experience[i]>=initialExperience){\\n                res += experience[i]+1-initialExperience;\\n                initialExperience = experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456643,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>&numse, vector<int>& numsx)\\n    {\\n        int n=numse.size();\\n        int val1=ini;\\n        int count1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numse[i]>=val1)\\n            {\\n                count1+=(numse[i]-val1+1);\\n                val1+=(numse[i]-val1+1);\\n            }\\n            val1-=numse[i];\\n        }\\n         int val2=ie;\\n        int count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numsx[i]>=val2)\\n            {\\n                count2+=(numsx[i]-val2+1);\\n                val2+=(count2);\\n            }\\n            val2+=numsx[i];\\n        }\\n        // cout<<count1<<\" \"<<count2<<endl;\\n        return count1+count2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>&numse, vector<int>& numsx)\\n    {\\n        int n=numse.size();\\n        int val1=ini;\\n        int count1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numse[i]>=val1)\\n            {\\n                count1+=(numse[i]-val1+1);\\n                val1+=(numse[i]-val1+1);\\n            }\\n            val1-=numse[i];\\n        }\\n         int val2=ie;\\n        int count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numsx[i]>=val2)\\n            {\\n                count2+=(numsx[i]-val2+1);\\n                val2+=(count2);\\n            }\\n            val2+=numsx[i];\\n        }\\n        // cout<<count1<<\" \"<<count2<<endl;\\n        return count1+count2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4090441,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        return max(sum(energy)-initialEnergy+1, 0) + max(max(map(sub, experience, accumulate(experience, initial= initialExperience)))+1, 0)      \\n```\\n> More readable\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        cnt, max_cnt = initialExperience, 0\\n        for e in experience:\\n            max_cnt = max(e-cnt+1, max_cnt)\\n            cnt += e\\n        return max(sum(energy)-initialEnergy+1, 0) + max_cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        return max(sum(energy)-initialEnergy+1, 0) + max(max(map(sub, experience, accumulate(experience, initial= initialExperience)))+1, 0)      \\n```\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        cnt, max_cnt = initialExperience, 0\\n        for e in experience:\\n            max_cnt = max(e-cnt+1, max_cnt)\\n            cnt += e\\n        return max(sum(energy)-initialEnergy+1, 0) + max_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089634,
                "title": "too-easy-to-understand-throughly-explained-beats-runtime-100-memory-71",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can be solved with simple array traversal approach.\\nTake i as an opponent index, which should increment only when the player has strictly greater energy and experience than the opponent.\\nIf the player does not satisfied any of these condition then it should train for hours equivalnet to the difference b/w energy or experience (whichever is unsatisfied) + 1 (+1 because of strictly condition). This training hour can be counted by any variable.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/ea84da01-69e8-43ed-a727-1e413665b43f_1695661187.3696287.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int energy, int experience, int[] Energy, int[] Experience) {\\n\\n        int count = 0;\\n        int n = Energy.length;\\n        int i = 0;\\n        while(i < n){\\n            //when the player energy and experience are greater than that of opponent\\n            //let them fight and decrease the energy and increse the experience of the player\\n            if(energy > Energy[i] && experience > Experience[i]){\\n                experience += Experience[i];\\n                energy -= Energy[i];\\n                i++;\\n                continue;\\n            }\\n            //if energy of player is less than the energy of the opponent\\n            //train hours equivalent to the differnces b/w energy + 1\\n            if(energy <= Energy[i]){\\n                count += Energy[i] - energy + 1;\\n                energy += Energy[i] - energy + 1;\\n            }\\n            //conditions for experience is same as energy\\n            if(experience <= Experience[i]){\\n                count += Experience[i] - experience + 1;\\n                experience += Experience[i] - experience + 1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int energy, int experience, int[] Energy, int[] Experience) {\\n\\n        int count = 0;\\n        int n = Energy.length;\\n        int i = 0;\\n        while(i < n){\\n            //when the player energy and experience are greater than that of opponent\\n            //let them fight and decrease the energy and increse the experience of the player\\n            if(energy > Energy[i] && experience > Experience[i]){\\n                experience += Experience[i];\\n                energy -= Energy[i];\\n                i++;\\n                continue;\\n            }\\n            //if energy of player is less than the energy of the opponent\\n            //train hours equivalent to the differnces b/w energy + 1\\n            if(energy <= Energy[i]){\\n                count += Energy[i] - energy + 1;\\n                energy += Energy[i] - energy + 1;\\n            }\\n            //conditions for experience is same as energy\\n            if(experience <= Experience[i]){\\n                count += Experience[i] - experience + 1;\\n                experience += Experience[i] - experience + 1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070487,
                "title": "java-greedy-beats-100",
                "content": "\\n\\n# Approach\\nSimple Greedy Approach. \\nYou Start with initial energy and experience. As you face a opponent, gain the extra energy and experience.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ce = initialEnergy;\\n        int cp = initialExperience;\\n        int extraE = 0;\\n        int extraP = 0;\\n\\n        for(int i = 0; i < energy.length; i++)\\n        {\\n            if(ce <= energy[i])\\n            {\\n                int x = energy[i] - ce + 1;\\n                ce += x;\\n                extraE += x;\\n            }\\n            ce = ce - energy[i];\\n            if(cp <= experience[i])\\n            {\\n                int x = experience[i] - cp + 1;\\n                cp +=x;\\n                extraP += x;\\n            }\\n            cp += experience[i];\\n        }\\n\\n        return extraE + extraP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ce = initialEnergy;\\n        int cp = initialExperience;\\n        int extraE = 0;\\n        int extraP = 0;\\n\\n        for(int i = 0; i < energy.length; i++)\\n        {\\n            if(ce <= energy[i])\\n            {\\n                int x = energy[i] - ce + 1;\\n                ce += x;\\n                extraE += x;\\n            }\\n            ce = ce - energy[i];\\n            if(cp <= experience[i])\\n            {\\n                int x = experience[i] - cp + 1;\\n                cp +=x;\\n                extraP += x;\\n            }\\n            cp += experience[i];\\n        }\\n\\n        return extraE + extraP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011490,
                "title": "simple-condition-based-solution",
                "content": "# Intuition\\nFirst I thought it was a tough question for me given various conditions in questions but when I understood the problem then it seemed quite easy.\\n\\n# Approach\\nFirst I took the example given and broke it into different steps to better understand the question, then I wrote the steps needed to complete the code. After that, I implemented the code in the solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> n is the number of opponents in the energy and experience array.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        int opponent = 0;\\n        while (opponent < energy.length) {\\n            // how much the opponent energy is more than initital energy\\n            int energyDiff = energy[opponent] - initialEnergy; \\n            // how much the opponent experience is more than initial experience\\n            int expDiff = experience[opponent] - initialExperience; \\n\\n            if (energyDiff >= 0) {\\n                initialEnergy += energyDiff + 1;\\n                hours += energyDiff + 1;\\n            }\\n\\n            if (expDiff >= 0) {\\n                initialExperience += expDiff + 1;\\n                hours += expDiff + 1;\\n            }\\n\\n            // Adjustments after the fight with opponent\\n            initialEnergy -= energy[opponent];\\n            initialExperience += experience[opponent];\\n            opponent++;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        int opponent = 0;\\n        while (opponent < energy.length) {\\n            // how much the opponent energy is more than initital energy\\n            int energyDiff = energy[opponent] - initialEnergy; \\n            // how much the opponent experience is more than initial experience\\n            int expDiff = experience[opponent] - initialExperience; \\n\\n            if (energyDiff >= 0) {\\n                initialEnergy += energyDiff + 1;\\n                hours += energyDiff + 1;\\n            }\\n\\n            if (expDiff >= 0) {\\n                initialExperience += expDiff + 1;\\n                hours += expDiff + 1;\\n            }\\n\\n            // Adjustments after the fight with opponent\\n            initialEnergy -= energy[opponent];\\n            initialExperience += experience[opponent];\\n            opponent++;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989127,
                "title": "easy-approach-cpp",
                "content": "# Intuition\\nThe goal of this problem is to determine the minimum number of hours of training required to defeat all opponents in a competition. To do this, we need to consider two aspects: energy and experience. We need both energy and experience to defeat an opponent. So, we have two options during training: increase energy or increase experience.\\n\\n# Approach\\nWe can iterate through the opponents one by one and determine if we have enough energy and experience to defeat each opponent. If we don\\'t, we need to decide whether to increase energy, experience, or both to meet the requirements.\\n\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a variable `cnt` to keep track of the total training hours required.\\n\\n2. Iterate through the opponents from the first to the last.\\n\\n3. For each opponent, check if our current energy (`ini`) is greater than the opponent\\'s energy (`en[i]`) and our experience (`ie`) is greater than the opponent\\'s experience (`exp[i]`).\\n\\n   - If both conditions are met, we can defeat the opponent without training. Update `ie` by adding `exp[i]` and decrease `ini` by `en[i]`.\\n\\n   - If one or both conditions are not met, we need to train.\\n\\n4. Determine the training strategy based on the conditions:\\n\\n   - If `ini` is less than or equal to `en[i]` and `ie` is less than or equal to `exp[i]`, we need to increase both energy and experience. Calculate the hours required for both and add them to `cnt`.\\n\\n   - If `ini` is greater than `en[i]` and `ie` is less than or equal to `exp[i]`, we need to increase experience. Calculate the hours required to reach `exp[i]` and add them to `cnt`.\\n\\n   - If `ini` is less than or equal to `en[i]` and `ie` is greater than `exp[i]`, we need to increase energy. Calculate the hours required to reach `en[i]` and add them to `cnt`.\\n\\n5. Update `ini` and `ie` based on the training strategy.\\n\\n6. Repeat the process for the next opponent.\\n\\n7. After defeating all opponents, return `cnt` as the minimum training hours required.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of opponents. We iterate through the opponents once.\\n- Space complexity: O(1) as we use a constant amount of additional space.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>& en, vector<int>& exp) {\\n        int cnt = 0;\\n        for(int i = 0; i < en.size(); i++) {\\n            if(ini > en[i] && ie < exp[i]) {\\n                // We can defeat the opponent without training\\n                ie += exp[i];\\n                ini -= en[i];\\n            }\\n            else {\\n                if(ini <= en[i] && ie <= exp[i]) {\\n                    // Need to increase both energy and experience\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                }\\n                else if(ini > en[i] && ie <= exp[i]) {\\n                    // Need to increase experience\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                    ini -= en[i];\\n                }\\n                else if(ini <= en[i] && ie > exp[i]) {\\n                    // Need to increase energy\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    ie += exp[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nThis code follows the described approach and calculates the minimum training hours required to win the competition.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>& en, vector<int>& exp) {\\n        int cnt = 0;\\n        for(int i = 0; i < en.size(); i++) {\\n            if(ini > en[i] && ie < exp[i]) {\\n                // We can defeat the opponent without training\\n                ie += exp[i];\\n                ini -= en[i];\\n            }\\n            else {\\n                if(ini <= en[i] && ie <= exp[i]) {\\n                    // Need to increase both energy and experience\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                }\\n                else if(ini > en[i] && ie <= exp[i]) {\\n                    // Need to increase experience\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                    ini -= en[i];\\n                }\\n                else if(ini <= en[i] && ie > exp[i]) {\\n                    // Need to increase energy\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    ie += exp[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981150,
                "title": "beats-100-00-of-users-with-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables exdif to track the difference between current experience and the opponent\\'s experience, and ensum to track the sum of energy.\\n2. Iterate through the opponents\\' attributes using a zip of energy and experience lists.\\n    - If your initial experience is less than or equal to the opponent\\'s experience, update exdif to ensure that you have a positive difference for the required training.\\n    - Update your experience by adding the opponent\\'s experience and the energy sum by adding the opponent\\'s energy.\\n3. Calculate the result by finding the maximum between the difference of total energy and initial energy (plus one to represent the time spent training) and exdif. If the calculated result is negative, replace it with zero.\\n4. Return the calculated result.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\nThe time complexity of the solution is **O(n)**, where n is the length of the energy and experience lists. The loop iterates through the lists once to calculate the required values.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n\\nThe space complexity of this solution is **O(1)**, as it only uses a constant amount of additional space to store the variables (exdif and ensum) regardless of the size of the input lists.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        exdif = 0\\n        ensum = 0\\n        \\n        for e, exp in zip(energy, experience):\\n            if initialExperience <= exp:\\n                exdif = max(exdif, exp + 1 - initialExperience)\\n            \\n            initialExperience += exp\\n            ensum += e\\n        \\n        return max(ensum - initialEnergy + 1, 0) + exdif\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        exdif = 0\\n        ensum = 0\\n        \\n        for e, exp in zip(energy, experience):\\n            if initialExperience <= exp:\\n                exdif = max(exdif, exp + 1 - initialExperience)\\n            \\n            initialExperience += exp\\n            ensum += e\\n        \\n        return max(ensum - initialEnergy + 1, 0) + exdif\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980996,
                "title": "solved-using-greedy-algorithm",
                "content": "# Intuition\\nThe problem asks to find minimum number of training hours hence it can be solved using DP or greedy algorithm.\\n\\n# Approach\\nThe idea is to calculate difference before each component for engery and experience and add them into results. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n         int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n         int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977821,
                "title": "clean-fast-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a variable to keep track of training hour then prefix_sum and simple mathematical arithmetic operations(addition and subtraction) \\nto keep track value of energy and experience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix_sum approach and simple maths addition substraction is approached\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs array is traversed once complexity order is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space used -->therefore, complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int tr_hour=0;\\n        int n=energy.size();\\n        int ep=initialExperience;\\n        int e=initialEnergy;\\n\\n        for(int i=0;i<n;i++ ){\\n            if(energy[i]>e && experience[i]>ep){\\n                tr_hour+=energy[i]-e+experience[i]-ep;\\n                e+=energy[i]-e;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]>e && experience[i]<ep){\\n                tr_hour+=energy[i]-e;\\n                e+=energy[i]-e;\\n            } \\n            if(energy[i]<e && experience[i]>ep){\\n                tr_hour+=experience[i]-ep;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]==e && experience[i]==ep){\\n                 tr_hour+=2;\\n                 e++;\\n                 ep++;\\n            }\\n            if(energy[i]==e && experience[i]>ep){\\n                tr_hour+=1+experience[i]-ep;\\n                e++;\\n                ep+=experience[i]-ep;\\n            }\\n            \\n             \\n            if(experience[i]==ep && energy[i]>e){\\n                tr_hour+=1+energy[i]-e;\\n                ep++;\\n                e+=energy[i]-e;\\n            }\\n            if(experience[i]==ep){\\n                tr_hour+=1;\\n                ep++;\\n               \\n            }\\n            if(energy[i]==e ){\\n                tr_hour+=1;\\n                e++;\\n                \\n            }\\n             \\n            e=e-energy[i];\\n            ep=ep+experience[i];\\n\\n        }\\n        return tr_hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int tr_hour=0;\\n        int n=energy.size();\\n        int ep=initialExperience;\\n        int e=initialEnergy;\\n\\n        for(int i=0;i<n;i++ ){\\n            if(energy[i]>e && experience[i]>ep){\\n                tr_hour+=energy[i]-e+experience[i]-ep;\\n                e+=energy[i]-e;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]>e && experience[i]<ep){\\n                tr_hour+=energy[i]-e;\\n                e+=energy[i]-e;\\n            } \\n            if(energy[i]<e && experience[i]>ep){\\n                tr_hour+=experience[i]-ep;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]==e && experience[i]==ep){\\n                 tr_hour+=2;\\n                 e++;\\n                 ep++;\\n            }\\n            if(energy[i]==e && experience[i]>ep){\\n                tr_hour+=1+experience[i]-ep;\\n                e++;\\n                ep+=experience[i]-ep;\\n            }\\n            \\n             \\n            if(experience[i]==ep && energy[i]>e){\\n                tr_hour+=1+energy[i]-e;\\n                ep++;\\n                e+=energy[i]-e;\\n            }\\n            if(experience[i]==ep){\\n                tr_hour+=1;\\n                ep++;\\n               \\n            }\\n            if(energy[i]==e ){\\n                tr_hour+=1;\\n                e++;\\n                \\n            }\\n             \\n            e=e-energy[i];\\n            ep=ep+experience[i];\\n\\n        }\\n        return tr_hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961230,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int training = 0, temp;\\n        for(int i=0; i < energy.size(); i++){\\n            bool flag = 0;\\n            if(initialEnergy > energy[i] and initialExperience > experience[i]){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    temp = energy[i]-initialEnergy;\\n                    if(temp==0) temp = 1;\\n                    initialEnergy+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(initialExperience <= experience[i]){\\n                    temp = experience[i] - initialExperience;\\n                    if(temp==0) temp = 1;\\n                    initialExperience+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(flag) i--;\\n            }\\n        }\\n        return training;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int training = 0, temp;\\n        for(int i=0; i < energy.size(); i++){\\n            bool flag = 0;\\n            if(initialEnergy > energy[i] and initialExperience > experience[i]){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    temp = energy[i]-initialEnergy;\\n                    if(temp==0) temp = 1;\\n                    initialEnergy+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(initialExperience <= experience[i]){\\n                    temp = experience[i] - initialExperience;\\n                    if(temp==0) temp = 1;\\n                    initialExperience+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(flag) i--;\\n            }\\n        }\\n        return training;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930141,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy,\\n                              int[] experience) {\\n    return getRequiredEnergy(initialEnergy, energy) +\\n        getRequiredExperience(initialExperience, experience);\\n  }\\n\\n  private int getRequiredEnergy(int initialEnergy, int[] energy) {\\n    return Math.max(0, Arrays.stream(energy).sum() + 1 - initialEnergy);\\n  }\\n\\n  private int getRequiredExperience(int currentExperience, int[] experience) {\\n    int requiredExperience = 0;\\n    for (final int e : experience) {\\n      if (e >= currentExperience) {\\n        requiredExperience += e + 1 - currentExperience;\\n        currentExperience += e + 1 - currentExperience;\\n      }\\n      currentExperience += e;\\n    }\\n    return requiredExperience;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy,\\n                              int[] experience) {\\n    return getRequiredEnergy(initialEnergy, energy) +\\n        getRequiredExperience(initialExperience, experience);\\n  }\\n\\n  private int getRequiredEnergy(int initialEnergy, int[] energy) {\\n    return Math.max(0, Arrays.stream(energy).sum() + 1 - initialEnergy);\\n  }\\n\\n  private int getRequiredExperience(int currentExperience, int[] experience) {\\n    int requiredExperience = 0;\\n    for (final int e : experience) {\\n      if (e >= currentExperience) {\\n        requiredExperience += e + 1 - currentExperience;\\n        currentExperience += e + 1 - currentExperience;\\n      }\\n      currentExperience += e;\\n    }\\n    return requiredExperience;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925492,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int count = 0;\\n        int diff;\\n\\n        for(int i=0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                diff = energy[i] - initialEnergy + 1;\\n                initialEnergy += diff;\\n                count += diff;\\n            }\\n            if(initialExperience <= experience[i]){\\n                diff = (experience[i] - initialExperience + 1);\\n                initialExperience += diff;\\n                count += diff;\\n            }\\n\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int count = 0;\\n        int diff;\\n\\n        for(int i=0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                diff = energy[i] - initialEnergy + 1;\\n                initialEnergy += diff;\\n                count += diff;\\n            }\\n            if(initialExperience <= experience[i]){\\n                diff = (experience[i] - initialExperience + 1);\\n                initialExperience += diff;\\n                count += diff;\\n            }\\n\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879749,
                "title": "java-0ms-beats-100-00",
                "content": "# Intuition & Approach\\n- perform a simulation\\n- keep track of each round\\'s shortfalls\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int n = energy.length;\\n\\n        int energyGap = 0;  // what we\\'ll return\\n        int experienceGap = 0;  // what we\\'ll return\\n\\n        int curEnergy = initialEnergy;\\n        int curExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < n; ++opponent) {\\n\\n            int energyDelta = curEnergy - energy[opponent];\\n            if (energyDelta <= 0) {\\n                int energyNeeded = -1 * energyDelta + 1;\\n                curEnergy += energyNeeded;\\n                energyGap += energyNeeded;\\n            }\\n\\n            int experienceDelta = curExperience - experience[opponent];\\n            if (experienceDelta <= 0) {\\n                int experienceNeeded = -1 * experienceDelta + 1;\\n                curExperience += experienceNeeded;\\n                experienceGap += experienceNeeded;\\n            }\\n\\n            // post-opponent stat changes\\n            curExperience += experience[opponent];\\n            curEnergy -= energy[opponent];\\n        }\\n\\n        return energyGap + experienceGap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int n = energy.length;\\n\\n        int energyGap = 0;  // what we\\'ll return\\n        int experienceGap = 0;  // what we\\'ll return\\n\\n        int curEnergy = initialEnergy;\\n        int curExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < n; ++opponent) {\\n\\n            int energyDelta = curEnergy - energy[opponent];\\n            if (energyDelta <= 0) {\\n                int energyNeeded = -1 * energyDelta + 1;\\n                curEnergy += energyNeeded;\\n                energyGap += energyNeeded;\\n            }\\n\\n            int experienceDelta = curExperience - experience[opponent];\\n            if (experienceDelta <= 0) {\\n                int experienceNeeded = -1 * experienceDelta + 1;\\n                curExperience += experienceNeeded;\\n                experienceGap += experienceNeeded;\\n            }\\n\\n            // post-opponent stat changes\\n            curExperience += experience[opponent];\\n            curEnergy -= energy[opponent];\\n        }\\n\\n        return energyGap + experienceGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875470,
                "title": "easy-c-solution-prefix-sum-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int in, int ix, vector<int>& en, vector<int>& ex) {\\n        int train=0;\\n        int total_en=0;\\n        for(int i=0;i<en.size();i++){\\n            total_en+=en[i];\\n        }\\n        if(total_en-in>=0){\\n            train+=total_en-in+1;\\n        }\\n        for(int i=0;i<ex.size();i++){\\n            if(ex[i]-ix>=0){\\n                train+=ex[i]-ix+1;\\n                ix+=ex[i]-ix+1;\\n            }\\n            ix+=ex[i];\\n        }\\n        \\n        return train;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int in, int ix, vector<int>& en, vector<int>& ex) {\\n        int train=0;\\n        int total_en=0;\\n        for(int i=0;i<en.size();i++){\\n            total_en+=en[i];\\n        }\\n        if(total_en-in>=0){\\n            train+=total_en-in+1;\\n        }\\n        for(int i=0;i<ex.size();i++){\\n            if(ex[i]-ix>=0){\\n                train+=ex[i]-ix+1;\\n                ix+=ex[i]-ix+1;\\n            }\\n            ix+=ex[i];\\n        }\\n        \\n        return train;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869811,
                "title": "easy-cpp-solution-beats-74-8-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/d38d7c19-3b83-4f30-913a-2bb291bc3c2b_1691293736.2784266.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int iE, vector<int>& e, vector<int>& E) {\\n        // Temporary variables\\n        int ideale = ie, idealE = iE;\\n        // ext1 for extra energy, ext for extra experience required\\n        int ext1 = 0, ext = 0;\\n        for(int i=0; i<e.size(); i++)\\n            ideale -= e[i];\\n        \\n        for(int i=0; i<E.size(); i++){\\n            if(idealE <= E[i]){\\n                ext+= (E[i] - idealE) + 1;\\n                idealE+=(E[i] - idealE) + 1;\\n            }\\n            idealE += E[i];\\n        }\\n        \\n        if(ideale <= 0) ext1 = (ideale*-1) + 1;\\n\\n        return ext1 + ext;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int iE, vector<int>& e, vector<int>& E) {\\n        // Temporary variables\\n        int ideale = ie, idealE = iE;\\n        // ext1 for extra energy, ext for extra experience required\\n        int ext1 = 0, ext = 0;\\n        for(int i=0; i<e.size(); i++)\\n            ideale -= e[i];\\n        \\n        for(int i=0; i<E.size(); i++){\\n            if(idealE <= E[i]){\\n                ext+= (E[i] - idealE) + 1;\\n                idealE+=(E[i] - idealE) + 1;\\n            }\\n            idealE += E[i];\\n        }\\n        \\n        if(ideale <= 0) ext1 = (ideale*-1) + 1;\\n\\n        return ext1 + ext;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862275,
                "title": "2383-minimum-hours-of-training-to-win-a-competition-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst try to solve the total energy and additional hour required the run for the exp part and keep on adding the exp else calculate the additional training hours required to gain that experience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursEnergy = 0;\\n        int totalEnergy = 0;\\n        for (int i = 0 ; i < energy.length; i++) {\\n            totalEnergy += energy[i];\\n        }\\n        if (totalEnergy >= initialEnergy) {\\n            hoursEnergy = totalEnergy - initialEnergy + 1;\\n            initialEnergy += hoursEnergy;\\n        }\\n        \\n        int hoursExp = 0;\\n        for (int i = 0 ; i < experience.length; i++) {\\n            if (initialExperience > experience[i]) {\\n                initialExperience += experience[i];\\n                \\n            } else {\\n                int temp = experience[i] + 1 - initialExperience;\\n                hoursExp += temp;\\n                initialExperience += temp;\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return hoursExp + hoursEnergy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursEnergy = 0;\\n        int totalEnergy = 0;\\n        for (int i = 0 ; i < energy.length; i++) {\\n            totalEnergy += energy[i];\\n        }\\n        if (totalEnergy >= initialEnergy) {\\n            hoursEnergy = totalEnergy - initialEnergy + 1;\\n            initialEnergy += hoursEnergy;\\n        }\\n        \\n        int hoursExp = 0;\\n        for (int i = 0 ; i < experience.length; i++) {\\n            if (initialExperience > experience[i]) {\\n                initialExperience += experience[i];\\n                \\n            } else {\\n                int temp = experience[i] + 1 - initialExperience;\\n                hoursExp += temp;\\n                initialExperience += temp;\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return hoursExp + hoursEnergy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849369,
                "title": "easy-to-understand-linear-time-complexity-constant-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        \\n        minimum = max(sum(energy) - initialEnergy + 1, 0)\\n        \\n        for e in experience:\\n            diff = max(0, e+1 - initialExperience)\\n            if diff >= 0:\\n                minimum += diff\\n            initialExperience += e + diff\\n        return minimum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        \\n        minimum = max(sum(energy) - initialEnergy + 1, 0)\\n        \\n        for e in experience:\\n            diff = max(0, e+1 - initialExperience)\\n            if diff >= 0:\\n                minimum += diff\\n            initialExperience += e + diff\\n        return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827142,
                "title": "intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0;\\n        for(int i = 0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                total += 1 + energy[i] - initialEnergy;\\n                initialEnergy = 1;\\n            }\\n            else{\\n                initialEnergy-=energy[i];\\n            }\\n            if(initialExperience <= experience[i]){\\n                total += 1 + experience[i] - initialExperience;\\n                initialExperience = 2*experience[i] + 1;\\n            }\\n            else{\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0;\\n        for(int i = 0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                total += 1 + energy[i] - initialEnergy;\\n                initialEnergy = 1;\\n            }\\n            else{\\n                initialEnergy-=energy[i];\\n            }\\n            if(initialExperience <= experience[i]){\\n                total += 1 + experience[i] - initialExperience;\\n                initialExperience = 2*experience[i] + 1;\\n            }\\n            else{\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821902,
                "title": "swift-one-liner-o-n-time-o-1-space-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        max(energy.reduce(1-initialEnergy, +),0)\\n        + experience.reduce((initialExperience, 0)) { ($0.0 + $1, max($0.1, 0, $1 - $0.0 + 1)) }.1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        max(energy.reduce(1-initialEnergy, +),0)\\n        + experience.reduce((initialExperience, 0)) { ($0.0 + $1, max($0.1, 0, $1 - $0.0 + 1)) }.1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820262,
                "title": "js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let energySum=1;\\n    let experienceSum=0;\\n    let minExperience=0;\\n    let n=energy.length;\\n    for(let i=0;i<n;i++){\\n        energySum+=energy[i];\\n        if((experience[i]>experienceSum)&&(minExperience<(experience[i]-experienceSum))){\\n            minExperience=experience[i]-experienceSum;\\n        }\\n        experienceSum+=experience[i];\\n    }\\n    let finalEnergy = ((energySum-initialEnergy)>0)?energySum-initialEnergy:0; \\n    let finalExperience = (minExperience>=initialExperience)?(minExperience-initialExperience+1):0; \\n    console.log(finalEnergy,finalExperience);\\n    return finalEnergy+finalExperience;\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let energySum=1;\\n    let experienceSum=0;\\n    let minExperience=0;\\n    let n=energy.length;\\n    for(let i=0;i<n;i++){\\n        energySum+=energy[i];\\n        if((experience[i]>experienceSum)&&(minExperience<(experience[i]-experienceSum))){\\n            minExperience=experience[i]-experienceSum;\\n        }\\n        experienceSum+=experience[i];\\n    }\\n    let finalEnergy = ((energySum-initialEnergy)>0)?energySum-initialEnergy:0; \\n    let finalExperience = (minExperience>=initialExperience)?(minExperience-initialExperience+1):0; \\n    console.log(finalEnergy,finalExperience);\\n    return finalEnergy+finalExperience;\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760857,
                "title": "java-greedy-explained",
                "content": "**Idea:** \\n* In each iteration, find the differences in energies and experience, and increase hours by 1 + diff if required\\n* Now you\\'re ready to fight this opponent, so decrease energy and increase experience by this opponent\\'s values\\n* Greedy approach ensures that the hours are minimum\\n>**T/S:** O(n)/O(1), where n = size(energy)\\n```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\tvar hours = 0;\\n\\n\\tfor (var i = 0; i < energy.length; i++) {\\n\\t\\tvar energyDiff = energy[i] - initialEnergy;\\n\\t\\tvar xpDiff = experience[i] - initialExperience;\\n\\n\\t\\tif (energyDiff++ >= 0) {\\n\\t\\t\\thours += energyDiff;\\n\\t\\t\\tinitialEnergy += energyDiff;\\n\\t\\t}\\n\\t\\tif (xpDiff++ >= 0) {\\n\\t\\t\\thours += xpDiff;\\n\\t\\t\\tinitialExperience += xpDiff;\\n\\t\\t}\\n\\n\\t\\tinitialEnergy -= energy[i];\\n\\t\\tinitialExperience += experience[i];\\n\\t}\\n\\n\\treturn hours;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\tvar hours = 0;\\n\\n\\tfor (var i = 0; i < energy.length; i++) {\\n\\t\\tvar energyDiff = energy[i] - initialEnergy;\\n\\t\\tvar xpDiff = experience[i] - initialExperience;\\n\\n\\t\\tif (energyDiff++ >= 0) {\\n\\t\\t\\thours += energyDiff;\\n\\t\\t\\tinitialEnergy += energyDiff;\\n\\t\\t}\\n\\t\\tif (xpDiff++ >= 0) {\\n\\t\\t\\thours += xpDiff;\\n\\t\\t\\tinitialExperience += xpDiff;\\n\\t\\t}\\n\\n\\t\\tinitialEnergy -= energy[i];\\n\\t\\tinitialExperience += experience[i];\\n\\t}\\n\\n\\treturn hours;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754868,
                "title": "c-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int curr_experience = initialExperience;\\n        int curr_energy = initialEnergy;\\n        \\n        int additional_experience_needed = 0;\\n        int additional_energy_needed = 0;\\n        \\n        const auto N = energy.size();\\n        for(size_t i = 0; i < N; ++i) {\\n            // check if we need additional hours of trainings for experience\\n            int delta = max(0, experience[i] - curr_experience + 1);\\n            additional_experience_needed += delta;\\n            curr_experience += delta + experience[i];\\n\\n            // check if we need additional hours of trainings for energy\\n            delta = max(0, energy[i] - curr_energy + 1);\\n            additional_energy_needed += delta;\\n            curr_energy += delta - energy[i];\\n        }\\n                        \\n        return additional_energy_needed + additional_experience_needed;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int curr_experience = initialExperience;\\n        int curr_energy = initialEnergy;\\n        \\n        int additional_experience_needed = 0;\\n        int additional_energy_needed = 0;\\n        \\n        const auto N = energy.size();\\n        for(size_t i = 0; i < N; ++i) {\\n            // check if we need additional hours of trainings for experience\\n            int delta = max(0, experience[i] - curr_experience + 1);\\n            additional_experience_needed += delta;\\n            curr_experience += delta + experience[i];\\n\\n            // check if we need additional hours of trainings for energy\\n            delta = max(0, energy[i] - curr_energy + 1);\\n            additional_energy_needed += delta;\\n            curr_energy += delta - energy[i];\\n        }\\n                        \\n        return additional_energy_needed + additional_experience_needed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739430,
                "title": "greedy-c-time-o-n-space-o-1",
                "content": "# Approach\\nTrain if needed, then fight.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int t = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n ; ){\\n            if(initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                i++;\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    t += (energy[i] - initialEnergy +1);\\n                    initialEnergy += (energy[i] - initialEnergy + 1);\\n                }\\n                if(initialExperience <= experience[i]){\\n                    t += (experience[i] - initialExperience +1);\\n                    initialExperience += (experience[i] - initialExperience + 1);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int t = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n ; ){\\n            if(initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                i++;\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    t += (energy[i] - initialEnergy +1);\\n                    initialEnergy += (energy[i] - initialEnergy + 1);\\n                }\\n                if(initialExperience <= experience[i]){\\n                    t += (experience[i] - initialExperience +1);\\n                    initialExperience += (experience[i] - initialExperience + 1);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719618,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n        let count=0;\\n        for (let i = 0; i < energy.length; i++){\\n            if (initialExperience <= experience[i]){\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;      \\n            }\\n            initialEnergy-= energy[i];           \\n            initialExperience+= experience[i];\\n        }\\n        if (initialEnergy < 1) count += 1-initialEnergy;\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n        let count=0;\\n        for (let i = 0; i < energy.length; i++){\\n            if (initialExperience <= experience[i]){\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;      \\n            }\\n            initialEnergy-= energy[i];           \\n            initialExperience+= experience[i];\\n        }\\n        if (initialEnergy < 1) count += 1-initialEnergy;\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714206,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hour = 0 , prev = 0;\\n        int i = 0;\\n        while (i<energy.size()){\\n            if (initialEnergy <= energy[i]){\\n                hour += 1 + (energy[i]-initialEnergy);\\n                initialEnergy += 1 + (energy[i]-initialEnergy);\\n            }\\n            if (initialExperience <= experience[i]){\\n                hour += 1 + (experience[i] - initialExperience);\\n                initialExperience += 1 + (experience[i] - initialExperience);\\n            }\\n            \\n            if (hour != prev){\\n                prev = hour;\\n                continue;\\n            }\\n            if (initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                prev = hour;\\n                i++;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hour = 0 , prev = 0;\\n        int i = 0;\\n        while (i<energy.size()){\\n            if (initialEnergy <= energy[i]){\\n                hour += 1 + (energy[i]-initialEnergy);\\n                initialEnergy += 1 + (energy[i]-initialEnergy);\\n            }\\n            if (initialExperience <= experience[i]){\\n                hour += 1 + (experience[i] - initialExperience);\\n                initialExperience += 1 + (experience[i] - initialExperience);\\n            }\\n            \\n            if (hour != prev){\\n                prev = hour;\\n                continue;\\n            }\\n            if (initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                prev = hour;\\n                i++;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694286,
                "title": "python-easy-one-o-n-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        a = sum(energy)\\n        hours = 0\\n        if initialEnergy<=a:\\n            hours+=(a-initialEnergy)+1\\n\\n        for i in experience:\\n            if initialExperience<=i:\\n                hours += i-initialExperience+1\\n                initialExperience += i+(i-initialExperience+1)\\n            else:\\n                initialExperience += i\\n\\n        return hours\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        a = sum(energy)\\n        hours = 0\\n        if initialEnergy<=a:\\n            hours+=(a-initialEnergy)+1\\n\\n        for i in experience:\\n            if initialExperience<=i:\\n                hours += i-initialExperience+1\\n                initialExperience += i+(i-initialExperience+1)\\n            else:\\n                initialExperience += i\\n\\n        return hours\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665711,
                "title": "minimum-hours-of-training-to-win-a-competition",
                "content": "Simple Approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& ex) {\\n        int val=0,sum=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            sum+=energy[i];\\n        }\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(ie>ex[i])\\n            {\\n                ie=ie+ex[i];\\n            }\\n            else\\n            {\\n                int diff=(ex[i]-ie)+1;\\n                val+=diff;\\n                ie=ie+diff;\\n                ie=ie+ex[i];\\n            }\\n        }\\n        if(initialEnergy>sum)\\n        {\\n            return val;\\n        }\\n            return (sum+1-initialEnergy+val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& ex) {\\n        int val=0,sum=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            sum+=energy[i];\\n        }\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(ie>ex[i])\\n            {\\n                ie=ie+ex[i];\\n            }\\n            else\\n            {\\n                int diff=(ex[i]-ie)+1;\\n                val+=diff;\\n                ie=ie+diff;\\n                ie=ie+ex[i];\\n            }\\n        }\\n        if(initialEnergy>sum)\\n        {\\n            return val;\\n        }\\n            return (sum+1-initialEnergy+val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664513,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum_e=0;\\n        for(auto it:energy){\\n            sum_e=sum_e+it;\\n        }\\n        int hour;\\n       if(sum_e<initialEnergy){\\n           hour=0;\\n       }\\n       else{\\n       hour=sum_e+1-initialEnergy;\\n       }\\n       \\n   \\n       int sum=initialExperience;\\n        if (experience.size()> 0 && sum <= experience[0] && initialEnergy < energy[0]) {\\n            hour = hour + experience[0] - sum + 1;\\n            sum = experience[0] + 1;\\n        }\\n       for(int i=0;i<experience.size();i++){\\n           if(sum<=experience[i]){\\n               hour=hour+experience[i]-sum+1;\\n                sum = experience[i] + 1;\\n           }\\n           sum=sum+experience[i];\\n\\n       }\\n       cout<<hour;\\n       if(hour<0)return 0;\\n\\n\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum_e=0;\\n        for(auto it:energy){\\n            sum_e=sum_e+it;\\n        }\\n        int hour;\\n       if(sum_e<initialEnergy){\\n           hour=0;\\n       }\\n       else{\\n       hour=sum_e+1-initialEnergy;\\n       }\\n       \\n   \\n       int sum=initialExperience;\\n        if (experience.size()> 0 && sum <= experience[0] && initialEnergy < energy[0]) {\\n            hour = hour + experience[0] - sum + 1;\\n            sum = experience[0] + 1;\\n        }\\n       for(int i=0;i<experience.size();i++){\\n           if(sum<=experience[i]){\\n               hour=hour+experience[i]-sum+1;\\n                sum = experience[i] + 1;\\n           }\\n           sum=sum+experience[i];\\n\\n       }\\n       cout<<hour;\\n       if(hour<0)return 0;\\n\\n\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3653457,
                "title": "ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nWe can figure out energy ahead of time, but we figure out expeirence by going into fights and adjusting as needed.\\n\\n# Approach\\n1. Find the sum of energy and compare with initial energy.  If initial energy is bigger, we don\\'t have to train for more energy at all.  Otherwise, we need to train enough to make them equal, plus 1.\\n2. Go through the opponents and compare experience:\\n    - If your experience is higher, add their experience without changing total.\\n    - If you experience is *lower*, add the difference (subtract the negative difference) from count, and subtract 1 more.  You need to train enough to be one more, plus you\\'ll add their experience, so you final experience will be double theirs + 1.\\n3. Return count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef min_number_of_hours(initial_energy, initial_experience, energy, experience)\\n    count = initial_energy > energy.sum ? 0 : energy.sum + 1 - initial_energy\\n\\n    (0...experience.length).each do |i|\\n        diff = initial_experience - experience[i]\\n        if diff > 0\\n            initial_experience += experience[i]\\n        else\\n            count -= diff - 1\\n            initial_experience = 2 * experience[i] + 1\\n        end\\n    end\\n\\n    count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_number_of_hours(initial_energy, initial_experience, energy, experience)\\n    count = initial_energy > energy.sum ? 0 : energy.sum + 1 - initial_energy\\n\\n    (0...experience.length).each do |i|\\n        diff = initial_experience - experience[i]\\n        if diff > 0\\n            initial_experience += experience[i]\\n        else\\n            count -= diff - 1\\n            initial_experience = 2 * experience[i] + 1\\n        end\\n    end\\n\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650217,
                "title": "java-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n        for(int i = 0; i < energy.length;i++){\\n            if(initialEnergy <= energy[i]){\\n            hours += energy[i] - initialEnergy +1;\\n            initialEnergy = energy[i] +1;\\n            }\\n            if(initialExperience <= experience[i]){\\n                hours+= experience[i] - initialExperience+1;\\n                initialExperience = experience[i] + 1;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n        for(int i = 0; i < energy.length;i++){\\n            if(initialEnergy <= energy[i]){\\n            hours += energy[i] - initialEnergy +1;\\n            initialEnergy = energy[i] +1;\\n            }\\n            if(initialExperience <= experience[i]){\\n                hours+= experience[i] - initialExperience+1;\\n                initialExperience = experience[i] + 1;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584107,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579258,
                "title": "jebas-raja-very-easy",
                "content": "# Intuition:karunya university:accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n      \\n\\t \\t int hours=0;\\n\\t \\t \\n\\t \\t for (int i=0;i<energy.length;i++)\\n\\t \\t { \\n\\t \\t    //if energy is greater than or equal to initialEnergy    \\n\\t \\t    \\n\\t \\t    if (energy[i]>=initialEnergy)\\n\\t \\t    {\\n\\t \\t        hours+=(energy[i]-initialEnergy)+1;\\n\\t \\t        initialEnergy+=(energy[i]-initialEnergy)+1;\\n\\t \\t         \\n\\t \\t    }\\n\\t \\t    \\n\\t \\t    \\n\\t \\t    if (experience[i]>=initialExperience)\\n\\t \\t    {\\n\\t \\t        hours+=(experience[i]-initialExperience)+1;\\n\\t \\t        initialExperience+=(experience[i]-initialExperience)+1;\\n\\t \\t    }\\n\\t \\t    \\n\\t \\t   initialEnergy-=energy[i];\\n\\t \\t   initialExperience+=experience[i];\\n\\t \\t  \\n\\t \\t }\\n        \\n        //System.out.println(hours);    \\n        return hours;   \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n      \\n\\t \\t int hours=0;\\n\\t \\t \\n\\t \\t for (int i=0;i<energy.length;i++)\\n\\t \\t { \\n\\t \\t    //if energy is greater than or equal to initialEnergy    \\n\\t \\t    \\n\\t \\t    if (energy[i]>=initialEnergy)\\n\\t \\t    {\\n\\t \\t        hours+=(energy[i]-initialEnergy)+1;\\n\\t \\t        initialEnergy+=(energy[i]-initialEnergy)+1;\\n\\t \\t         \\n\\t \\t    }\\n\\t \\t    \\n\\t \\t    \\n\\t \\t    if (experience[i]>=initialExperience)\\n\\t \\t    {\\n\\t \\t        hours+=(experience[i]-initialExperience)+1;\\n\\t \\t        initialExperience+=(experience[i]-initialExperience)+1;\\n\\t \\t    }\\n\\t \\t    \\n\\t \\t   initialEnergy-=energy[i];\\n\\t \\t   initialExperience+=experience[i];\\n\\t \\t  \\n\\t \\t }\\n        \\n        //System.out.println(hours);    \\n        return hours;   \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566782,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        auto energyNeeded = 1, experienceNeeded = 0, currentExperience = initialExperience;\\n        for (auto i = 0; i < energy.size(); ++i) {\\n            energyNeeded += energy[i];\\n            auto experienceDiff = max(0, experience[i] - currentExperience + 1);\\n            experienceNeeded += experienceDiff;\\n            currentExperience += experienceDiff + experience[i];\\n        }\\n        return max(0, energyNeeded - initialEnergy) + experienceNeeded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        auto energyNeeded = 1, experienceNeeded = 0, currentExperience = initialExperience;\\n        for (auto i = 0; i < energy.size(); ++i) {\\n            energyNeeded += energy[i];\\n            auto experienceDiff = max(0, experience[i] - currentExperience + 1);\\n            experienceNeeded += experienceDiff;\\n            currentExperience += experienceDiff + experience[i];\\n        }\\n        return max(0, energyNeeded - initialEnergy) + experienceNeeded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558479,
                "title": "beat-100-in-both-memory-and-runtime-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs energy is decreasing after every fight , i had calculate total energy req at the beginning by summing up the energy array. Total initial energy req will be greater then the sum by one(min condition).\\n\\nFor calculating the experience , i had taken exp to track it, which is initialised to initialexperience. Now after every fight if we encounter a experience lvl greater than or equal to exp then we need to calculate the req exprience at that lvl only, this is because after crossing that lvl our exp lvl may be eligible for the next fight simply because we are adding exp after every fight. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energyCount = 0;\\n        int training = 0;\\n        for(int i=0 ; i<energy.length ; i++){\\n            energyCount += energy[i];\\n        }\\n        int reqenergy = energyCount + 1;\\n        if(reqenergy > initialEnergy){\\n            training = reqenergy-initialEnergy;\\n        }\\n        // counting experience\\n\\n        int exp = initialExperience;\\n        for(int i=0 ; i<experience.length ; i++){\\n            if(experience[i] >= exp){\\n                int reqexp = experience[i]-exp+1;\\n                training += reqexp;\\n                exp += experience[i]+(reqexp);\\n            }else{\\n                exp += experience[i];\\n            }\\n        }\\n        return training;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energyCount = 0;\\n        int training = 0;\\n        for(int i=0 ; i<energy.length ; i++){\\n            energyCount += energy[i];\\n        }\\n        int reqenergy = energyCount + 1;\\n        if(reqenergy > initialEnergy){\\n            training = reqenergy-initialEnergy;\\n        }\\n        // counting experience\\n\\n        int exp = initialExperience;\\n        for(int i=0 ; i<experience.length ; i++){\\n            if(experience[i] >= exp){\\n                int reqexp = experience[i]-exp+1;\\n                training += reqexp;\\n                exp += experience[i]+(reqexp);\\n            }else{\\n                exp += experience[i];\\n            }\\n        }\\n        return training;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527521,
                "title": "c-100-fast-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,ans=0;\\n        for(int i=0;i<energy.size();i++){\\n            sum+=energy[i];\\n        }\\n        if(sum>=initialEnergy){\\n            ans=sum-initialEnergy+1;\\n        }\\n        for(int i=0;i<experience.size();i++){\\n            if(initialExperience<=experience[i]){\\n                ans+=experience[i]-initialExperience+1;\\n                initialExperience=experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,ans=0;\\n        for(int i=0;i<energy.size();i++){\\n            sum+=energy[i];\\n        }\\n        if(sum>=initialEnergy){\\n            ans=sum-initialEnergy+1;\\n        }\\n        for(int i=0;i<experience.size();i++){\\n            if(initialExperience<=experience[i]){\\n                ans+=experience[i]-initialExperience+1;\\n                initialExperience=experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520160,
                "title": "java-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursForEnergy = 0;\\n        int hoursForExperience = 0; \\n        for (int i = 0; i < energy.length; i++) {\\n            if (initialExperience <= experience[i]) {\\n                int diffOfXp = experience[i] - initialExperience + 1;\\n                hoursForExperience += diffOfXp;\\n                initialExperience += diffOfXp;\\n            }\\n            initialExperience += experience[i];\\n            hoursForEnergy += energy[i];\\n        }\\n        hoursForEnergy = hoursForEnergy - initialEnergy + 1;\\n        if (hoursForEnergy <= 0) {\\n            hoursForEnergy = 0;\\n        }\\n        return hoursForEnergy + hoursForExperience;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursForEnergy = 0;\\n        int hoursForExperience = 0; \\n        for (int i = 0; i < energy.length; i++) {\\n            if (initialExperience <= experience[i]) {\\n                int diffOfXp = experience[i] - initialExperience + 1;\\n                hoursForExperience += diffOfXp;\\n                initialExperience += diffOfXp;\\n            }\\n            initialExperience += experience[i];\\n            hoursForEnergy += energy[i];\\n        }\\n        hoursForEnergy = hoursForEnergy - initialEnergy + 1;\\n        if (hoursForEnergy <= 0) {\\n            hoursForEnergy = 0;\\n        }\\n        return hoursForEnergy + hoursForExperience;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507285,
                "title": "java-simple-solution-one-pass-math-greedy",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energySum = 0;\\n        for (int currentEnergy : energy) {\\n            energySum += currentEnergy;\\n        }\\n        \\n        int experinceTrainingTime = 0;\\n        int experienceSum = initialExperience;\\n        for (int currentExperience : experience) {\\n            if (experienceSum <= currentExperience) {\\n                int difference = currentExperience - experienceSum + 1;\\n                experinceTrainingTime += difference;\\n                experienceSum += difference;\\n            }\\n            experienceSum += currentExperience;\\n        }\\n        \\n        int energyTrainingTime = 0;\\n        if (energySum >= initialEnergy) {\\n            energyTrainingTime = energySum - initialEnergy + 1;\\n        }\\n\\n        return energyTrainingTime + experinceTrainingTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energySum = 0;\\n        for (int currentEnergy : energy) {\\n            energySum += currentEnergy;\\n        }\\n        \\n        int experinceTrainingTime = 0;\\n        int experienceSum = initialExperience;\\n        for (int currentExperience : experience) {\\n            if (experienceSum <= currentExperience) {\\n                int difference = currentExperience - experienceSum + 1;\\n                experinceTrainingTime += difference;\\n                experienceSum += difference;\\n            }\\n            experienceSum += currentExperience;\\n        }\\n        \\n        int energyTrainingTime = 0;\\n        if (energySum >= initialEnergy) {\\n            energyTrainingTime = energySum - initialEnergy + 1;\\n        }\\n\\n        return energyTrainingTime + experinceTrainingTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490689,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int totalTraninigForEnergy = Math.Max(energy.Sum() - initialEnergy + 1, 0);\\n        int totalTraninigForExp = 0, expGained = initialExperience;\\n        foreach(int exp in experience) {\\n            if(expGained > exp) {\\n                expGained += exp;\\n            } else {\\n                int diff = exp - expGained + 1;\\n                expGained += exp + diff;\\n                totalTraninigForExp += diff;\\n            }\\n        }\\n\\n        return totalTraninigForEnergy + totalTraninigForExp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int totalTraninigForEnergy = Math.Max(energy.Sum() - initialEnergy + 1, 0);\\n        int totalTraninigForExp = 0, expGained = initialExperience;\\n        foreach(int exp in experience) {\\n            if(expGained > exp) {\\n                expGained += exp;\\n            } else {\\n                int diff = exp - expGained + 1;\\n                expGained += exp + diff;\\n                totalTraninigForExp += diff;\\n            }\\n        }\\n\\n        return totalTraninigForEnergy + totalTraninigForExp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461880,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int ans=0;\\n        int sumReqE=0;\\n        for(int i=0;i<energy.size();i++)\\n          sumReqE+=energy[i];\\n     \\n        \\n        sumReqE++;\\n        //energy\\n        if(initialEnergy<sumReqE)\\n          ans+=(sumReqE-initialEnergy);\\n          \\n         //Experience\\n         int i=0;\\n         int ex=initialExperience;//where to increment;\\n         int x=initialExperience;\\n         while(i<energy.size()){\\n            if(experience[i]<x){\\n               x=x+experience[i];\\n               i++;\\n             }else{\\n                i=0;\\n                ex++;\\n                x=ex;\\n            }\\n         }\\n         \\n         ans+=(ex-initialExperience);\\n         if(ans<0)\\n            return 0;\\n\\n           return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int ans=0;\\n        int sumReqE=0;\\n        for(int i=0;i<energy.size();i++)\\n          sumReqE+=energy[i];\\n     \\n        \\n        sumReqE++;\\n        //energy\\n        if(initialEnergy<sumReqE)\\n          ans+=(sumReqE-initialEnergy);\\n          \\n         //Experience\\n         int i=0;\\n         int ex=initialExperience;//where to increment;\\n         int x=initialExperience;\\n         while(i<energy.size()){\\n            if(experience[i]<x){\\n               x=x+experience[i];\\n               i++;\\n             }else{\\n                i=0;\\n                ex++;\\n                x=ex;\\n            }\\n         }\\n         \\n         ans+=(ex-initialExperience);\\n         if(ans<0)\\n            return 0;\\n\\n           return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455145,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int reqEn = 0;\\n        for (int x: energy)\\n            reqEn += x;\\n        reqEn = Math.max(0, reqEn - initialEnergy + 1);\\n        \\n        int reqEx = 0, currEx = initialExperience;\\n        for (int x: experience)\\n        {\\n            if (currEx > x)\\n                currEx += x;\\n            else\\n            {\\n                reqEx += x - currEx + 1;\\n                currEx += (x - currEx + 1)   +   x;\\n            }\\n        }\\n        \\n        return reqEn + reqEx;\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int reqEn = 0;\\n        for (int x: energy)\\n            reqEn += x;\\n        reqEn = Math.max(0, reqEn - initialEnergy + 1);\\n        \\n        int reqEx = 0, currEx = initialExperience;\\n        for (int x: experience)\\n        {\\n            if (currEx > x)\\n                currEx += x;\\n            else\\n            {\\n                reqEx += x - currEx + 1;\\n                currEx += (x - currEx + 1)   +   x;\\n            }\\n        }\\n        \\n        return reqEn + reqEx;\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434447,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) where n is the numbers of elements in array energy\\n\\n- Space complexity:O(n) where n is the numbers of elements in array energy\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //int\\'s are positive values\\n        int hours = 0;\\n        for(int i = 0; i < energy.length; i++) {\\n            while(initialEnergy <= energy[i]){\\n                initialEnergy++;\\n                hours += 1;\\n            }\\n            while(initialExperience <= experience[i]) {\\n                initialExperience++;\\n                hours += 1;\\n            }\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //int\\'s are positive values\\n        int hours = 0;\\n        for(int i = 0; i < energy.length; i++) {\\n            while(initialEnergy <= energy[i]){\\n                initialEnergy++;\\n                hours += 1;\\n            }\\n            while(initialExperience <= experience[i]) {\\n                initialExperience++;\\n                hours += 1;\\n            }\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428836,
                "title": "competition-javascript-calculate-training-hours-52-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/515f583c-0b6f-46bd-89f4-25c579427b51_1681782884.5946465.png)\\n\\n```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {  \\n    cur = initialExperience      \\n    a = b = 0        \\n    \\n    for (let i = 0; i < experience.length; i++) {  \\n        b = Math.max(experience[i] + 1 - cur, b)         \\n        cur += experience[i]          \\n        a += energy[i]            \\n    }\\n\\n    a = Math.max(0, a + 1 - initialEnergy)    \\n\\n    return a + b\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {  \\n    cur = initialExperience      \\n    a = b = 0        \\n    \\n    for (let i = 0; i < experience.length; i++) {  \\n        b = Math.max(experience[i] + 1 - cur, b)         \\n        cur += experience[i]          \\n        a += energy[i]            \\n    }\\n\\n    a = Math.max(0, a + 1 - initialEnergy)    \\n\\n    return a + b\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408678,
                "title": "simple-c-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }\\n        ex+=experience[i];\\n    }\\n    en+=1;\\n    if(initialEnergy<en )\\n    {\\n        min=en-initialEnergy+h;\\n    }\\n    else\\n    {\\n        min+=h;\\n    }\\n    return min;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }\\n        ex+=experience[i];\\n    }\\n    en+=1;\\n    if(initialEnergy<en )\\n    {\\n        min=en-initialEnergy+h;\\n    }\\n    else\\n    {\\n        min+=h;\\n    }\\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406100,
                "title": "self-explanatory-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        train_hours = 0\\n        if initialEnergy <= sum(energy):\\n            train_hours = abs(initialEnergy - sum(energy)) + 1\\n        for exp in experience:\\n            if exp >= initialExperience:\\n                train_hours += exp - initialExperience + 1\\n                initialExperience += exp - initialExperience + 1 + exp\\n            else:\\n                initialExperience += exp\\n        return train_hours\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        train_hours = 0\\n        if initialEnergy <= sum(energy):\\n            train_hours = abs(initialEnergy - sum(energy)) + 1\\n        for exp in experience:\\n            if exp >= initialExperience:\\n                train_hours += exp - initialExperience + 1\\n                initialExperience += exp - initialExperience + 1 + exp\\n            else:\\n                initialExperience += exp\\n        return train_hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385857,
                "title": "easy-for-unferstanding-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n\\n    let count = energy.reduce((sum, current) => sum + current, 0)-initialEnergy+1;\\n    if (count<0) {count=0;}\\n    \\n    \\n\\n    for (let i=0; i<experience.length; i++){ \\n    \\n        if (experience[i]<initialExperience) {initialExperience+=experience[i];}\\n    \\n    else {count+=experience[i]-initialExperience+1;initialExperience+=experience[i]-initialExperience+experience[i]+1; }\\n    if (count<0) {count=0;}\\n    }\\n    return count;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n\\n    let count = energy.reduce((sum, current) => sum + current, 0)-initialEnergy+1;\\n    if (count<0) {count=0;}\\n    \\n    \\n\\n    for (let i=0; i<experience.length; i++){ \\n    \\n        if (experience[i]<initialExperience) {initialExperience+=experience[i];}\\n    \\n    else {count+=experience[i]-initialExperience+1;initialExperience+=experience[i]-initialExperience+experience[i]+1; }\\n    if (count<0) {count=0;}\\n    }\\n    return count;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3384767,
                "title": "simple-solution-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let eng = initialEnergy\\n    let exp = initialExperience\\n    let rest = 0\\n\\n  \\tfor (let round = 0; round < energy.length; round++) {\\n        let enemyExp = experience[round]\\n        let enemyEng = energy[round]\\n      \\n        if (enemyExp >= exp && rest <= enemyExp - exp) {\\n      \\t    rest = (enemyExp - exp) + 1\\n        }\\n      \\n        exp += enemyExp\\n        eng -= enemyEng\\n    }\\n    \\n    if (eng <= 0) {\\n    \\trest += Math.abs(eng) + 1\\n    }\\n\\n    return rest\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let eng = initialEnergy\\n    let exp = initialExperience\\n    let rest = 0\\n\\n  \\tfor (let round = 0; round < energy.length; round++) {\\n        let enemyExp = experience[round]\\n        let enemyEng = energy[round]\\n      \\n        if (enemyExp >= exp && rest <= enemyExp - exp) {\\n      \\t    rest = (enemyExp - exp) + 1\\n        }\\n      \\n        exp += enemyExp\\n        eng -= enemyEng\\n    }\\n    \\n    if (eng <= 0) {\\n    \\trest += Math.abs(eng) + 1\\n    }\\n\\n    return rest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382290,
                "title": "easy-o-n-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    const hoursForEnergy = Math.max(energy.reduce((acc, e) => acc + e, 0) - initialEnergy + 1, 0);\\n\\n    let hoursForExpirience = 0;\\n    for (const e of experience) {\\n        if (initialExperience <= e) {\\n            const neededAdditionalExpirience = e - initialExperience + 1;\\n            hoursForExpirience += neededAdditionalExpirience;\\n            initialExperience += neededAdditionalExpirience;\\n        }\\n        initialExperience += e;\\n    }\\n\\n    return hoursForEnergy + hoursForExpirience;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    const hoursForEnergy = Math.max(energy.reduce((acc, e) => acc + e, 0) - initialEnergy + 1, 0);\\n\\n    let hoursForExpirience = 0;\\n    for (const e of experience) {\\n        if (initialExperience <= e) {\\n            const neededAdditionalExpirience = e - initialExperience + 1;\\n            hoursForExpirience += neededAdditionalExpirience;\\n            initialExperience += neededAdditionalExpirience;\\n        }\\n        initialExperience += e;\\n    }\\n\\n    return hoursForEnergy + hoursForExpirience;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328955,
                "title": "javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every step we check whether there is enough initial energy to defeat next competitor. If not, we should increase `hours` by `energy[i] + 1 - initialEnergy`, then `initialEnergy` becomes `energy[i] + 1`. We do the same with experience. Then we decrease amount of energy and decrease amount of experience before next step.\\n\\nTime complexity: O(n).\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n\\n    for (let i = 0; i < energy.length; i++ ) {\\n        if (initialEnergy <= energy[i]) {\\n            hours += energy[i] + 1 - initialEnergy;\\n            initialEnergy = energy[i] + 1;\\n        }\\n\\n        if (initialExperience <= experience[i]) {\\n            hours += experience[i] + 1 - initialExperience;\\n            initialExperience = experience[i] + 1;\\n        }\\n\\n        initialEnergy -= energy[i];\\n        initialExperience += experience[i];\\n    }\\n\\n    return hours;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n\\n    for (let i = 0; i < energy.length; i++ ) {\\n        if (initialEnergy <= energy[i]) {\\n            hours += energy[i] + 1 - initialEnergy;\\n            initialEnergy = energy[i] + 1;\\n        }\\n\\n        if (initialExperience <= experience[i]) {\\n            hours += experience[i] + 1 - initialExperience;\\n            initialExperience = experience[i] + 1;\\n        }\\n\\n        initialEnergy -= energy[i];\\n        initialExperience += experience[i];\\n    }\\n\\n    return hours;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324170,
                "title": "python-one-line-for-energy-one-loop-for-experience",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraining hours for **Energy** can be calculated in just one line.\\nTraining hours for **Experience** are a bit more complicated, the most evident way is to traverse them one by one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Energy** : All we need is an additional amount of energy which is slightly greater than the sum of all opponents\\' energy. If our initial energy is significantly high, we don\\'t have to train at all.\\n\\n        energy_hr = sum(energy) - initialEnergy + 1\\n\\n-   **Experience** : For each iteration, there are two values that need updating. First, the amount of training hours needed (**ex_hr**) for every single opponent. Second is our current experience (**initialExperience**), since we receive an extra amount of experience whenever we win.\\n\\n        if initialExperience <= experience[i]:\\n            s = (experience[i] - initialExperience) + 1\\n            ex_hr += s\\n            initialExperience += s + experience[i]\\n        else: initialExperience+=experience[i]\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: list[int], experience: list[int]) -> int:\\n        energy_hr = sum(energy) - initialEnergy + 1\\n        ex_hr,s = 0,0\\n        if energy_hr < 0:\\n            energy_hr = 0\\n\\n        if len(energy) == 1:\\n            if experience[0] < initialExperience:  \\n                ex_hr = 0\\n            else: ex_hr = experience[0] - initialExperience + 1\\n            return energy_hr + ex_hr\\n\\n        for i in range(len(experience)):\\n            if initialExperience <= experience[i]:\\n                s = (experience[i] - initialExperience) + 1\\n                ex_hr += s\\n                initialExperience += s + experience[i]\\n            else: initialExperience+=experience[i]\\n\\n\\n        return energy_hr + ex_hr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: list[int], experience: list[int]) -> int:\\n        energy_hr = sum(energy) - initialEnergy + 1\\n        ex_hr,s = 0,0\\n        if energy_hr < 0:\\n            energy_hr = 0\\n\\n        if len(energy) == 1:\\n            if experience[0] < initialExperience:  \\n                ex_hr = 0\\n            else: ex_hr = experience[0] - initialExperience + 1\\n            return energy_hr + ex_hr\\n\\n        for i in range(len(experience)):\\n            if initialExperience <= experience[i]:\\n                s = (experience[i] - initialExperience) + 1\\n                ex_hr += s\\n                initialExperience += s + experience[i]\\n            else: initialExperience+=experience[i]\\n\\n\\n        return energy_hr + ex_hr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306946,
                "title": "python-o-n-time-complexity",
                "content": "This is Larry\\'s solution. Credits to him.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote that it is said in the question that energy and experience should be strictly greater while defeating someone. Hence, 1 more level should be added to whenever our initial energy and experience level becomes equal to defeating someone. Reminder that energy decreases after defeating and experience increases.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        n=len(energy)\\n\\n        needed=0\\n        current_energy=initialEnergy\\n        current_experience=initialExperience\\n\\n        for i in range(n):\\n            if current_energy<=energy[i]:\\n                delta=energy[i]-current_energy+1\\n                needed+=delta\\n                current_energy+=delta\\n            if current_experience<=experience[i]:\\n                delta=experience[i]-current_experience+1\\n                needed+=delta\\n                current_experience+=delta\\n            current_energy-=energy[i]\\n            current_experience+=experience[i]\\n        return needed\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        n=len(energy)\\n\\n        needed=0\\n        current_energy=initialEnergy\\n        current_experience=initialExperience\\n\\n        for i in range(n):\\n            if current_energy<=energy[i]:\\n                delta=energy[i]-current_energy+1\\n                needed+=delta\\n                current_energy+=delta\\n            if current_experience<=experience[i]:\\n                delta=experience[i]-current_experience+1\\n                needed+=delta\\n                current_experience+=delta\\n            current_energy-=energy[i]\\n            current_experience+=experience[i]\\n        return needed\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302435,
                "title": "bf-c-solution",
                "content": "```\\nint MAX(int a, int b){ return a>b?a:b; }\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }\\n\\n    ans += (initialEnergy > energySum)? 0 : energySum - initialEnergy + 1;\\n    ans += minExp;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint MAX(int a, int b){ return a>b?a:b; }\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }\\n\\n    ans += (initialEnergy > energySum)? 0 : energySum - initialEnergy + 1;\\n    ans += minExp;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297997,
                "title": "java-100-faster-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEnergy and experience are idential except that we add vs subtract so we can make a method for it with an add/subtract boolean.\\n\\nWe need to capture the difference when there is a deficit and add 1 to get our total hours to train\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain the current value for either energy or experience while going through the arrays. When we have a deficit, we find the difference, and add 1 since it has to be entirely greater than the opponent. We add that difference to our total hours to train and continue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis requires linear time $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis requires constant space $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        return getTrainingHours(initialEnergy, energy, false) + getTrainingHours(initialExperience, experience, true);\\n    }\\n\\n    private int getTrainingHours(int initial, int[] enemies, boolean useAddition) {\\n        int current = initial;\\n        int trainingHours = 0;\\n        for (int i = 0; i < enemies.length; i++) {\\n            int enemy = enemies[i];\\n            if (current <= enemy) {\\n                int diff = enemy - current + 1;\\n                trainingHours += diff;\\n                current += diff;\\n            }\\n\\n            if (useAddition)\\n                current += enemy;\\n            else\\n                current -= enemy;\\n        }\\n        return trainingHours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        return getTrainingHours(initialEnergy, energy, false) + getTrainingHours(initialExperience, experience, true);\\n    }\\n\\n    private int getTrainingHours(int initial, int[] enemies, boolean useAddition) {\\n        int current = initial;\\n        int trainingHours = 0;\\n        for (int i = 0; i < enemies.length; i++) {\\n            int enemy = enemies[i];\\n            if (current <= enemy) {\\n                int diff = enemy - current + 1;\\n                trainingHours += diff;\\n                current += diff;\\n            }\\n\\n            if (useAddition)\\n                current += enemy;\\n            else\\n                current -= enemy;\\n        }\\n        return trainingHours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293153,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// O(n)\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let le = 0;\\n    let lex = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (initialEnergy <= energy[i]) {\\n            let val = Math.abs(initialEnergy - energy[i]) + 1;\\n            le += val;\\n            initialEnergy += val;\\n        }\\n        initialEnergy -= energy[i];\\n        if (initialExperience <= experience[i]) {\\n            let val = Math.abs(initialExperience - experience[i]) + 1;\\n            lex += val;\\n            initialExperience += val;\\n        }\\n        initialExperience += experience[i];\\n    }\\n    return le + lex;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n)\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let le = 0;\\n    let lex = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (initialEnergy <= energy[i]) {\\n            let val = Math.abs(initialEnergy - energy[i]) + 1;\\n            le += val;\\n            initialEnergy += val;\\n        }\\n        initialEnergy -= energy[i];\\n        if (initialExperience <= experience[i]) {\\n            let val = Math.abs(initialExperience - experience[i]) + 1;\\n            lex += val;\\n            initialExperience += val;\\n        }\\n        initialExperience += experience[i];\\n    }\\n    return le + lex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290264,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u91DD\\u5C0D\\u6BCF\\u4E00\\u56DE\\u5408\\u5224\\u65B7Energy\\u3001Experience\\n1. initialEnergy <= energy[i] \\u2192 \\u8981\\u8A13\\u7DF4energy[i]-initialEnergy+1 \\u5C0F\\u6642\\n2. initialExperience<=experience[i] \\u2192 experience[i]-initialExperience+1 \\u5C0F\\u6642\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:97.78%(71ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:82.22%(38.8MB)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hour = 0;\\n        int i = 0;\\n        while(i < energy.Length)\\n        {\\n            if(initialEnergy> energy[i] && initialExperience>experience[i])\\n            {\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n                i++;\\n            }else\\n            {\\n                if(initialEnergy <= energy[i])\\n                {\\n                    hour+=energy[i]-initialEnergy+1;\\n                    initialEnergy = energy[i] +1;                    \\n                }\\n                if(initialExperience<=experience[i])\\n                {\\n                    hour+=experience[i]-initialExperience+1;\\n                    initialExperience = experience[i]+1;                    \\n                }\\n\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hour = 0;\\n        int i = 0;\\n        while(i < energy.Length)\\n        {\\n            if(initialEnergy> energy[i] && initialExperience>experience[i])\\n            {\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n                i++;\\n            }else\\n            {\\n                if(initialEnergy <= energy[i])\\n                {\\n                    hour+=energy[i]-initialEnergy+1;\\n                    initialEnergy = energy[i] +1;                    \\n                }\\n                if(initialExperience<=experience[i])\\n                {\\n                    hour+=experience[i]-initialExperience+1;\\n                    initialExperience = experience[i]+1;                    \\n                }\\n\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290124,
                "title": "lc-2383-e-python3-a-plain-solution",
                "content": "`min_energy_hours` and `min_exp_hours` are calculated as requested independently.\\n\\n```python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        min_energy_hours = max(0, sum(energy) + 1 - initialEnergy)\\n        min_exp_hours = 0\\n        exp = initialExperience\\n        for v in experience:\\n            if (diff := v + 1 - exp) > min_exp_hours:\\n                min_exp_hours = diff\\n            exp += v\\n        \\n        return min_energy_hours + min_exp_hours\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        min_energy_hours = max(0, sum(energy) + 1 - initialEnergy)\\n        min_exp_hours = 0\\n        exp = initialExperience\\n        for v in experience:\\n            if (diff := v + 1 - exp) > min_exp_hours:\\n                min_exp_hours = diff\\n            exp += v\\n        \\n        return min_energy_hours + min_exp_hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277215,
                "title": "o-n-c-code",
                "content": "# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0, n = experience.size();\\n        int reqEnergy = 0, sum = accumulate(energy.begin(), energy.end(), 0);\\n        int reqXP = 0;\\n        if(sum >= initialEnergy) reqEnergy = sum - initialEnergy + 1;\\n        total += reqEnergy;\\n        cout << \"energy = \" << reqEnergy << endl;\\n        for(int i = 0; i < n; i++){\\n            if(initialExperience > experience[i]) initialExperience += experience[i];\\n            else{\\n                total += experience[i] - initialExperience + 1;\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i];\\n            }\\n        }\\n        cout << \"xp = \" << total - reqEnergy;\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0, n = experience.size();\\n        int reqEnergy = 0, sum = accumulate(energy.begin(), energy.end(), 0);\\n        int reqXP = 0;\\n        if(sum >= initialEnergy) reqEnergy = sum - initialEnergy + 1;\\n        total += reqEnergy;\\n        cout << \"energy = \" << reqEnergy << endl;\\n        for(int i = 0; i < n; i++){\\n            if(initialExperience > experience[i]) initialExperience += experience[i];\\n            else{\\n                total += experience[i] - initialExperience + 1;\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i];\\n            }\\n        }\\n        cout << \"xp = \" << total - reqEnergy;\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3226266,
                "title": "js-javascript-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(en, ex, energy, experience) {\\n    let hours = 0\\n    for (let i = 0; i < energy.length; i++){\\n        if (en <= energy[i]){\\n            hours += energy[i] - en + 1\\n            en = 1\\n        } else {\\n            en -= energy[i]\\n        }\\n        if (ex <= experience[i]){\\n            hours += experience[i] - ex + 1\\n            ex = experience[i] + 1\\n        }\\n        ex += experience[i]\\n\\n    }\\n    return hours\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(en, ex, energy, experience) {\\n    let hours = 0\\n    for (let i = 0; i < energy.length; i++){\\n        if (en <= energy[i]){\\n            hours += energy[i] - en + 1\\n            en = 1\\n        } else {\\n            en -= energy[i]\\n        }\\n        if (ex <= experience[i]){\\n            hours += experience[i] - ex + 1\\n            ex = experience[i] + 1\\n        }\\n        ex += experience[i]\\n\\n    }\\n    return hours\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221942,
                "title": "python-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIterate through the energy and experience arrays.\\nIf your `initialEnergy` is not enough, add the difference plus one to the result and your `initialEnergy` becomes 1.\\nIf your `initialExperience` is not enough, add the difference plus one to the result and your `initialExperience` becomes `2*experience+1`.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        res = [0, 0]\\n        for en, ex in zip(energy, experience):\\n            if initialEnergy <= en:\\n                res[0] += (en - initialEnergy) + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= en\\n\\n            if initialExperience <= ex:\\n                res[1] += (ex - initialExperience) + 1\\n                initialExperience = ex * 2 + 1\\n            else:\\n                initialExperience += ex\\n        return sum(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        res = [0, 0]\\n        for en, ex in zip(energy, experience):\\n            if initialEnergy <= en:\\n                res[0] += (en - initialEnergy) + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= en\\n\\n            if initialExperience <= ex:\\n                res[1] += (ex - initialExperience) + 1\\n                initialExperience = ex * 2 + 1\\n            else:\\n                initialExperience += ex\\n        return sum(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184690,
                "title": "short-kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        val n = energy.size\\n        var needEng = 0\\n        var needExp = 0\\n        var currExp = initialExperience\\n        for (i in 0..n-1) {\\n            needEng += energy[i]\\n            needExp += maxOf(experience[i] - currExp - needExp + 1, 0)\\n            currExp += experience[i]\\n        }\\n        return maxOf(needEng - initialEnergy + 1, 0) + needExp\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        val n = energy.size\\n        var needEng = 0\\n        var needExp = 0\\n        var currExp = initialExperience\\n        for (i in 0..n-1) {\\n            needEng += energy[i]\\n            needExp += maxOf(experience[i] - currExp - needExp + 1, 0)\\n            currExp += experience[i]\\n        }\\n        return maxOf(needEng - initialEnergy + 1, 0) + needExp\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153522,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s quite easy to see that the total energy required is one plus the sum of the energy array, and to find the total experience, we need only to find the maximum of the experience minus the accumulated experience beforehand and add one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple one time loop is sufficient to find both of our required values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        expn = initialExperience\\n        total = 0\\n        for exp in experience:\\n            if exp + 1 - total > expn:\\n                expn = exp + 1 - total\\n            total += exp\\n        energyn = sum(energy) + 1 - initialEnergy if sum(energy) + 1 > initialEnergy else 0\\n        return energyn + expn - initialExperience\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        expn = initialExperience\\n        total = 0\\n        for exp in experience:\\n            if exp + 1 - total > expn:\\n                expn = exp + 1 - total\\n            total += exp\\n        energyn = sum(energy) + 1 - initialEnergy if sum(energy) + 1 > initialEnergy else 0\\n        return energyn + expn - initialExperience\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141253,
                "title": "javascript-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n    const n = energy.length;\\n\\n    for (let i = 0; i<n; i++) {\\n        if (initialEnergy > energy[i] && initialExperience > experience[i]) {\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        } else {\\n            if (initialEnergy <= energy[i] && initialExperience <= experience[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                hours += (experience[i] - initialExperience)+1;\\n                initialEnergy = 1\\n                initialExperience = experience[i] +1+experience[i];\\n            } else if (initialEnergy <= energy[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                initialEnergy = 1;\\n                initialExperience += experience[i];\\n            } else if (initialExperience <= experience[i]) {\\n                hours += (experience[i] - initialExperience)+1;\\n                initialExperience = experience[i] +1+experience[i];\\n                initialEnergy -= energy[i]\\n            }\\n        }\\n    }\\n    return hours;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n    const n = energy.length;\\n\\n    for (let i = 0; i<n; i++) {\\n        if (initialEnergy > energy[i] && initialExperience > experience[i]) {\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        } else {\\n            if (initialEnergy <= energy[i] && initialExperience <= experience[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                hours += (experience[i] - initialExperience)+1;\\n                initialEnergy = 1\\n                initialExperience = experience[i] +1+experience[i];\\n            } else if (initialEnergy <= energy[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                initialEnergy = 1;\\n                initialExperience += experience[i];\\n            } else if (initialExperience <= experience[i]) {\\n                hours += (experience[i] - initialExperience)+1;\\n                initialExperience = experience[i] +1+experience[i];\\n                initialEnergy -= energy[i]\\n            }\\n        }\\n    }\\n    return hours;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135419,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130846,
                "title": "beats-99-79",
                "content": "# Upvote it\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        if sum(energy) >= initialEnergy: c = sum(energy) - initialEnergy + 1\\n        else: c = 0\\n        for e in experience:\\n            if initialExperience > e: initialExperience += e\\n            else:\\n                diff = e - initialExperience + 1\\n                c += diff\\n                initialExperience += diff + e\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        if sum(energy) >= initialEnergy: c = sum(energy) - initialEnergy + 1\\n        else: c = 0\\n        for e in experience:\\n            if initialExperience > e: initialExperience += e\\n            else:\\n                diff = e - initialExperience + 1\\n                c += diff\\n                initialExperience += diff + e\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125228,
                "title": "java-greedy-easy-to-understand-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res=0;\\n        int sum=0;\\n        for(int x:energy){\\n            sum+=x;\\n        }\\n        if(initialEnergy<=sum){\\n            res+=sum+1-initialEnergy;\\n        }\\n        for(int y:experience){\\n            if(initialExperience>y){\\n                initialExperience+=y;\\n            }\\n            else{\\n                res+=y+1-initialExperience;\\n                initialExperience+=y+(y+1)-initialExperience;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res=0;\\n        int sum=0;\\n        for(int x:energy){\\n            sum+=x;\\n        }\\n        if(initialEnergy<=sum){\\n            res+=sum+1-initialEnergy;\\n        }\\n        for(int y:experience){\\n            if(initialExperience>y){\\n                initialExperience+=y;\\n            }\\n            else{\\n                res+=y+1-initialExperience;\\n                initialExperience+=y+(y+1)-initialExperience;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115485,
                "title": "find-out-train-of-en-and-ex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int en, int ex, int[] e1, int[] e2) {\\n        int a = 0, b = 0;  //a is train of en and b is train of ex\\n        for(int n: e1)\\n        {\\n            if(en <= n) \\n            {\\n                a += n - en + 1;\\n                en = 1;\\n            }\\n            else\\n                 en -= n;\\n        }\\n        for(int n: e2)\\n        {\\n            if(ex <= n) \\n            {\\n                b += n - ex + 1;\\n                ex = n + 1;\\n            }\\n            ex += n;\\n        }\\n        return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int en, int ex, int[] e1, int[] e2) {\\n        int a = 0, b = 0;  //a is train of en and b is train of ex\\n        for(int n: e1)\\n        {\\n            if(en <= n) \\n            {\\n                a += n - en + 1;\\n                en = 1;\\n            }\\n            else\\n                 en -= n;\\n        }\\n        for(int n: e2)\\n        {\\n            if(ex <= n) \\n            {\\n                b += n - ex + 1;\\n                ex = n + 1;\\n            }\\n            ex += n;\\n        }\\n        return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104607,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        \\n        var ee = 0\\n        var ce = initialEnergy\\n        \\n        for e in energy {\\n            while e >= ce {\\n                ce += 1\\n                ee += 1\\n            }\\n            ce -= e\\n        }\\n        \\n        var ex = 0\\n        var cx = initialExperience\\n        \\n        for e in experience {\\n            while e >= cx {\\n                ex += 1\\n                cx += 1\\n            }\\n            cx += e\\n        }\\n        \\n        return ee + ex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        \\n        var ee = 0\\n        var ce = initialEnergy\\n        \\n        for e in energy {\\n            while e >= ce {\\n                ce += 1\\n                ee += 1\\n            }\\n            ce -= e\\n        }\\n        \\n        var ex = 0\\n        var cx = initialExperience\\n        \\n        for e in experience {\\n            while e >= cx {\\n                ex += 1\\n                cx += 1\\n            }\\n            cx += e\\n        }\\n        \\n        return ee + ex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094738,
                "title": "python-attempt-that-works-tried-to-keep-it-simple",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTried to keep it as simple as possible. By far not the best solution but I think its not too difficult to follow.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        \"\"\"\\n        :type initialEnergy: int\\n        :type initialExperience: int\\n        :type energy: List[int]\\n        :type experience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Number of hours needed for Training\\n        hrs_train = 0\\n        # Total Opposition Energy\\n        opp_energy = 0\\n\\n        # Calculating Total Opposition Energy\\n        for i in energy:\\n            opp_energy += i\\n\\n        #print(\"Opponent Energy\",opp_energy)\\n\\n        # Adds hours to training whether initial Energy is 1 or greater\\n        if opp_energy - initialEnergy >= 0:\\n            if initialEnergy == 1:\\n                hrs_train = opp_energy \\n            else:    \\n                hrs_train = (opp_energy - initialEnergy) + 1\\n\\n        #print(\"Hours Energy Training Needed\", hrs_train)\\n        \\n        # For Total Experience Gained\\n        exp = initialExperience\\n        # Hours Difference for needed Experience\\n        diff = 0 \\n\\n        # Loop through experience and calculating number of necessarry training hours\\n        for i in range(len(experience)):\\n            # Finding difference between each experience value and dealing with it accordingly\\n            if exp < experience[i]:\\n                diff = experience[i] - exp + 1\\n                hrs_train = hrs_train + diff\\n\\n            # If experience is the same only an extra hour/ experience point is needed\\n            if exp == experience[i]:\\n                diff = 1\\n                hrs_train = hrs_train + 1\\n\\n            # Experience is calculated each turn to update new experience gained and appropriate difference if any\\n            exp = exp + experience[i] + diff\\n            diff = 0\\n\\n        return hrs_train\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        \"\"\"\\n        :type initialEnergy: int\\n        :type initialExperience: int\\n        :type energy: List[int]\\n        :type experience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Number of hours needed for Training\\n        hrs_train = 0\\n        # Total Opposition Energy\\n        opp_energy = 0\\n\\n        # Calculating Total Opposition Energy\\n        for i in energy:\\n            opp_energy += i\\n\\n        #print(\"Opponent Energy\",opp_energy)\\n\\n        # Adds hours to training whether initial Energy is 1 or greater\\n        if opp_energy - initialEnergy >= 0:\\n            if initialEnergy == 1:\\n                hrs_train = opp_energy \\n            else:    \\n                hrs_train = (opp_energy - initialEnergy) + 1\\n\\n        #print(\"Hours Energy Training Needed\", hrs_train)\\n        \\n        # For Total Experience Gained\\n        exp = initialExperience\\n        # Hours Difference for needed Experience\\n        diff = 0 \\n\\n        # Loop through experience and calculating number of necessarry training hours\\n        for i in range(len(experience)):\\n            # Finding difference between each experience value and dealing with it accordingly\\n            if exp < experience[i]:\\n                diff = experience[i] - exp + 1\\n                hrs_train = hrs_train + diff\\n\\n            # If experience is the same only an extra hour/ experience point is needed\\n            if exp == experience[i]:\\n                diff = 1\\n                hrs_train = hrs_train + 1\\n\\n            # Experience is calculated each turn to update new experience gained and appropriate difference if any\\n            exp = exp + experience[i] + diff\\n            diff = 0\\n\\n        return hrs_train\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092784,
                "title": "simple-cpp-datta-bayo",
                "content": "Easy condition Traversal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours =0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                hours += energy[i]-initialEnergy+1;\\n                initialEnergy+=energy[i]-initialEnergy+1;\\n\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                hours+=experience[i]-initialExperience+1;\\n                initialExperience+=experience[i]-initialExperience+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours =0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                hours += energy[i]-initialEnergy+1;\\n                initialEnergy+=energy[i]-initialEnergy+1;\\n\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                hours+=experience[i]-initialExperience+1;\\n                initialExperience+=experience[i]-initialExperience+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088002,
                "title": "java-0ms-clear-explications",
                "content": "# Approach\\n1. Traverse both arrays with an index and\\n    - calculate the totalEnergy by adding energy[i]\\n    - determine if this round you need Experience or not. neededRoundExp.Start with gainedExperience = initialExperience\\n    If current exp lvl >= gainedEnergy, you need the diff + 1. neededRoundExp = diff + 1, else you need  0.\\n    Add this neededRoundExp to a global var.(totalNeededExp)\\n    Also increment your gained experience with exp[i] + nededRoundExperience.\\n2. Return the sum between totalNeededExp and (if neededEnergy >= initial, add the diff+1, else 0)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(11)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int neededRoundExperience = 0, neededTotalExperience = 0, gainedExperience = initialExperience;\\n        int neededEnergy = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            neededRoundExperience = experience[i] >= gainedExperience ? (experience[i]  - gainedExperience) + 1 : 0;\\n            gainedExperience += experience[i] + neededRoundExperience;\\n            neededTotalExperience += neededRoundExperience;\\n            neededEnergy += energy[i];\\n        }\\n        return neededTotalExperience + (neededEnergy >= initialEnergy ? ++neededEnergy - initialEnergy : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int neededRoundExperience = 0, neededTotalExperience = 0, gainedExperience = initialExperience;\\n        int neededEnergy = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            neededRoundExperience = experience[i] >= gainedExperience ? (experience[i]  - gainedExperience) + 1 : 0;\\n            gainedExperience += experience[i] + neededRoundExperience;\\n            neededTotalExperience += neededRoundExperience;\\n            neededEnergy += energy[i];\\n        }\\n        return neededTotalExperience + (neededEnergy >= initialEnergy ? ++neededEnergy - initialEnergy : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075692,
                "title": "c",
                "content": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int ans = 0 ;\\n    // analyze energy\\n    int e = 0 ;\\n    for(int i = 0; i < energySize ; i++){\\n        e += energy[i] ;\\n    }\\n    e++ ;\\n    ans += ( (initialEnergy < e )) ? e - initialEnergy : 0 ;\\n    \\n    //analyze experience\\n    int cur = initialExperience ;\\n    for(int i = 0; i < experienceSize; i++){\\n        if( cur > experience[i] ){\\n            cur += experience[i] ;\\n        }\\n        else{\\n            ans += (experience[i] - cur + 1) ;\\n            cur = experience[i] * 2 + 1 ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int ans = 0 ;\\n    // analyze energy\\n    int e = 0 ;\\n    for(int i = 0; i < energySize ; i++){\\n        e += energy[i] ;\\n    }\\n    e++ ;\\n    ans += ( (initialEnergy < e )) ? e - initialEnergy : 0 ;\\n    \\n    //analyze experience\\n    int cur = initialExperience ;\\n    for(int i = 0; i < experienceSize; i++){\\n        if( cur > experience[i] ){\\n            cur += experience[i] ;\\n        }\\n        else{\\n            ans += (experience[i] - cur + 1) ;\\n            cur = experience[i] * 2 + 1 ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058582,
                "title": "explanation-in-same-story-form",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours=0;//Cause we try to defeat with initalEnergy and initialExperience.\\n        for(int i=0;i<energy.Length;i++)//iterate through every element of opponents energy and experience\\n        {\\n            int extraEnergy = Math.Max(0,energy[i]-initialEnergy+1);//if energy required for current oppponent then required energy is added else 0 is added.\\n            initialEnergy+=extraEnergy;\\n\\n            int extraexp = Math.Max(0,experience[i]-initialExperience+1);//if experience required for current oppponent then required experience is added else 0 is added.\\n            initialExperience+=extraexp;\\n\\n            hours+=extraEnergy+extraexp;//hours of training increased here\\n            initialEnergy-=energy[i];//energy after defeating opponent is reduced.\\n            initialExperience+=experience[i];//Experinece of current opponnet is added cause he is defeated.\\n        }\\n        return hours;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours=0;//Cause we try to defeat with initalEnergy and initialExperience.\\n        for(int i=0;i<energy.Length;i++)//iterate through every element of opponents energy and experience\\n        {\\n            int extraEnergy = Math.Max(0,energy[i]-initialEnergy+1);//if energy required for current oppponent then required energy is added else 0 is added.\\n            initialEnergy+=extraEnergy;\\n\\n            int extraexp = Math.Max(0,experience[i]-initialExperience+1);//if experience required for current oppponent then required experience is added else 0 is added.\\n            initialExperience+=extraexp;\\n\\n            hours+=extraEnergy+extraexp;//hours of training increased here\\n            initialEnergy-=energy[i];//energy after defeating opponent is reduced.\\n            initialExperience+=experience[i];//Experinece of current opponnet is added cause he is defeated.\\n        }\\n        return hours;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026666,
                "title": "python-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        hours=0\\n        if sum(energy)>=initialEnergy:\\n            hours = sum(energy)-initialEnergy+1\\n        exph = 0\\n        for exp in experience:\\n            exph = max(1 + exp - initialExperience, exph)\\n            initialExperience += exp\\n        \\n        print(hours, exph)\\n        return hours+exph\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        hours=0\\n        if sum(energy)>=initialEnergy:\\n            hours = sum(energy)-initialEnergy+1\\n        exph = 0\\n        for exp in experience:\\n            exph = max(1 + exp - initialExperience, exph)\\n            initialExperience += exp\\n        \\n        print(hours, exph)\\n        return hours+exph\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020863,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        energy = max(0, sum(energy) - initialEnergy + 1)\\n\\n        exp = max_exp = 0\\n        for x in experience:\\n            max_exp = max(max_exp, x - exp)\\n            exp += x\\n        experience = max(0, max_exp - initialExperience + 1)\\n\\n        return energy + experience\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        energy = max(0, sum(energy) - initialEnergy + 1)\\n\\n        exp = max_exp = 0\\n        for x in experience:\\n            max_exp = max(max_exp, x - exp)\\n            exp += x\\n        experience = max(0, max_exp - initialExperience + 1)\\n\\n        return energy + experience\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020794,
                "title": "simple-js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(inen, inex, en, ex) {\\n    sol=0;\\n    for(i in en){\\n       if(inen>en[i]) inen=inen-en[i];\\n       else{\\n           sol=sol+(en[i]-inen+1) \\n           inen=1;\\n       }\\n\\n       if(inex>ex[i]) inex=inex+ex[i];\\n       else{\\n           sol=sol+(ex[i]-inex+1);\\n           inex=2*ex[i]+1\\n       }\\n    }\\n    return sol;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(inen, inex, en, ex) {\\n    sol=0;\\n    for(i in en){\\n       if(inen>en[i]) inen=inen-en[i];\\n       else{\\n           sol=sol+(en[i]-inen+1) \\n           inen=1;\\n       }\\n\\n       if(inex>ex[i]) inex=inex+ex[i];\\n       else{\\n           sol=sol+(ex[i]-inex+1);\\n           inex=2*ex[i]+1\\n       }\\n    }\\n    return sol;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989476,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n       int trainHoursRequired = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n            initialEnergy -= energy[i];\\n            trainHoursRequired += extraEnergy;\\n        }\\n\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n            initialExperience += experience[i];\\n            trainHoursRequired +=  extraExperience;\\n        }\\n        return trainHoursRequired ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n       int trainHoursRequired = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n            initialEnergy -= energy[i];\\n            trainHoursRequired += extraEnergy;\\n        }\\n\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n            initialExperience += experience[i];\\n            trainHoursRequired +=  extraExperience;\\n        }\\n        return trainHoursRequired ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973349,
                "title": "java-o-n-100-runtime-100-memory",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energies, int[] experience) {\\n        return getNumberOfHoursForEnergy(initialEnergy, energies) + \\n        getNumberOfHoursForExperience(initialExperience, experience);\\n    }\\n\\n    private int getNumberOfHoursForEnergy(int initialEnergy, int[] energies) {\\n        int sum = getSum(energies);\\n        return initialEnergy > sum ? 0 : sum - initialEnergy + 1;\\n    }\\n\\n    private int getNumberOfHoursForExperience(int initialExperience, int[] experience) {\\n        int hours = 0;\\n\\n        for (int xp: experience) {\\n            if (initialExperience <= xp) {\\n                int diff = xp - initialExperience + 1; \\n                hours += diff;\\n                initialExperience += diff;\\n            }\\n            \\n            initialExperience += xp;\\n        }\\n\\n        return hours;\\n    }\\n\\n    private int getSum(int[] arr) {\\n        int sum = 0;\\n\\n        for (int num: arr)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energies, int[] experience) {\\n        return getNumberOfHoursForEnergy(initialEnergy, energies) + \\n        getNumberOfHoursForExperience(initialExperience, experience);\\n    }\\n\\n    private int getNumberOfHoursForEnergy(int initialEnergy, int[] energies) {\\n        int sum = getSum(energies);\\n        return initialEnergy > sum ? 0 : sum - initialEnergy + 1;\\n    }\\n\\n    private int getNumberOfHoursForExperience(int initialExperience, int[] experience) {\\n        int hours = 0;\\n\\n        for (int xp: experience) {\\n            if (initialExperience <= xp) {\\n                int diff = xp - initialExperience + 1; \\n                hours += diff;\\n                initialExperience += diff;\\n            }\\n            \\n            initialExperience += xp;\\n        }\\n\\n        return hours;\\n    }\\n\\n    private int getSum(int[] arr) {\\n        int sum = 0;\\n\\n        for (int num: arr)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966841,
                "title": "full-explanation-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Since we know an hour of work before either gets us one more energy or experience, it is fairly straightforward to make 1 pass through the array, compute the number of hours of work we need to do to get the minimum required energy, compute the number of hours of work we need to do to get the minimum required experience, and add them together.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do one loop through the energy and experience array. since their length is the same, we do all the computation within a single loop. \\nTwo cases. How to deal with energy? How to deal with effort?\\n1. Initialize two variables, initialEnergy and initialExperience, and set them equal to the parameters in the problem\\n2. for each value in the energy array, we are going to test our initialenergy against it. if initialenergy is greater than it, great, no need to do any work before we fight all n bad guys. just update initialenergy, so it is now equal to initialenergy - energy[i] where i is the currentindex. If energy[i] is greater than or equal to initial energy, we need to add the number of hours to get initialenergy 1 above energy[i] to the counter (ret), and run simulation accordingly.\\nUse similar logic for experience, but remember experience is added, not subtracted.\\n3. add the computations together\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ret = 0\\n        for i in range(0, len(energy)):\\n            if energy[i] >= initialEnergy:\\n                ret += energy[i] - initialEnergy + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= energy[i]\\n            if experience[i] >= initialExperience:\\n                ret += experience[i] - initialExperience + 1\\n                initialExperience = experience[i] + 1 + experience[i]\\n\\n            else:\\n                initialExperience += experience[i]\\n        return ret\\n   \\n            \\n                \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ret = 0\\n        for i in range(0, len(energy)):\\n            if energy[i] >= initialEnergy:\\n                ret += energy[i] - initialEnergy + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= energy[i]\\n            if experience[i] >= initialExperience:\\n                ret += experience[i] - initialExperience + 1\\n                initialExperience = experience[i] + 1 + experience[i]\\n\\n            else:\\n                initialExperience += experience[i]\\n        return ret\\n   \\n            \\n                \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948370,
                "title": "c-simple-concise-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int res = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n; i++) {\\n            if(energy[i] >= initialEnergy) {\\n                int diff = energy[i] - initialEnergy + 1;\\n                res += diff; initialEnergy += diff;\\n            }\\n            if(experience[i] >= initialExperience) {\\n                int diff = experience[i] - initialExperience + 1;\\n                res += diff; initialExperience += diff;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int res = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n; i++) {\\n            if(energy[i] >= initialEnergy) {\\n                int diff = energy[i] - initialEnergy + 1;\\n                res += diff; initialEnergy += diff;\\n            }\\n            if(experience[i] >= initialExperience) {\\n                int diff = experience[i] - initialExperience + 1;\\n                res += diff; initialExperience += diff;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939038,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for ene, exp in zip(energy, experience):\\n            if initialEnergy <= ene:\\n                value = 1 + ene - initialEnergy\\n                initialEnergy += value\\n                result += value\\n            initialEnergy -= ene\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result\\n```\\n\\n```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for exp in experience:\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result + max(0, sum(energy) + 1 - initialEnergy)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for ene, exp in zip(energy, experience):\\n            if initialEnergy <= ene:\\n                value = 1 + ene - initialEnergy\\n                initialEnergy += value\\n                result += value\\n            initialEnergy -= ene\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result\\n```\n```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for exp in experience:\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result + max(0, sum(energy) + 1 - initialEnergy)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1735899,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 2044144,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1914905,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1830897,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1624061,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            }
        ]
    }
]