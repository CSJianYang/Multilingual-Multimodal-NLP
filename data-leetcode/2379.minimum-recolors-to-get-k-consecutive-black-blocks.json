[
    {
        "title": "Minimum Recolors to Get K Consecutive Black Blocks",
        "question_content": "You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.\nYou are also given an integer k, which is the desired number of consecutive black blocks.\nIn one operation, you can recolor a white block such that it becomes a black block.\nReturn the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.\n&nbsp;\nExample 1:\n\nInput: blocks = \"WBBWWBBWBW\", k = 7\nOutput: 3\nExplanation:\nOne way to achieve 7 consecutive black blocks is to recolor the 0th, 3rd, and 4th blocks\nso that blocks = \"BBBBBBBWBW\". \nIt can be shown that there is no way to achieve 7 consecutive black blocks in less than 3 operations.\nTherefore, we return 3.\n\nExample 2:\n\nInput: blocks = \"WBWBBBW\", k = 2\nOutput: 0\nExplanation:\nNo changes need to be made, since 2 consecutive black blocks already exist.\nTherefore, we return 0.\n\n&nbsp;\nConstraints:\n\n\tn == blocks.length\n\t1 <= n <= 100\n\tblocks[i] is either 'W' or 'B'.\n\t1 <= k <= n",
        "solutions": [
            {
                "id": 2454159,
                "title": "c-using-sliding-window-very-simple-and-easy-to-understand-solution",
                "content": "<b>Up Vote if you like the solution\\n- Sliding window of size K and minimize the no. of \\'W\\' in window \\n- When found a \\'W\\' in forward pointer, increament counter\\n- when found \\'W\\' in back pointer, decreament counter\\n- Take the minimum of counter as the answer\\n```\\nint minimumRecolors(string blocks, int k) {\\n    int back = 0, front = 0, count_w = 0, ans = INT_MAX;\\n    while(front < blocks.size()){\\n        if(blocks[front] == \\'W\\'){ count_w++; }\\n        if(front - back + 1 == k){\\n            ans = min(ans, count_w);\\n            if(blocks[back] == \\'W\\') count_w--;\\n            back++;\\n        }\\n        front++;\\n    }\\n    return ans;\\n}\\n```\\n\\n<b>Here is an article of my interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minimumRecolors(string blocks, int k) {\\n    int back = 0, front = 0, count_w = 0, ans = INT_MAX;\\n    while(front < blocks.size()){\\n        if(blocks[front] == \\'W\\'){ count_w++; }\\n        if(front - back + 1 == k){\\n            ans = min(ans, count_w);\\n            if(blocks[back] == \\'W\\') count_w--;\\n            back++;\\n        }\\n        front++;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454833,
                "title": "c-java-python-beginner-friendly-sliding-window",
                "content": "**flips:** to count the number of flips from `W -> B` till now.\\n**count:** to count the number of consecutive B\\'s.\\n**minOps:** minimum operations required.\\n**i:** start of window.\\n**j:** end of window.\\n\\nTC: O(n)\\nSC: O(1)\\n\\n\\u2714 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size(), minOps = 1e9, flips = 0, count = 0, i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            if(blocks[j] == \\'W\\') {\\n                flips++;\\n                count++;\\n            } else if(blocks[j] == \\'B\\') {\\n                count++;\\n            }\\n            if(count == k) {\\n                minOps = min(minOps, flips);\\n                if(blocks[i] == \\'W\\') {\\n                    flips--;\\n                    count--;\\n                } else count--;\\n                i++;\\n            }\\n        }\\n        return minOps;\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int n = blocks.length(), minOps = Integer.MAX_VALUE, flips = 0, count = 0, i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            if(blocks.charAt(j) == \\'W\\') {\\n                flips++;\\n                count++;\\n            } else if(blocks.charAt(j) == \\'B\\') {\\n                count++;\\n            }\\n            if(count == k) {\\n                minOps = Math.min(minOps, flips);\\n                if(blocks.charAt(i) == \\'W\\') {\\n                    flips--;\\n                    count--;\\n                } else count--;\\n                i++;\\n            }\\n        }\\n        return minOps;\\n    }\\n}\\n```\\n\\n\\u2714 Python:\\n\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size(), minOps = 1e9, flips = 0, count = 0, i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            if(blocks[j] == \\'W\\') {\\n                flips++;\\n                count++;\\n            } else if(blocks[j] == \\'B\\') {\\n                count++;\\n            }\\n            if(count == k) {\\n                minOps = min(minOps, flips);\\n                if(blocks[i] == \\'W\\') {\\n                    flips--;\\n                    count--;\\n                } else count--;\\n                i++;\\n            }\\n        }\\n        return minOps;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int n = blocks.length(), minOps = Integer.MAX_VALUE, flips = 0, count = 0, i = 0;\\n        for(int j = 0; j < n; ++j) {\\n            if(blocks.charAt(j) == \\'W\\') {\\n                flips++;\\n                count++;\\n            } else if(blocks.charAt(j) == \\'B\\') {\\n                count++;\\n            }\\n            if(count == k) {\\n                minOps = Math.min(minOps, flips);\\n                if(blocks.charAt(i) == \\'W\\') {\\n                    flips--;\\n                    count--;\\n                } else count--;\\n                i++;\\n            }\\n        }\\n        return minOps;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, minOps, flips, count, i = len(blocks), 1e9, 0, 0, 0\\n        for j in range (n):\\n            if blocks[j] == \\'W\\':\\n                flips += 1\\n                count += 1\\n            elif blocks[j] == \\'B\\':\\n                count += 1\\n            if count == k:\\n                minOps = min(minOps, flips)\\n                if blocks[i] == \\'W\\':\\n                    flips -= 1\\n                    count -= 1\\n                else: count -= 1\\n                i += 1\\n        return minOps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454254,
                "title": "java-python-3-sliding-window-t-o-n-s-o-1-w-brief-explanation-and-analysis",
                "content": "Maintain a sliding window of size `k`, keep updating the count of `W` out of it and find the minimum.\\n\\nNote: `lo` and `hi` are the lower and upper bounds of the sliding window, exclusive and inclusive respectively.\\n```java\\n    public int minimumRecolors(String blocks, int k) {\\n        int min = Integer.MAX_VALUE;\\n        for (int lo = -1, hi = 0, white = 0; hi < blocks.length(); ++hi) {\\n            white += blocks.charAt(hi) == \\'W\\' ? 1 : 0;\\n            if (hi - lo >= k) { // the window reaches size of k.\\n                min = Math.min(min, white); // update  minimum.\\n                // slide 1 step right the lower bound of the sliding\\n                // window and update the value of white count.\\n                white -= blocks.charAt(++lo) == \\'W\\' ? 1 : 0;\\n            }\\n        }\\n        return min;\\n    }\\n```\\n```python\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        lo, white, mi = -1, 0, inf\\n        for hi, c in enumerate(blocks):\\n            if c == \\'W\\':\\n                white += 1\\n            if hi - lo >= k:\\n                mi = min(white, mi)\\n                lo += 1\\n                white -= blocks[lo] == \\'W\\' \\n        return mi\\n```\\nTime `O(k * n)` Python 3 code: - credit to **@chuhonghao01**\\n```python\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, mi = len(blocks), inf\\n        for i in range(n - k + 1):\\n            white = blocks.count(\\'W\\', i, i + k)\\n            mi = min(white, mi)\\n        return mi\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = blocks.length()`.\\n\\n----\\n\\nSimilar Problems: - Credit to **@haihoangdang91**.\\n\\n1151. Minimum Swaps to Group All 1\\'s Together\\n2134. Minimum Swaps to Group All 1\\'s Together II\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int minimumRecolors(String blocks, int k) {\\n        int min = Integer.MAX_VALUE;\\n        for (int lo = -1, hi = 0, white = 0; hi < blocks.length(); ++hi) {\\n            white += blocks.charAt(hi) == \\'W\\' ? 1 : 0;\\n            if (hi - lo >= k) { // the window reaches size of k.\\n                min = Math.min(min, white); // update  minimum.\\n                // slide 1 step right the lower bound of the sliding\\n                // window and update the value of white count.\\n                white -= blocks.charAt(++lo) == \\'W\\' ? 1 : 0;\\n            }\\n        }\\n        return min;\\n    }\\n```\n```python\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        lo, white, mi = -1, 0, inf\\n        for hi, c in enumerate(blocks):\\n            if c == \\'W\\':\\n                white += 1\\n            if hi - lo >= k:\\n                mi = min(white, mi)\\n                lo += 1\\n                white -= blocks[lo] == \\'W\\' \\n        return mi\\n```\n```python\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        n, mi = len(blocks), inf\\n        for i in range(n - k + 1):\\n            white = blocks.count(\\'W\\', i, i + k)\\n            mi = min(white, mi)\\n        return mi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2454187,
                "title": "sliding-window",
                "content": "**C++**\\n```cpp\\nint minimumRecolors(string blocks, int k) {\\n    int b = 0, mb = 0;\\n    for (int i = 0; i < blocks.size(); ++i) {\\n        b += blocks[i] == \\'B\\';\\n        if (i >= k)\\n            b -= blocks[i - k] == \\'B\\';\\n        mb = max(b, mb);\\n    }\\n    return k - mb;\\n}",
                "solutionTags": [],
                "code": "**C++**\\n```cpp\\nint minimumRecolors(string blocks, int k) {\\n    int b = 0, mb = 0;\\n    for (int i = 0; i < blocks.size(); ++i) {\\n        b += blocks[i] == \\'B\\';\\n        if (i >= k)\\n            b -= blocks[i - k] == \\'B\\';\\n        mb = max(b, mb);\\n    }\\n    return k - mb;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2454290,
                "title": "c-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k)\\n    {        \\n        int count=0;\\n        int i=0,j=0;\\n        int n = s.length();\\n        int mini=INT_MAX;\\n        while(j<n)\\n        {\\n            if(s[j]==\\'W\\')\\n                count++;\\n            \\n            if(j-i+1==k)\\n            {\\n                mini=min(mini,count);\\n                if(s[i]==\\'W\\')\\n                    count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mini;\\n    }\\n};\\n```\\nHope you liked it please upvote.\\nThanks.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k)\\n    {        \\n        int count=0;\\n        int i=0,j=0;\\n        int n = s.length();\\n        int mini=INT_MAX;\\n        while(j<n)\\n        {\\n            if(s[j]==\\'W\\')\\n                count++;\\n            \\n            if(j-i+1==k)\\n            {\\n                mini=min(mini,count);\\n                if(s[i]==\\'W\\')\\n                    count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459001,
                "title": "sliding-window",
                "content": "\\\\* Let\\'s start with a brute-force solution that better explains the sliding window logic.\\n\\n##### Java: \\n```java\\npublic int minimumRecolors(String blocks, int k) {\\n        int minimumRecolors = blocks.length();\\n        for (int left = 0, right = left + k - 1; right < blocks.length(); ++left, ++right) {\\n            minimumRecolors = Math.min(minimumRecolors, k - blackInSubstring(blocks.substring(left, right + 1)));\\n        }\\n        return minimumRecolors;\\n    }\\n\\n    private int blackInSubstring(String substring) {\\n        int count = 0;\\n        for (char c : substring.toCharArray()) {\\n            if (c == \\'B\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nAnd now we will not count the number \\'B\\' in the entire substring, but let\\'s see how it changed when a new character was added on the right and removed (if the window length is already more than k) on the left\\n\\n##### Java: \\n```java\\npublic int minimumRecolors(String blocks, int k) {\\n        int minimumRecolors = blocks.length();\\n        for (int right = 0, blackInCurrentWindow = 0; right < blocks.length(); ++right) {\\n            if (blocks.charAt(right) == \\'B\\')\\n                blackInCurrentWindow++;\\n            \\n            if (right >= k && blocks.charAt(right - k) == \\'B\\')\\n                blackInCurrentWindow--;\\n\\n            minimumRecolors = Math.min(minimumRecolors, k - blackInCurrentWindow);\\n        }\\n        return minimumRecolors;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int minimumRecolors = blocks.size();\\n        for (int right = 0, blackInCurrentWindow = 0; right < blocks.size(); ++right) {\\n            if (blocks[right] == \\'B\\')\\n                blackInCurrentWindow++;\\n\\n            if (right >= k && blocks[right - k] == \\'B\\')\\n                blackInCurrentWindow--;\\n\\n            minimumRecolors = min(minimumRecolors, k - blackInCurrentWindow);\\n        }\\n        return minimumRecolors;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Sliding Window"
                ],
                "code": "```java\\npublic int minimumRecolors(String blocks, int k) {\\n        int minimumRecolors = blocks.length();\\n        for (int left = 0, right = left + k - 1; right < blocks.length(); ++left, ++right) {\\n            minimumRecolors = Math.min(minimumRecolors, k - blackInSubstring(blocks.substring(left, right + 1)));\\n        }\\n        return minimumRecolors;\\n    }\\n\\n    private int blackInSubstring(String substring) {\\n        int count = 0;\\n        for (char c : substring.toCharArray()) {\\n            if (c == \\'B\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n```\n```java\\npublic int minimumRecolors(String blocks, int k) {\\n        int minimumRecolors = blocks.length();\\n        for (int right = 0, blackInCurrentWindow = 0; right < blocks.length(); ++right) {\\n            if (blocks.charAt(right) == \\'B\\')\\n                blackInCurrentWindow++;\\n            \\n            if (right >= k && blocks.charAt(right - k) == \\'B\\')\\n                blackInCurrentWindow--;\\n\\n            minimumRecolors = Math.min(minimumRecolors, k - blackInCurrentWindow);\\n        }\\n        return minimumRecolors;\\n    }\\n```\n```c++\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int minimumRecolors = blocks.size();\\n        for (int right = 0, blackInCurrentWindow = 0; right < blocks.size(); ++right) {\\n            if (blocks[right] == \\'B\\')\\n                blackInCurrentWindow++;\\n\\n            if (right >= k && blocks[right - k] == \\'B\\')\\n                blackInCurrentWindow--;\\n\\n            minimumRecolors = min(minimumRecolors, k - blackInCurrentWindow);\\n        }\\n        return minimumRecolors;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3108120,
                "title": "aditya-verma-approach-sliding-window-with-fixed-size-window-100-faster",
                "content": "# Intuition\\nSliding window with fixed size window.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i=0,j=0,n=s.length(),cnt=0,minn=INT_MAX;\\n        while(j<n){\\n            if(s[j]==\\'W\\'){\\n                cnt++;\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                minn=min(minn,cnt);\\n                if(s[i]==\\'W\\'){\\n                    cnt--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i=0,j=0,n=s.length(),cnt=0,minn=INT_MAX;\\n        while(j<n){\\n            if(s[j]==\\'W\\'){\\n                cnt++;\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                minn=min(minn,cnt);\\n                if(s[i]==\\'W\\'){\\n                    cnt--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469113,
                "title": "python-elegant-short-one-pass-sliding-window",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(k)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\t\\tmin_cost = cost = blocks[:k].count(\\'W\\')\\n\\n\\t\\t\\tfor i in range(k, len(blocks)):\\n\\t\\t\\t\\tcost = cost - (blocks[i - k] == \\'W\\') + (blocks[i] == \\'W\\')\\n\\t\\t\\t\\tmin_cost = min(min_cost, cost)\\n\\n\\t\\t\\treturn min_cost\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(k)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\t\\tmin_cost = cost = blocks[:k].count(\\'W\\')\\n\\n\\t\\t\\tfor i in range(k, len(blocks)):\\n\\t\\t\\t\\tcost = cost - (blocks[i - k] == \\'W\\') + (blocks[i] == \\'W\\')\\n\\t\\t\\t\\tmin_cost = min(min_cost, cost)\\n\\n\\t\\t\\treturn min_cost\\n",
                "codeTag": "Java"
            },
            {
                "id": 2455323,
                "title": "c-solution-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) \\n    {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            count+=(s[i]==\\'W\\');\\n        }\\n        ans=count;\\n        for(int i=k;i<s.size();i++)\\n        {\\n            count-=(s[i-k]==\\'W\\');\\n            count+=(s[i]==\\'W\\');\\n            ans=min(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) \\n    {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            count+=(s[i]==\\'W\\');\\n        }\\n        ans=count;\\n        for(int i=k;i<s.size();i++)\\n        {\\n            count-=(s[i-k]==\\'W\\');\\n            count+=(s[i]==\\'W\\');\\n            ans=min(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456360,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*n)**\\n**Java**\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min_count = Integer.MAX_VALUE;\\n        for(int i=0; i<blocks.length(); i++){\\n            int black_count = 0, count = 0;\\n            for(int j=i; j<blocks.length(); j++){\\n                if(blocks.charAt(j) == \\'B\\') black_count++;\\n                else{\\n                    black_count++;\\n                    count++;\\n                }\\n                if(black_count == k){\\n                    min_count = Math.min(min_count, count);\\n                    break;\\n                }\\n            }\\n        }\\n        return min_count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar minimumRecolors = function(blocks, k) {\\n    let min_count = Number.MAX_VALUE\\n    for(let i=0; i<blocks.length; i++){\\n        let black_count = 0, count = 0\\n        for(let j=i; j<blocks.length; j++){\\n            if(blocks.charAt(j) == \\'B\\') black_count++\\n            else{\\n                black_count++\\n                count++\\n            }\\n            if(black_count == k){\\n                min_count = Math.min(min_count, count)\\n                break\\n            }\\n        }\\n    }\\n    return min_count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        min_count = sys.maxsize\\n        for i in range(len(blocks)):\\n            black_count, count = 0, 0\\n            for j in range(i, len(blocks)):\\n                if blocks[j] == \\'B\\':\\n                    black_count += 1\\n                else:\\n                    black_count += 1\\n                    count += 1\\n                if black_count == k:\\n                    min_count = min(min_count, count)\\n                    break\\n        return min_count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min_count = Integer.MAX_VALUE;\\n        for(int i=0; i<blocks.length(); i++){\\n            int black_count = 0, count = 0;\\n            for(int j=i; j<blocks.length(); j++){\\n                if(blocks.charAt(j) == \\'B\\') black_count++;\\n                else{\\n                    black_count++;\\n                    count++;\\n                }\\n                if(black_count == k){\\n                    min_count = Math.min(min_count, count);\\n                    break;\\n                }\\n            }\\n        }\\n        return min_count;\\n    }\\n}\\n```\n```\\nvar minimumRecolors = function(blocks, k) {\\n    let min_count = Number.MAX_VALUE\\n    for(let i=0; i<blocks.length; i++){\\n        let black_count = 0, count = 0\\n        for(let j=i; j<blocks.length; j++){\\n            if(blocks.charAt(j) == \\'B\\') black_count++\\n            else{\\n                black_count++\\n                count++\\n            }\\n            if(black_count == k){\\n                min_count = Math.min(min_count, count)\\n                break\\n            }\\n        }\\n    }\\n    return min_count\\n};\\n```\n```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        min_count = sys.maxsize\\n        for i in range(len(blocks)):\\n            black_count, count = 0, 0\\n            for j in range(i, len(blocks)):\\n                if blocks[j] == \\'B\\':\\n                    black_count += 1\\n                else:\\n                    black_count += 1\\n                    count += 1\\n                if black_count == k:\\n                    min_count = min(min_count, count)\\n                    break\\n        return min_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046773,
                "title": "java-sliding-window-commented-explanation",
                "content": "# Please Upvote :D\\n---\\n- The idea is to find the minimum number of whites to exist in a window.\\n- We will turn those whites to blacks.\\n``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int left = 0, right = 0;            // initialise pointers\\n        int whites = 0;                     // to record number of whites in the window\\n        int minWhites = blocks.length();    // to record minimum number of whites in a window\\n        \\n        // place the starting window (from 0 to k-1)\\n        // also count the number of whites in the starting window\\n        while (right < k) {\\n            if (blocks.charAt(right++) == \\'W\\') {\\n                whites++;\\n            }\\n        }\\n        // update minWhites with whatever we have achieved in the starting window\\n        minWhites = Math.min(minWhites, whites);\\n\\n        // start sliding the window\\n        while (right < blocks.length()) {\\n            // Because we will move forward, we will have to \\n            // discard what we have at the leftmost end and acquire from the rightmost end\\n            if (blocks.charAt(left++) == \\'W\\') {     // if leftmost end has a W\\n                whites--;                           // discard\\n            }\\n            if (blocks.charAt(right++) == \\'W\\') {    // if rightmost end has a W\\n                whites++;                           // acquire\\n            }\\n            minWhites = Math.min(minWhites, whites);    // update minWhites\\n        }\\n\\n        return minWhites;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int left = 0, right = 0;            // initialise pointers\\n        int whites = 0;                     // to record number of whites in the window\\n        int minWhites = blocks.length();    // to record minimum number of whites in a window\\n        \\n        // place the starting window (from 0 to k-1)\\n        // also count the number of whites in the starting window\\n        while (right < k) {\\n            if (blocks.charAt(right++) == \\'W\\') {\\n                whites++;\\n            }\\n        }\\n        // update minWhites with whatever we have achieved in the starting window\\n        minWhites = Math.min(minWhites, whites);\\n\\n        // start sliding the window\\n        while (right < blocks.length()) {\\n            // Because we will move forward, we will have to \\n            // discard what we have at the leftmost end and acquire from the rightmost end\\n            if (blocks.charAt(left++) == \\'W\\') {     // if leftmost end has a W\\n                whites--;                           // discard\\n            }\\n            if (blocks.charAt(right++) == \\'W\\') {    // if rightmost end has a W\\n                whites++;                           // acquire\\n            }\\n            minWhites = Math.min(minWhites, whites);    // update minWhites\\n        }\\n\\n        return minWhites;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484046,
                "title": "c-easy-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        \\n        int start = 0;\\n        \\n        for(int i =0; i<k ;i++){\\n            if(blocks[i]==\\'B\\')\\n                start++;\\n        }\\n        \\n        // window variable\\n        int temp = start;\\n        \\n        for(int i =0, j = k; j<blocks.size(); i++, j++ ){\\n            \\n            if(blocks[i]==\\'B\\')\\n                temp--;\\n            if(blocks[j]==\\'B\\')\\n                temp++;\\n            \\n            start = max(start,temp);\\n        }\\n        \\n        return k-start;            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        \\n        int start = 0;\\n        \\n        for(int i =0; i<k ;i++){\\n            if(blocks[i]==\\'B\\')\\n                start++;\\n        }\\n        \\n        // window variable\\n        int temp = start;\\n        \\n        for(int i =0, j = k; j<blocks.size(); i++, j++ ){\\n            \\n            if(blocks[i]==\\'B\\')\\n                temp--;\\n            if(blocks[j]==\\'B\\')\\n                temp++;\\n            \\n            start = max(start,temp);\\n        }\\n        \\n        return k-start;            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454269,
                "title": "c-o-n-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**: maintaining \\'sliding window\\' of size \\'k\\' and keeping track of number of \\'W\\', so these are the number of charcters we need to remove to have \\'k\\' consecutive \\'B\\'\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumRecolors(string s, int k) {\\n        int n=s.length();\\n        \\n        int white_count=0; // count of \\'W\\' in string of size \\'k\\'\\n        int i=0, j=0;\\n        int ans=n;\\n        while(j<n){\\n            if(s[j]==\\'W\\') white_count++;\\n            \\n            if(j-i+1 == k){\\n                ans=min(ans,bad);\\n                if(s[i]==\\'W\\') white_count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumRecolors(string s, int k) {\\n        int n=s.length();\\n        \\n        int white_count=0; // count of \\'W\\' in string of size \\'k\\'\\n        int i=0, j=0;\\n        int ans=n;\\n        while(j<n){\\n            if(s[j]==\\'W\\') white_count++;\\n            \\n            if(j-i+1 == k){\\n                ans=min(ans,bad);\\n                if(s[i]==\\'W\\') white_count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457015,
                "title": "easy-c-sliding-window-for-beginners-clean-fast-and-friendly-code-tc-o-n-sc-o-1",
                "content": "This is a basic sliding window approach. \\nThe main idea here is to **count the minimum number of \\'White\\' blocks in a substring of size \\'k\\'**.\\nUse the above idea to code, and you got it!\\nI hope my code helps you understand the ***Sliding Window*** approach.\\nComment if you have any :)\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.length();\\n        int ans = INT_MAX;      // will be used to compare ans store minimum\\n        int white = 0;      // number of white blocks\\n        int black = 0;      // number of black blocks\\n        // sliding window start ---\\n        int windowStart = 0;\\n        for (int windowEnd = 0; windowEnd <n ; ++windowEnd) {\\n            char rightChar = blocks[windowEnd];         // rightmost character of the window\\n            \\n            if (rightChar == \\'W\\')\\n                white++;\\n            else black++;\\n            \\n            // if window size is equal to \\'k\\', shrink the window\\n            if (windowEnd - windowStart +1 == k) {\\n                \\n                ans = min (ans, white);     // store the minimum white count before shrinking starts\\n                \\n                char leftChar = blocks[windowStart];    // leftmost character of the window\\n                // remove the count of \\'leftChar\\'\\n                if (leftChar == \\'W\\')\\n                    white--;\\n                else black--;\\n                \\n                ++windowStart;      // window shrunk\\n            }\\n        }\\n        return ans; \\n        // \\'ans\\' was assigned INT_MAX but it will surely change whatever the test case is.\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.length();\\n        int ans = INT_MAX;      // will be used to compare ans store minimum\\n        int white = 0;      // number of white blocks\\n        int black = 0;      // number of black blocks\\n        // sliding window start ---\\n        int windowStart = 0;\\n        for (int windowEnd = 0; windowEnd <n ; ++windowEnd) {\\n            char rightChar = blocks[windowEnd];         // rightmost character of the window\\n            \\n            if (rightChar == \\'W\\')\\n                white++;\\n            else black++;\\n            \\n            // if window size is equal to \\'k\\', shrink the window\\n            if (windowEnd - windowStart +1 == k) {\\n                \\n                ans = min (ans, white);     // store the minimum white count before shrinking starts\\n                \\n                char leftChar = blocks[windowStart];    // leftmost character of the window\\n                // remove the count of \\'leftChar\\'\\n                if (leftChar == \\'W\\')\\n                    white--;\\n                else black--;\\n                \\n                ++windowStart;      // window shrunk\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2455209,
                "title": "c-0ms100-o-n-sliding-window-thanks-to-adityaverma",
                "content": "Self Explanatory :)\\nAll adityaverma\\'fellows upvotes this!!\\n\\n\\n```\\nTC: O(N)\\nSC: O(1)\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) \\n    {\\n        int n=s.size();\\n        int white=0;\\n        int i=0,j=0;\\n        int ans=n;\\n        while(j<n)\\n        {\\n            if(s[j]==\\'W\\')\\n                {\\n                    white++;\\n                }\\n            if(j-i+1<k)\\n            {\\n                \\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                \\n                ans=min(ans,white);\\n                if(s[i]==\\'W\\')\\n                {\\n                    white--;\\n                }\\n                i++,j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) \\n    {\\n        int n=s.size();\\n        int white=0;\\n        int i=0,j=0;\\n        int ans=n;\\n        while(j<n)\\n        {\\n            if(s[j]==\\'W\\')\\n                {\\n                    white++;\\n                }\\n            if(j-i+1<k)\\n            {\\n                \\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                \\n                ans=min(ans,white);\\n                if(s[i]==\\'W\\')\\n                {\\n                    white--;\\n                }\\n                i++,j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454653,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(sum(w == \\'W\\' for w in blocks[i:i + k]) for i in range(len(blocks) - k + 1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(sum(w == \\'W\\' for w in blocks[i:i + k]) for i in range(len(blocks) - k + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454257,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int mini = INT_MAX, cnt;\\n        int n = blocks.size();\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            cnt = 0;\\n            for(int j=i; j<i+k; j++)\\n            {\\n                if(blocks[j]==\\'W\\') cnt++;\\n            }\\n            mini = min(mini, cnt);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int mini = INT_MAX, cnt;\\n        int n = blocks.size();\\n        \\n        for(int i=0; i<=n-k; i++)\\n        {\\n            cnt = 0;\\n            for(int j=i; j<i+k; j++)\\n            {\\n                if(blocks[j]==\\'W\\') cnt++;\\n            }\\n            mini = min(mini, cnt);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454226,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n\\n        int miniOper = INT_MAX ;\\n        for(int i=0; i<=blocks.size()-k; i++){\\n            int countW =0 , countB =0;\\n            \\n            for(int j=i; j<i+k; j++){\\n                if(blocks[j] == \\'W\\')    countW++ ;\\n            }\\n            \\n            miniOper = min(miniOper, countW) ;\\n        }\\n        \\n        return miniOper ;\\n    }\\n};  \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n\\n        int miniOper = INT_MAX ;\\n        for(int i=0; i<=blocks.size()-k; i++){\\n            int countW =0 , countB =0;\\n            \\n            for(int j=i; j<i+k; j++){\\n                if(blocks[j] == \\'W\\')    countW++ ;\\n            }\\n            \\n            miniOper = min(miniOper, countW) ;\\n        }\\n        \\n        return miniOper ;\\n    }\\n};  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454193,
                "title": "java-bruteforce-simple",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int result=101;\\n        int n=blocks.length();\\n        \\n        \\n        for(int i=0;i+k-1<n;i++){                          //   i+k-1   ->  Maintain Window of Size k \\n           \\n            int requiredBlackBlock=0;\\n            \\n            for(int j=i;j<=i+k-1;j++){                     //   Get the currentWindow requiredBlackBlock\\n                \\n            if(blocks.charAt(j)== \\'W\\')\\n            requiredBlackBlock++;\\n            }\\n            if(requiredBlackBlock==0)                      //   if requiredBlackBlock = 0 -> return 0\\n            return 0;\\n            \\n            result=Math.min(result,requiredBlackBlock);    // Keep min requiredBlackBlock in result\\n        }\\n            \\n       return result;\\n    }\\n           \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int result=101;\\n        int n=blocks.length();\\n        \\n        \\n        for(int i=0;i+k-1<n;i++){                          //   i+k-1   ->  Maintain Window of Size k \\n           \\n            int requiredBlackBlock=0;\\n            \\n            for(int j=i;j<=i+k-1;j++){                     //   Get the currentWindow requiredBlackBlock\\n                \\n            if(blocks.charAt(j)== \\'W\\')\\n            requiredBlackBlock++;\\n            }\\n            if(requiredBlackBlock==0)                      //   if requiredBlackBlock = 0 -> return 0\\n            return 0;\\n            \\n            result=Math.min(result,requiredBlackBlock);    // Keep min requiredBlackBlock in result\\n        }\\n            \\n       return result;\\n    }\\n           \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864169,
                "title": "python-99-23-faster-sliding-window-o-n-t-c",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        i=c=0\\n        m,n=100,len(blocks)\\n        for j in range(n):\\n            if blocks[j]==\\'W\\':\\n                c+=1\\n            if j-i==k-1:\\n                m=min(m,c)\\n                if blocks[i]==\\'W\\':\\n                    c-=1\\n                i+=1                \\n        return m\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        i=c=0\\n        m,n=100,len(blocks)\\n        for j in range(n):\\n            if blocks[j]==\\'W\\':\\n                c+=1\\n            if j-i==k-1:\\n                m=min(m,c)\\n                if blocks[i]==\\'W\\':\\n                    c-=1\\n                i+=1                \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459673,
                "title": "c-3-line-solution-0ms-faster-than-100",
                "content": "**Do upvote if helpfull**\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans=INT_MAX, i=0;\\n        while(i<=blocks.size()-k){\\n            int cnt= count(blocks.begin()+i,blocks.begin()+i+k,\\'W\\');\\n            ans= min(ans,cnt);\\n            i++;\\n        }                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans=INT_MAX, i=0;\\n        while(i<=blocks.size()-k){\\n            int cnt= count(blocks.begin()+i,blocks.begin()+i+k,\\'W\\');\\n            ans= min(ans,cnt);\\n            i++;\\n        }                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455985,
                "title": "c-sliding-window-o-n-100-fast-0ms",
                "content": "We can use a \"sliding window\" of length ```k```, and just see how many \"white\" blocks are in this window.\\n\\n```\\n    int minimumRecolors(const string& blocks, int k) {\\n        int white = 0;\\n\\t\\t// How many white blocks are in the first |k| characters.\\n        for (int i = 0; i < k; ++i) {\\n            white += blocks[i] == \\'W\\';\\n        }\\n        int ans = white;\\n\\t\\t// Sliding window.\\n        for (int i = k; i < size(blocks); ++i) {\\n\\t\\t    // Add block[i], and remove the block that is moving out of the window.\\n            white -= blocks[i - k] == \\'W\\';\\n            white += blocks[i] == \\'W\\';\\n\\t\\t\\t// Keep track of the best answer so far.\\n            ans = min(ans, white);\\n        }\\n        return ans;\\n    }\\n```\\n\\ntime complexity: ```O(n)``` we look at each character in ```blocks``` at most twice.\\nspace complexity: ```O(1)``` only loop counters and two more integers.\\n\\nWe could \"fuse\" the two loops and see what\\'s the maximum black blocks in the window, but that has the \"downside\" that we an extra branch in the mainloop, if we want to micro optimize it. This does likley not matter though.\\n\\n```\\n    int minimumRecolors(const string& blocks, int k) {\\n        int max_blacks = 0;\\n        for (int i = 0, black = 0; i < size(blocks); ++i) {\\n            black += blocks[i] == \\'B\\';\\n            if (i >= k) black -= blocks[i - k] == \\'B\\';\\n            max_blacks = max(max_blacks, black);\\n        }\\n        return k - max_blacks;\\n    }\\n```\\n\\nThis variant has the same time and space complexity.\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```k```\n```\\n    int minimumRecolors(const string& blocks, int k) {\\n        int white = 0;\\n\\t\\t// How many white blocks are in the first |k| characters.\\n        for (int i = 0; i < k; ++i) {\\n            white += blocks[i] == \\'W\\';\\n        }\\n        int ans = white;\\n\\t\\t// Sliding window.\\n        for (int i = k; i < size(blocks); ++i) {\\n\\t\\t    // Add block[i], and remove the block that is moving out of the window.\\n            white -= blocks[i - k] == \\'W\\';\\n            white += blocks[i] == \\'W\\';\\n\\t\\t\\t// Keep track of the best answer so far.\\n            ans = min(ans, white);\\n        }\\n        return ans;\\n    }\\n```\n```O(n)```\n```blocks```\n```O(1)```\n```\\n    int minimumRecolors(const string& blocks, int k) {\\n        int max_blacks = 0;\\n        for (int i = 0, black = 0; i < size(blocks); ++i) {\\n            black += blocks[i] == \\'B\\';\\n            if (i >= k) black -= blocks[i - k] == \\'B\\';\\n            max_blacks = max(max_blacks, black);\\n        }\\n        return k - max_blacks;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455027,
                "title": "c-using-prefix-sum-0-n-complexity",
                "content": "https://codeforces.com/problemset/problem/1690/D  \\n  Same question.\\n   ** please Upvote :P**\\n\\n\\t\\t\\t\\t        W B B W W B B W B W  k = 7\\n       prefix  arr :- 0 1 1 1 2 3 3 3 4 4 5\\n\\n       \"If Character is \\'W\\' increase the count by Previous+1 \\n       else prev\\n      For Fetching the number of White in particular window\\n      arr[ind] - arr[ind-k]\\n      It will give the frequency of White in  K window\"\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        long long mini=INT_MAX;\\n        int n = s.size();\\n    vector<long long> ps(n+1,0);\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'W\\'){\\n            ps[i+1]=ps[i]+1;\\n        }\\n        else{\\n            ps[i+1]=ps[i];\\n        }\\n    }\\n    for(int i=k;i<=n;i++){\\n        mini=min(mini,ps[i]-ps[i-k]);\\n    }\\n     return mini;\\n    }\\n};`\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        long long mini=INT_MAX;\\n        int n = s.size();\\n    vector<long long> ps(n+1,0);\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'W\\'){\\n            ps[i+1]=ps[i]+1;\\n        }\\n        else{\\n            ps[i+1]=ps[i];\\n        }\\n    }\\n    for(int i=k;i<=n;i++){\\n        mini=min(mini,ps[i]-ps[i-k]);\\n    }\\n     return mini;\\n    }\\n};`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454458,
                "title": "python-easy-approach-sliding-window-count",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        \\n        ans = 0\\n        res = 0\\n\\n        for i in range(len(blocks) - k + 1):\\n            res = blocks.count(\\'B\\', i, i + k)\\n            ans = max(res, ans)\\n\\n        ans = k - ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        \\n        ans = 0\\n        res = 0\\n\\n        for i in range(len(blocks) - k + 1):\\n            res = blocks.count(\\'B\\', i, i + k)\\n            ans = max(res, ans)\\n\\n        ans = k - ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992424,
                "title": "o-n-2-to-o-n-sliding-window",
                "content": "# O(N^2):\\n``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = blocks.length();\\n        for(int i=0; i<n-k+1; i++) {\\n            int local=0;\\n            for(int j=i; j<i+k; j++) {\\n                if(blocks.charAt(j)==\\'W\\') {\\n                    local++;\\n                }\\n            }\\n            ans = Math.min(local, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nCan we do it using only one loop?\\n# Sliding Window:\\n\\n``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = blocks.length();\\n        int count = 0;\\n        for(int i=0; i<k; i++) {\\n            if(blocks.charAt(i)==\\'W\\') {\\n                count++;\\n            }\\n        }\\n        ans = Math.min(count, ans);\\n        for(int i=k; i<n; i++) {\\n            int ws = i-k;\\n            if(blocks.charAt(ws)==\\'W\\') {\\n                count--;\\n            }\\n            if(blocks.charAt(i)==\\'W\\') {\\n                count++;\\n            }\\n            ans = Math.min(count, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = blocks.length();\\n        for(int i=0; i<n-k+1; i++) {\\n            int local=0;\\n            for(int j=i; j<i+k; j++) {\\n                if(blocks.charAt(j)==\\'W\\') {\\n                    local++;\\n                }\\n            }\\n            ans = Math.min(local, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        int n = blocks.length();\\n        int count = 0;\\n        for(int i=0; i<k; i++) {\\n            if(blocks.charAt(i)==\\'W\\') {\\n                count++;\\n            }\\n        }\\n        ans = Math.min(count, ans);\\n        for(int i=k; i<n; i++) {\\n            int ws = i-k;\\n            if(blocks.charAt(ws)==\\'W\\') {\\n                count--;\\n            }\\n            if(blocks.charAt(i)==\\'W\\') {\\n                count++;\\n            }\\n            ans = Math.min(count, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639657,
                "title": "easy-to-understand-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size();\\n        int winSize = 0;\\n        int start = 0;\\n        int white = 0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            if(winSize < k){\\n                if(blocks[i] == \\'W\\') white++;\\n                winSize++;\\n                continue;\\n            }\\n            ans = min(ans,white);\\n            if(blocks[start] == \\'W\\') white--;\\n            if(blocks[i] == \\'W\\') white++;\\n            start++;\\n        }\\n        ans = min(ans,white);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size();\\n        int winSize = 0;\\n        int start = 0;\\n        int white = 0;\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            if(winSize < k){\\n                if(blocks[i] == \\'W\\') white++;\\n                winSize++;\\n                continue;\\n            }\\n            ans = min(ans,white);\\n            if(blocks[start] == \\'W\\') white--;\\n            if(blocks[i] == \\'W\\') white++;\\n            start++;\\n        }\\n        ans = min(ans,white);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618665,
                "title": "c-sliding-window-simple-clean-beats-100-runtime-98-memory",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int minChanges = INT_MAX;\\n        int changes = 0;\\n\\n        for (int i = 0; i < blocks.size(); i++) {\\n            if (blocks[i] == \\'W\\') changes++;\\n            if (i < k-1) continue; // Let the window grow to size k\\n            minChanges = min(changes, minChanges);\\n            if (blocks[i - (k - 1)] == \\'W\\') changes--;\\n        }\\n\\n        return minChanges;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int minChanges = INT_MAX;\\n        int changes = 0;\\n\\n        for (int i = 0; i < blocks.size(); i++) {\\n            if (blocks[i] == \\'W\\') changes++;\\n            if (i < k-1) continue; // Let the window grow to size k\\n            minChanges = min(changes, minChanges);\\n            if (blocks[i - (k - 1)] == \\'W\\') changes--;\\n        }\\n\\n        return minChanges;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450395,
                "title": "c-sliding-window-o-n-time-complexity",
                "content": "# Intuition\\nMin operation means , substring with minimum no. of `White`\\n\\n# Approach\\n- Find the first k length substring and keep a count of white\\n- Start decreasing the window from left and increasing drom right.\\n- Either subtract white count when decreasing window or add when increasing window.\\n- Return the min count in the process\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string a, int k) {\\n        int n=a.length(), count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(a[i]==\\'W\\')\\n              count++;\\n        }\\n        int ans =count;\\n        int l=0, r=k;\\n        while(r<n)\\n        {\\n            if(a[l]==\\'W\\')\\n            {\\n                if(count>0)\\n                   count--; \\n            }\\n            l++;\\n            if(a[r]==\\'W\\')\\n              count++;\\n            r++;\\n            ans = min(ans, count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string a, int k) {\\n        int n=a.length(), count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(a[i]==\\'W\\')\\n              count++;\\n        }\\n        int ans =count;\\n        int l=0, r=k;\\n        while(r<n)\\n        {\\n            if(a[l]==\\'W\\')\\n            {\\n                if(count>0)\\n                   count--; \\n            }\\n            l++;\\n            if(a[r]==\\'W\\')\\n              count++;\\n            r++;\\n            ans = min(ans, count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326005,
                "title": "c-using-sliding-window-very-simple-and-straight-forward-sol-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile creating the window of size K just keep count of White blocks.\\nOn reaching the window size just compare the current count and store it in a variable.\\nEverytime whenever you reach the window size and after comparing the minimum count just increase the left side by 1 and decrease the count by 1 if the block at left was a white block.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int ans = INT_MAX;\\n        int count = 0;\\n        while(right < blocks.size()){\\n            if(blocks[right] == \\'W\\'){\\n                count++;\\n            }\\n            if(right - left + 1 == k){\\n                ans = min(count, ans);\\n                if(blocks[left] == \\'W\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int left = 0;\\n        int right = 0;\\n        int ans = INT_MAX;\\n        int count = 0;\\n        while(right < blocks.size()){\\n            if(blocks[right] == \\'W\\'){\\n                count++;\\n            }\\n            if(right - left + 1 == k){\\n                ans = min(count, ans);\\n                if(blocks[left] == \\'W\\'){\\n                    count--;\\n                }\\n                left++;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156403,
                "title": "simple-and-esaies-approach-shortest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<$$O(n)$$\\n\\n- Space complexity: \\n- $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int i=0,j=0,cnt=0,ans=INT_MAX;\\n        int n=blocks.size();\\n        while(j<n){\\n            if(blocks[j]==\\'W\\') cnt++;\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k){\\n                ans=min(ans,cnt);\\n                if(blocks[i]==\\'W\\') cnt--;\\n\\n               i++;\\n               j++; \\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int i=0,j=0,cnt=0,ans=INT_MAX;\\n        int n=blocks.size();\\n        while(j<n){\\n            if(blocks[j]==\\'W\\') cnt++;\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k){\\n                ans=min(ans,cnt);\\n                if(blocks[i]==\\'W\\') cnt--;\\n\\n               i++;\\n               j++; \\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059610,
                "title": "sliding-window-java-javascript-easy-to-understandable-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n         int mini = k, whiteBlockCount = 0;\\n\\n        for(int i = 0; i < blocks.length(); i++) {\\n            if(blocks.charAt(i) == \\'W\\') whiteBlockCount++;\\n            \\n            if(i >= k - 1) {\\n                if(i-k >= 0 && blocks.charAt(i - k) == \\'W\\') whiteBlockCount--;\\n                mini = Math.min(mini, whiteBlockCount);\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n}\\n```\\n# JavaScript Code\\n```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function(blocks, k) {\\n    let min = k,  whiteBlockCount = 0;\\n\\n    for(let i = 0; i < blocks.length; i++) {\\n        if(blocks[i] === \"W\") whiteBlockCount++;\\n        \\n        if(i >= k - 1) {\\n            if(blocks[i - k] === \"W\") whiteBlockCount--;\\n            min = Math.min(min, whiteBlockCount);\\n        }\\n    }\\n    \\n    return min;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n         int mini = k, whiteBlockCount = 0;\\n\\n        for(int i = 0; i < blocks.length(); i++) {\\n            if(blocks.charAt(i) == \\'W\\') whiteBlockCount++;\\n            \\n            if(i >= k - 1) {\\n                if(i-k >= 0 && blocks.charAt(i - k) == \\'W\\') whiteBlockCount--;\\n                mini = Math.min(mini, whiteBlockCount);\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function(blocks, k) {\\n    let min = k,  whiteBlockCount = 0;\\n\\n    for(let i = 0; i < blocks.length; i++) {\\n        if(blocks[i] === \"W\") whiteBlockCount++;\\n        \\n        if(i >= k - 1) {\\n            if(blocks[i - k] === \"W\") whiteBlockCount--;\\n            min = Math.min(min, whiteBlockCount);\\n        }\\n    }\\n    \\n    return min;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781691,
                "title": "easy-c-sliding-window-technique-explanation-for-beginners",
                "content": "# 1. Hash-Table Approach - (Lands base for understanding no hashtable method)\\n* **Step 1** \\u2714\\uFE0F Check every character in the string and store the frequencies in a hash table. \\n.....**INTUITION1** - Keep in mind that *(the length of string you have scanned so far) - (frequency of \\'B\\') is the number of \\'W\\' blocks you have encountered and it is exactly that many replacements you need at that moment to make upto that part of string completely B.* **You need to minimize this.** so,\\n* **Step 2** \\u2714\\uFE0F Whenever the character you are scanning is \\'B\\' increase **maxcount** so that later, you can perform **INTUITION1** which is **WBlocks = (length scanned so far) - (maxcount).** \\n* .....**INTUITION2** - k is, required length of B and maxcount defines that how many times we already got B. so,\\n* **Step 3** \\u2714\\uFE0F Whenever **WBlocks i.e (length scanned so far) - (maxcount)** increases k, that means we have more than \\'k\\' W characters in the substring. **The portion of substring where the frequency of \\'W\\' is not less than \\'k\\' is our sliding window.** so, \\n* **Step 4** \\u2714\\uFE0F reduce the window size from left until WBlocks is no longer greater than k.\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        unordered_map<char, int> freq;\\n        int minsteps = INT_MAX, left = 0, maxfreq = 0;\\n        for(int right = 0; right < blocks.length(); right++){\\n            char rightchar = blocks[right];\\n            freq[rightchar]++;   // step 1 \\u2714\\uFE0F\\n            if(rightchar == \\'B\\') maxfreq = max(maxfreq, freq[rightchar]); // step 2 \\u2714\\uFE0F\\n            if(right - left + 1 >= k){  // step 3 \\u2714\\uFE0F\\n                char leftchar = blocks[left];\\n                freq[leftchar]--;\\n                if(freq[leftchar] == 0) freq.erase(leftchar);\\n                minsteps = min(minsteps, right - left + 1 - maxfreq);\\n                left++; // step 4 \\u2714\\uFE0F\\n            }\\n        }\\n        return minsteps;\\n    }\\n};\\n```\\n```\\n.........................................Time Complexity - O(n)...............................\\n.........................................Space Complexity - O(n).............................\\n```\\n# 2. No Hash-Table Approach - (0ms code Beats 100% c++ submissions)\\n.....**INTUITION -** \\nThe same idea applies here as well. Instead of taking hash-table and storing the frequencies, we notice that **we don\\'t actually need to store frequencies of characters other than character \\'B\\'**.  so, \\n* **Step 1 -** \\u2714\\uFE0F **Scan the string and count the occurance of character \\'B\\' only**. We keep two pointers to maintain a window which we can slide.\\n* **Step 2 -** \\u2714\\uFE0F Whenever the length of window is equal to \\'k\\' or greater, that means **we have the desired number of \"B\" now and let\\'s check if we can find even smaller length substring** ( as question said that we desire to have \\'k\\' B characters) and the number of replacements required to make this window all \\'B\\' is **(length scanned so far) - (count of occurance of B)**. As the question asked, we **obviously have to keep a min count of this** to get a smallest string that matches our criteria.\\n* **Step 3-** \\u2714\\uFE0F Slide the window forward to get smaller window and find an even smaller \\'steps\\' if it exists.  \\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int countb = 0, minsteps = INT_MAX, left = 0;\\n        for(int right = 0; right < blocks.length();right++){\\n            if(blocks[right] == \\'B\\') countb++; // step 1 \\u2714\\uFE0F\\n            if(right - left + 1 >= k){  //right - left + 1 is the length of string scanned so far\\n                minsteps = min(minsteps, right - left + 1 - countb); // step 2 \\u2714\\uFE0F\\n                if(blocks[left] == \\'B\\') countb--;\\n                left++; // step 3 \\u2714\\uFE0F\\n            }\\n        }\\n        return minsteps;\\n    }\\n};\\n```\\n```\\n.........................................Time Complexity - O(n)...............................\\n.........................................Space Complexity - O(1)............................. \\n```\\n**Upvote if liked :-)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        unordered_map<char, int> freq;\\n        int minsteps = INT_MAX, left = 0, maxfreq = 0;\\n        for(int right = 0; right < blocks.length(); right++){\\n            char rightchar = blocks[right];\\n            freq[rightchar]++;   // step 1 \\u2714\\uFE0F\\n            if(rightchar == \\'B\\') maxfreq = max(maxfreq, freq[rightchar]); // step 2 \\u2714\\uFE0F\\n            if(right - left + 1 >= k){  // step 3 \\u2714\\uFE0F\\n                char leftchar = blocks[left];\\n                freq[leftchar]--;\\n                if(freq[leftchar] == 0) freq.erase(leftchar);\\n                minsteps = min(minsteps, right - left + 1 - maxfreq);\\n                left++; // step 4 \\u2714\\uFE0F\\n            }\\n        }\\n        return minsteps;\\n    }\\n};\\n```\n```\\n.........................................Time Complexity - O(n)...............................\\n.........................................Space Complexity - O(n).............................\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int countb = 0, minsteps = INT_MAX, left = 0;\\n        for(int right = 0; right < blocks.length();right++){\\n            if(blocks[right] == \\'B\\') countb++; // step 1 \\u2714\\uFE0F\\n            if(right - left + 1 >= k){  //right - left + 1 is the length of string scanned so far\\n                minsteps = min(minsteps, right - left + 1 - countb); // step 2 \\u2714\\uFE0F\\n                if(blocks[left] == \\'B\\') countb--;\\n                left++; // step 3 \\u2714\\uFE0F\\n            }\\n        }\\n        return minsteps;\\n    }\\n};\\n```\n```\\n.........................................Time Complexity - O(n)...............................\\n.........................................Space Complexity - O(1)............................. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755716,
                "title": "crisp-n-clear-o-n-javascript-memory-86-08-meaningful-vars",
                "content": "Runtime: 78 ms, faster than 86.65% of JavaScript online submissions for Minimum Recolors to Get K Consecutive Black Blocks.\\nMemory Usage: 42.2 MB, less than 86.08% of JavaScript online submissions for Minimum Recolors to Get K Consecutive Black Blocks.\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nvar minimumRecolors = function (blocks, k) {\\n    let finalChangeRequire = \\'\\';\\n    let tempStore = \\'\\';\\n    let changeRequire = (function () {\\n        let tempK = k;\\n        let count = 0;\\n        let index = 0;\\n        while (tempK--) {\\n            if (blocks[index] === \\'W\\') {\\n                count++;\\n            }\\n            tempStore += blocks[index++];\\n        }\\n        return count;\\n    })();\\n    let tempChangeRequire = changeRequire;\\n    for (let index = k; index < blocks.length; index++) {\\n        if (blocks[index - k] === \\'W\\') {\\n            tempChangeRequire -= 1;\\n        }\\n        if (blocks[index] === \\'W\\') {\\n            tempChangeRequire += 1;\\n        }\\n        if (tempChangeRequire < changeRequire) {\\n            changeRequire = tempChangeRequire;\\n        }\\n    }\\n    return changeRequire;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRecolors = function (blocks, k) {\\n    let finalChangeRequire = \\'\\';\\n    let tempStore = \\'\\';\\n    let changeRequire = (function () {\\n        let tempK = k;\\n        let count = 0;\\n        let index = 0;\\n        while (tempK--) {\\n            if (blocks[index] === \\'W\\') {\\n                count++;\\n            }\\n            tempStore += blocks[index++];\\n        }\\n        return count;\\n    })();\\n    let tempChangeRequire = changeRequire;\\n    for (let index = k; index < blocks.length; index++) {\\n        if (blocks[index - k] === \\'W\\') {\\n            tempChangeRequire -= 1;\\n        }\\n        if (blocks[index] === \\'W\\') {\\n            tempChangeRequire += 1;\\n        }\\n        if (tempChangeRequire < changeRequire) {\\n            changeRequire = tempChangeRequire;\\n        }\\n    }\\n    return changeRequire;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560871,
                "title": "java-easy-solution-using-string-methods",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min=Integer.MAX_VALUE;\\n        int i=k,c=0,idl=0,idr=0;\\n        while(i<=blocks.length())\\n        {\\n            String sub=blocks.substring(i-k,i);            \\n            char ch[]=sub.toCharArray();\\n            Arrays.sort(ch);\\n            sub=new String(ch);            \\n            idl=sub.indexOf(\\'W\\');\\n            idr=sub.lastIndexOf(\\'W\\');\\n            if(idl==-1 && idr==-1)c=0;\\n            else c=idr-idl+1;\\n            if(c<min)min=c;\\n            i+=1;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min=Integer.MAX_VALUE;\\n        int i=k,c=0,idl=0,idr=0;\\n        while(i<=blocks.length())\\n        {\\n            String sub=blocks.substring(i-k,i);            \\n            char ch[]=sub.toCharArray();\\n            Arrays.sort(ch);\\n            sub=new String(ch);            \\n            idl=sub.indexOf(\\'W\\');\\n            idr=sub.lastIndexOf(\\'W\\');\\n            if(idl==-1 && idr==-1)c=0;\\n            else c=idr-idl+1;\\n            if(c<min)min=c;\\n            i+=1;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502303,
                "title": "java-easy-to-understand-solution-o-n",
                "content": "Idea of this solution is to count number of white blocks within each k-size window and find its minimal value.\\n1. First step we just check first k-size window and count number of whites there.\\n2. If blocks is k size, then just return num of whites.\\n3. Otherwise slide to the right one by one, and update number of whites\\n4. If head of previous k-size window is white, we decrease number of whites\\n5. If tail of current k-size window is white, we increase number of whites\\n6. Just store minimal value\\n\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int whites = 0;\\n        // check first k-size window \\n        for (int i = 0; i < k; i++)\\n            if (blocks.charAt(i) == \\'W\\')\\n                whites++;\\n        \\n        if (blocks.length() == k)\\n            return whites;\\n        \\n        // then slide by one element to right\\n        int ans = whites;\\n        for (int i = k; i < blocks.length(); i++) {\\n            if (blocks.charAt(i - k) == \\'W\\')\\n                whites--;\\n            if (blocks.charAt(i) == \\'W\\')\\n                whites++;\\n\\n            ans = Math.min(ans, whites);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int whites = 0;\\n        // check first k-size window \\n        for (int i = 0; i < k; i++)\\n            if (blocks.charAt(i) == \\'W\\')\\n                whites++;\\n        \\n        if (blocks.length() == k)\\n            return whites;\\n        \\n        // then slide by one element to right\\n        int ans = whites;\\n        for (int i = k; i < blocks.length(); i++) {\\n            if (blocks.charAt(i - k) == \\'W\\')\\n                whites--;\\n            if (blocks.charAt(i) == \\'W\\')\\n                whites++;\\n\\n            ans = Math.min(ans, whites);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2492612,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int w = 0 , ans = INT_MAX ;\\n        for(int s = 0 ,e = 0 ;  e < blocks.size() ; ++ e){\\n            w += (blocks[e] == \\'W\\') ;\\n            if(e >= k - 1) ans = min(ans,w) , w -= (blocks[s++] == \\'W\\') ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int w = 0 , ans = INT_MAX ;\\n        for(int s = 0 ,e = 0 ;  e < blocks.size() ; ++ e){\\n            w += (blocks[e] == \\'W\\') ;\\n            if(e >= k - 1) ans = min(ans,w) , w -= (blocks[s++] == \\'W\\') ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458426,
                "title": "c-best-explanation-100-time-space-beginner-friendly",
                "content": "**Approach**\\n1. You can count either black or white.\\n2. I have counted black.\\n3. Firstly, I have counted starting k elements.\\n4. Then, Removing the count of first element from those k element and adding count of k+1 element.\\n5. Note the maximum value of count.\\n\\n**If you are counting white note the minimum value**\\n\\n![image](https://assets.leetcode.com/users/images/4856ec9c-6dae-4c55-8ddb-28bb1101727f_1661076041.279513.jpeg)\\n\\n**Code :-**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int c = 0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i] == \\'B\\')\\n            {\\n                c++;\\n            }\\n        }\\n        if(c == k)\\n        {\\n            return 0;\\n        }\\n        int m = INT_MIN;\\n        m = max(c,m);\\n        for(int i=k;i<blocks.size();i++)\\n        {\\n            if(blocks[i-k] == \\'B\\')\\n            {\\n                c--;\\n            }\\n            if(blocks[i] == \\'B\\')\\n            {\\n                c++;\\n            }\\n            m = max(m,c);\\n            if(c == k)\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        return (k-m);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/233f2732-c8bd-4b40-ba65-c5b268ddf4d2_1661076161.2255206.png)\\n\\n**If you like the solution *Upvote it* !!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int c = 0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i] == \\'B\\')\\n            {\\n                c++;\\n            }\\n        }\\n        if(c == k)\\n        {\\n            return 0;\\n        }\\n        int m = INT_MIN;\\n        m = max(c,m);\\n        for(int i=k;i<blocks.size();i++)\\n        {\\n            if(blocks[i-k] == \\'B\\')\\n            {\\n                c--;\\n            }\\n            if(blocks[i] == \\'B\\')\\n            {\\n                c++;\\n            }\\n            m = max(m,c);\\n            if(c == k)\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        return (k-m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457820,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        int count = 0;\\n        \\n        // apply sliding window and get count of \\'B\\' in each window of size k, keep track of max count\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if size is less than k\\n            \\n            if(i < k)\\n            {\\n                if(str[i] == \\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            // if size == k\\n            \\n            else\\n            {\\n                // update maxi\\n                \\n                maxi = max(maxi, count);\\n                \\n                // remove the starting element of window\\n                    \\n                if(str[i - k] == \\'B\\')\\n                {\\n                    count--;\\n                }\\n                \\n                // add the curr element into window\\n                \\n                if(str[i] == \\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // update maxi\\n        \\n        maxi = max(maxi, count);\\n        \\n        return k - maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        int maxi = INT_MIN;\\n        \\n        int count = 0;\\n        \\n        // apply sliding window and get count of \\'B\\' in each window of size k, keep track of max count\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if size is less than k\\n            \\n            if(i < k)\\n            {\\n                if(str[i] == \\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            // if size == k\\n            \\n            else\\n            {\\n                // update maxi\\n                \\n                maxi = max(maxi, count);\\n                \\n                // remove the starting element of window\\n                    \\n                if(str[i - k] == \\'B\\')\\n                {\\n                    count--;\\n                }\\n                \\n                // add the curr element into window\\n                \\n                if(str[i] == \\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        // update maxi\\n        \\n        maxi = max(maxi, count);\\n        \\n        return k - maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455841,
                "title": "c-easy-approach-sliding-window-beginners-friendly",
                "content": "```\\nint minimumRecolors(string blocks, int k) {\\n        int j=0,l=k;\\n        int minm=INT_MAX;\\n        for(int i=0;i<=blocks.size()-k;i++){\\n            string f=\"\";\\n            for(int j=i;j<k+i;j++){\\n                f+=blocks[j];\\n            }\\n            int c=count(f.begin(),f.end(),\\'W\\');\\n            minm=min(c,minm); \\n        }\\n        return minm;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minimumRecolors(string blocks, int k) {\\n        int j=0,l=k;\\n        int minm=INT_MAX;\\n        for(int i=0;i<=blocks.size()-k;i++){\\n            string f=\"\";\\n            for(int j=i;j<k+i;j++){\\n                f+=blocks[j];\\n            }\\n            int c=count(f.begin(),f.end(),\\'W\\');\\n            minm=min(c,minm); \\n        }\\n        return minm;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454903,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int i=0;\\n        int j=0;\\n        int mn=INT_MAX;\\n        int count=0;\\n        while(j<blocks.size()){\\n            if(blocks[j]==\\'W\\') count++;\\n            if(j-i+1==k){\\n                mn=min(mn,count);\\n                if(blocks[i]==\\'W\\')count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int i=0;\\n        int j=0;\\n        int mn=INT_MAX;\\n        int count=0;\\n        while(j<blocks.size()){\\n            if(blocks[j]==\\'W\\') count++;\\n            if(j-i+1==k){\\n                mn=min(mn,count);\\n                if(blocks[i]==\\'W\\')count--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454892,
                "title": "sliding-window-o-n-simple-and-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int w=0;\\n        int l=0,r=k-1;\\n        for(int i=l;i<=r;i++) {\\n            if (blocks[i]==\\'W\\') w++;\\n        }\\n        int ans=w;\\n        for(int i=r+1;i<blocks.size();i++) {\\n            if (blocks[l]==\\'W\\') w--;\\n            l++;\\n            r++;\\n            if (blocks[r]==\\'W\\') w++;\\n            ans=min(ans,w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int w=0;\\n        int l=0,r=k-1;\\n        for(int i=l;i<=r;i++) {\\n            if (blocks[i]==\\'W\\') w++;\\n        }\\n        int ans=w;\\n        for(int i=r+1;i<blocks.size();i++) {\\n            if (blocks[l]==\\'W\\') w--;\\n            l++;\\n            r++;\\n            if (blocks[r]==\\'W\\') w++;\\n            ans=min(ans,w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454562,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n          int maximum=0;\\n        \\n        for(int i=0;i<=(blocks.size()-k);i++)\\n        {\\n            int count=0;\\n            for(int j=i;j<(k+i);j++)\\n            {\\n                if(blocks[j]==\\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            maximum=max(maximum,count);\\n        }\\n        return (k-maximum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n          int maximum=0;\\n        \\n        for(int i=0;i<=(blocks.size()-k);i++)\\n        {\\n            int count=0;\\n            for(int j=i;j<(k+i);j++)\\n            {\\n                if(blocks[j]==\\'B\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            maximum=max(maximum,count);\\n        }\\n        return (k-maximum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454465,
                "title": "scala-sliding-oneliner",
                "content": "```scala\\ndef minimumRecolors(blocks: String, k: Int): Int =\\n  blocks.sliding(k).map(_.count(_ == \\'W\\')).min\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef minimumRecolors(blocks: String, k: Int): Int =\\n  blocks.sliding(k).map(_.count(_ == \\'W\\')).min\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2454443,
                "title": "c-sliding-window-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int start = 0;\\n        int n = size(blocks);\\n        int i = 0;\\n        int wCount = 0;\\n        int res = INT_MAX;\\n        int window = 0;\\n\\t\\t\\n        while(i < n) {\\n            if(blocks[i] == \\'W\\') ++wCount;\\n            if(++window == k) {\\n                res = min(res, wCount);\\n                \\n                if(blocks[start++] == \\'W\\') --wCount;\\n                window--;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int start = 0;\\n        int n = size(blocks);\\n        int i = 0;\\n        int wCount = 0;\\n        int res = INT_MAX;\\n        int window = 0;\\n\\t\\t\\n        while(i < n) {\\n            if(blocks[i] == \\'W\\') ++wCount;\\n            if(++window == k) {\\n                res = min(res, wCount);\\n                \\n                if(blocks[start++] == \\'W\\') --wCount;\\n                window--;\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454386,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int MinimumRecolors(string blocks, int k)\\n    {\\n        var min = Int32.MaxValue;\\n        for (int i = 0; i <= blocks.Length - k; i++)\\n        {\\n            var word = blocks.Substring(i, k);\\n            var length = word.Count(x => x == \\'W\\');\\n            min = Math.Min(min, length);\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int MinimumRecolors(string blocks, int k)\\n    {\\n        var min = Int32.MaxValue;\\n        for (int i = 0; i <= blocks.Length - k; i++)\\n        {\\n            var word = blocks.Substring(i, k);\\n            var length = word.Count(x => x == \\'W\\');\\n            min = Math.Min(min, length);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454335,
                "title": "c-easy-to-understand-solution-short",
                "content": "![image](https://assets.leetcode.com/users/images/9516faf4-f744-4352-a1e7-7fe96608ada3_1661011465.7265265.png)\\n\\n**T->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumRecolors(string s, int k) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tint b=0,w=0;\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tif(s[i]==\\'B\\')b++;\\n\\t\\t\\t\\telse w++;\\n\\t\\t\\t}\\n\\t\\t\\tint mini=w;\\n\\t\\t\\tfor(int i=1;i<=n-k;i++){\\n\\t\\t\\t\\tif(s[i-1]==\\'W\\')w--;\\n\\t\\t\\t\\telse b--;\\n\\t\\t\\t\\tif(s[i+k-1]==\\'W\\')w++;\\n\\t\\t\\t\\telse b++;\\n\\t\\t\\t\\tmini=min(mini,w);\\n\\t\\t\\t}\\n\\t\\t\\treturn  mini;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumRecolors(string s, int k) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tint b=0,w=0;\\n\\t\\t\\tfor(int i=0;i<k;i++){\\n\\t\\t\\t\\tif(s[i]==\\'B\\')b++;\\n\\t\\t\\t\\telse w++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4034368,
                "title": "0ms-simple-easy-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i = 0 , j = 0 , n = s.length(), curr = 0 , ans = INT_MAX;\\n\\n        while(j<n){\\n            if(s[j] == \\'W\\'){\\n                curr++;\\n            }\\n            if((j-i+1) < k){\\n                j++;\\n            }\\n            else{\\n                ans = min(ans,curr);\\n                j++;\\n                if(s[i]==\\'W\\'){\\n                    curr--;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i = 0 , j = 0 , n = s.length(), curr = 0 , ans = INT_MAX;\\n\\n        while(j<n){\\n            if(s[j] == \\'W\\'){\\n                curr++;\\n            }\\n            if((j-i+1) < k){\\n                j++;\\n            }\\n            else{\\n                ans = min(ans,curr);\\n                j++;\\n                if(s[i]==\\'W\\'){\\n                    curr--;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972608,
                "title": "aditya-verma-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int i=0,j=0;\\n        int count=0;\\n        int ans=INT_MAX;\\n        while(j<n){\\n            if(blocks[j]==\\'W\\'){\\n                \\n                count++;\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                ans=min(ans,count);\\n                if(blocks[i]==\\'W\\'){\\n                    count--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int i=0,j=0;\\n        int count=0;\\n        int ans=INT_MAX;\\n        while(j<n){\\n            if(blocks[j]==\\'W\\'){\\n                \\n                count++;\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                ans=min(ans,count);\\n                if(blocks[i]==\\'W\\'){\\n                    count--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930979,
                "title": "beats-90-cpp-sol",
                "content": "# **Pls Upvote If Helpful \\uD83E\\uDD79**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int front = 0;\\n        int back = 0;\\n        int whiteCount = 0;\\n        int ans = INT_MAX;\\n        while(front < blocks.size()){\\n            if(blocks[front] == \\'W\\'){\\n                whiteCount += 1;\\n            }\\n            if(front-back+1 >= k){\\n                ans = min(ans, whiteCount);\\n                if(blocks[back] == \\'W\\'){\\n                    whiteCount--;\\n                } \\n                back++;\\n            }\\n            front++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int front = 0;\\n        int back = 0;\\n        int whiteCount = 0;\\n        int ans = INT_MAX;\\n        while(front < blocks.size()){\\n            if(blocks[front] == \\'W\\'){\\n                whiteCount += 1;\\n            }\\n            if(front-back+1 >= k){\\n                ans = min(ans, whiteCount);\\n                if(blocks[back] == \\'W\\'){\\n                    whiteCount--;\\n                } \\n                back++;\\n            }\\n            front++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791740,
                "title": "easy-java-solution-clean-code-beats-95-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int count = 0;\\n        while(end < blocks.length()) {\\n            if(blocks.charAt(end) == \\'W\\') {\\n                count++;\\n            }\\n            if(end - start + 1 < k) {\\n                end++;\\n            }\\n            else if (end - start + 1 == k) {\\n                ans = Math.min(count, ans);\\n                if(blocks.charAt(start) == \\'W\\') {\\n                    count--;\\n                }\\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int count = 0;\\n        while(end < blocks.length()) {\\n            if(blocks.charAt(end) == \\'W\\') {\\n                count++;\\n            }\\n            if(end - start + 1 < k) {\\n                end++;\\n            }\\n            else if (end - start + 1 == k) {\\n                ans = Math.min(count, ans);\\n                if(blocks.charAt(start) == \\'W\\') {\\n                    count--;\\n                }\\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702655,
                "title": "5ms-dynamic-programming",
                "content": "# Approach\\nWe do dp two times.\\nAccumulate the occurence of \\'W\\', and calculate the occurence \\'W\\' in the substring which ending in index i. Finally, return the minimal of this dp array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, but little slower than sliding window\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        const int n = blocks.size();\\n        vector<int> dp(n);\\n\\n        dp[0] = blocks[0]==\\'W\\';\\n        for(int i=1; i<n; i++){\\n            if(blocks[i]==\\'W\\') dp[i] = dp[i-1]+1;\\n            else dp[i] = dp[i-1];\\n        }\\n\\n        for(int i=n-1; i>=0; i--){\\n            // assuming dp[-1] == 0\\n            if(i-k<-1) dp[i]=INT_MAX;   // impossible case\\n            else if(i-k==-1) dp[i] = dp[i];\\n            else dp[i]-=dp[i-k];\\n        }\\n\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        const int n = blocks.size();\\n        vector<int> dp(n);\\n\\n        dp[0] = blocks[0]==\\'W\\';\\n        for(int i=1; i<n; i++){\\n            if(blocks[i]==\\'W\\') dp[i] = dp[i-1]+1;\\n            else dp[i] = dp[i-1];\\n        }\\n\\n        for(int i=n-1; i>=0; i--){\\n            // assuming dp[-1] == 0\\n            if(i-k<-1) dp[i]=INT_MAX;   // impossible case\\n            else if(i-k==-1) dp[i] = dp[i];\\n            else dp[i]-=dp[i-k];\\n        }\\n\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541810,
                "title": "sliding-window-c",
                "content": "`Please Upvote if Like!!!`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int cnt = count(blocks.begin(), blocks.begin() + k, \\'W\\'); // Count the number of \\'W\\' blocks in the first k elements\\n        int ans = cnt; // Initialize ans with the initial count\\n        for (int i = k; i < blocks.size(); i++) {\\n            cnt += (blocks[i] == \\'W\\'); // Increment the count if the current block is \\'W\\'\\n            cnt -= (blocks[i - k] == \\'W\\'); // Decrement the count if the block k positions ago was \\'W\\'\\n            ans = min(ans, cnt); // Update ans with the minimum count so far\\n        }\\n        return ans; // Return the minimum count of \\'W\\' blocks needed to be recolored\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int cnt = count(blocks.begin(), blocks.begin() + k, \\'W\\'); // Count the number of \\'W\\' blocks in the first k elements\\n        int ans = cnt; // Initialize ans with the initial count\\n        for (int i = k; i < blocks.size(); i++) {\\n            cnt += (blocks[i] == \\'W\\'); // Increment the count if the current block is \\'W\\'\\n            cnt -= (blocks[i - k] == \\'W\\'); // Decrement the count if the block k positions ago was \\'W\\'\\n            ans = min(ans, cnt); // Update ans with the minimum count so far\\n        }\\n        return ans; // Return the minimum count of \\'W\\' blocks needed to be recolored\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489647,
                "title": "simple-java-solution-sliding-window",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int i=0,j=0,count=0;\\n        int max=Integer.MAX_VALUE;\\n        while(i<blocks.length()){\\n            if(blocks.charAt(i)==\\'W\\') count++;\\n            if(i-j+1==k){\\n                max=Math.min(count,max);\\n                if(blocks.charAt(j)==\\'W\\') count--;\\n                j++;\\n            }\\n             i++;\\n           \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int i=0,j=0,count=0;\\n        int max=Integer.MAX_VALUE;\\n        while(i<blocks.length()){\\n            if(blocks.charAt(i)==\\'W\\') count++;\\n            if(i-j+1==k){\\n                max=Math.min(count,max);\\n                if(blocks.charAt(j)==\\'W\\') count--;\\n                j++;\\n            }\\n             i++;\\n           \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358240,
                "title": "javascript-o-n-sliding-window",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEach step we adding `1` to `current` minimal value if we meet `\\'W\\'`.  When our substring is length of `k` we start compare it with a `min` value initialized with `k` so it can\\'t be more than length of substring. Then check `bloks[start]`, if it is equal to `\\'W\\'` substract `1` from current.\\n\\n\\nTime complexity: O(n).\\n\\n# Code\\n```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function(blocks, k) {\\n    const WHITE = \\'W\\';\\n    let min = k;\\n    let current = 0;\\n    let start = 0;\\n\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === WHITE) {\\n            current++;\\n        }\\n\\n        if (end + 1 >= k) {\\n            min = Math.min(min, current);\\n\\n            if (blocks[start++] === WHITE) {\\n                current--;\\n            }\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function(blocks, k) {\\n    const WHITE = \\'W\\';\\n    let min = k;\\n    let current = 0;\\n    let start = 0;\\n\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === WHITE) {\\n            current++;\\n        }\\n\\n        if (end + 1 >= k) {\\n            min = Math.min(min, current);\\n\\n            if (blocks[start++] === WHITE) {\\n                current--;\\n            }\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253303,
                "title": "python3-sliding-window-beat-91-94-28ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        i, j, minval = 0, k, k\\n        while j <= len(blocks):\\n            count = blocks[i:j].count(\"W\")\\n            minval = min(minval, count)\\n            i += 1\\n            j += 1\\n        return minval\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        i, j, minval = 0, k, k\\n        while j <= len(blocks):\\n            count = blocks[i:j].count(\"W\")\\n            minval = min(minval, count)\\n            i += 1\\n            j += 1\\n        return minval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234091,
                "title": "c-sliding-window-o-n-solution",
                "content": "The idea is to check all possible sequences with length $$k$$ and calculate amount of white blocks in them, but not using brute force. Note, that if we know the number of white blocks for the sequence $$[l...l + k)$$, then we can efficiently calculate this number for the sequence $$[l + 1...l + k + 1)$$. See the code for details. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int number_of_white_blocks = 0;\\n        for (int i = 0; i < k; i++) {\\n            if (blocks[i] == \\'W\\') number_of_white_blocks++;\\n        }\\n        int answer = number_of_white_blocks;\\n        int l = 1, r = k;\\n        while (r < blocks.size()) {\\n            if (blocks[r] == \\'W\\') {\\n                number_of_white_blocks++;\\n            }\\n            if (blocks[l - 1] == \\'W\\') {\\n                number_of_white_blocks--;\\n            }\\n            answer = std::min(answer, number_of_white_blocks);\\n            l++;\\n            r++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int number_of_white_blocks = 0;\\n        for (int i = 0; i < k; i++) {\\n            if (blocks[i] == \\'W\\') number_of_white_blocks++;\\n        }\\n        int answer = number_of_white_blocks;\\n        int l = 1, r = k;\\n        while (r < blocks.size()) {\\n            if (blocks[r] == \\'W\\') {\\n                number_of_white_blocks++;\\n            }\\n            if (blocks[l - 1] == \\'W\\') {\\n                number_of_white_blocks--;\\n            }\\n            answer = std::min(answer, number_of_white_blocks);\\n            l++;\\n            r++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201209,
                "title": "faster-than-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = k;\\n        for (int i = 0; i <= blocks.size()-k; i++){\\n            int a = 0;\\n            for (int j = i; j < i + k; j++){\\n                if (blocks[j] == \\'W\\'){\\n                    a++;\\n                }\\n            }\\n            ans = min(a, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = k;\\n        for (int i = 0; i <= blocks.size()-k; i++){\\n            int a = 0;\\n            for (int j = i; j < i + k; j++){\\n                if (blocks[j] == \\'W\\'){\\n                    a++;\\n                }\\n            }\\n            ans = min(a, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191668,
                "title": "0ms-c-easy-to-understand-most-efficient-solution-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = 10000;\\n        for(int i=0, j=k; i<=blocks.size()-k, j<=blocks.size(); i++, j++) {\\n            int count = 0;\\n            for(int ind=i; ind<j; ind++) {\\n                if(blocks[ind] == \\'W\\') count++;\\n            }\\n            ans = min(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = 10000;\\n        for(int i=0, j=k; i<=blocks.size()-k, j<=blocks.size(); i++, j++) {\\n            int count = 0;\\n            for(int ind=i; ind<j; ind++) {\\n                if(blocks[ind] == \\'W\\') count++;\\n            }\\n            ans = min(ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176932,
                "title": "sliding-window-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int left=0, right=k-1;\\n        int count=0, ans=0;\\n        for(int i=left; i<=right; i++){\\n            if(blocks[i]==\\'W\\') count++;\\n        }\\n        ans=count;\\n\\n        left++, right++;\\n        while(right<n){\\n            if(blocks[right]==\\'W\\' && blocks[left-1]==\\'B\\') count++;\\n            else if(blocks[right]==\\'B\\' && blocks[left-1]==\\'W\\') count--;\\n            ans=min(ans, count);\\n            left++;\\n            right++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int left=0, right=k-1;\\n        int count=0, ans=0;\\n        for(int i=left; i<=right; i++){\\n            if(blocks[i]==\\'W\\') count++;\\n        }\\n        ans=count;\\n\\n        left++, right++;\\n        while(right<n){\\n            if(blocks[right]==\\'W\\' && blocks[left-1]==\\'B\\') count++;\\n            else if(blocks[right]==\\'B\\' && blocks[left-1]==\\'W\\') count--;\\n            ans=min(ans, count);\\n            left++;\\n            right++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133550,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinimumRecolors(string blocks, int k) {\\n        \\n        var minOperations = Int32.MaxValue;\\n        for(int i = 0; i < blocks.Length; i++)\\n        {\\n            if( i + k > blocks.Length) break;\\n\\n            var substr = blocks.Substring(i, k);\\n\\n            var operationCount = substr.Count(x => x == \\'W\\');\\n\\n            if(operationCount < minOperations)\\n            {\\n                minOperations = operationCount;\\n            }\\n        }\\n\\n        return minOperations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumRecolors(string blocks, int k) {\\n        \\n        var minOperations = Int32.MaxValue;\\n        for(int i = 0; i < blocks.Length; i++)\\n        {\\n            if( i + k > blocks.Length) break;\\n\\n            var substr = blocks.Substring(i, k);\\n\\n            var operationCount = substr.Count(x => x == \\'W\\');\\n\\n            if(operationCount < minOperations)\\n            {\\n                minOperations = operationCount;\\n            }\\n        }\\n\\n        return minOperations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082235,
                "title": "sliding-window-count-if-c",
                "content": "\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Let me know if you have any Q and *plz upvote if you like the solution!*\\n```\\nclass Solution \\n{\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int c = count_if(blocks.begin(),blocks.begin()+k,[](char ch)\\n        {\\n            return ch==\\'W\\';\\n        });\\n        int minOpe = c, n = blocks.size()-k+1;\\n        for(int i=1;i<n;i++)\\n        {\\n            c = c - (blocks[i-1]==\\'W\\') + (blocks[i+k-1]==\\'W\\');\\n            minOpe = min(minOpe,c); \\n        }\\n        return minOpe;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int c = count_if(blocks.begin(),blocks.begin()+k,[](char ch)\\n        {\\n            return ch==\\'W\\';\\n        });\\n        int minOpe = c, n = blocks.size()-k+1;\\n        for(int i=1;i<n;i++)\\n        {\\n            c = c - (blocks[i-1]==\\'W\\') + (blocks[i+k-1]==\\'W\\');\\n            minOpe = min(minOpe,c); \\n        }\\n        return minOpe;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849540,
                "title": "very-simple-c-o-n-time-complexity-o-1-space",
                "content": "# Approach\\nWe want to maximize number of \\'B\\' in the given window of size k\\n\\nSo create a window of k size and count number of \\'B\\' character \\n\\nKeep track of maximum \\'B\\' found over each window \\n\\nThe total no of operation required will be the required number - maximum \\'B\\' \\n\\nWhich is **k- max number of \\'B\\'**\\n\\n# Complexity\\n- Time complexity:\\nSince one traversal - O(N)\\n\\n- Space complexity:\\nNo extra space required - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int match(int l,int r,string blocks){\\n        int val=0;\\n        for(int i=0;i<r;i++){\\n            if(blocks[l+i]==\\'B\\'){\\n                val++;\\n            }\\n\\n        }\\n        return val;\\n    }\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int max1=INT_MIN;\\n        for(int l=0,r=k-1;r<n;l++,r++){\\n            max1=max(match(l,k,blocks),max1);\\n        }\\n        return k-max1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int match(int l,int r,string blocks){\\n        int val=0;\\n        for(int i=0;i<r;i++){\\n            if(blocks[l+i]==\\'B\\'){\\n                val++;\\n            }\\n\\n        }\\n        return val;\\n    }\\n    int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int max1=INT_MIN;\\n        for(int l=0,r=k-1;r<n;l++,r++){\\n            max1=max(match(l,k,blocks),max1);\\n        }\\n        return k-max1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849281,
                "title": "sliding-window-approach-easy-to-understand-beginner",
                "content": "# Intuition\\nWe can clearly see that we need to count number of whites in the\\nsubarray of length k\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding window approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n    int ans=0;\\n    int window_count=0;\\n    for(int i=0;i<k;i++)\\n    {\\n    if(blocks[i]==\\'W\\')\\n    window_count++;\\n    }\\n    ans=window_count;\\n    for(int i=k;i<blocks.size();i++)\\n    {\\n    if(blocks[i]==\\'W\\')\\n    window_count++;\\n    if(blocks[i-k]==\\'W\\')\\n    window_count--;\\n    ans=min(window_count,ans);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n    int ans=0;\\n    int window_count=0;\\n    for(int i=0;i<k;i++)\\n    {\\n    if(blocks[i]==\\'W\\')\\n    window_count++;\\n    }\\n    ans=window_count;\\n    for(int i=k;i<blocks.size();i++)\\n    {\\n    if(blocks[i]==\\'W\\')\\n    window_count++;\\n    if(blocks[i-k]==\\'W\\')\\n    window_count--;\\n    ans=min(window_count,ans);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833402,
                "title": "javascript-sliding-window-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function (blocks, k) {\\n    let min = Infinity;\\n    let start = 0;\\n    let currentMin = 0;\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === \\'W\\') currentMin++;\\n        if (end - start + 1 == k) {\\n            min = Math.min(currentMin, min);\\n            if (blocks[start++] === \\'W\\') {\\n                currentMin--\\n            }\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} blocks\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumRecolors = function (blocks, k) {\\n    let min = Infinity;\\n    let start = 0;\\n    let currentMin = 0;\\n    for (let end = 0; end < blocks.length; end++) {\\n        if (blocks[end] === \\'W\\') currentMin++;\\n        if (end - start + 1 == k) {\\n            min = Math.min(currentMin, min);\\n            if (blocks[start++] === \\'W\\') {\\n                currentMin--\\n            }\\n        }\\n    }\\n\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807888,
                "title": "easy-c-sliding-window-technique-0-n-time-0-1-space-complexity-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->For every  window of length K , we find count of B (Black Box)\\n->so inorder to get atleast K Black Box , no of Changes required in a window of size k is ( k - cnt of Black Box)\\n-> For Minimum ans  , the minimum of ( k - coubtnt of Black Box) would satisfy our need .\\n\\nLets dry run using one example .\\n\\nstring s = \"WWBWWBBW\" k = 3 \\n\\n- Substring with length k  :\\n\\n WWB , WBW , BWW , WWB , WBB , BBW \\n\\n- Now no of Black Box in each substring :\\n\\nWWB - 1, WBW - 1, BWW - 1 , WWB - 1 , WBB - 2 , BBW - 2\\n\\n- No of changes required so that all substring are \"BBB\":\\n\\nWWB -> (3-1) = 2, WBW ->  (3 - 1) = 2, BWW -> (3-1) = 2 , WWB -> (3-1) =2  , WBB -> (3-2) = 1 , BBW -> (3-2) = 1 \\n\\n- Minimum from all the values would be ans ( 1 in this case)\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf u liked the approach , please upvote \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n\\n        int i  = 0 ; \\n\\n        int cnt = 0 ;\\n\\n        int ans = INT_MAX ; \\n\\n        for(int j = 0 ; j < blocks.length() ; j++)\\n        {\\n            if(blocks[j] == \\'B\\')\\n            cnt++;\\n\\n            if( j - i + 1  == k)\\n            {\\n                 ans = min(ans , k - cnt);\\n\\n                 if(blocks[i] == \\'B\\')\\n                 cnt--;\\n\\n                 i++;\\n            }\\n        }\\n       return ans ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n\\n        int i  = 0 ; \\n\\n        int cnt = 0 ;\\n\\n        int ans = INT_MAX ; \\n\\n        for(int j = 0 ; j < blocks.length() ; j++)\\n        {\\n            if(blocks[j] == \\'B\\')\\n            cnt++;\\n\\n            if( j - i + 1  == k)\\n            {\\n                 ans = min(ans , k - cnt);\\n\\n                 if(blocks[i] == \\'B\\')\\n                 cnt--;\\n\\n                 i++;\\n            }\\n        }\\n       return ans ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779060,
                "title": "100-faster-90-less-memory-easy-to-understand",
                "content": "\\n\\n# Approach\\nSliding Window Technique\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int res=0,count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n            count++;\\n        }\\n        res = max(res,count);\\n        for(int i=k;i<blocks.length();i++)\\n        {\\n            if(blocks[i]==\\'B\\'&&blocks[i-k]==\\'W\\')\\n            count++;\\n            if(blocks[i]==\\'W\\'&&blocks[i-k]==\\'B\\')\\n            count--;\\n            res = max(res,count);\\n        }\\n        return k-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int res=0,count=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n            count++;\\n        }\\n        res = max(res,count);\\n        for(int i=k;i<blocks.length();i++)\\n        {\\n            if(blocks[i]==\\'B\\'&&blocks[i-k]==\\'W\\')\\n            count++;\\n            if(blocks[i]==\\'W\\'&&blocks[i-k]==\\'B\\')\\n            count--;\\n            res = max(res,count);\\n        }\\n        return k-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737121,
                "title": "java-same-as-1456-sliding-window-with-minimum-iterations",
                "content": "```\\nclass Solution {\\n    public boolean isWhite(char ch){\\n        return ch == \\'W\\';\\n    }\\n    public int minimumRecolors(String s, int k) {\\n        int min = s.length(), i = 0, counter = 0;\\n        String generator = s.substring(i, i+k);\\n        for(char c : generator.toCharArray()){\\n            if(isWhite(c)){\\n                counter++;\\n            }\\n        }\\n        min = Math.min(counter, min);\\n        while(i < s.length() - k){\\n            if(isWhite(generator.charAt(0))){\\n                counter--;\\n            }\\n            i++;\\n            generator = s.substring(i, i+k);\\n            if(isWhite(generator.charAt(generator.length()-1))){\\n                counter++;\\n            }\\n            min = Math.min(counter, min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isWhite(char ch){\\n        return ch == \\'W\\';\\n    }\\n    public int minimumRecolors(String s, int k) {\\n        int min = s.length(), i = 0, counter = 0;\\n        String generator = s.substring(i, i+k);\\n        for(char c : generator.toCharArray()){\\n            if(isWhite(c)){\\n                counter++;\\n            }\\n        }\\n        min = Math.min(counter, min);\\n        while(i < s.length() - k){\\n            if(isWhite(generator.charAt(0))){\\n                counter--;\\n            }\\n            i++;\\n            generator = s.substring(i, i+k);\\n            if(isWhite(generator.charAt(generator.length()-1))){\\n                counter++;\\n            }\\n            min = Math.min(counter, min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695455,
                "title": "java-solution-using-slinding-window",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int s=0;\\n        int e=k;\\n        int res=0;\\n        char[] lst=blocks.toCharArray();\\n        for(int i=0; i<k; i++) if(lst[i]==\\'W\\') res++;\\n        int tot=res;\\n        for(int i=0; i<lst.length-k; i++){\\n            if(lst[s]==\\'W\\') tot-=1;\\n            if(lst[e]==\\'W\\') tot+=1;\\n            res=Math.min(res, tot);\\n            s++;\\n            e++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int s=0;\\n        int e=k;\\n        int res=0;\\n        char[] lst=blocks.toCharArray();\\n        for(int i=0; i<k; i++) if(lst[i]==\\'W\\') res++;\\n        int tot=res;\\n        for(int i=0; i<lst.length-k; i++){\\n            if(lst[s]==\\'W\\') tot-=1;\\n            if(lst[e]==\\'W\\') tot+=1;\\n            res=Math.min(res, tot);\\n            s++;\\n            e++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618747,
                "title": "java-simple-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int res=k+1;\\n        for(int i=0;i<=b.length()-k;i++){\\n            String a=b.substring(i,i+k);\\n            int m=a.split(\"W\",-1).length-1;\\n            res=Math.min(m,res);\\n        }return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int res=k+1;\\n        for(int i=0;i<=b.length()-k;i++){\\n            String a=b.substring(i,i+k);\\n            int m=a.split(\"W\",-1).length-1;\\n            res=Math.min(m,res);\\n        }return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596130,
                "title": "c-sliding-window-faster-than-100-o-n",
                "content": "### Intuition:\\n1. Store each element in a map.\\n2. Achieve the given window size by increasing \\'j-th\\' index.\\n3. If achieved desire window then calculate the answer which is count of \\'W\\' from Map.\\n4. Store minimun of the count in \\'mn\\'.\\n5. slide the window by increasing \\'i-th\\' and \\'j-th\\' index.\\n6. Atlast, return \\'mn\\' thats our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        unordered_map<char, int>mp;\\n        int i=0; int j=0; int mn = INT_MAX;\\n        while(j < blocks.length()){\\n            mp[blocks[j]]++;\\n            int cnt = mp[\\'W\\'];\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1 == k){\\n                mn = min(mn, cnt);\\n                mp[blocks[i]]--;\\n                \\n                i++; j++;\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```\\n#### If You understand the Intuition and as well as code then.... pls Upvote me... and feel free to comment if you have any doubt related to this solution....",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        unordered_map<char, int>mp;\\n        int i=0; int j=0; int mn = INT_MAX;\\n        while(j < blocks.length()){\\n            mp[blocks[j]]++;\\n            int cnt = mp[\\'W\\'];\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1 == k){\\n                mn = min(mn, cnt);\\n                mp[blocks[i]]--;\\n                \\n                i++; j++;\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554865,
                "title": "100-faster-easy-sliding-window",
                "content": "For every window except the first, we only need to take care of the index to be **added** and the index to be **removed** in the **previous window**.\\nPlease upvote if you find the solution good.\\n***Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int left = 0, right = 0, n = s.size(), res = 0, temp = 0;\\n        while(right < k) {\\n            temp += (s[right++] == \\'W\\');\\n        }\\n        res = temp;\\n        while(right < n) {\\n            temp -= (s[left++] == \\'W\\'); temp += (s[right++] == \\'W\\');\\n            res = min(res, temp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int left = 0, right = 0, n = s.size(), res = 0, temp = 0;\\n        while(right < k) {\\n            temp += (s[right++] == \\'W\\');\\n        }\\n        res = temp;\\n        while(right < n) {\\n            temp -= (s[left++] == \\'W\\'); temp += (s[right++] == \\'W\\');\\n            res = min(res, temp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488377,
                "title": "python-for-beginners-nice-question-to-learn-for-sliding-window-algorithm-commented-solution",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        #Simple-Approach (Sliding Window)\\n        #Runtime:42ms \\n        lis=[]\\n        for i in range(0,len(blocks)):\\n            count_b=blocks[i:i+k].count(\"B\")  #Count Blacks\\n            if(count_b>=k):                   #If Count Blacks > desired number of consecutive black blocks return 0\\n                return 0\\n            lis.append(k-count_b)       # Minimum number of operation required for consecutive black k times\\n        return min(lis)  #Return minimum number of blocks operation required \\n```\\n\\n**Without using list**- **[Efficient than above one]**\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        #Simple-Approach (Sliding Window)\\n        #Runtime:32ms \\n        minimum_change=k     #Worst Case scenario if all blocks are white minimum change required is k times\\n        for i in range(0,len(blocks)):\\n            count_b=blocks[i:i+k].count(\"B\")  #Count Blacks\\n            if(count_b>=k):                   #If Count Blacks > desired number of consecutive black blocks return 0\\n                return 0\\n            minimum_change=min(minimum_change,k-count_b)     #updating the minimum change  \\n        return minimum_change\\n```\\n\\n**Hope you will like it....!!\\uD83D\\uDE09\\uD83D\\uDE09**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        #Simple-Approach (Sliding Window)\\n        #Runtime:42ms \\n        lis=[]\\n        for i in range(0,len(blocks)):\\n            count_b=blocks[i:i+k].count(\"B\")  #Count Blacks\\n            if(count_b>=k):                   #If Count Blacks > desired number of consecutive black blocks return 0\\n                return 0\\n            lis.append(k-count_b)       # Minimum number of operation required for consecutive black k times\\n        return min(lis)  #Return minimum number of blocks operation required \\n```\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        #Simple-Approach (Sliding Window)\\n        #Runtime:32ms \\n        minimum_change=k     #Worst Case scenario if all blocks are white minimum change required is k times\\n        for i in range(0,len(blocks)):\\n            count_b=blocks[i:i+k].count(\"B\")  #Count Blacks\\n            if(count_b>=k):                   #If Count Blacks > desired number of consecutive black blocks return 0\\n                return 0\\n            minimum_change=min(minimum_change,k-count_b)     #updating the minimum change  \\n        return minimum_change\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479213,
                "title": "c-0-ms-time-100-faster",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int blackCount = 0, i;\\n        for (i = 0; i < k; i++) if (blocks[i] == \\'B\\') blackCount++;        \\n        int res = k - blackCount;\\n        while (i < blocks.size()) {\\n            if (blocks[i] == \\'B\\') blackCount++;\\n            if (blocks[i - k] == \\'B\\') blackCount--;\\n            res = min(res, k - blackCount);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int blackCount = 0, i;\\n        for (i = 0; i < k; i++) if (blocks[i] == \\'B\\') blackCount++;        \\n        int res = k - blackCount;\\n        while (i < blocks.size()) {\\n            if (blocks[i] == \\'B\\') blackCount++;\\n            if (blocks[i - k] == \\'B\\') blackCount--;\\n            res = min(res, k - blackCount);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478962,
                "title": "python-easy-solution-28-ms-faster-than-100",
                "content": "**While** our current **step** is less then (length - number of blocks \"k\" - 1):\\n1. define a temporary array which will contain only from the step to \"k\" index characters\\n2. count the number of \"W\" in **temp array** and compare the number with **previous min_operation**\\n3. Increment the step and repeat it & return minimum operation.\\n\\n```\\nclass Solution:\\n\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\tmin_operation, step = 0, 0\\n\\t\\twhile step < len(blocks) - k + 1:\\n\\t\\t\\ttemp_arr = blocks[step : step + k]\\n\\t\\t\\tif step == 0:\\n\\t\\t\\t\\tmin_operation += temp_arr.count(\"W\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmin_operation = min(min_operation, temp_arr.count(\"W\"))\\n\\t\\t\\tstep += 1\\n\\n\\t\\treturn min_operation\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5fbc23cd-df31-49cd-8549-6a8cacb82fb7_1661437169.0957355.png)\\n\\n\\n**Without if /else**\\nYou can ignore if / else condition if you define \"min_operation\" as a positive inf value\\n```\\nfrom math import inf\\n\\nclass Solution:\\n\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\tmin_operation, step = inf, 0\\n\\t\\twhile step < len(blocks) - k + 1:\\n\\t\\t\\ttemp_arr = blocks[step : step + k]\\n\\t\\t\\tmin_operation = min(min_operation, temp_arr.count(\"W\"))\\n\\t\\t\\tstep += 1\\n\\n\\t\\treturn min_operation\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\tmin_operation, step = 0, 0\\n\\t\\twhile step < len(blocks) - k + 1:\\n\\t\\t\\ttemp_arr = blocks[step : step + k]\\n\\t\\t\\tif step == 0:\\n\\t\\t\\t\\tmin_operation += temp_arr.count(\"W\")\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmin_operation = min(min_operation, temp_arr.count(\"W\"))\\n\\t\\t\\tstep += 1\\n\\n\\t\\treturn min_operation\\n```\n```\\nfrom math import inf\\n\\nclass Solution:\\n\\tdef minimumRecolors(self, blocks: str, k: int) -> int:\\n\\t\\tmin_operation, step = inf, 0\\n\\t\\twhile step < len(blocks) - k + 1:\\n\\t\\t\\ttemp_arr = blocks[step : step + k]\\n\\t\\t\\tmin_operation = min(min_operation, temp_arr.count(\"W\"))\\n\\t\\t\\tstep += 1\\n\\n\\t\\treturn min_operation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474611,
                "title": "simple-javascript-solution-100-faster",
                "content": "```\\nvar minimumRecolors = function (blocks, k) {\\n    let count = 0;\\n    let minCount = Infinity;\\n    for (let i = 0; i <= blocks.length - k; i++) {\\n        for (let j = i; j < k+i; j++) {\\n            if(blocks[j] == `W`)\\n            {\\n                count++;\\n            }\\n        }\\n        if(minCount > count)\\n        {\\n            minCount = count;\\n        }\\n        count = 0;\\n    }\\n    return minCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRecolors = function (blocks, k) {\\n    let count = 0;\\n    let minCount = Infinity;\\n    for (let i = 0; i <= blocks.length - k; i++) {\\n        for (let j = i; j < k+i; j++) {\\n            if(blocks[j] == `W`)\\n            {\\n                count++;\\n            }\\n        }\\n        if(minCount > count)\\n        {\\n            minCount = count;\\n        }\\n        count = 0;\\n    }\\n    return minCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2471572,
                "title": "python-easy-sliding-window-solution-faster-than-80",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        res = len(blocks)\\n        for i in range(len(blocks)):\\n            select = blocks[i:i+k]\\n            if len(select) == k:\\n                if select.count(\\'W\\') < res:\\n                    res = select.count(\\'W\\')\\n            else:\\n                break\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        res = len(blocks)\\n        for i in range(len(blocks)):\\n            select = blocks[i:i+k]\\n            if len(select) == k:\\n                if select.count(\\'W\\') < res:\\n                    res = select.count(\\'W\\')\\n            else:\\n                break\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2469592,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minimumRecolors(string block, int k)\\n        {\\n            int ans = k;\\n            int count = 0;\\n            int i = 0;\\n            int j = 0;\\n            while (j < block.size())\\n            {\\n               \\t// if(j-i+1 < k){\\n                if (block[j] == \\'W\\') count++;\\n               \\t// j++;\\n               \\t// }\\n                if (j - i + 1 == k)\\n                {\\n                    ans = min(ans, count);\\n                    if (block[i] == \\'W\\') count--;\\n                   \\t// if(block[j] == \\'W\\')count++;\\n                    i++;\\n                   \\t// j++;\\n                }\\n                j++;\\n               \\t// ans = min(ans,count);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minimumRecolors(string block, int k)\\n        {\\n            int ans = k;\\n            int count = 0;\\n            int i = 0;\\n            int j = 0;\\n            while (j < block.size())\\n            {\\n               \\t// if(j-i+1 < k){\\n                if (block[j] == \\'W\\') count++;\\n               \\t// j++;\\n               \\t// }\\n                if (j - i + 1 == k)\\n                {\\n                    ans = min(ans, count);\\n                    if (block[i] == \\'W\\') count--;\\n                   \\t// if(block[j] == \\'W\\')count++;\\n                    i++;\\n                   \\t// j++;\\n                }\\n                j++;\\n               \\t// ans = min(ans,count);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458816,
                "title": "leetcode-the-hard-way-brute-force-solution",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size(), ans = 1e9;\\n\\t\\t// the idea is to try all positions as a starting point\\n        for (int i = 0; i + k <= n; i++) {\\n\\t\\t    // count the number of \\'W\\' in a given window size `k`\\n            int cnt = 0;\\n            for (int j = 0; j < k; j++) {\\n\\t\\t\\t    // if it is \\'W\\', we can recolor it\\n                if (blocks[i + j] == \\'W\\') {\\n                    cnt += 1;\\n                }\\n            }\\n            // keep track of the min value\\n            ans = min(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.size(), ans = 1e9;\\n\\t\\t// the idea is to try all positions as a starting point\\n        for (int i = 0; i + k <= n; i++) {\\n\\t\\t    // count the number of \\'W\\' in a given window size `k`\\n            int cnt = 0;\\n            for (int j = 0; j < k; j++) {\\n\\t\\t\\t    // if it is \\'W\\', we can recolor it\\n                if (blocks[i + j] == \\'W\\') {\\n                    cnt += 1;\\n                }\\n            }\\n            // keep track of the min value\\n            ans = min(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458359,
                "title": "sliding-window-c-easy-solution",
                "content": "```\\n int n=blocks.length();\\n        string res=\"\";\\n        int cnt=0;\\n        for(int i=0;i<k;i++){\\n            res+=blocks[i];\\n            if(blocks[i]==\\'W\\'){\\n                cnt++;\\n            }\\n        }\\n        int ans=cnt;\\n        for(int i=k;i<n;i++){\\n           res+=blocks[i];\\n         //   res-=blocks[i-k];\\n            if(res[i]==\\'W\\'){\\n                cnt++;\\n            }\\n            if(res[i-k]==\\'W\\'){\\n                cnt--;\\n            }\\n            ans=min(ans,cnt);\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "```\\n int n=blocks.length();\\n        string res=\"\";\\n        int cnt=0;\\n        for(int i=0;i<k;i++){\\n            res+=blocks[i];\\n            if(blocks[i]==\\'W\\'){\\n                cnt++;\\n            }\\n        }\\n        int ans=cnt;\\n        for(int i=k;i<n;i++){\\n           res+=blocks[i];\\n         //   res-=blocks[i-k];\\n            if(res[i]==\\'W\\'){\\n                cnt++;\\n            }\\n            if(res[i-k]==\\'W\\'){\\n                cnt--;\\n            }\\n            ans=min(ans,cnt);\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2458274,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn minimum_recolors(blocks: String, k: i32) -> i32 {\\n        let idx = |b: u8| -> usize { (b > b\\'B\\') as _ };\\n        let mut counter = [0; 2];\\n        let mut res = i32::MAX;\\n        let bb = blocks.as_bytes();\\n        let ku = k as usize;\\n\\n        for (i, w) in bb.windows(ku).enumerate() {\\n            match i > 0 {\\n                true => {\\n                    counter[idx(w[ku - 1])] += 1;\\n                    counter[idx(bb[i - 1])] -= 1;\\n                }\\n                false => w.iter().for_each(|&b| counter[idx(b)] += 1),\\n            };\\n\\n            match counter[1] {\\n                0 => return 0,\\n                n => res = res.min(n),\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_recolors(blocks: String, k: i32) -> i32 {\\n        let idx = |b: u8| -> usize { (b > b\\'B\\') as _ };\\n        let mut counter = [0; 2];\\n        let mut res = i32::MAX;\\n        let bb = blocks.as_bytes();\\n        let ku = k as usize;\\n\\n        for (i, w) in bb.windows(ku).enumerate() {\\n            match i > 0 {\\n                true => {\\n                    counter[idx(w[ku - 1])] += 1;\\n                    counter[idx(bb[i - 1])] -= 1;\\n                }\\n                false => w.iter().for_each(|&b| counter[idx(b)] += 1),\\n            };\\n\\n            match counter[1] {\\n                0 => return 0,\\n                n => res = res.min(n),\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457590,
                "title": "python3-for-beginners",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        blocks=list(blocks)\\n        c=0\\n        s=[]\\n        for i in range(len(blocks)):\\n            if len(blocks[i:k+i])==k:\\n                s.append(blocks[i:k+i])\\n        for i in range(len(s)):\\n            s[i]=k-(s[i].count(\\'B\\'))\\n        return min(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        blocks=list(blocks)\\n        c=0\\n        s=[]\\n        for i in range(len(blocks)):\\n            if len(blocks[i:k+i])==k:\\n                s.append(blocks[i:k+i])\\n        for i in range(len(s)):\\n            s[i]=k-(s[i].count(\\'B\\'))\\n        return min(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457572,
                "title": "100-easy-solution-c",
                "content": "**\\nint minimumRecolors(string blocks, int k) {\\n        \\n        int n= blocks.length();\\n        int cntW;\\n        int mini= INT_MAX;\\n        for(int i=0;i<n-k+1;i++)\\n        {\\n             cntW=0;\\n            for(int j=i; j<k+i;j++)\\n            {\\n                \\n                if(blocks[j]==\\'W\\')\\n                    cntW = cntW+1;\\n                \\n\\n                \\n            }\\n            if(cntW==0)\\n                return 0;\\n            \\n            mini= min(mini, cntW);\\n\\n        }\\n        \\n        \\n        \\n        return mini;\\n    \\n    }**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "**\\nint minimumRecolors(string blocks, int k) {\\n        \\n        int n= blocks.length();\\n        int cntW;\\n        int mini= INT_MAX;\\n        for(int i=0;i<n-k+1;i++)\\n        {\\n             cntW=0;\\n            for(int j=i; j<k+i;j++)\\n            {\\n                \\n                if(blocks[j]==\\'W\\')\\n                    cntW = cntW+1;\\n                \\n\\n                \\n            }\\n            if(cntW==0)\\n                return 0;\\n            \\n            mini= min(mini, cntW);\\n\\n        }\\n        \\n        \\n        \\n        return mini;\\n    \\n    }**",
                "codeTag": "Unknown"
            },
            {
                "id": 2455997,
                "title": "java-0-ms-easy-sliding-windows-with-easy-explanations",
                "content": "Note that, we just focus on all the `k` length substring and consider how many blocks we need to recolor to make all the blocks black, then return the minimum one.\\n\\nWe build a ``` int[] cum```, with `n+1` length, to count how many blocks that we need to recolor so for. \\nIn the example of \"WBBWWBBWBW\", we will have:\\n`cum = {0, 1, 1, 1, 2, 3, 3, 3, 4, 4, 5 }` .\\n`str[] = .{W, B, B, W, W, B, B, W, B, W }`.\\n\\nThen, we use sliding window, to traverse all `k` length substring, to get the minimun number of recoloring blocks. That is, when `k = 7` we will have: \\n`[0, 7] = cum[7] - cum[0] = 3 - 0 = 3`, where string is \"WBBWWBB\", needs 3 recolorings.\\n`[1, 8] = cum[8] - cum[1] = 4 - 1 = 3`, where string is \"BBWWBBW\", needs 3 recolorings\\'\\n`[9, 2] = 4 - 1 = 3`, where string is \"BWWBBWB\", needs 3 recolorings\\'\\n`[10, 3] = 5 - 1 = 4`, where string is \"WWBBWBW\", needs 4 recolorings.\\n\\nSo, `3` is the optimal choice for returning.\\n\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        //using sliding windows to slove this question\\'\\n        int n = blocks.length();\\n        int[] cum = new int[n+1];\\n        char[] c = blocks.toCharArray();\\n        for(int i = 0; i < n; i++){\\n            cum[i+1] = cum[i] + (c[i] == \\'W\\'?1:0);\\n        }\\n        int res = n;\\n        //traverse all the k length blocks, and count the min recolor blocks\\n        for(int i = 0; i <= n-k; i++){\\n            res = Math.min(cum[i+k] - cum[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "``` int[] cum```\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        //using sliding windows to slove this question\\'\\n        int n = blocks.length();\\n        int[] cum = new int[n+1];\\n        char[] c = blocks.toCharArray();\\n        for(int i = 0; i < n; i++){\\n            cum[i+1] = cum[i] + (c[i] == \\'W\\'?1:0);\\n        }\\n        int res = n;\\n        //traverse all the k length blocks, and count the min recolor blocks\\n        for(int i = 0; i <= n-k; i++){\\n            res = Math.min(cum[i+k] - cum[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455721,
                "title": "javascript-sliding-window-o-n-optimized",
                "content": "```\\nvar minimumRecolors = function(blocks, k) {\\n    var w=0;\\n    for(var i=0; i<k; i++)\\n        {\\n            if(blocks[i]==\"W\")\\n                w++;\\n        }\\n    var min = w;\\n    for(var j=1; j<=blocks.length-k; j++)\\n        {\\n            if(blocks[j-1]==\"W\")\\n                w--;\\n            if(blocks[j+k-1] == \"W\")\\n                w++;\\n            if(min>w)\\n                min=w;\\n        }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRecolors = function(blocks, k) {\\n    var w=0;\\n    for(var i=0; i<k; i++)\\n        {\\n            if(blocks[i]==\"W\")\\n                w++;\\n        }\\n    var min = w;\\n    for(var j=1; j<=blocks.length-k; j++)\\n        {\\n            if(blocks[j-1]==\"W\")\\n                w--;\\n            if(blocks[j+k-1] == \"W\")\\n                w++;\\n            if(min>w)\\n                min=w;\\n        }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455631,
                "title": "python-simple-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        ans = []\\n        for i in range(0, len(blocks)-k+1):\\n            ans.append(blocks[i:i+k].count(\\'W\\'))\\n        return min(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        ans = []\\n        for i in range(0, len(blocks)-k+1):\\n            ans.append(blocks[i:i+k].count(\\'W\\'))\\n        return min(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455546,
                "title": "c-0-ms-fast-sliding-window-t-o-n-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int minimumRecolors(string blocks, int k) {\\n        int black=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'B\\'){\\n                black++;\\n            }\\n        }\\n        int ans=k-black;\\n        for(int i=k;i<blocks.size();i++){\\n            if(blocks[i-k]==\\'W\\' && blocks[i]==\\'B\\'){\\n                black++;\\n            }\\n            else if(blocks[i-k]==\\'B\\' && blocks[i]==\\'W\\'){\\n                black--;\\n            }\\n            ans=min(ans,k-black);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumRecolors(string blocks, int k) {\\n        int black=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'B\\'){\\n                black++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2455468,
                "title": "java-sliding-window",
                "content": "Runtime: 1 ms, faster than 80.00% of Java online submissions for Minimum Recolors to Get K Consecutive Black Blocks.\\nMemory Usage: 41.8 MB, less than 40.00% of Java online submissions for Minimum Recolors to Get K Consecutive Black Blocks.\\n```\\nclass Solution {\\n  public int minimumRecolors(String blocks, int k) {\\n    int b = 0;\\n    \\n    for(int i = 0; i != k; i++)\\n      if(blocks.charAt(i) == \\'B\\') b++;\\n    \\n    \\n    int mini = k - b;\\n    \\n    for(int i = k; i != blocks.length() && mini != 0; i++){\\n      if(blocks.charAt(i-k) == \\'B\\') b--;\\n      if(blocks.charAt(i) == \\'B\\') b++;\\n      mini = Math.min(mini, k-b);\\n    }\\n      \\n    return mini;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int minimumRecolors(String blocks, int k) {\\n    int b = 0;\\n    \\n    for(int i = 0; i != k; i++)\\n      if(blocks.charAt(i) == \\'B\\') b++;\\n    \\n    \\n    int mini = k - b;\\n    \\n    for(int i = k; i != blocks.length() && mini != 0; i++){\\n      if(blocks.charAt(i-k) == \\'B\\') b--;\\n      if(blocks.charAt(i) == \\'B\\') b++;\\n      mini = Math.min(mini, k-b);\\n    }\\n      \\n    return mini;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455340,
                "title": "efficient-concise-solution-t-c-o-n-s-c-o-1-explained",
                "content": "**PLS UPVOTE IF YOU LIKE THE SOLUTION:)**\\n**IDEA:-**\\n* We use the concept of sliding window here where we maintain a window of k size. \\n* Firstly  WE count how many whites are there in the first k window.\\n* Then to move the window we reduce the count by 1 if blocks[i-1] is a white and increase count 1 if upcoming element i.e(blocks[i+k-1]) is a white.\\n* and then we compare out of count and minm which is minimum and store it in minm.\\n* LATER minm is returned from the function.\\n**T.C:-** O(N)    **S.C:-** O(1)\\nwhere **N** is the length of string blocks\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int count=0,minm=0;\\n        for(int i{0};i<=blocks.size()-k;++i){\\n            if(i==0){\\n                for(int j{0};j<k;++j){\\n                    if(blocks[j]==\\'W\\'){\\n                        count++;\\n                    }\\n                }\\n                minm=count;\\n            }else{\\n                if(blocks[i-1]==\\'W\\'){\\n                    count--;\\n                }\\n                if(blocks[i+k-1]==\\'W\\'){\\n                    count++;\\n                }\\n                minm=min(count,minm);\\n            }\\n        }\\n        return minm;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int count=0,minm=0;\\n        for(int i{0};i<=blocks.size()-k;++i){\\n            if(i==0){\\n                for(int j{0};j<k;++j){\\n                    if(blocks[j]==\\'W\\'){\\n                        count++;\\n                    }\\n                }\\n                minm=count;\\n            }else{\\n                if(blocks[i-1]==\\'W\\'){\\n                    count--;\\n                }\\n                if(blocks[i+k-1]==\\'W\\'){\\n                    count++;\\n                }\\n                minm=min(count,minm);\\n            }\\n        }\\n        return minm;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455231,
                "title": "c-brute-force-easy-solution",
                "content": "***Please do upvote if you find it useful to keep me motivated. :)***\\n\\n```\\nint minimumRecolors(string blocks, int k) {\\n        int n = blocks.size();               // find length of string \\'blocks\\'\\n        int nn = n-k;                     \\n        int min_recolor=INT_MAX;          // assign minimum recolors to INT_MAX\\n        for(int i=0;i<=nn;i++){\\n            int t=0;          // assign no of recolor to be done to 0\\n            for(int j=i;j<(i+k);j++){\\n\\t\\t\\t // if any block is \\'W\\' we have to convert it to \\'B\\' so increase the recoloring variable by 1\\n                if(blocks[j]==\\'W\\') t++;       \\n            }\\n            min_recolor=min(min_recolor,t);       // take minimum of the minimum recolors and current recoloring count\\n        }\\n        return min_recolor;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumRecolors(string blocks, int k) {\\n        int n = blocks.size();               // find length of string \\'blocks\\'\\n        int nn = n-k;                     \\n        int min_recolor=INT_MAX;          // assign minimum recolors to INT_MAX\\n        for(int i=0;i<=nn;i++){\\n            int t=0;          // assign no of recolor to be done to 0\\n            for(int j=i;j<(i+k);j++){\\n\\t\\t\\t // if any block is \\'W\\' we have to convert it to \\'B\\' so increase the recoloring variable by 1\\n                if(blocks[j]==\\'W\\') t++;       \\n            }\\n            min_recolor=min(min_recolor,t);       // take minimum of the minimum recolors and current recoloring count\\n        }\\n        return min_recolor;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455030,
                "title": "c-solution-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minimumRecolors(string &blocks, int k) {\\n        int mx = 0, count = 0;\\n        for (int i = 0; i <= (blocks.size() - k); i++) {\\n            count = 0;\\n            for (int j = i; j < (k + i); j++) {\\n                if (blocks[j] == \\'B\\'){\\n                    count++;\\n                }\\n            }\\n            mx = max(mx, count);\\n        }\\n        return (k - mx);\\n    }\\n};\\n```\\n\\nPlease **upvote/share** if you like it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumRecolors(string &blocks, int k) {\\n        int mx = 0, count = 0;\\n        for (int i = 0; i <= (blocks.size() - k); i++) {\\n            count = 0;\\n            for (int j = i; j < (k + i); j++) {\\n                if (blocks[j] == \\'B\\'){\\n                    count++;\\n                }\\n            }\\n            mx = max(mx, count);\\n        }\\n        return (k - mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454838,
                "title": "c-o-n-time-using-sliding-window",
                "content": "**C++ Code:**\\n\\n```\\n int minimumRecolors(string blocks, int k) {\\n        int countB = 0;\\n        int ans = k;\\n        int i;\\n        for(i=0;i<k;i++)\\n          if(blocks[i]==\\'B\\') countB++;\\n        ans = min(ans,k-countB);\\n        while(i<blocks.length())\\n        {\\n            if(blocks[i]==\\'B\\') countB++;\\n            if(blocks[i-k]==\\'B\\') countB--;\\n            ans = min(ans,k-countB);\\n            i++;\\n        }\\n    return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int minimumRecolors(string blocks, int k) {\\n        int countB = 0;\\n        int ans = k;\\n        int i;\\n        for(i=0;i<k;i++)\\n          if(blocks[i]==\\'B\\') countB++;\\n        ans = min(ans,k-countB);\\n        while(i<blocks.length())\\n        {\\n            if(blocks[i]==\\'B\\') countB++;\\n            if(blocks[i-k]==\\'B\\') countB--;\\n            ans = min(ans,k-countB);\\n            i++;\\n        }\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454804,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int i = 0, j = 0, blackCount = 0, ans = Integer.MAX_VALUE;\\n        while(j < blocks.length()) {\\n            \\n            char ch = blocks.charAt(j);\\n            if(ch == \\'B\\') blackCount++;\\n            \\n            if(j-i+1 < k)\\n                j++;\\n            \\n            else if(j-i+1 == k) {\\n                ans = Math.min(ans, k - blackCount);\\n                char cur = blocks.charAt(i);\\n                if(cur == \\'B\\') blackCount--;\\n                i++; j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        \\n        int i = 0, j = 0, blackCount = 0, ans = Integer.MAX_VALUE;\\n        while(j < blocks.length()) {\\n            \\n            char ch = blocks.charAt(j);\\n            if(ch == \\'B\\') blackCount++;\\n            \\n            if(j-i+1 < k)\\n                j++;\\n            \\n            else if(j-i+1 == k) {\\n                ans = Math.min(ans, k - blackCount);\\n                char cur = blocks.charAt(i);\\n                if(cur == \\'B\\') blackCount--;\\n                i++; j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454772,
                "title": "simple-sliding-window-solution-c",
                "content": "```\\n  int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int i=0,j=0;\\n        int ans=n;\\n        int cnt=0;\\n        while(j<n){\\n            if(blocks[j]==\\'W\\'){\\n                cnt++;\\n                \\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }else if(j-i+1==k){\\n                ans=min(ans,cnt);\\n                \\n                j++;\\n                if(blocks[i]==\\'W\\'){\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int minimumRecolors(string blocks, int k) {\\n        int n=blocks.size();\\n        int i=0,j=0;\\n        int ans=n;\\n        int cnt=0;\\n        while(j<n){\\n            if(blocks[j]==\\'W\\'){\\n                cnt++;\\n                \\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }else if(j-i+1==k){\\n                ans=min(ans,cnt);\\n                \\n                j++;\\n                if(blocks[i]==\\'W\\'){\\n                    cnt--;\\n                }\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454630,
                "title": "java-easy-to-understand-with-full-explaination",
                "content": "I dont know why but seems question flavor is similar to\\nhttps://leetcode.com/problems/longest-repeating-character-replacement/\\n\\nbut whatever here is the solution in java\\n\\n```\\nclass Solution {\\n    int minimumRecolors(String blocks, int k) {\\n            int strLen = blocks.length();int bCount = 0, maxBCount = 0; int ans =0;\\n            char[] inputArray = blocks.toCharArray();\\n            for (int i = 0; i < strLen; i++) {\\n                if(inputArray[i] == \\'B\\') bCount++;\\n                if (i >= k)\\n                    if(inputArray[i - k] == \\'B\\') bCount--;\\n                maxBCount = Math.max(bCount, maxBCount);\\n            }\\n            ans = k - maxBCount;\\n            return ans;\\n        }\\n}\\n```\\n\\n**Explaination**\\n1) We will initialize bcount (to store each b count),  and bmaxcount (calculate max b count out of all the calculated bcount)\\n2) for each iteration we get \\'B\\' we make bcount++.\\n3) we make sure that as our iteration (i) cross the k, so after i>=k if we get any \\'B\\' again at the starting position of sliding window string i.e inputArray[i - k] we will decrement our i.e. bcount--. \\n4) Now we will find out the maxBcount based out last maxBcount and we will update our maxBcount.\\n5) We will subtract k from our calculated bMaxcount and return ans = k-bMaxcount.\\nNow say for eg\\n\\nTest Case. 1\\n\\n```\\n\"BWWWBB\"\\n6\\n\\ncount of B  = 3, since because condition i (max i length is 6) >=k (6) is false.\\ni.e maxBCount = 3\\nans (3) = k (6) - maxBCount  (3) \\n\\n```\\n\\nTest Case 2\\n```\\n\"WBB\"\\n1\\nB count = 2, i should be max 1 so \"B\" already is satifying the condition so maxBCount =1;\\n\\nans (0) = k(1) - maxBCount(1)\\n```\\n\\nTest Case 3\\n```\\n\"WBBWWWWBBWWBBBBWWBBWWBBBWWBBBWWWBWBWW\"\\n15\\n\\nNow try this with our own Haha :D :D\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int minimumRecolors(String blocks, int k) {\\n            int strLen = blocks.length();int bCount = 0, maxBCount = 0; int ans =0;\\n            char[] inputArray = blocks.toCharArray();\\n            for (int i = 0; i < strLen; i++) {\\n                if(inputArray[i] == \\'B\\') bCount++;\\n                if (i >= k)\\n                    if(inputArray[i - k] == \\'B\\') bCount--;\\n                maxBCount = Math.max(bCount, maxBCount);\\n            }\\n            ans = k - maxBCount;\\n            return ans;\\n        }\\n}\\n```\n```\\n\"BWWWBB\"\\n6\\n\\ncount of B  = 3, since because condition i (max i length is 6) >=k (6) is false.\\ni.e maxBCount = 3\\nans (3) = k (6) - maxBCount  (3) \\n\\n```\n```\\n\"WBB\"\\n1\\nB count = 2, i should be max 1 so \"B\" already is satifying the condition so maxBCount =1;\\n\\nans (0) = k(1) - maxBCount(1)\\n```\n```\\n\"WBBWWWWBBWWBBBBWWBBWWBBBWWBBBWWWBWBWW\"\\n15\\n\\nNow try this with our own Haha :D :D\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454542,
                "title": "java-sliding-window-o-n",
                "content": "Sliding window approach \\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = 0;\\n        int n = blocks.length();\\n        for(int i = 0;i<k;i++){\\n            if(blocks.charAt(i) == \\'W\\') ans++;\\n        }\\n        int min = ans;\\n        int l = 0, r = k;\\n        while(r<n){\\n            if(blocks.charAt(l) == \\'W\\') ans--;\\n            if(blocks.charAt(r) == \\'W\\') ans++;\\n            if(ans == 0) return 0;\\n            min = Math.min(ans, min);\\n            l++;\\n            r++;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = 0;\\n        int n = blocks.length();\\n        for(int i = 0;i<k;i++){\\n            if(blocks.charAt(i) == \\'W\\') ans++;\\n        }\\n        int min = ans;\\n        int l = 0, r = k;\\n        while(r<n){\\n            if(blocks.charAt(l) == \\'W\\') ans--;\\n            if(blocks.charAt(r) == \\'W\\') ans++;\\n            if(ans == 0) return 0;\\n            min = Math.min(ans, min);\\n            l++;\\n            r++;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454482,
                "title": "c-easy-solution-briute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string b, int k) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<b.size();i++){\\n            if(i+k > b.size())\\n                break;\\n            int c=0;\\n            for(int j=i;j<i+k;j++){\\n                if(b[j]==\\'W\\')\\n                    c++;\\n            }\\n            ans=min(ans,c);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string b, int k) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<b.size();i++){\\n            if(i+k > b.size())\\n                break;\\n            int c=0;\\n            for(int j=i;j<i+k;j++){\\n                if(b[j]==\\'W\\')\\n                    c++;\\n            }\\n            ans=min(ans,c);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454447,
                "title": "c-comment-easy-frequency-count-in-each-window-sliding-window-o-n",
                "content": "Comments-\\nFilps is always number of whites in a window.\\nJust find number of whites in each k window and keep the count of min flips;\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int mp[2]={0};\\n        for(int i=0;i<k;i++)\\n        {   \\n            if (blocks[i]==\\'B\\')\\n                mp[0]++;\\n            else\\n                mp[1]++;\\n        }\\n        int flips=mp[1];\\n        for(int i=0;i<blocks.length()-k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n                mp[0]--;\\n            if(blocks[i]==\\'W\\')\\n                mp[1]--;\\n            if(blocks[i+k]==\\'B\\')\\n                mp[0]++;\\n            if(blocks[i+k]==\\'W\\')\\n                mp[1]++;\\n            flips=min(flips,mp[1]);\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```\\nRealized Freq of black not needed after contest\\nOptimised solution\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int freq=0;\\n        int flips=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'W\\')\\n                freq++;\\n        }\\n        flips=freq;\\n        for(int i=0;i<blocks.length()-k;i++)\\n        {\\n            if(blocks[i]==\\'W\\')\\n                freq--;\\n            if(blocks[i+k]==\\'W\\')\\n                freq++;\\n            flips=min(flips,freq);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int mp[2]={0};\\n        for(int i=0;i<k;i++)\\n        {   \\n            if (blocks[i]==\\'B\\')\\n                mp[0]++;\\n            else\\n                mp[1]++;\\n        }\\n        int flips=mp[1];\\n        for(int i=0;i<blocks.length()-k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n                mp[0]--;\\n            if(blocks[i]==\\'W\\')\\n                mp[1]--;\\n            if(blocks[i+k]==\\'B\\')\\n                mp[0]++;\\n            if(blocks[i+k]==\\'W\\')\\n                mp[1]++;\\n            flips=min(flips,mp[1]);\\n        }\\n        return flips;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int freq=0;\\n        int flips=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'W\\')\\n                freq++;\\n        }\\n        flips=freq;\\n        for(int i=0;i<blocks.length()-k;i++)\\n        {\\n            if(blocks[i]==\\'W\\')\\n                freq--;\\n            if(blocks[i+k]==\\'W\\')\\n                freq++;\\n            flips=min(flips,freq);\\n        }\\n        return flips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454342,
                "title": "c-easy-and-concise-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int mini = INT_MAX;\\n        for(int i=0; i<blocks.size() - k + 1; i++)\\n        {\\n            int cnt = 0;\\n            for(int j=i; j<i+k; j++){\\n                if(blocks[j] == \\'W\\')\\n                    cnt++;\\n            }\\n            \\n            mini = min(mini, cnt);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int mini = INT_MAX;\\n        for(int i=0; i<blocks.size() - k + 1; i++)\\n        {\\n            int cnt = 0;\\n            for(int j=i; j<i+k; j++){\\n                if(blocks[j] == \\'W\\')\\n                    cnt++;\\n            }\\n            \\n            mini = min(mini, cnt);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454328,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int n = blocks.length();\\n        int limit = n - k;\\n        int minSteps = Integer.MAX_VALUE;\\n        int i=0;\\n        while(i<=limit)\\n        {\\n            int count = 0;\\n            for(int j=i;j<i+k;j++)\\n            {\\n                if(blocks.charAt(j)==\\'W\\')\\n                    count++;\\n            }\\n            minSteps = Math.min(minSteps,count);\\n            i++;\\n        }\\n        return minSteps;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int n = blocks.length();\\n        int limit = n - k;\\n        int minSteps = Integer.MAX_VALUE;\\n        int i=0;\\n        while(i<=limit)\\n        {\\n            int count = 0;\\n            for(int j=i;j<i+k;j++)\\n            {\\n                if(blocks.charAt(j)==\\'W\\')\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454291,
                "title": "java-use-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w=0;\\n        int min=k;\\n         \\n        int i, n=blocks.length();\\n        int start=0;\\n        for( i=0;i<k;++i){\\n            \\n            \\n            if(blocks.charAt(i)==\\'W\\'){\\n                w++;\\n            }\\n        }\\n        min=Math.min(min,w);\\n        while(i<n){\\n           if(blocks.charAt(start++)==\\'W\\'){\\n               --w;\\n           }\\n             \\n            if(blocks.charAt(i++)==\\'W\\'){\\n                w++;\\n            }\\n             min=Math.min(min,w);\\n           \\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w=0;\\n        int min=k;\\n         \\n        int i, n=blocks.length();\\n        int start=0;\\n        for( i=0;i<k;++i){\\n            \\n            \\n            if(blocks.charAt(i)==\\'W\\'){\\n                w++;\\n            }\\n        }\\n        min=Math.min(min,w);\\n        while(i<n){\\n           if(blocks.charAt(start++)==\\'W\\'){\\n               --w;\\n           }\\n             \\n            if(blocks.charAt(i++)==\\'W\\'){\\n                w++;\\n            }\\n             min=Math.min(min,w);\\n           \\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454275,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int ans = INT_MAX;\\n        int n = blocks.length();\\n        \\n\\t\\t// check (n-k) means untill we can form k from i\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            int cnt=0;\\n            for(int j=i;j<i+k;j++)          // check from curr i to till Kth value how many operations we required\\n            {\\n                if(blocks[j]==\\'W\\') \\n                    cnt++;\\n            }\\n            ans  = min(ans,cnt);          // Each time check ans store the minimum number of operations\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) \\n    {\\n        int ans = INT_MAX;\\n        int n = blocks.length();\\n        \\n\\t\\t// check (n-k) means untill we can form k from i\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            int cnt=0;\\n            for(int j=i;j<i+k;j++)          // check from curr i to till Kth value how many operations we required\\n            {\\n                if(blocks[j]==\\'W\\') \\n                    cnt++;\\n            }\\n            ans  = min(ans,cnt);          // Each time check ans store the minimum number of operations\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454252,
                "title": "lowest-whites-among-all",
                "content": "\\nIntuition:\\ncheck for lowest count of whites among all k length subarrays\\nHint - Sliding Window\\n\\n# C++   \\n    int minimumRecolors(string s, int k) {\\n        int b=0,w=0 ,n= s.size(),swaps=n;\\n        for(int i=0;i<k;i++)  s[i]==\\'W\\'? w++ : b++;\\n        for(int i=0;i<=n-k;i++){\\n            swaps= min(swaps,w);\\n            s[i]==\\'W\\'? w-- : b--;\\n            i+k<=n and s[i+k]==\\'W\\'? w++ : b++;\\n        } \\n        return swaps;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\nIntuition:\\ncheck for lowest count of whites among all k length subarrays\\nHint - Sliding Window\\n\\n# C++   \\n    int minimumRecolors(string s, int k) {\\n        int b=0,w=0 ,n= s.size(),swaps=n;\\n        for(int i=0;i<k;i++)  s[i]==\\'W\\'? w++ : b++;\\n        for(int i=0;i<=n-k;i++){\\n            swaps= min(swaps,w);\\n            s[i]==\\'W\\'? w-- : b--;\\n            i+k<=n and s[i+k]==\\'W\\'? w++ : b++;\\n        } \\n        return swaps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454224,
                "title": "easy-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minimumRecolors(string& s, int k) {\\n        ll sz = s.length(), b = 0, w = 0;\\n        for (ll i = 0;i < k;++i) {\\n            if (s[i] == \\'B\\') {\\n                b++;\\n            }\\n            else {\\n                w++;\\n            }\\n        }\\n        ll ans = w;\\n        for (ll i = k;i < sz;++i) {\\n            if (s[i] == \\'B\\') {\\n                b++;\\n            }\\n            else {\\n                w++;\\n            }\\n            if (s[i - k] == \\'B\\') {\\n                --b;\\n            }\\n            else {\\n                --w;\\n            }\\n            ans = min(ans, w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int minimumRecolors(string& s, int k) {\\n        ll sz = s.length(), b = 0, w = 0;\\n        for (ll i = 0;i < k;++i) {\\n            if (s[i] == \\'B\\') {\\n                b++;\\n            }\\n            else {\\n                w++;\\n            }\\n        }\\n        ll ans = w;\\n        for (ll i = k;i < sz;++i) {\\n            if (s[i] == \\'B\\') {\\n                b++;\\n            }\\n            else {\\n                w++;\\n            }\\n            if (s[i - k] == \\'B\\') {\\n                --b;\\n            }\\n            else {\\n                --w;\\n            }\\n            ans = min(ans, w);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454213,
                "title": "java-count-black-in-k-length",
                "content": "Time: O(N)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n  public int minimumRecolors(String blocks, int k) {\\n    final int n = blocks.length();\\n    int max = 0;\\n    for (int i = 0, b = 0; i < n; i++) {\\n      if (blocks.charAt(i) == \\'B\\') {\\n        b++;\\n      }\\n      if (i >= k) {\\n        if (blocks.charAt(i - k) == \\'B\\') {\\n          b--;\\n        }\\n      }\\n      max = Math.max(max, b);\\n    }\\n\\n    return k - max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  public int minimumRecolors(String blocks, int k) {\\n    final int n = blocks.length();\\n    int max = 0;\\n    for (int i = 0, b = 0; i < n; i++) {\\n      if (blocks.charAt(i) == \\'B\\') {\\n        b++;\\n      }\\n      if (i >= k) {\\n        if (blocks.charAt(i - k) == \\'B\\') {\\n          b--;\\n        }\\n      }\\n      max = Math.max(max, b);\\n    }\\n\\n    return k - max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454196,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int p=b.length()-k,x=Integer.MAX_VALUE;\\n        for(int i=0;i<=p;i++)\\n        {\\n            String f=b.substring(i,i+k);\\n            int m=0;\\n            for(char c:f.toCharArray())\\n            {\\n                if(c==\\'W\\')\\n                   m++; \\n            }\\n            x=Math.min(x,m);\\n        }\\n        return x;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int p=b.length()-k,x=Integer.MAX_VALUE;\\n        for(int i=0;i<=p;i++)\\n        {\\n            String f=b.substring(i,i+k);\\n            int m=0;\\n            for(char c:f.toCharArray())\\n            {\\n                if(c==\\'W\\')\\n                   m++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454177,
                "title": "python3-sliding-window",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nThis is a typical sliding window problem. \\nLet\\'s define `rsm` to be the number of white blocks in a window of length k. Then, we simply need to return the mininum of `rsm`. \\n\\n**Analysis**\\nTime complexity O(N) \\nSpace complexity O(1)\\n\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        ans = inf \\n        rsm = 0 \\n        for i, ch in enumerate(blocks): \\n            if ch == \\'W\\': rsm += 1\\n            if i >= k and blocks[i-k] == \\'W\\': rsm -= 1\\n            if i >= k-1: ans = min(ans, rsm)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        ans = inf \\n        rsm = 0 \\n        for i, ch in enumerate(blocks): \\n            if ch == \\'W\\': rsm += 1\\n            if i >= k and blocks[i-k] == \\'W\\': rsm -= 1\\n            if i >= k-1: ans = min(ans, rsm)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098457,
                "title": "c-simple-sliding-window",
                "content": "# Approach\\nThis is a sliding window where we count how many blacks are needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int left = 0;\\n        int right = 0;\\n\\n        int count_b = 0;\\n\\n        int res = k;\\n\\n        // init the window\\n        while (right < k) {\\n            if (blocks[right++] == \\'B\\') {\\n                count_b++;\\n            }\\n        }\\n\\n        res = min(res, k-count_b);\\n\\n        while (right < blocks.length()) {\\n            if (blocks[left++] == \\'B\\') {\\n                count_b--;\\n            }\\n            if (blocks[right++] == \\'B\\') {\\n                count_b++;\\n            }\\n            res = min(res, k-count_b);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int left = 0;\\n        int right = 0;\\n\\n        int count_b = 0;\\n\\n        int res = k;\\n\\n        // init the window\\n        while (right < k) {\\n            if (blocks[right++] == \\'B\\') {\\n                count_b++;\\n            }\\n        }\\n\\n        res = min(res, k-count_b);\\n\\n        while (right < blocks.length()) {\\n            if (blocks[left++] == \\'B\\') {\\n                count_b--;\\n            }\\n            if (blocks[right++] == \\'B\\') {\\n                count_b++;\\n            }\\n            res = min(res, k-count_b);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093673,
                "title": "java-beginner-friendly-padaiyappa-bathil",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String str, int n) \\n    {\\n        int m = Integer.MAX_VALUE;\\n        for (int i = 0 ; i<str.length()-n+1;i++)\\n        {\\n            String str1 = str.substring(i,i+n);\\n            int count =0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if(str1.charAt(j)==\\'W\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            m = Math.min(m,count);\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String str, int n) \\n    {\\n        int m = Integer.MAX_VALUE;\\n        for (int i = 0 ; i<str.length()-n+1;i++)\\n        {\\n            String str1 = str.substring(i,i+n);\\n            int count =0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if(str1.charAt(j)==\\'W\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            m = Math.min(m,count);\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092314,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(accumulate(range(1, len(blocks)-k+1), lambda cnt, i: cnt + (blocks[i+k-1] == \\'W\\') - (blocks[i-1] == \\'W\\'), initial= blocks[:k].count(\\'W\\')))\\n```\\n> More readable\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        min_cnt = cnt = blocks[:k].count(\\'W\\')\\n        for i in range(1, len(blocks)-k+1):\\n            cnt += (blocks[i+k-1] == \\'W\\') - (blocks[i-1] == \\'W\\')\\n            min_cnt = min(cnt, min_cnt)\\n        return min_cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(accumulate(range(1, len(blocks)-k+1), lambda cnt, i: cnt + (blocks[i+k-1] == \\'W\\') - (blocks[i-1] == \\'W\\'), initial= blocks[:k].count(\\'W\\')))\\n```\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        min_cnt = cnt = blocks[:k].count(\\'W\\')\\n        for i in range(1, len(blocks)-k+1):\\n            cnt += (blocks[i+k-1] == \\'W\\') - (blocks[i-1] == \\'W\\')\\n            min_cnt = min(cnt, min_cnt)\\n        return min_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092221,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int countB = 0;\\n    int maxCountB = 0;\\n\\n    for (int i = 0; i < blocks.length(); ++i) {\\n      if (blocks.charAt(i) == \\'B\\')\\n        ++countB;\\n      if (i >= k && blocks.charAt(i - k) == \\'B\\')\\n        --countB;\\n      maxCountB = Math.max(maxCountB, countB);\\n    }\\n\\n    return k - maxCountB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int countB = 0;\\n    int maxCountB = 0;\\n\\n    for (int i = 0; i < blocks.length(); ++i) {\\n      if (blocks.charAt(i) == \\'B\\')\\n        ++countB;\\n      if (i >= k && blocks.charAt(i - k) == \\'B\\')\\n        --countB;\\n      maxCountB = Math.max(maxCountB, countB);\\n    }\\n\\n    return k - maxCountB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089756,
                "title": "solve-by-using-sliding-window-made-easy-solution",
                "content": "\\n# Intuition /  Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n- by using sliding window solve this problem.\\n- only find white in the k size window(array).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            if(b.charAt(i)==\\'W\\'){\\n                c++;\\n            }\\n        }\\n        ans=c;\\n        int i=1; int j=k;\\n        while(j<b.length()){\\n            if(b.charAt(i-1)==\\'W\\'){\\n              c--;  \\n            }\\n            if(b.charAt(j)==\\'W\\' ){\\n                c++;\\n            }\\n            \\n            if(c<ans){\\n                \\n                ans=c;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String b, int k) {\\n        int c=0;\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            if(b.charAt(i)==\\'W\\'){\\n                c++;\\n            }\\n        }\\n        ans=c;\\n        int i=1; int j=k;\\n        while(j<b.length()){\\n            if(b.charAt(i-1)==\\'W\\'){\\n              c--;  \\n            }\\n            if(b.charAt(j)==\\'W\\' ){\\n                c++;\\n            }\\n            \\n            if(c<ans){\\n                \\n                ans=c;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088954,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        \"\"\"\\n        :type blocks: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ans = 100\\n        for i in range(len(blocks) - k + 1):\\n            count = 0\\n            for c in blocks[i:i+k]:\\n                if c == \\'W\\':\\n                    count += 1\\n            if count < ans:\\n                ans = count \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        \"\"\"\\n        :type blocks: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        ans = 100\\n        for i in range(len(blocks) - k + 1):\\n            count = 0\\n            for c in blocks[i:i+k]:\\n                if c == \\'W\\':\\n                    count += 1\\n            if count < ans:\\n                ans = count \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085387,
                "title": "0ns-runtime-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int cnt=INT_MAX,b=0,w=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'W\\') w++;\\n        }\\n        cnt=min(cnt,w);\\n        int i=0;\\n        while(k<blocks.size()){\\n            if(blocks[k++]==\\'W\\') w++;\\n            if(blocks[i++]==\\'W\\') w--;\\n            cnt=min(cnt,w);\\n        }     \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int cnt=INT_MAX,b=0,w=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'W\\') w++;\\n        }\\n        cnt=min(cnt,w);\\n        int i=0;\\n        while(k<blocks.size()){\\n            if(blocks[k++]==\\'W\\') w++;\\n            if(blocks[i++]==\\'W\\') w--;\\n            cnt=min(cnt,w);\\n        }     \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085035,
                "title": "sliding-window-java-solution-100-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) \\n    {\\n        int minOp=Integer.MAX_VALUE;\\n        int n=blocks.length();\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<n)\\n        {\\n            \\n            if(blocks.charAt(j)==\\'W\\') count++;\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                \\n                minOp=Math.min(minOp,count);\\n                if(blocks.charAt(i)==\\'W\\') count--;\\n                j++;\\n                i++;\\n            }\\n\\n        }\\n        return minOp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) \\n    {\\n        int minOp=Integer.MAX_VALUE;\\n        int n=blocks.length();\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        while(j<n)\\n        {\\n            \\n            if(blocks.charAt(j)==\\'W\\') count++;\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                \\n                minOp=Math.min(minOp,count);\\n                if(blocks.charAt(i)==\\'W\\') count--;\\n                j++;\\n                i++;\\n            }\\n\\n        }\\n        return minOp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083486,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<blocks.length(); i++){\\n            int count = 0, temp = 0;\\n            for(int j= i; j <blocks.length(); j++){\\n                if(blocks.charAt(j) == \\'W\\'){\\n                    count++;  temp++;\\n                }\\n                else{\\n                    temp++;\\n                }\\n                if(temp == k){\\n                    min = Math.min(count, min);\\n                }\\n\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<blocks.length(); i++){\\n            int count = 0, temp = 0;\\n            for(int j= i; j <blocks.length(); j++){\\n                if(blocks.charAt(j) == \\'W\\'){\\n                    count++;  temp++;\\n                }\\n                else{\\n                    temp++;\\n                }\\n                if(temp == k){\\n                    min = Math.min(count, min);\\n                }\\n\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080195,
                "title": "python-2-pointer-solution",
                "content": "```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        i = 0\\n        j = 0\\n        blackCount = 0\\n        whiteCount = 0\\n        while j < k:\\n            if blocks[j] == \\'W\\':\\n                whiteCount += 1\\n            else:\\n                blackCount += 1\\n            j += 1\\n        ans = k - blackCount\\n        while j < len(blocks):\\n            #print(i , j )\\n            if blocks[j] == \\'W\\':\\n                whiteCount += 1\\n            else:\\n                blackCount += 1\\n            if blocks[i] == \\'W\\':\\n                whiteCount -= 1\\n            else:\\n                blackCount -= 1\\n            #print(\"--> \", whiteCount, blackCount)\\n            i += 1\\n            diff = k - blackCount\\n            ans = min(ans, diff)\\n            j += 1 \\n        return  ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumRecolors(self, blocks, k):\\n        i = 0\\n        j = 0\\n        blackCount = 0\\n        whiteCount = 0\\n        while j < k:\\n            if blocks[j] == \\'W\\':\\n                whiteCount += 1\\n            else:\\n                blackCount += 1\\n            j += 1\\n        ans = k - blackCount\\n        while j < len(blocks):\\n            #print(i , j )\\n            if blocks[j] == \\'W\\':\\n                whiteCount += 1\\n            else:\\n                blackCount += 1\\n            if blocks[i] == \\'W\\':\\n                whiteCount -= 1\\n            else:\\n                blackCount -= 1\\n            #print(\"--> \", whiteCount, blackCount)\\n            i += 1\\n            diff = k - blackCount\\n            ans = min(ans, diff)\\n            j += 1 \\n        return  ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070374,
                "title": "simple-java-solution",
                "content": "# Intuition\\nSliding window\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ops = 0;\\n        int count = 0;\\n        int start = 0;\\n        int minOps = Integer.MAX_VALUE;\\n        for(int i=0;i<blocks.length();i++){\\n            if(blocks.charAt(i) == \\'B\\'){\\n                count++;\\n            }else{\\n                ops++;\\n                count++;\\n            }\\n            if(count == k){\\n                minOps = Math.min(ops,minOps);\\n                if(blocks.charAt(start) == \\'W\\'){\\n                    --ops;\\n                }\\n                count--;\\n                start++;\\n            }\\n        }\\n        return minOps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ops = 0;\\n        int count = 0;\\n        int start = 0;\\n        int minOps = Integer.MAX_VALUE;\\n        for(int i=0;i<blocks.length();i++){\\n            if(blocks.charAt(i) == \\'B\\'){\\n                count++;\\n            }else{\\n                ops++;\\n                count++;\\n            }\\n            if(count == k){\\n                minOps = Math.min(ops,minOps);\\n                if(blocks.charAt(start) == \\'W\\'){\\n                    --ops;\\n                }\\n                count--;\\n                start++;\\n            }\\n        }\\n        return minOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069155,
                "title": "sliding-window-o-n-time-o-1-space",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        count = Counter(blocks[:k])\\n        op = k - count[\\'B\\']\\n\\n        for r in range(k, len(blocks)):\\n            l = r - k\\n            count[blocks[r]] = 1 + count.get(blocks[r], 0)\\n            count[blocks[l]] -= 1\\n            op = min(op, k - count[\\'B\\'])\\n\\n        return op\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        count = Counter(blocks[:k])\\n        op = k - count[\\'B\\']\\n\\n        for r in range(k, len(blocks)):\\n            l = r - k\\n            count[blocks[r]] = 1 + count.get(blocks[r], 0)\\n            count[blocks[l]] -= 1\\n            op = min(op, k - count[\\'B\\'])\\n\\n        return op\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065374,
                "title": "easy-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int b=0,w=0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n                b++;\\n            else w++;\\n            }\\n        int i=0,j=k;\\n        int ans=k-b;\\n        \\n        \\n        while(j<blocks.length())\\n        {\\n            if(blocks[j]==\\'W\\')\\n                w++;\\n            else b++;\\n            \\n            if(blocks[i]==\\'W\\')w--;\\n            else b--;\\n            \\n            i++;\\n            j++;\\n            \\n            ans=min(ans,k-b);\\n                \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int b=0,w=0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            if(blocks[i]==\\'B\\')\\n                b++;\\n            else w++;\\n            }\\n        int i=0,j=k;\\n        int ans=k-b;\\n        \\n        \\n        while(j<blocks.length())\\n        {\\n            if(blocks[j]==\\'W\\')\\n                w++;\\n            else b++;\\n            \\n            if(blocks[i]==\\'W\\')w--;\\n            else b--;\\n            \\n            i++;\\n            j++;\\n            \\n            ans=min(ans,k-b);\\n                \\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064508,
                "title": "easy-solution-in-c-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    // TC: O(N)\\n    // SC: O(1)\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.length();\\n        int i=0,j=0;\\n        int mini=INT_MAX;\\n        int white=0;\\n        while(j<n){\\n            while(j-i+1<k){\\n                if(blocks[j]==\\'W\\') white++;\\n                j++;\\n            }\\n            if(j-i+1==k){\\n                \\n                if(i-1>=0){\\n                    if(blocks[i-1]==\\'W\\') white--;\\n                }\\n                \\n                if(blocks[j]==\\'W\\') white++;\\n                    \\n                // operation\\n                mini = min(white,mini);\\n            }\\n            i++;\\n            j++;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC: O(N)\\n    // SC: O(1)\\n    int minimumRecolors(string blocks, int k) {\\n        int n = blocks.length();\\n        int i=0,j=0;\\n        int mini=INT_MAX;\\n        int white=0;\\n        while(j<n){\\n            while(j-i+1<k){\\n                if(blocks[j]==\\'W\\') white++;\\n                j++;\\n            }\\n            if(j-i+1==k){\\n                \\n                if(i-1>=0){\\n                    if(blocks[i-1]==\\'W\\') white--;\\n                }\\n                \\n                if(blocks[j]==\\'W\\') white++;\\n                    \\n                // operation\\n                mini = min(white,mini);\\n            }\\n            i++;\\n            j++;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056207,
                "title": "python3-o-n-sliding-window-solution-beats-97-14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        count_w = 0\\n        count_b = 0\\n        res = float(\"infinity\")\\n        left = 0\\n  \\n        for right in range(len(blocks)):\\n            if blocks[right] == \"W\": count_w += 1\\n            elif blocks[right] == \"B\": count_b += 1\\n\\n            while right - left + 1 > k:\\n                if blocks[left] == \"W\": count_w -= 1\\n                elif blocks[left] == \"B\": count_b -= 1\\n                left += 1\\n\\n            if right - left + 1 == k:\\n                if count_b >= k:\\n                    return 0    \\n                if count_w > 0:\\n                    res = min(res, count_w)\\n              \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        count_w = 0\\n        count_b = 0\\n        res = float(\"infinity\")\\n        left = 0\\n  \\n        for right in range(len(blocks)):\\n            if blocks[right] == \"W\": count_w += 1\\n            elif blocks[right] == \"B\": count_b += 1\\n\\n            while right - left + 1 > k:\\n                if blocks[left] == \"W\": count_w -= 1\\n                elif blocks[left] == \"B\": count_b -= 1\\n                left += 1\\n\\n            if right - left + 1 == k:\\n                if count_b >= k:\\n                    return 0    \\n                if count_w > 0:\\n                    res = min(res, count_w)\\n              \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055775,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w = 0;\\n        int b = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }else {\\n                b++;\\n            }\\n        }\\n        int res = w;\\n        for(int i = k; i < blocks.length(); i++) {\\n            if(blocks.charAt(i - k) == \\'W\\') {\\n                w--;\\n            }\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }\\n            if(res > w) {\\n                res = w;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w = 0;\\n        int b = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }else {\\n                b++;\\n            }\\n        }\\n        int res = w;\\n        for(int i = k; i < blocks.length(); i++) {\\n            if(blocks.charAt(i - k) == \\'W\\') {\\n                w--;\\n            }\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }\\n            if(res > w) {\\n                res = w;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055771,
                "title": "minimum-recolors-to-get-k-consecutive-black-blocks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w = 0;\\n        int b = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }else {\\n                b++;\\n            }\\n        }\\n        int res = w;\\n        for(int i = k; i < blocks.length(); i++) {\\n            if(blocks.charAt(i - k) == \\'W\\') {\\n                w--;\\n            }\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }\\n            if(res > w) {\\n                res = w;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int w = 0;\\n        int b = 0;\\n        for(int i = 0; i < k; i++) {\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }else {\\n                b++;\\n            }\\n        }\\n        int res = w;\\n        for(int i = k; i < blocks.length(); i++) {\\n            if(blocks.charAt(i - k) == \\'W\\') {\\n                w--;\\n            }\\n            if(blocks.charAt(i) == \\'W\\') {\\n                w++;\\n            }\\n            if(res > w) {\\n                res = w;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050728,
                "title": "python-sliding-window-using-dictionary-method-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReword it to the window size with the least white blocks.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can find the amount of white blocks by using a dictionary and counting every block.\\n\\nOnce we reach our window size k, we can start adjusting the left side as we move along and detucting the count so we have the correct amount of W and B count in our dictionary.\\n\\nAt each iteration after the window size is k, check if we have less white blocks than the global value.\\n\\nreturn this value at the end.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n\\n        #PLAN\\n        # - reword: what window of size k has the least white blocks\\n\\n        #CODE\\n        left = 0\\n        minWhite = float(\\'inf\\')\\n        counter = {\\'W\\': 0, \\'B\\':0}\\n        \\n        for right in range(0, len(blocks)):\\n            counter[blocks[right]] += 1\\n\\n            if right >= k-1:\\n                minWhite = min(minWhite, counter[\\'W\\'])\\n                counter[blocks[left]] -= 1\\n                left += 1\\n            \\n        return minWhite\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n\\n        #PLAN\\n        # - reword: what window of size k has the least white blocks\\n\\n        #CODE\\n        left = 0\\n        minWhite = float(\\'inf\\')\\n        counter = {\\'W\\': 0, \\'B\\':0}\\n        \\n        for right in range(0, len(blocks)):\\n            counter[blocks[right]] += 1\\n\\n            if right >= k-1:\\n                minWhite = min(minWhite, counter[\\'W\\'])\\n                counter[blocks[left]] -= 1\\n                left += 1\\n            \\n        return minWhite\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047658,
                "title": "c-sliding-window-beats-100-cpp-sol",
                "content": "Using 2 pointers keeping track of intial \\'w\\' and end \\'w\\' and whenever end-st is equal to k then minimum value of cnt of \\'w\\' will be taken\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int st = 0, end  = 0, w = 0,mx = INT_MAX;\\n        while(end<blocks.size()){\\n            if(blocks[end] == \\'W\\')\\n                w++;\\n            if(end-st+1 == k){\\n                mx = min(w,mx);\\n                if(blocks[st] == \\'W\\')\\n                    w--;\\n                st++;\\n            }\\n            end++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int st = 0, end  = 0, w = 0,mx = INT_MAX;\\n        while(end<blocks.size()){\\n            if(blocks[end] == \\'W\\')\\n                w++;\\n            if(end-st+1 == k){\\n                mx = min(w,mx);\\n                if(blocks[st] == \\'W\\')\\n                    w--;\\n                st++;\\n            }\\n            end++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043556,
                "title": "easy-sliding-window-approach-c",
                "content": "# Intuition\\nSince the problem is about checking subarrays sliding window is a good Solution\\n\\n# Approach\\nSliding Window approach will be used.\\nFirst we will count the number of changes required for sub array from index 0 to (k - 1).\\nStep 2 is to loop from index k to length of input string and to increment count when \\'W\\' is hit on index i and decrement count if \\'W\\' is at index (i - k)\\n\\n# Complexity\\n- Time complexity:\\nSince we are looping through array one time complexity is O(n)\\n\\n- Space complexity:\\nAuxiliary Space: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int min_count  = 0;\\n        for(int i = 0 ; i < k ; i++){\\n            if(blocks[i] == \\'W\\'){\\n                min_count++;\\n            }\\n        }\\n        int wnd_count = min_count;\\n        for(int i = k ; i < blocks.length() ; i++){\\n            if(blocks[i] == \\'W\\'){\\n                wnd_count++;\\n            }\\n            if(blocks[i - k] == \\'W\\'){\\n                    wnd_count--;\\n            }\\n            min_count = min(min_count, wnd_count);\\n        }\\n        return min_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int min_count  = 0;\\n        for(int i = 0 ; i < k ; i++){\\n            if(blocks[i] == \\'W\\'){\\n                min_count++;\\n            }\\n        }\\n        int wnd_count = min_count;\\n        for(int i = k ; i < blocks.length() ; i++){\\n            if(blocks[i] == \\'W\\'){\\n                wnd_count++;\\n            }\\n            if(blocks[i - k] == \\'W\\'){\\n                    wnd_count--;\\n            }\\n            min_count = min(min_count, wnd_count);\\n        }\\n        return min_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040325,
                "title": "python3-sliding-window",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        N = len(blocks)        \\n        bCnt = 0\\n\\n        ans = k\\n        dq = collections.deque()\\n        cnt = 0\\n        for i in range(N):\\n            if len(dq)>k:\\n                first = dq.popleft()\\n                if blocks[first]==\\'B\\':\\n                    bCnt-=1\\n            ans = min(ans, k-bCnt)\\n            dq.append(i)\\n            if blocks[i]==\\'B\\':\\n                bCnt+=1\\n\\n        if len(dq)>k:\\n            first = dq.popleft()\\n            if blocks[first]==\\'B\\':\\n                bCnt-=1\\n        ans = min(ans, k-bCnt)\\n\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        N = len(blocks)        \\n        bCnt = 0\\n\\n        ans = k\\n        dq = collections.deque()\\n        cnt = 0\\n        for i in range(N):\\n            if len(dq)>k:\\n                first = dq.popleft()\\n                if blocks[first]==\\'B\\':\\n                    bCnt-=1\\n            ans = min(ans, k-bCnt)\\n            dq.append(i)\\n            if blocks[i]==\\'B\\':\\n                bCnt+=1\\n\\n        if len(dq)>k:\\n            first = dq.popleft()\\n            if blocks[first]==\\'B\\':\\n                bCnt-=1\\n        ans = min(ans, k-bCnt)\\n\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039153,
                "title": "python3-intuitive-sliding-window",
                "content": "# Intuition\\nK is our window size\\n\\n# Approach\\nUse sliding window technique to count k characters, which is the range of r - l + 1, then take the minimum of ans or count.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        l = 0\\n        ans = 101\\n        count = 0\\n\\n        for r in range(len(blocks)):\\n            count += 1 if blocks[r] == \\'W\\' else 0\\n            if r - l + 1 == k:\\n                ans = min(ans, count)\\n                count -= 1 if blocks[l] == \\'W\\' else 0\\n                l += 1            \\n        \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        l = 0\\n        ans = 101\\n        count = 0\\n\\n        for r in range(len(blocks)):\\n            count += 1 if blocks[r] == \\'W\\' else 0\\n            if r - l + 1 == k:\\n                ans = min(ans, count)\\n                count -= 1 if blocks[l] == \\'W\\' else 0\\n                l += 1            \\n        \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035779,
                "title": "python-sliding-window-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove a sliding window of size `k` over the `blocks`, count the number of white blocks (`W`) in each window, and return the `min`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we do a single iteration over the array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - we do not allocate any additional data structures.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(accumulate(zip(blocks[k:], blocks), lambda n, x: n + (x[0] == \\'W\\') - (x[1] == \\'W\\'), initial=blocks[:k].count(\\'W\\')))\\n```\\n\\nHere\\'s also a more verbose (readable) solution that does exactly the same thing as well:\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        res = n = blocks[:k].count(\\'W\\')\\n        for a, b in zip(blocks[k:], blocks):\\n            n += (a == \\'W\\') - (b == \\'W\\')\\n            res = min(res, n)\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        return min(accumulate(zip(blocks[k:], blocks), lambda n, x: n + (x[0] == \\'W\\') - (x[1] == \\'W\\'), initial=blocks[:k].count(\\'W\\')))\\n```\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        res = n = blocks[:k].count(\\'W\\')\\n        for a, b in zip(blocks[k:], blocks):\\n            n += (a == \\'W\\') - (b == \\'W\\')\\n            res = min(res, n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030781,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int ans=INT_MAX;\\n        int c=0;\\n        int start=0;\\n        int end=0;\\n        while(end<s.length())\\n        {\\n            if(end-start+1<=k)\\n            {\\n                if(s[end]==\\'W\\')\\n                {\\n                    c++;\\n                }\\n                if(end-start+1==k)\\n                {\\n                    ans=min(ans,c);\\n                }\\n                end++;\\n            }\\n            else\\n            {\\n                if(s[start]==\\'W\\')\\n                {\\n                    c--;\\n                }\\n                start++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int ans=INT_MAX;\\n        int c=0;\\n        int start=0;\\n        int end=0;\\n        while(end<s.length())\\n        {\\n            if(end-start+1<=k)\\n            {\\n                if(s[end]==\\'W\\')\\n                {\\n                    c++;\\n                }\\n                if(end-start+1==k)\\n                {\\n                    ans=min(ans,c);\\n                }\\n                end++;\\n            }\\n            else\\n            {\\n                if(s[start]==\\'W\\')\\n                {\\n                    c--;\\n                }\\n                start++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028193,
                "title": "sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSliding window solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int minCountOfWhite = Integer.MAX_VALUE;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        while( j < blocks.length()) {\\n            // add char with count in the map\\n            map.put(blocks.charAt(j), map.getOrDefault(blocks.charAt(j), 0) + 1);\\n            if(j-i+1 < k) {\\n                j++;\\n            } else if (j-i+1 == k) {\\n                //if map size is same as sliding window\\'s size\\n                if( map.containsKey(\\'B\\') && map.get(\\'B\\') >= k ) {\\n                    count +=1;\\n                } else {\\n                    int blackCount = map.containsKey(\\'B\\') ? map.get(\\'B\\') : 0;\\n                    minCountOfWhite = Math.min(minCountOfWhite, k - blackCount);\\n                }\\n                //Slide window\\n                if (map.getOrDefault(blocks.charAt(i), 0) > 1) {\\n                    map.put(blocks.charAt(i), map.getOrDefault(blocks.charAt(i), 0) - 1);\\n                } else {\\n                    map.remove(blocks.charAt(i));\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count > 0 ? 0 : minCountOfWhite;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        int minCountOfWhite = Integer.MAX_VALUE;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        while( j < blocks.length()) {\\n            // add char with count in the map\\n            map.put(blocks.charAt(j), map.getOrDefault(blocks.charAt(j), 0) + 1);\\n            if(j-i+1 < k) {\\n                j++;\\n            } else if (j-i+1 == k) {\\n                //if map size is same as sliding window\\'s size\\n                if( map.containsKey(\\'B\\') && map.get(\\'B\\') >= k ) {\\n                    count +=1;\\n                } else {\\n                    int blackCount = map.containsKey(\\'B\\') ? map.get(\\'B\\') : 0;\\n                    minCountOfWhite = Math.min(minCountOfWhite, k - blackCount);\\n                }\\n                //Slide window\\n                if (map.getOrDefault(blocks.charAt(i), 0) > 1) {\\n                    map.put(blocks.charAt(i), map.getOrDefault(blocks.charAt(i), 0) - 1);\\n                } else {\\n                    map.remove(blocks.charAt(i));\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count > 0 ? 0 : minCountOfWhite;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025608,
                "title": "c-easy-to-understand-sliding-window-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i=0,j=0;\\n        int count=0;\\n        int mins=INT_MAX;\\n        while(j<s.size())\\n        {   \\n            if(s[j]==\\'W\\')\\n            count++;\\n\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                mins=min(mins,count);\\n                if(s[i]==\\'W\\')\\n                {\\n                    count--;\\n                }\\n                i++;j++;\\n            }\\n        }\\n        return mins;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int i=0,j=0;\\n        int count=0;\\n        int mins=INT_MAX;\\n        while(j<s.size())\\n        {   \\n            if(s[j]==\\'W\\')\\n            count++;\\n\\n            if(j-i+1<k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==k)\\n            {\\n                mins=min(mins,count);\\n                if(s[i]==\\'W\\')\\n                {\\n                    count--;\\n                }\\n                i++;j++;\\n            }\\n        }\\n        return mins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016666,
                "title": "simplest-sliding-window",
                "content": "# Intuition\\nSimplest Sliding window \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i =0 ; i < blocks.length()-k+1 ; i++){\\n            ans = Math.min(ans , count(blocks.substring(i, i+k)));\\n        }\\n        return ans;\\n    }\\n    public int count(String s){\\n        int count1 =0;\\n        for(int i =0 ; i<s.length() ; i++){\\n            if(s.charAt(i) ==\\'W\\'){\\n                count1++;\\n            }\\n        }\\n        return count1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i =0 ; i < blocks.length()-k+1 ; i++){\\n            ans = Math.min(ans , count(blocks.substring(i, i+k)));\\n        }\\n        return ans;\\n    }\\n    public int count(String s){\\n        int count1 =0;\\n        for(int i =0 ; i<s.length() ; i++){\\n            if(s.charAt(i) ==\\'W\\'){\\n                count1++;\\n            }\\n        }\\n        return count1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015576,
                "title": "python3-using-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n\\n        def dfs(l,r, min_whites):\\n            if r==len(blocks):\\n                return min_whites\\n            s = blocks[l:r+1]\\n            min_whites = min(s.count(\"W\"), min_whites)\\n            return dfs(l+1,r+1, min_whites)\\n                \\n        return dfs(0,k-1,len(blocks) +1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n\\n        def dfs(l,r, min_whites):\\n            if r==len(blocks):\\n                return min_whites\\n            s = blocks[l:r+1]\\n            min_whites = min(s.count(\"W\"), min_whites)\\n            return dfs(l+1,r+1, min_whites)\\n                \\n        return dfs(0,k-1,len(blocks) +1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015229,
                "title": "sliding-window-approach-simple-solution-java",
                "content": "# Approach\\n- set a size of window equal to the k.\\n- check in window how many whites are there.\\n- window containing mimimum number of whites will be the ans i.e we have to how perform mimimun operations on that window to make all color to black.\\n- just remove character from window and add new character if that character is W then do count-- means now current window contain one less W color and if added character is W then do count++.\\n- Upvote if you have understood it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = 0;\\n        int i=0;\\n        int j=0;\\n        while(j<k){ // setting the window of size k\\n            if(blocks.charAt(j)==\\'W\\'){\\n                ans++;\\n            }\\n            j++;\\n        }\\n        int count = ans;\\n        while(j<blocks.length()){ // moving window ahead\\n            if(blocks.charAt(i)==\\'W\\'){\\n                count--;\\n            }\\n            if(blocks.charAt(j)==\\'W\\'){\\n                count++;\\n            }\\n            ans = Math.min(ans,count);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int ans = 0;\\n        int i=0;\\n        int j=0;\\n        while(j<k){ // setting the window of size k\\n            if(blocks.charAt(j)==\\'W\\'){\\n                ans++;\\n            }\\n            j++;\\n        }\\n        int count = ans;\\n        while(j<blocks.length()){ // moving window ahead\\n            if(blocks.charAt(i)==\\'W\\'){\\n                count--;\\n            }\\n            if(blocks.charAt(j)==\\'W\\'){\\n                count++;\\n            }\\n            ans = Math.min(ans,count);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006053,
                "title": "most-intutive-c-solution-easy-sliding-window",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int n = s.size();\\n\\n        int cnt = 0;\\n        for (int i = 0; i < k; i++) {\\n            cnt += s[i] == \\'W\\';\\n        }\\n\\n        int ans = cnt;\\n        for (int i = k; i < n; i++) {\\n            cnt += s[i] == \\'W\\';\\n            cnt -= s[i - k] == \\'W\\';\\n            ans = min(ans, cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string s, int k) {\\n        int n = s.size();\\n\\n        int cnt = 0;\\n        for (int i = 0; i < k; i++) {\\n            cnt += s[i] == \\'W\\';\\n        }\\n\\n        int ans = cnt;\\n        for (int i = k; i < n; i++) {\\n            cnt += s[i] == \\'W\\';\\n            cnt -= s[i - k] == \\'W\\';\\n            ans = min(ans, cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991755,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int op=99999999;\\n\\n        // APProach 1 O(N^2)\\n       /* for(int i=0;i<blocks.length()-k+1;i++){\\n            string temp=blocks.substr(i,k);\\n\\n            int count=0;\\n            for(int j=0;j<temp.length();j++){\\n                if(temp[j]==\\'W\\')\\n                count++;\\n            }\\n            op=min(op,count);\\n        }\\n        return op;*/\\n\\n        int wcount=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'W\\')\\n            wcount++;\\n        }\\n        op=min(op,wcount);\\n\\n        for(int i=k;i<blocks.size();i++){\\n            if(blocks[i-k]==\\'W\\')\\n            wcount--;\\n\\n            if(blocks[i]==\\'W\\')\\n            wcount++;\\n\\n            op=min(op,wcount);\\n        }\\n\\n        return op;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int op=99999999;\\n\\n        // APProach 1 O(N^2)\\n       /* for(int i=0;i<blocks.length()-k+1;i++){\\n            string temp=blocks.substr(i,k);\\n\\n            int count=0;\\n            for(int j=0;j<temp.length();j++){\\n                if(temp[j]==\\'W\\')\\n                count++;\\n            }\\n            op=min(op,count);\\n        }\\n        return op;*/\\n\\n        int wcount=0;\\n        for(int i=0;i<k;i++){\\n            if(blocks[i]==\\'W\\')\\n            wcount++;\\n        }\\n        op=min(op,wcount);\\n\\n        for(int i=k;i<blocks.size();i++){\\n            if(blocks[i-k]==\\'W\\')\\n            wcount--;\\n\\n            if(blocks[i]==\\'W\\')\\n            wcount++;\\n\\n            op=min(op,wcount);\\n        }\\n\\n        return op;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988823,
                "title": "java-solution-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int minOperation = Integer.MAX_VALUE;\\n        int count = 0;\\n        int i = 0; \\n        for(int j = 0; j < blocks.length(); j++) {\\n            if(blocks.charAt(j) == \\'W\\') count++;\\n            if(j-i+1 == k) {\\n                minOperation = Math.min(count, minOperation);\\n                if(blocks.charAt(i) == \\'W\\') count--; i++;\\n            }\\n        }\\n        return minOperation;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int minOperation = Integer.MAX_VALUE;\\n        int count = 0;\\n        int i = 0; \\n        for(int j = 0; j < blocks.length(); j++) {\\n            if(blocks.charAt(j) == \\'W\\') count++;\\n            if(j-i+1 == k) {\\n                minOperation = Math.min(count, minOperation);\\n                if(blocks.charAt(i) == \\'W\\') count--; i++;\\n            }\\n        }\\n        return minOperation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982585,
                "title": "python3-sliding-window-without-using-count",
                "content": "\\n\\n# Approach\\nSliding Window\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        operations = 0\\n        for i in range(k):\\n            if blocks[i] == \"W\":\\n                operations+=1\\n        ans = operations\\n        for i in range(k, len(blocks)):\\n            if blocks[i-k] == \"W\":\\n                operations -= 1\\n            if blocks[i] == \"W\":\\n                operations += 1\\n            if operations == 0:\\n                ans = operations\\n            else:\\n                ans = min(ans, operations)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        operations = 0\\n        for i in range(k):\\n            if blocks[i] == \"W\":\\n                operations+=1\\n        ans = operations\\n        for i in range(k, len(blocks)):\\n            if blocks[i-k] == \"W\":\\n                operations -= 1\\n            if blocks[i] == \"W\":\\n                operations += 1\\n            if operations == 0:\\n                ans = operations\\n            else:\\n                ans = min(ans, operations)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979479,
                "title": "easy-to-understand-solution-sliding-window",
                "content": "# Intuition\\nTake a desire window and check the minimum number of \"W\" in that window. Return the least amount of \"W\".\\n\\n\\n\\n# Complexity\\n- Time complexity:\\no(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n       minOps = 2000\\n       \\n\\n       for i in range(len(blocks)-k+1):\\n           newStr = blocks[i:i+k]\\n           temp = 0\\n           \\n           for ch in newStr:\\n                if ch == \\'W\\':\\n                    temp += 1\\n\\n           minOps = min(temp , minOps)\\n       return minOps\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n       minOps = 2000\\n       \\n\\n       for i in range(len(blocks)-k+1):\\n           newStr = blocks[i:i+k]\\n           temp = 0\\n           \\n           for ch in newStr:\\n                if ch == \\'W\\':\\n                    temp += 1\\n\\n           minOps = min(temp , minOps)\\n       return minOps\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978112,
                "title": "fixed-sliding-window-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int minRecolor = 0, i = 0, ans = Integer.MAX_VALUE;\\n\\n        for(int j = 0; j < blocks.length(); j++){\\n            if(blocks.charAt(j) == \\'W\\'){\\n                minRecolor++;\\n            }\\n\\n            if(j - i + 1 == k){\\n                ans = Math.min(minRecolor, ans);\\n                if(blocks.charAt(i) == \\'W\\') minRecolor--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int minRecolor = 0, i = 0, ans = Integer.MAX_VALUE;\\n\\n        for(int j = 0; j < blocks.length(); j++){\\n            if(blocks.charAt(j) == \\'W\\'){\\n                minRecolor++;\\n            }\\n\\n            if(j - i + 1 == k){\\n                ans = Math.min(minRecolor, ans);\\n                if(blocks.charAt(i) == \\'W\\') minRecolor--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977400,
                "title": "sliding-window-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        \\n        int n=blocks.size();\\n        int mini = INT_MAX,i=0,j=0,count=0;\\n        while(j<n)\\n        {\\n            if(blocks[j]==\\'W\\') count++;\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1==k)\\n            {\\n                mini = min(mini,count);\\n                if(blocks[i]==\\'W\\') count--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        \\n        int n=blocks.size();\\n        int mini = INT_MAX,i=0,j=0,count=0;\\n        while(j<n)\\n        {\\n            if(blocks[j]==\\'W\\') count++;\\n            if(j-i+1 < k) j++;\\n            else if(j-i+1==k)\\n            {\\n                mini = min(mini,count);\\n                if(blocks[i]==\\'W\\') count--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969376,
                "title": "python-3-sliding-window-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        white_counts = 0\\n\\n        for i in range(k):\\n            if blocks[i] == \"W\":\\n                white_counts += 1\\n\\n        ans = white_counts\\n        for i in range(k, len(blocks)):\\n            if blocks[i] == \"W\":\\n                white_counts += 1\\n            if blocks[i - k] == \"W\":\\n                white_counts -= 1\\n            ans = min(ans, white_counts)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        white_counts = 0\\n\\n        for i in range(k):\\n            if blocks[i] == \"W\":\\n                white_counts += 1\\n\\n        ans = white_counts\\n        for i in range(k, len(blocks)):\\n            if blocks[i] == \"W\":\\n                white_counts += 1\\n            if blocks[i - k] == \"W\":\\n                white_counts -= 1\\n            ans = min(ans, white_counts)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967699,
                "title": "java-sliding-window-solution-with-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nU can use this template to solve many of sliding window solution -> \\n```\\nint l = 0 , r = 0 , ans =0;\\n\\nfor ( ; r < nums.length ; r++){\\n\\n    // add in window\\n    for(; isInvalid() ; l++){\\n        // remove from window\\n    }\\n    // calculate answer\\n}\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int l = 0 , r = 0 , ans = Integer.MAX_VALUE , black_count = 0 , white_count = 0;\\n\\n        for(; r < blocks.length() ; r++){\\n            char ch = blocks.charAt(r);\\n            if(ch == \\'B\\'){\\n                black_count++;\\n            }else {\\n                white_count++;\\n            }\\n            for(; black_count + white_count  > k ; l++){\\n                char ch2 = blocks.charAt(l);\\n                if(ch2 == \\'B\\') black_count--;\\n                else white_count--;\\n            }\\n            if(r-l+1 == k){\\n                ans = Math.min(ans , white_count);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint l = 0 , r = 0 , ans =0;\\n\\nfor ( ; r < nums.length ; r++){\\n\\n    // add in window\\n    for(; isInvalid() ; l++){\\n        // remove from window\\n    }\\n    // calculate answer\\n}\\n```\n```\\nclass Solution {\\n    public int minimumRecolors(String blocks, int k) {\\n        int l = 0 , r = 0 , ans = Integer.MAX_VALUE , black_count = 0 , white_count = 0;\\n\\n        for(; r < blocks.length() ; r++){\\n            char ch = blocks.charAt(r);\\n            if(ch == \\'B\\'){\\n                black_count++;\\n            }else {\\n                white_count++;\\n            }\\n            for(; black_count + white_count  > k ; l++){\\n                char ch2 = blocks.charAt(l);\\n                if(ch2 == \\'B\\') black_count--;\\n                else white_count--;\\n            }\\n            if(r-l+1 == k){\\n                ans = Math.min(ans , white_count);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967595,
                "title": "black-blocks-javascript-beginner-friendly",
                "content": "```\\nvar minimumRecolors = function(blocks, k) {\\n    let min = blocks.length\\n\\n    for (let i = 0; i <= blocks.length - k; i++) {\\n        let count = 0\\n        for (let j = i; j < i + k; j++) {\\n            if (blocks[j] == \\'W\\') count ++\\n        }\\n        min = Math.min(min, count)\\n    }\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumRecolors = function(blocks, k) {\\n    let min = blocks.length\\n\\n    for (let i = 0; i <= blocks.length - k; i++) {\\n        let count = 0\\n        for (let j = i; j < i + k; j++) {\\n            if (blocks[j] == \\'W\\') count ++\\n        }\\n        min = Math.min(min, count)\\n    }\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964026,
                "title": "fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = INT_MAX ; \\n       int j = 0 ;\\n       int n = blocks.length();\\n       while( j <=n - k) { \\n        int count = 0;\\n        for(int i = j ; i < k + j  ; i++)\\n        {    \\n        \\n            if(blocks[i] == \\'W\\') count++;\\n        }\\n        ans = min(ans , count) ;\\n        j++;\\n         }\\n\\n\\n        return ans;;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int ans = INT_MAX ; \\n       int j = 0 ;\\n       int n = blocks.length();\\n       while( j <=n - k) { \\n        int count = 0;\\n        for(int i = j ; i < k + j  ; i++)\\n        {    \\n        \\n            if(blocks[i] == \\'W\\') count++;\\n        }\\n        ans = min(ans , count) ;\\n        j++;\\n         }\\n\\n\\n        return ans;;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963987,
                "title": "beat-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        vector<int> ans;\\n        int n = blocks.size();\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            int curr_white = 0;\\n            string temp = blocks.substr(i,k);\\n            for(int j = 0;j<temp.size();j++)\\n            {\\n                if(temp[j] == \\'W\\')\\n                {\\n                    curr_white++;\\n                }\\n            }\\n            ans.push_back(curr_white);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        return ans.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        vector<int> ans;\\n        int n = blocks.size();\\n        for(int i=0;i<=n-k;i++)\\n        {\\n            int curr_white = 0;\\n            string temp = blocks.substr(i,k);\\n            for(int j = 0;j<temp.size();j++)\\n            {\\n                if(temp[j] == \\'W\\')\\n                {\\n                    curr_white++;\\n                }\\n            }\\n            ans.push_back(curr_white);\\n        }\\n        sort(ans.begin(),ans.end());\\n\\n        return ans.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963047,
                "title": "easy-sliding-window-python-3-easy-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSliding Window technique by maintaining window size of k and finding the minimum number of whiteballs needs to be converted to blacks to get consecutive k blacks balls.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$ O(1) $$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        \\n\\n\\n\\n        # current index\\n        i=0\\n\\n        # we want to find minimum white balls to blacks balls.\\n        ans=float(\\'inf\\')\\n\\n        # no of balls converted from white to black \\n        wb=0\\n\\n        n=len(blocks)\\n\\n        d=defaultdict(int)\\n\\n        for x in range(n):\\n            # store the ball either \\'W\\' or \\'B\\'\\n            d[blocks[x]]+=1\\n            # if the ball is white so we convert to black ball.\\n            if blocks[x]==\\'W\\':\\n                wb+=1\\n            # if the window size is greater than k increment left pointer \\'i\\' by 1\\n            if x-i+1>k:\\n                # if the ball is white decrement the count by 1\\n                if blocks[i]==\\'W\\':\\n                    wb-=1\\n\\n                d[blocks[i]]-=1\\n                if d[blocks[i]]==0:\\n                    d.pop(blocks[i])\\n                i+=1\\n            # if we get window size of k we store the ans \\n            if x-i+1==k:\\n                ans=min(ans,wb)\\n\\n\\n        return ans\\n\\n\\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minimumRecolors(self, blocks: str, k: int) -> int:\\n        \\n\\n\\n\\n        # current index\\n        i=0\\n\\n        # we want to find minimum white balls to blacks balls.\\n        ans=float(\\'inf\\')\\n\\n        # no of balls converted from white to black \\n        wb=0\\n\\n        n=len(blocks)\\n\\n        d=defaultdict(int)\\n\\n        for x in range(n):\\n            # store the ball either \\'W\\' or \\'B\\'\\n            d[blocks[x]]+=1\\n            # if the ball is white so we convert to black ball.\\n            if blocks[x]==\\'W\\':\\n                wb+=1\\n            # if the window size is greater than k increment left pointer \\'i\\' by 1\\n            if x-i+1>k:\\n                # if the ball is white decrement the count by 1\\n                if blocks[i]==\\'W\\':\\n                    wb-=1\\n\\n                d[blocks[i]]-=1\\n                if d[blocks[i]]==0:\\n                    d.pop(blocks[i])\\n                i+=1\\n            # if we get window size of k we store the ans \\n            if x-i+1==k:\\n                ans=min(ans,wb)\\n\\n\\n        return ans\\n\\n\\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961405,
                "title": "sliding-window-c-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int answer=INT_MAX;\\n        int wcount=0;\\n        int i=0;\\n        int j=0;\\n        int size=blocks.length();\\n        while(j<size){\\n            if(blocks[j]==\\'W\\'){wcount++;}\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                answer=min(answer,wcount);\\n                if(blocks[i]==\\'W\\'){\\n                    wcount--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n       return answer; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n        int answer=INT_MAX;\\n        int wcount=0;\\n        int i=0;\\n        int j=0;\\n        int size=blocks.length();\\n        while(j<size){\\n            if(blocks[j]==\\'W\\'){wcount++;}\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                answer=min(answer,wcount);\\n                if(blocks[i]==\\'W\\'){\\n                    wcount--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n       return answer; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952085,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Run the loop from index 0 to index-k, because we need to get only \\'k\\' consecutive Bs.\\n2. Maintain a variable, countB which counts the number of B\\'s and countW which counts the number of W\\'s in the window from i to i+k\\n3. Run the loop till count gets to k because we need only k Bs. \\n4. Keep in track of the variable \\'num\\' so that it would start with \\ni=0 and the num runs from 0 to k.\\ni=1 and the num runs frim 1 to k.\\n5. if countB == k then return 0. (There is no need of converting Ws to Bs)\\n6. Find mini at each loop to keep track of the minimum.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n       int mini = INT_MAX;\\n        for(int i=0;i<=blocks.length()-k;i++)\\n        {\\n            int count = 0;\\n            int countB = 0;\\n            int countW = 0;\\n            int num = i;\\n            while(count<k)\\n            {\\n                if(blocks[num] == \\'B\\')\\n                {\\n                    countB++;\\n                }\\n                if(blocks[num] == \\'W\\')\\n                {\\n                    countW++;\\n                }\\n                num++;\\n                count++;\\n            }\\n            if(countB == k) return 0;\\n            mini = min(mini,countW);\\n            \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumRecolors(string blocks, int k) {\\n       int mini = INT_MAX;\\n        for(int i=0;i<=blocks.length()-k;i++)\\n        {\\n            int count = 0;\\n            int countB = 0;\\n            int countW = 0;\\n            int num = i;\\n            while(count<k)\\n            {\\n                if(blocks[num] == \\'B\\')\\n                {\\n                    countB++;\\n                }\\n                if(blocks[num] == \\'W\\')\\n                {\\n                    countW++;\\n                }\\n                num++;\\n                count++;\\n            }\\n            if(countB == k) return 0;\\n            mini = min(mini,countW);\\n            \\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1762257,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1670555,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 2051555,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1844396,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1826476,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            },
            {
                "id": 1835207,
                "content": [
                    {
                        "username": "eduard92",
                        "content": "I am new to sliding window and I don\\'t know when I read the problem at first glance it feels I can\\'t do it without brute force, it feels like a hard problem. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Don\\'t worry , i\\'m just like you but eventually the fog clears up little by little "
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "you should try easy ones first ,this one is little complicated"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Great problem from the house of Sliding Window... Do check out my solution on solutions tab -->"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Find the number of changes for each substring to make all blocks black, and return the minimum of these.\\n "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Very nice , relaxing problem "
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nHint : Sliding Window \\n\\nMy solution Link : https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3273544/0ms-c-easy-and-simple-solution-using-sliding-window/\\n<br>\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward brute force approach:-\\n\\n- Initialize a variable min to a large number (such as 101) and n to the length of the input string blocks.\\n- Iterate over all possible contiguous subsequences of length k in the input string blocks.\\n- For each subsequence, count the number of white blocks in that subsequence using a loop that iterates over the subsequence and checks if each block is white.\\n- Update the minimum count seen so far (min) with the current count of white blocks, if the current count is smaller than min.\\n- Return the minimum count of white blocks seen in all the contiguous subsequences."
                    },
                    {
                        "username": "Hokage_Namikaze_Minato",
                        "content": "[@yeedaKing](/yeedaKing) I guess the constraint is 100 so 101 can be considered large xD\\n"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "101 is a large number? :o"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link:-\\nhttps://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/3308085/straightforward-brute-force-solution/?orderBy=newest_to_oldest"
                    }
                ]
            }
        ]
    }
]