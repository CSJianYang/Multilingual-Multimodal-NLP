[
    {
        "title": "Find First and Last Position of Element in Sorted Array",
        "question_content": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must&nbsp;write an algorithm with&nbsp;O(log n) runtime complexity.\n&nbsp;\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n&nbsp;\nConstraints:\n\n\t0 <= nums.length <= 105\n\t-109&nbsp;<= nums[i]&nbsp;<= 109\n\tnums is a non-decreasing array.\n\t-109&nbsp;<= target&nbsp;<= 109",
        "solutions": [
            {
                "id": 14699,
                "title": "clean-iterative-solution-with-two-binary-searches-with-explanation",
                "content": "The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:\\n\\nFirst let's find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:\\n\\n   1. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   2. If A[mid] > target, it means the range must begins on the ***left*** of mid (j = mid-1)\\n   3. If A[mid] = target, then the range must begins ***on the left of or at*** mid  (j= mid)\\n\\nSince we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:\\n\\n   2*. If A[mid] >= target, j = mid;\\n\\nSurprisingly, 1 and 2* are the only logic you need to put in loop while (i < j). When the while loop terminates, the value of i/j is where the start of the range is. Why? \\n\\nNo matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:\\n\\n    case 1: [5 7] (A[i] = target < A[j])\\n\\tcase 2: [5 3] (A[i] = target > A[j])\\n    case 3: [5 5] (A[i] = target = A[j])\\n    case 4: [3 5] (A[j] = target > A[i])\\n    case 5: [3 7] (A[i] < target < A[j])\\n\\tcase 6: [3 4] (A[i] < A[j] < target)\\n\\tcase 7: [6 7] (target < A[i] < A[j])\\n\\nFor case 1, 2 and 3, if we follow the above rule, since mid = i => A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.  \\n\\nFor case 4, since A[mid] < target, then set i = mid+1. The loop terminates and both i and j point to 5.\\n\\nFor all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.\\n\\nIn conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;\\n\\nFor the right of the range, we can use a similar idea. Again we can come up with several rules:\\n\\n   1. If A[mid] > target, then the range must begins on the ***left*** of mid (j = mid-1)\\n   2. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   3. If A[mid] = target, then the range must begins ***on the right of or at*** mid  (i= mid) \\n\\nAgain, we can merge condition 2 and 3 into:\\n\\n    2* If A[mid] <= target, then i = mid;\\n\\nHowever, the terminate condition on longer works this time. Consider the following case:\\n\\n    [5 7], target = 5\\n\\t\\nNow A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!\\n\\nThe solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:\\n\\n    mid = (i+j)/2+1\\n\\t\\nWhy does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always *biased* towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won't get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid *biased* to the right, i.e. mid = (i+j)/2+1.\\n\\nAll this reasoning boils down to the following simple code:\\n\\n    vector<int> searchRange(int A[], int n, int target) {\\n        int i = 0, j = n - 1;\\n        vector<int> ret(2, -1);\\n        // Search for the left one\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2;\\n            if (A[mid] < target) i = mid + 1;\\n            else j = mid;\\n        }\\n        if (A[i]!=target) return ret;\\n        else ret[0] = i;\\n        \\n        // Search for the right one\\n        j = n-1;  // We don't have to set i to 0 the second time.\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2 + 1;\\t// Make mid biased to the right\\n            if (A[mid] > target) j = mid - 1;  \\n            else i = mid;\\t\\t\\t\\t// So that this won't make the search range stuck.\\n        }\\n        ret[1] = j;\\n        return ret; \\n    }",
                "solutionTags": [],
                "code": "The problem can be simply broken down as two binary searches for the begining and end of the range, respectively:\\n\\nFirst let's find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities:\\n\\n   1. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   2. If A[mid] > target, it means the range must begins on the ***left*** of mid (j = mid-1)\\n   3. If A[mid] = target, then the range must begins ***on the left of or at*** mid  (j= mid)\\n\\nSince we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed:\\n\\n   2*. If A[mid] >= target, j = mid;\\n\\nSurprisingly, 1 and 2* are the only logic you need to put in loop while (i < j). When the while loop terminates, the value of i/j is where the start of the range is. Why? \\n\\nNo matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases:\\n\\n    case 1: [5 7] (A[i] = target < A[j])\\n\\tcase 2: [5 3] (A[i] = target > A[j])\\n    case 3: [5 5] (A[i] = target = A[j])\\n    case 4: [3 5] (A[j] = target > A[i])\\n    case 5: [3 7] (A[i] < target < A[j])\\n\\tcase 6: [3 4] (A[i] < A[j] < target)\\n\\tcase 7: [6 7] (target < A[i] < A[j])\\n\\nFor case 1, 2 and 3, if we follow the above rule, since mid = i => A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5.  \\n\\nFor case 4, since A[mid] < target, then set i = mid+1. The loop terminates and both i and j point to 5.\\n\\nFor all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails.\\n\\nIn conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1;\\n\\nFor the right of the range, we can use a similar idea. Again we can come up with several rules:\\n\\n   1. If A[mid] > target, then the range must begins on the ***left*** of mid (j = mid-1)\\n   2. If A[mid] < target, then the range must begins on the ***right*** of mid (hence i = mid+1 for the next iteration)\\n   3. If A[mid] = target, then the range must begins ***on the right of or at*** mid  (i= mid) \\n\\nAgain, we can merge condition 2 and 3 into:\\n\\n    2* If A[mid] <= target, then i = mid;\\n\\nHowever, the terminate condition on longer works this time. Consider the following case:\\n\\n    [5 7], target = 5\\n\\t\\nNow A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all!\\n\\nThe solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do:\\n\\n    mid = (i+j)/2+1\\n\\t\\nWhy does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always *biased* towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won't get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid *biased* to the right, i.e. mid = (i+j)/2+1.\\n\\nAll this reasoning boils down to the following simple code:\\n\\n    vector<int> searchRange(int A[], int n, int target) {\\n        int i = 0, j = n - 1;\\n        vector<int> ret(2, -1);\\n        // Search for the left one\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2;\\n            if (A[mid] < target) i = mid + 1;\\n            else j = mid;\\n        }\\n        if (A[i]!=target) return ret;\\n        else ret[0] = i;\\n        \\n        // Search for the right one\\n        j = n-1;  // We don't have to set i to 0 the second time.\\n        while (i < j)\\n        {\\n            int mid = (i + j) /2 + 1;\\t// Make mid biased to the right\\n            if (A[mid] > target) j = mid - 1;  \\n            else i = mid;\\t\\t\\t\\t// So that this won't make the search range stuck.\\n        }\\n        ret[1] = j;\\n        return ret; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14734,
                "title": "easy-java-o-logn-solution",
                "content": "There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element.\\n\\n\\n    public class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] result = new int[2];\\n        result[0] = findFirst(nums, target);\\n        result[1] = findLast(nums, target);\\n        return result;\\n    }\\n    \\n    private int findFirst(int[] nums, int target){\\n        int idx = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            if(nums[mid] >= target){\\n                end = mid - 1;\\n            }else{\\n                start = mid + 1;\\n            }\\n            if(nums[mid] == target) idx = mid;\\n        }\\n        return idx;\\n    }\\n    \\n    private int findLast(int[] nums, int target){\\n        int idx = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start <= end){\\n            int mid = (start + end) / 2;\\n            if(nums[mid] <= target){\\n                start = mid + 1;\\n            }else{\\n                end = mid - 1;\\n            }\\n            if(nums[mid] == target) idx = mid;\\n        }\\n        return idx;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] result = new int[2];\\n        result[0] = findFirst(nums, target);\\n        result[1] = findLast(nums, target);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 14701,
                "title": "a-very-simple-java-solution-with-only-one-binary-search-algorithm",
                "content": "    public class Solution {\\n    \\tpublic int[] searchRange(int[] A, int target) {\\n    \\t\\tint start = Solution.firstGreaterEqual(A, target);\\n    \\t\\tif (start == A.length || A[start] != target) {\\n    \\t\\t\\treturn new int[]{-1, -1};\\n    \\t\\t}\\n    \\t\\treturn new int[]{start, Solution.firstGreaterEqual(A, target + 1) - 1};\\n    \\t}\\n    \\n    \\t//find the first number that is greater than or equal to target.\\n    \\t//could return A.length if target is greater than A[A.length-1].\\n    \\t//actually this is the same as lower_bound in C++ STL.\\n    \\tprivate static int firstGreaterEqual(int[] A, int target) {\\n    \\t\\tint low = 0, high = A.length;\\n    \\t\\twhile (low < high) {\\n    \\t\\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\t\\t//low <= mid < high\\n    \\t\\t\\tif (A[mid] < target) {\\n    \\t\\t\\t\\tlow = mid + 1;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\t//should not be mid-1 when A[mid]==target.\\n    \\t\\t\\t\\t//could be mid even if A[mid]>target because mid<high.\\n    \\t\\t\\t\\thigh = mid;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn low;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\tpublic int[] searchRange(int[] A, int target) {\\n    \\t\\tint start = Solution.firstGreaterEqual(A, target);\\n    \\t\\tif (start == A.length || A[start] != target) {\\n    \\t\\t\\treturn new int[]{-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 14707,
                "title": "9-11-lines-o-log-n",
                "content": "Solution 1 : **Divide and Conquer with early breaks** : 56 ms\\n\\nThe O(log n) time isn't quite obvious, so I'll explain it below. Or you can take the challenge and prove it yourself :-)\\n\\n    def searchRange(self, nums, target):\\n        def search(lo, hi):\\n            if nums[lo] == target == nums[hi]:\\n                return [lo, hi]\\n            if nums[lo] <= target <= nums[hi]:\\n                mid = (lo + hi) / 2\\n                l, r = search(lo, mid), search(mid+1, hi)\\n                return max(l, r) if -1 in l+r else [l[0], r[1]]\\n            return [-1, -1]\\n        return search(0, len(nums)-1)\\n\\nThe `search` helper function returns an index range just like the requested `searchRange` function, but only searches in `nums[lo..hi]`. It first compares the end points and immediately returns `[lo, hi]` if that whole part of `nums` is full of `target`, and immediately returns `[-1, -1]` if `target` is outside the range. The interesting case is when `target` can be in the range but doesn't fill it completely.\\n\\nIn that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn't this explode exponentially? Well, let's call the numbers in the left half `A, ..., B` and the numbers in the right half `C, ..., D`. Now if one of them immediately return their `[lo, hi]` or `[-1, -1]`, then this doesn't explode. And if neither immediately returns, that means we have `A <= target <= B` and `C <= target <= D`. And since `nums` is sorted, we actually have `target <= B <= C <= target`, so `B = C = target`. **The left half thus ends with `target` and the right half starts with it.** I highlight that because it's important. Now consider what happens further. The left half gets halved again. Call the middle elements `a` and `b`, so the left half is `A, ..., a, b, ..., B`. Then `a <= target` and:\\n\\n - If `a < target`, then the call analyzing `A, ..., a` immediately returns `[-1, -1]` and we only look further into `b, ..., B` **which is again a part that ends with `target`**.\\n - If `a == target`, then `a = b = ... = B = target` and thus the call analyzing `b, ..., B` immediately returns its `[lo, hi]` and we only look further into `A, ..., a` **which is again a part that ends with `target`**.\\n\\nSame for the right half `C, ..., D`. So in the beginning of the search, as long as `target` is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where `target` is in both halves, then we split into *two* paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n).\\n\\nThis is btw based on [us917's solution](https://leetcode.com/discuss/4238/can-solution-be-obtained-in-one-pass?show=4425#a4425).\\n\\n---\\n\\nSolution 2 : **Two binary searches** : 56 ms\\n\\n    def searchRange(self, nums, target):\\n        def search(n):\\n            lo, hi = 0, len(nums)\\n            while lo < hi:\\n                mid = (lo + hi) / 2\\n                if nums[mid] >= n:\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            return lo\\n        lo = search(target)\\n        return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\nHere, my helper function is a simple binary search, telling me the first index where I could insert a number `n` into `nums` to keep it sorted. Thus, if `nums` contains `target`, I can find the first occurrence with `search(target)`. I do that, and if `target` isn't actually there, then I return `[-1, -1]`. Otherwise, I ask `search(target+1)`, which tells me the first index where I could insert `target+1`, which of course is one index behind the last index containing `target`, so all I have left to do is subtract 1.\\n\\n---\\n\\nSolution 3 : **Two binary searches, using the library**\\n\\nBinary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand.\\n\\n**Python:**\\n\\n    def searchRange(self, nums, target):\\n        lo = bisect.bisect_left(nums, target)\\n        return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\n**C++:**\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto bounds = equal_range(nums.begin(), nums.end(), target);\\n        if (bounds.first == bounds.second)\\n            return {-1, -1};\\n        return {bounds.first - nums.begin(), bounds.second - nums.begin() - 1};\\n    }\\n\\nOr:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        if (lo == nums.size() || nums[lo] != target)\\n            return {-1, -1};\\n        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;\\n        return {lo, hi};\\n    }\\n\\n**Java:**\\n\\nWell, Java decided to be annoying and offer `Arrays.binSearch` but with *\"If the array contains multiple elements with the specified value, there is no guarantee which one will be found\"*. So it's useless for us. I'm not good at Java, though, so maybe I'm overlooking a way to still make it work. If you manage to do so, please let me know.",
                "solutionTags": [],
                "code": "Solution 1 : **Divide and Conquer with early breaks** : 56 ms\\n\\nThe O(log n) time isn't quite obvious, so I'll explain it below. Or you can take the challenge and prove it yourself :-)\\n\\n    def searchRange(self, nums, target):\\n        def search(lo, hi):\\n            if nums[lo] == target == nums[hi]:\\n                return [lo, hi]\\n            if nums[lo] <= target <= nums[hi]:\\n                mid = (lo + hi) / 2\\n                l, r = search(lo, mid), search(mid+1, hi)\\n                return max(l, r) if -1 in l+r else [l[0], r[1]]\\n            return [-1, -1]\\n        return search(0, len(nums)-1)\\n\\nThe `search` helper function returns an index range just like the requested `searchRange` function, but only searches in `nums[lo..hi]`. It first compares the end points and immediately returns `[lo, hi]` if that whole part of `nums` is full of `target`, and immediately returns `[-1, -1]` if `target` is outside the range. The interesting case is when `target` can be in the range but doesn't fill it completely.\\n\\nIn that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn't this explode exponentially? Well, let's call the numbers in the left half `A, ..., B` and the numbers in the right half `C, ..., D`. Now if one of them immediately return their `[lo, hi]` or `[-1, -1]`, then this doesn't explode. And if neither immediately returns, that means we have `A <= target <= B` and `C <= target <= D`. And since `nums` is sorted, we actually have `target <= B <= C <= target`, so `B = C = target`. **The left half thus ends with `target` and the right half starts with it.** I highlight that because it's important. Now consider what happens further. The left half gets halved again. Call the middle elements `a` and `b`, so the left half is `A, ..., a, b, ..., B`. Then `a <= target` and:\\n\\n - If `a < target`, then the call analyzing `A, ..., a` immediately returns `[-1, -1]` and we only look further into `b, ..., B` **which is again a part that ends with `target`**.\\n - If `a == target`, then `a = b = ... = B = target` and thus the call analyzing `b, ..., B` immediately returns its `[lo, hi]` and we only look further into `A, ..., a` **which is again a part that ends with `target`**.\\n\\nSame for the right half `C, ..., D`. So in the beginning of the search, as long as `target` is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where `target` is in both halves, then we split into *two* paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n).\\n\\nThis is btw based on [us917's solution](https://leetcode.com/discuss/4238/can-solution-be-obtained-in-one-pass?show=4425#a4425).\\n\\n---\\n\\nSolution 2 : **Two binary searches** : 56 ms\\n\\n    def searchRange(self, nums, target):\\n        def search(n):\\n            lo, hi = 0, len(nums)\\n            while lo < hi:\\n                mid = (lo + hi) / 2\\n                if nums[mid] >= n:\\n                    hi = mid\\n                else:\\n                    lo = mid + 1\\n            return lo\\n        lo = search(target)\\n        return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\nHere, my helper function is a simple binary search, telling me the first index where I could insert a number `n` into `nums` to keep it sorted. Thus, if `nums` contains `target`, I can find the first occurrence with `search(target)`. I do that, and if `target` isn't actually there, then I return `[-1, -1]`. Otherwise, I ask `search(target+1)`, which tells me the first index where I could insert `target+1`, which of course is one index behind the last index containing `target`, so all I have left to do is subtract 1.\\n\\n---\\n\\nSolution 3 : **Two binary searches, using the library**\\n\\nBinary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand.\\n\\n**Python:**\\n\\n    def searchRange(self, nums, target):\\n        lo = bisect.bisect_left(nums, target)\\n        return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1]\\n\\n**C++:**\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto bounds = equal_range(nums.begin(), nums.end(), target);\\n        if (bounds.first == bounds.second)\\n            return {-1, -1};\\n        return {bounds.first - nums.begin(), bounds.second - nums.begin() - 1};\\n    }\\n\\nOr:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        if (lo == nums.size() || nums[lo] != target)\\n            return {-1, -1};\\n        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;\\n        return {lo, hi};\\n    }\\n\\n**Java:**\\n\\nWell, Java decided to be annoying and offer `Arrays.binSearch` but with *\"If the array contains multiple elements with the specified value, there is no guarantee which one will be found\"*. So it's useless for us. I'm not good at Java, though, so maybe I'm overlooking a way to still make it work. If you manage to do so, please let me know.",
                "codeTag": "Python3"
            },
            {
                "id": 3188625,
                "title": "best-c-2-solution-binary-search-linear-search-brute-force-optimize-one-stop-solu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Linear Search (Brute Force Approach).\\n2. Solved using Binary Search (Optimized Approach).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = -1, endingPosition = -1;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                startingPosition = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] == target){\\n                endingPosition = i;\\n                break;\\n            }\\n        }\\n        return {startingPosition, endingPosition};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int lower_bound(vector<int>& nums, int low, int high, int target){\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int startingPosition = lower_bound(nums, low, high, target);\\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = -1, endingPosition = -1;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                startingPosition = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] == target){\\n                endingPosition = i;\\n                break;\\n            }\\n        }\\n        return {startingPosition, endingPosition};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int lower_bound(vector<int>& nums, int low, int high, int target){\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int startingPosition = lower_bound(nums, low, high, target);\\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\\n            return {startingPosition, endingPosition};\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14717,
                "title": "c-binary-search-solution-lower-bound-implementation",
                "content": "        \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int idx1 = lower_bound(nums, target);\\n        int idx2 = lower_bound(nums, target+1)-1;\\n        if (idx1 < nums.size() && nums[idx1] == target)\\n            return {idx1, idx2};\\n        else\\n            return {-1, -1};\\n    }\\n    \\n    int lower_bound(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "        \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int idx1 = lower_bound(nums, target);\\n        int idx2 = lower_bound(nums, target+1)-1;\\n        if (idx1 < nums.size() && nums[idx1] == target)\\n            return {idx1, idx2};\\n        else\\n            return {-1, -1};\\n    }\\n    \\n    int lower_bound(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        while (l <= r) {\\n            int mid = (r-l)/2+l;\\n            if (nums[mid] < target)\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 573123,
                "title": "c-how-to-nail-binary-search-the-very-first-time-explained",
                "content": "I used to be afraid about getting binary searches not working the first time. I had the opportunity to see a great programmer code it out in front of my eyes a few times. Here is what I learnt from the way he did it. \\n\\n1) Use a variable to **store the temporary result** during the search(let\\'s call it ans). Every time you hit a not found condition AND if there is a possibility of one of the mid or its neighbours being the desired answer **store it**. \\nReason : storing can\\'t harm you if its constant space, the later points will show you how it reduces a burden while writing binary search. Also it ensures an answer.\\n\\n2) Whenever you hit not found condition **do `s = mid+1` or `e = mid-1`** according to the condition without worrying. \\nReason : You have stored your value if the loop ends, can\\'t go wrong. This also ensures you don\\'t go into infinite loops.\\n\\n3) Default to writing **`mid = s + (e-s)/2`** and NOT **`mid = (s+e)/2`**. \\nReason : The later can result in an overflow when you are not searching in an array but rather on an answer space, specially because binary search if it can be applied is a great tool for huge numbers.\\n\\n4) Write your if and elses well, and don\\'t worry about adding extra conditions with the neighbours, at the same time don\\'t forget to check whether the neighbour exists.\\nReason : This is the only thing you should be worrying about coding right, because this depends on the problem. If it is a easy or medium sometimes even medium-hard, this part shouldnt cause much trouble.\\n\\nThis is not the only way to approach binary search in a fail-safe way every time, there are others too. Choose any and code a lot of problems using that, but don\\'t mix two ways up.\\n\\nHere is a basic code to the problem using the above way.\\n\\n```cpp\\nvector<int> searchRange(vector<int>& a, int target) {\\n\\tint s = 0, e = a.size()-1;\\n\\tvector<int> ans(2, -1);\\n\\t//first occurrence\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == s || a[m] != a[m-1]){\\n\\t\\t\\t\\tans[0] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\te = m-1;\\n\\t\\t\\t\\tans[0] = m-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//last occurrence\\n\\ts = 0, e = a.size()-1;\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == e || a[m] != a[m+1]){\\n\\t\\t\\t\\tans[1] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts = m+1;\\n\\t\\t\\t\\tans[1] = m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans; \\n}\\n```\\nIf you\\'re wondering why I have written `m == s` and again `m == e` in my conditions. This is because I am sure my answer cannot be outside the range s and e and if it is it has been stored. If you\\'re more comfortable you can replace with `m == 0` or `m == a.size()-1`\\n\\nI hope you found this helpful.\\n\\n**Update:**\\nSolved this again 2 years from the time I first wrote this post as part of daily challenge, found it more elegant than quite a few of the other most voted solutions, that have implemented the solution using two binary searchs. Using library lower_bound or solving using one binary search by calling twice for target and target + 1, beats the purpose of practising this question, unless your only aim is to make your solution short.\\n\\nThat said if you want to learn binary search, you should still go through the earlier solution I wrote as it demonstrates the point of checking neighbours(which can be useful in other problems and hence more general). The solution below avoids that and hence you may miss getting practise for that.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans(2, -1);\\n        int start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < target) start = mid+1;\\n            else {\\n                if(nums[mid] == target) ans[0] = mid;\\n                end = mid-1;\\n            }\\n        }\\n        start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] > target) end = mid-1;\\n            else {\\n                if(nums[mid] == target) ans[1] = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIt makes me happy that I decided to share this 2 years back, over 10k people have read this, and atleast 100 people have found this helpful. \\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nvector<int> searchRange(vector<int>& a, int target) {\\n\\tint s = 0, e = a.size()-1;\\n\\tvector<int> ans(2, -1);\\n\\t//first occurrence\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == s || a[m] != a[m-1]){\\n\\t\\t\\t\\tans[0] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\te = m-1;\\n\\t\\t\\t\\tans[0] = m-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t//last occurrence\\n\\ts = 0, e = a.size()-1;\\n\\twhile(s <= e){\\n\\t\\tint m = s + (e-s)/2;\\n\\t\\tif(a[m] < target)\\n\\t\\t\\ts = m+1;\\n\\t\\telse if(a[m] > target)\\n\\t\\t\\te = m-1;\\n\\t\\telse{\\n\\t\\t\\tif(m == e || a[m] != a[m+1]){\\n\\t\\t\\t\\tans[1] = m;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts = m+1;\\n\\t\\t\\t\\tans[1] = m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans; \\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans(2, -1);\\n        int start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < target) start = mid+1;\\n            else {\\n                if(nums[mid] == target) ans[0] = mid;\\n                end = mid-1;\\n            }\\n        }\\n        start = 0, end = (int)nums.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] > target) end = mid-1;\\n            else {\\n                if(nums[mid] == target) ans[1] = mid;\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14714,
                "title": "16-line-python-solution-symmetric-and-clean-binary-search-52ms",
                "content": "    def searchRange(self, nums, target):\\n        def binarySearchLeft(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x > A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n\\n        def binarySearchRight(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x >= A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return right\\n            \\n        left, right = binarySearchLeft(nums, target), binarySearchRight(nums, target)\\n        return (left, right) if left <= right else [-1, -1]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    def searchRange(self, nums, target):\\n        def binarySearchLeft(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x > A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n\\n        def binarySearchRight(A, x):\\n            left, right = 0, len(A) - 1\\n            while left <= right:\\n                mid = (left + right) / 2\\n                if x >= A[mid]: left = mid + 1\\n                else: right = mid - 1\\n            return right\\n            \\n        left, right = binarySearchLeft(nums, target), binarySearchRight(nums, target)\\n        return (left, right) if left <= right else [-1, -1]",
                "codeTag": "Python3"
            },
            {
                "id": 1054742,
                "title": "python-o-logn",
                "content": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717306,
                "title": "python3-solution-with-detailed-explanation",
                "content": "First thing first! When you hear `O(logn)` or sorted array, your mind should go back to [**binary search**](https://leetcode.com/problems/binary-search/)  example! \\n\\nI think the problem statement is not hard to understand, right? Check out the examples provided in case you have problem digesting it. \\n\\nThe idea is that we have to return two indices, one for start of the `target` and one for end of the `target` in an array. So, we use two different functions, one would go and try to find the starting index, the other to find the end index. as simple as that! We have two helper functions in the code below which are responsible for these tasks. The `main function` is just a wrapper that initializa (line `#1`)  the output and assign updated values  (line `#2, 3`) from helper functions and `return results`  (line `#4`) at the end. \\n\\n\\n\\n``` \\nclass Solution(object): \\n\\n#### Main function\\n\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [-1, -1] #1\\n        \\n        result[0] = self.findStartingIndex(nums, target)  #2 \\n        result[1] = self.findEndingIndex(nums, target)  #3\\n        \\n        return result #4\\n\\t\\t\\n#### Helper function 1 \\n\\n    def findStartingIndex(self, nums, target):\\n        index = -1 #5 \\n        low, high = 0, len(nums) -1 #6\\n        \\n        while low <= high: #7\\n            mid = low + (high - low)/2 #8\\n\\t\\t\\t\\n            if nums[mid] == target: #9\\n                index = mid #10\\n                high = mid - 1 #11\\n            elif nums[mid] > target:  #12\\n                high = mid - 1 #13\\n            else:  #14\\n                low = mid + 1 #15       \\n        \\n        return index\\n        \\n#### Helper function 2\\n  \\n    def findEndingIndex(self, nums, target):\\n        index = -1\\n        low, high = 0, len(nums) -1\\n        \\n        while low <= high:\\n            \\n            mid = low + (high - low)/2\\n            \\n            if nums[mid] == target:\\n                index = mid\\n                low = mid + 1 #16\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                 low = mid + 1\\n            \\n            \\n        \\n        return index\\n```\\n\\nNote: the two helper functions are exactly the same except for one line (there are ways to actually combine the two, but, I though it\\'s much easier to read and understand this way). The only difference is between line `#11` and line `#16` because the `findStartingIndex` would try to find the starting value and need to go to the left most target value in the array. However, `findEndingIndex` would try to find the right most one. So, in the first helper function, we try to narrow the limit of search (by changing `low` and `high`. We make `high = mid - 1 ` in line `#11`) to focus on the left side of mid while we do the same for right side in the second helper function (`low = mid + 1 `, line `#16`), does this make sense? Good. From now on, I\\'ll focus on the `findStartingIndex` function. \\n\\n\\nIt\\'s binary search! you set limits first, try to narrow it down using `mid` and focus on one side to find your `target` value. We want to return an `index` which would be `-1` in case we don\\'t find the `target`. So, we initialize it to be `-1` (line `#5`) and we will return the `index` at the end of the function, meaning that if the `index` variable doesn\\'t get updated, it will be `-1` and `target` doesn\\'t exist in the array we\\'re searching in. \\n\\nWe define a `while` loop (line `#7`) which is accurate at most when `low` and `high` are equal. You know why is that? No? Try to understand [this](https://leetcode.com/problems/binary-search/) before moving forward! If you know binary search, the rest should be easy! \\n\\nWe define a `mid` variable (line `#8`, this way of defining `mid` is to prevent overflow problem, you don\\'t need to worry about this. `mid  = (low + high) /2` or `mid = (low + high) //2` or `mid = (low + high) >> 1` also works) and compare it with `target` (line `#9`). If it\\'s the `target`, update the `index` variable (line `#10`). However, we\\'re not done here. Think about this example [1,3,3,3,5]. `mid` is 3 here. But, it\\'s not the left most 3, is it? So, you update `index` but at the same time, try to move to the left side of `mid` to find the left most `target` value (line `#11`, for the `findEndingIndex` function, you want to move to the right of `mid`, so you make `low = mid + 1`, line `#16`), 3 in this example. Make sense? Good. \\n\\nThere are two more cases in the function. If middle number is less than `target` or larger than `target`. The first case is dealth with in line `#13` and the other in line `#15`. How? If `nums[mid]` is larger than `target`, it means that `target` is on the left side of `mid`, right? Remember it is a sorted array. So, we update the `high` to be `mid - 1` so that we focus on the left side. Similar to the left, if `nums[mid]` is less than `target`, we need to focus on the right side of the `mid` value, correct? So, we update `low` to be `mid + 1`. You migh ask why `mid + 1 ` or `mid -1` and not just `mid` when we\\'re updating in lines `#11` and `#15`? Since we already dealth with `mid` in lines `#9` and `#10` and we moved to `#12` or `14` when `nums[mid]` was not equal to `target`. So, why bother and update to the `mid` value since we know it is not equal to `target`, right? \\n\\nThat\\'s it. You\\'re done! Go to the next problem. \\n\\n\\n=========================================================\\nFinal note: Please let me know if you found any typo, etc. I\\'ll try to fix them\\n\\nFinal note 2: I\\'ve found explaning stuff in the simplest way is helpful for my own learning. Thanks for reading this!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution(object): \\n\\n#### Main function\\n\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [-1, -1] #1\\n        \\n        result[0] = self.findStartingIndex(nums, target)  #2 \\n        result[1] = self.findEndingIndex(nums, target)  #3\\n        \\n        return result #4\\n\\t\\t\\n#### Helper function 1 \\n\\n    def findStartingIndex(self, nums, target):\\n        index = -1 #5 \\n        low, high = 0, len(nums) -1 #6\\n        \\n        while low <= high: #7\\n            mid = low + (high - low)/2 #8\\n\\t\\t\\t\\n            if nums[mid] == target: #9\\n                index = mid #10\\n                high = mid - 1 #11\\n            elif nums[mid] > target:  #12\\n                high = mid - 1 #13\\n            else:  #14\\n                low = mid + 1 #15       \\n        \\n        return index\\n        \\n#### Helper function 2\\n  \\n    def findEndingIndex(self, nums, target):\\n        index = -1\\n        low, high = 0, len(nums) -1\\n        \\n        while low <= high:\\n            \\n            mid = low + (high - low)/2\\n            \\n            if nums[mid] == target:\\n                index = mid\\n                low = mid + 1 #16\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                 low = mid + 1\\n            \\n            \\n        \\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14770,
                "title": "the-standard-and-clean-c-binary-search-implementation",
                "content": "Yeah, binary search is quite simple, but many people write complex and error-prone code.\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size(), mid, left, right;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] >= target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        left = start;\\n        start = 0, end = nums.size();\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] > target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        right = start;\\n        return left == right ? vector<int> {-1,-1} : vector<int> {left,right-1};\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "Yeah, binary search is quite simple, but many people write complex and error-prone code.\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = 0, end = nums.size(), mid, left, right;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] >= target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        left = start;\\n        start = 0, end = nums.size();\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (nums[mid] > target)\\n                end = mid;\\n            else\\n                start = mid + 1;\\n        }\\n        right = start;\\n        return left == right ? vector<int> {-1,-1} : vector<int> {left,right-1};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 519580,
                "title": "c-o-log-n-fast-runtime-binary-search",
                "content": "```\\nRuntime: 4 ms, faster than 99.18% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {BinarySearch(nums, target, \"FIRST\"), BinarySearch(nums, target, \"LAST\")};\\n    }\\n    \\n    int BinarySearch(vector<int> nums, int num, string find) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        int result = -1;\\n\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n\\n            if (nums[mid] == num) {\\n                result = mid;\\n                (find == \"FIRST\") ? right = mid - 1 : left = mid + 1;\\n            }\\n            else if (nums[mid] > num) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nRuntime: 4 ms, faster than 99.18% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 8.8 MB, less than 100.00% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {BinarySearch(nums, target, \"FIRST\"), BinarySearch(nums, target, \"LAST\")};\\n    }\\n    \\n    int BinarySearch(vector<int> nums, int num, string find) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        int result = -1;\\n\\n        while (left <= right) {\\n            mid = (left + right) / 2;\\n\\n            if (nums[mid] == num) {\\n                result = mid;\\n                (find == \"FIRST\") ? right = mid - 1 : left = mid + 1;\\n            }\\n            else if (nums[mid] > num) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329415,
                "title": "c-stl-5-line-code-bits-100-test-time-saving-method",
                "content": "**Time Complexity :-** `O(Log(n))`\\n**Space Complexity :-** `O(1)`\\n\\n**If you like my approch please upvote**\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(low == nums.end() || *low != target)    return {-1,-1};\\n        \\n        int first = low - nums.begin();\\n        int last = up - nums.begin()-1;\\n        \\n        return {first ,last};\\n    }\\n};\\n```\\n**If you like my approch please upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(low == nums.end() || *low != target)    return {-1,-1};\\n        \\n        int first = low - nums.begin();\\n        int last = up - nums.begin()-1;\\n        \\n        return {first ,last};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181832,
                "title": "js-python-java-c-easy-binary-search-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is very nearly the definition of a **binary search**. A binary search allows us to find the insertion index for a target number in a sorted array. It\\'s called a \"binary\" search because in each step it halves the input array and determines in which half the number belongs. Since a binary search is able to eliminate half the remaining array in each iteration, it can accomplish its objective with a **time complexity** of **O(log N)**.\\n\\nIn this case, however, we don\\'t just want to find out where the target number (**T**) would be placed in the nums array (**N**), we want to additionally find out if **T** _actually_ exists in **N**, as well as the starting and end indexes.\\n\\nThe standard implementation of a binary search will find the left-most index in which **T** could be placed, though many languages have functions for both sides. Rather than having to define two sets of functions here, however, we can, with a little creativity, use a single function to find our answer.\\n\\nFirst, we can perform the standard left binary search (**find**) on **T**. Next, we can easily check to see if **T** exists in **N** already by checking the value stored at the result of that first search (**N[Tleft]**). If we don\\'t find **T** at that index, then **T** does not exist in **N** and we should **return [-1, -1]**.\\n\\nOtherwise, we still need to find the right end of the range of **T** values in **N**. To do this, we can just use **find** again, this time with the next integer (**T + 1**). Since this will find the index _after_ the end of the range of **T** values, we can just move back one position to find the end of the **T** range.\\n\\nNow that we have our range, we can **return** it.\\n\\n - _**Time Complexity: O(log N)** for the binary search_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has built-in binary search functions for both sides: **bisect_left()** and **bisect_right()**.\\n\\nThe built-in function for Java, **Arrays.binarySearch()** does not find the left-most insertion point, so it\\'s easier to define our own binary search function.\\n\\nC++ can use the built-in function **equal_range()**, which returns iterator pointers to the range of T values.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n\\n##### ***w/ bisect_left() & bisect_right():***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\\n##### ***w/ Custom Binary Search:***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ equal_range():***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\\n##### ***w/ Custom Binary Search:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14999,
                "title": "simple-and-strict-o-logn-solution-in-java-using-recursion",
                "content": "    public class Solution {\\n        public int[] searchRange(int[] A, int target) {\\n            int[] range = {A.length, -1};\\n            searchRange(A, target, 0, A.length - 1, range);\\n            if (range[0] > range[1]) range[0] = -1; \\n            return range;\\n        }\\n        \\n        public void searchRange(int[] A, int target, int left, int right, int[] range) {\\n            if (left > right) return;\\n            int mid = left + (right - left) / 2;\\n            if (A[mid] == target) {\\n                if (mid < range[0]) {\\n                    range[0] = mid;\\n                    searchRange(A, target, left, mid - 1, range);\\n                }\\n                if (mid > range[1]) {\\n                    range[1] = mid;\\n                    searchRange(A, target, mid + 1, right, range);\\n                }\\n            } else if (A[mid] < target) {\\n                searchRange(A, target, mid + 1, right, range);\\n            } else {\\n                searchRange(A, target, left, mid - 1, range);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] searchRange(int[] A, int target) {\\n            int[] range = {A.length, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1608890,
                "title": "clean-and-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start=0,end=nums.size()-1,res=-1;\\n        vector<int>ans;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target)\\n            {\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid])\\n                end=mid-1;\\n            else\\n                start=mid+1;   \\n        }\\n        ans.push_back(res);\\n        start=0,end=nums.size()-1,res=-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target)\\n            {\\n                res=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid])\\n                end=mid-1;\\n            else\\n                start=mid+1;   \\n        }\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n\\npls upvote if it was helpful:)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702162,
                "title": "python-let-s-implement-python-s-bisect-algorithm",
                "content": "Thinking in terms of pythons bisect_left and bisect right is helpful for this problem. Since binary search is the central feature of this problem, I believe an interviewer would also expect you to know how to implement bisect_left and bisect_right if you want to use them. Reading python source code is a great way to learn algorithms with python: https://github.com/python/cpython/blob/3.8/Lib/bisect.py#L49\\n```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left, right = self.bisect_left(nums, target), self.bisect_right(nums, target) - 1\\n        return [\\n            left if left < len(nums) and nums[left] == target else -1,\\n            right if 0 <= right < len(nums) and nums[right] == target else -1\\n        ]\\n      \\n    def bisect_left(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] < x: lo = mid + 1\\n            else: hi = mid\\n        return lo\\n    \\n    def bisect_right(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than or equal to x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] > x: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left, right = self.bisect_left(nums, target), self.bisect_right(nums, target) - 1\\n        return [\\n            left if left < len(nums) and nums[left] == target else -1,\\n            right if 0 <= right < len(nums) and nums[right] == target else -1\\n        ]\\n      \\n    def bisect_left(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] < x: lo = mid + 1\\n            else: hi = mid\\n        return lo\\n    \\n    def bisect_right(self, a, x):\\n\\t\\t\\'\\'\\'returns i where all a[:i] is less than or equal to x\\'\\'\\'\\n        lo, hi = 0, len(a)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if a[mid] > x: hi = mid\\n            else: lo = mid + 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15056,
                "title": "my-2-binary-search-solution-without-too-many-if-checks",
                "content": "\\n\\n        public int[] searchRange(int[] A, int target) {\\n        int[] ret = {-1, -1};\\n        \\n        // the first binary search to find the left boundary\\n        int l = 0, r = A.length-1;\\n        while(l < r) {\\n            int mid = (l+r)/2;\\n            if (A[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        \\n        // if target can not be found, return {-1, -1}\\n        if (A[l] != target)\\n            return ret;\\n        \\n        ret[0] = l;\\n        // second binary search to find the right boundary\\n        r = A.length-1;\\n        while(l < r) {\\n            // mid is calculated differently\\n            int mid = (l + r+1)/2;\\n            if (A[mid] > target)\\n                r = mid - 1;\\n            else\\n                l = mid;\\n        }\\n        ret[1] = l;\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n        public int[] searchRange(int[] A, int target) {\\n        int[] ret = {-1, -1};\\n        \\n        // the first binary search to find the left boundary\\n        int l = 0, r = A.length-1;\\n        while(l < r) {\\n            int mid = (l+r)/2;\\n            if (A[mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid;\\n        }\\n        \\n        // if target can not be found, return {-1, -1}\\n        if (A[l] != target)\\n            return ret;\\n        \\n        ret[0] = l;\\n        // second binary search to find the right boundary\\n        r = A.length-1;\\n        while(l < r) {\\n            // mid is calculated differently\\n            int mid = (l + r+1)/2;\\n            if (A[mid] > target)\\n                r = mid - 1;\\n            else\\n                l = mid;\\n        }\\n        ret[1] = l;\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2330593,
                "title": "binary-search-beats-99-fully-explained-with-intuition-image-explanation",
                "content": "If you found this post helpful, please upvote <3\\n\\n<hr />\\n\\nWe are given a sorted array of integers, and required to find some `target`.\\n\\nSince the array is sorted, an intuition to do a binary search should pop into our head, but there\\'s a trick.\\n\\nIt\\'s not enough to find the target, we need to find the **left most index**, and **right most index** of the target in the given nums array.\\n\\nLet\\'s take the following array as an example, say `target = 7` (red numbers are the indexes)\\n\\n![image](https://assets.leetcode.com/users/images/87be2062-76ef-4f64-8033-7723cf7a7099_1658733561.213248.png)\\n\\nAfter we find the `target=7` we don\\'t know if it\\'s the left most, or right most. We could iterate to the left and right indexes, but potentially the array consists of only 7\\'s like: `[7,7,7,7,7,7,7,7]` and then end up in O(n) complexity.\\n\\nInstead we should separate our logic into 2 binary searches.\\n\\nOne binary search searches for the **left most index**, whenever we find the `target`, we \"mark\" it as the potential answer and continue binary searching left.\\n\\nSame logic for the other side, whenever we find the target we \"mark\" and continue searching right.\\n\\nIn the end we return the best matches we found in each binary search. \\n\\nThis will perform 2 binary searches as `2*log(n)` which is asymptotically `O(logn)`\\n\\nNote: we could exit after 1 binary search if we **didn\\'t** find any target in our array. Both indexes will be `[-1, -1]`\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search_on_left(nums, target, 0, len(nums) - 1)\\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search_on_right(nums, target, 0, len(nums) - 1)\\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search_on_left(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_left = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_left = mid\\n            \\n            if nums[mid] >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return index_on_left\\n            \\n    \\n    def binary_search_on_right(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_right = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_right = mid\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n            \\n        return index_on_right\\n```\\n\\n# Cleaner code\\nWe could clean the code by passing a callback as a parameter for the condition checks.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value >= target\\n        )\\n        \\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value > target\\n        )\\n        \\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search(self, nums: list[int], target: int, left: int, right: int, predicate):\\n        best_index_match = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                best_index_match = mid\\n            \\n            if predicate(nums[mid]):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return best_index_match\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search_on_left(nums, target, 0, len(nums) - 1)\\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search_on_right(nums, target, 0, len(nums) - 1)\\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search_on_left(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_left = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_left = mid\\n            \\n            if nums[mid] >= target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return index_on_left\\n            \\n    \\n    def binary_search_on_right(self, nums: list[int], target: int, left: int, right: int):\\n        index_on_right = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                index_on_right = mid\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n            \\n        return index_on_right\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        left_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value >= target\\n        )\\n        \\n        if left_target_index == -1:\\n            return [-1, -1]\\n        \\n        right_target_index = self.binary_search(\\n            nums,\\n            target,\\n            0,\\n            len(nums) - 1,\\n            lambda mid_value: mid_value > target\\n        )\\n        \\n        return [left_target_index, right_target_index]\\n    \\n    def binary_search(self, nums: list[int], target: int, left: int, right: int, predicate):\\n        best_index_match = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] == target:\\n                best_index_match = mid\\n            \\n            if predicate(nums[mid]):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n            \\n        return best_index_match\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182518,
                "title": "4-different-approach-easy-understanding",
                "content": "* Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int i = 0, j = nums.size()-1;\\n        int start = -1, end = -1;\\n        while(i <= j)\\n        {\\n            int mid = (i+j)/2;\\n            if(nums[mid] == target){\\n               int temp = mid;\\n                while(mid > 0 && nums[mid-1] == target) //iterating left side of mid until target value is found\\n                    mid--;\\n                start = mid;\\n                while(temp < nums.size()-1 && nums[temp+1] == target) //iterating right side of mid until target value is found (here temp is equal to mid)\\n                    temp++;\\n                end = temp;\\n                \\n                ans.push_back(start);\\n                ans.push_back(end);\\n                return ans;\\n            }\\n            else if(nums[mid] > target)\\n                j = mid-1;\\n            else\\n                i = mid+1;\\n        }\\n        \\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```\\n* Using Unordered map\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2, -1);\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        int index = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == target){\\n                index = i;\\n                break;\\n            }\\n        if(index != -1){\\n            ans[0] = index;\\n            ans[1] = index + mp[target] - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n* Using inbuilt lower and upper bound functions\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        vector<int>::iterator it, lower, upper;\\n        it = find(nums.begin(), nums.end(), target);\\n        if(it != nums.end()){\\n            lower = lower_bound(nums.begin(), nums.end(), target);\\n            upper = upper_bound(nums.begin(), nums.end(), target);\\n            ans.push_back(lower - nums.begin());\\n            ans.push_back(upper - nums.begin() - 1);\\n        }\\n        else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n* By iterating over nums array\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int first = -1, last = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == target){\\n                if(first == -1){\\n                    first = i;\\n                    last = i;\\n                }\\n                else\\n                    last = i;\\n            }\\n        }\\n        ans.push_back(first);\\n        ans.push_back(last);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int i = 0, j = nums.size()-1;\\n        int start = -1, end = -1;\\n        while(i <= j)\\n        {\\n            int mid = (i+j)/2;\\n            if(nums[mid] == target){\\n               int temp = mid;\\n                while(mid > 0 && nums[mid-1] == target) //iterating left side of mid until target value is found\\n                    mid--;\\n                start = mid;\\n                while(temp < nums.size()-1 && nums[temp+1] == target) //iterating right side of mid until target value is found (here temp is equal to mid)\\n                    temp++;\\n                end = temp;\\n                \\n                ans.push_back(start);\\n                ans.push_back(end);\\n                return ans;\\n            }\\n            else if(nums[mid] > target)\\n                j = mid-1;\\n            else\\n                i = mid+1;\\n        }\\n        \\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2, -1);\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        \\n        int index = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n            if(nums[i] == target){\\n                index = i;\\n                break;\\n            }\\n        if(index != -1){\\n            ans[0] = index;\\n            ans[1] = index + mp[target] - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        vector<int>::iterator it, lower, upper;\\n        it = find(nums.begin(), nums.end(), target);\\n        if(it != nums.end()){\\n            lower = lower_bound(nums.begin(), nums.end(), target);\\n            upper = upper_bound(nums.begin(), nums.end(), target);\\n            ans.push_back(lower - nums.begin());\\n            ans.push_back(upper - nums.begin() - 1);\\n        }\\n        else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans;\\n        int first = -1, last = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == target){\\n                if(first == -1){\\n                    first = i;\\n                    last = i;\\n                }\\n                else\\n                    last = i;\\n            }\\n        }\\n        ans.push_back(first);\\n        ans.push_back(last);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181777,
                "title": "python-solution-using-bisect-explained",
                "content": "Use binary search with adaptation twice: once to find the left place and once to find the right place. I understand that goal is to write binary search from scratch if you are on the interview, but here is solution, using already existing `bisect` library in python. \\nThe idea is to use `bisect` (which is also `bisect_right`) and `bisect_left` to get the range of numbers: first one will return index before all repetitions of `target` and the second one: after. So, if these two indexes are equal, it means that we did not found this element, so we return `[-1, -1]`. If we found, we return `[l, r - 1]`.\\n\\n#### Complexity\\nTime complexity is `O(log n)`, space is `O(1)`.\\n\\n#### Code\\n```\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def searchRange(self, nums, target):\\n        l = bisect_left(nums,target)\\n        r = bisect(nums,target)\\n        return [-1, -1] if l == r else [l, r - 1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect, bisect_left\\n\\nclass Solution:\\n    def searchRange(self, nums, target):\\n        l = bisect_left(nums,target)\\n        r = bisect(nums,target)\\n        return [-1, -1] if l == r else [l, r - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14708,
                "title": "share-my-concise-java-o-logn-solution-just-1-time-binary-search-easy-to-understand",
                "content": "This solution is to find the start and end index of target number with using just one time binary search\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n    \\t\\tint[] res = {-1, -1};\\n    \\t\\tint lo = 0, hi = nums.length - 1;\\n    \\n    \\t\\t//lo is the start index of target\\n    \\t\\t//hi is the end index of target\\n    \\t\\twhile(nums[lo] < nums[hi]) {\\n    \\t\\t\\tint mid = lo + (hi - lo)/2;\\n    \\t\\t\\tif(nums[mid] > target) {//target is in the left half\\n    \\t\\t\\t\\thi = mid - 1;\\n    \\t\\t\\t} else if(nums[mid] < target) {// target is in the right half\\n    \\t\\t\\t\\tlo = mid + 1;\\n    \\t\\t\\t} else {//find target, then need to find the start and end point\\n    \\t\\t\\t\\tif(nums[lo] == nums[mid]) {\\n    \\t\\t\\t\\t\\thi--;\\n    \\t\\t\\t\\t}else {\\n    \\t\\t\\t\\t\\tlo++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t//check whether find the target number\\n    \\t\\tif(nums[lo] == nums[hi] && nums[lo]== target) {\\n    \\t\\t\\tres[0] = lo;\\n    \\t\\t\\tres[1] = hi;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn res;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "This solution is to find the start and end index of target number with using just one time binary search\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n    \\t\\tint[] res = {-1, -1};\\n    \\t\\tint lo = 0, hi = nums.length - 1;\\n    \\n    \\t\\t//lo is the start index of target\\n    \\t\\t//hi is the end index of target\\n    \\t\\twhile(nums[lo] < nums[hi]) {\\n    \\t\\t\\tint mid = lo + (hi - lo)/2;\\n    \\t\\t\\tif(nums[mid] > target) {//target is in the left half\\n    \\t\\t\\t\\thi = mid - 1;\\n    \\t\\t\\t} else if(nums[mid] < target) {// target is in the right half\\n    \\t\\t\\t\\tlo = mid + 1;\\n    \\t\\t\\t} else {//find target, then need to find the start and end point\\n    \\t\\t\\t\\tif(nums[lo] == nums[mid]) {\\n    \\t\\t\\t\\t\\thi--;\\n    \\t\\t\\t\\t}else {\\n    \\t\\t\\t\\t\\tlo++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t//check whether find the target number\\n    \\t\\tif(nums[lo] == nums[hi] && nums[lo]== target) {\\n    \\t\\t\\tres[0] = lo;\\n    \\t\\t\\tres[1] = hi;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn res;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 694526,
                "title": "binary-search-o-log-n-even-for-worst-case-with-explanation",
                "content": "Thanks for @hon9g, I finally found a real O(log n) solution for all cases\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar searchRange = function (nums, target) {\\n    // initiate binary search\\n    let l = 0, r = nums.length - 1;\\n\\n    // search for the first appearance index of target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // try to push the array to the left smaller half\\n        // that\\'s why even when nums[mid] == target, we still set r = mid\\n        nums[mid] >= target ? r = mid : l = mid + 1;\\n    }\\n\\n    // after the first while loop, the small index l should already be the first appearance index of target\\n    // otherwise, target is not in the array and [-1, -1] should be returned\\n    if (nums[l] !== target) return [-1, -1];\\n\\n    // now we have the first appearance index of target, and it is the small index l\\n    // we can store it to a new variable for further usage\\n    let start = l;\\n\\n    // since both of the indices were changed (both of them are at the first appearance index of target)\\n    // we need to reset the big index to the end of the array to do the second binary search\\n    // to find the last appearance index of the target\\n    r = nums.length - 1;\\n\\n    // search for the last appearance index of the target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // nums[mid] <= target? l = mid : r = mid -1\\n        // the above will not work as it will run into infinite loop\\n        nums[mid] <= target ? l = mid + 1 : r = mid;\\n    }\\n\\n    // after the second while loop, now l == nums.length - 1\\n    // now there are 2 conditions: target is also appeared at the last index of the array, or not\\n    // store the last appearance index of target to another variable\\n    let end = nums[l] === target ? l : l - 1;\\n\\n    // finally return the two indices into an array\\n    return [start, end];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar searchRange = function (nums, target) {\\n    // initiate binary search\\n    let l = 0, r = nums.length - 1;\\n\\n    // search for the first appearance index of target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // try to push the array to the left smaller half\\n        // that\\'s why even when nums[mid] == target, we still set r = mid\\n        nums[mid] >= target ? r = mid : l = mid + 1;\\n    }\\n\\n    // after the first while loop, the small index l should already be the first appearance index of target\\n    // otherwise, target is not in the array and [-1, -1] should be returned\\n    if (nums[l] !== target) return [-1, -1];\\n\\n    // now we have the first appearance index of target, and it is the small index l\\n    // we can store it to a new variable for further usage\\n    let start = l;\\n\\n    // since both of the indices were changed (both of them are at the first appearance index of target)\\n    // we need to reset the big index to the end of the array to do the second binary search\\n    // to find the last appearance index of the target\\n    r = nums.length - 1;\\n\\n    // search for the last appearance index of the target\\n    while (l < r) {\\n        let mid = Math.floor((l + r) / 2);\\n\\n        // nums[mid] <= target? l = mid : r = mid -1\\n        // the above will not work as it will run into infinite loop\\n        nums[mid] <= target ? l = mid + 1 : r = mid;\\n    }\\n\\n    // after the second while loop, now l == nums.length - 1\\n    // now there are 2 conditions: target is also appeared at the last index of the array, or not\\n    // store the last appearance index of target to another variable\\n    let end = nums[l] === target ? l : l - 1;\\n\\n    // finally return the two indices into an array\\n    return [start, end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1651676,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ t: Int) -> [Int] {\\n        var arr = [-1,-1]\\n        if nums.isEmpty { return arr }\\n        \\n        var lhs = 0, rhs = nums.count - 1\\n        \\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2\\n            nums[mid] < t ? (lhs = mid + 1) : (rhs = mid)\\n        }\\n        \\n        guard nums[lhs] == t else { return arr }\\n        arr[0] = lhs\\n        \\n        rhs = nums.count - 1\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2 + 1\\n            nums[mid] > t ? (rhs = mid - 1) : (lhs = mid)\\n        }\\n        arr[1] = lhs\\n        return arr\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 8)\\n        XCTAssertEqual(value, [3,4])\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 6)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchRange([], 0)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ t: Int) -> [Int] {\\n        var arr = [-1,-1]\\n        if nums.isEmpty { return arr }\\n        \\n        var lhs = 0, rhs = nums.count - 1\\n        \\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2\\n            nums[mid] < t ? (lhs = mid + 1) : (rhs = mid)\\n        }\\n        \\n        guard nums[lhs] == t else { return arr }\\n        arr[0] = lhs\\n        \\n        rhs = nums.count - 1\\n        while lhs < rhs {\\n            let mid = lhs + (rhs - lhs) / 2 + 1\\n            nums[mid] > t ? (rhs = mid - 1) : (lhs = mid)\\n        }\\n        arr[1] = lhs\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 8)\\n        XCTAssertEqual(value, [3,4])\\n    }\\n    \\n    func test1() {\\n        let value = solution.searchRange([5,7,7,8,8,10], 6)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n    \\n    func test2() {\\n        let value = solution.searchRange([], 0)\\n        XCTAssertEqual(value, [-1,-1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224587,
                "title": "python-binary-search-bisect-left-and-bisect-right-from-scratch",
                "content": "Offering my two cents of understanding.\\nOverall TC: O( 2 * logN) ~ O(logN)\\nOverall SC: O(1)\\n\\nBisect left finds the leftmost insertion point in the sorted array.\\nE.g. target = 7\\n\\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                  # nums[mid] < target, hence move right to mid\\nl/m  r\\n    l/r                          # break, return left\\n```\\n\\t\\nBisect right finds the rightmost insertion point in the sorted array.\\nE.g. target = 7\\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                         # nums[mid] <= target, hence move left = mid + 1. Key difference to find right bound\\n       l/m  r\\n           l/r                          # break, return left\\n```\\n\\nThe only condition where bisect_left and bisect_right will return the same result is if the element does exist in the array.\\nHence we can check if both binary search functions return the same result. If they do, we know the element doesn\\'t exist in the array.\\n\\nIf they are different, then there is at least one occurrence of the element in the array.\\nWe return [left_bound, right_bound - 1] as bisect_right will always return the rightmost insertion point (i.e. index of rightmost occurrence of target + 1).\\n\\nAlso, took me a while to figure this out.\\nFor most binary search variations, the right pointer is initialized with the value of the last index of the sorted array (i.e. right = len(nums) - 1).\\nHowever, in this case, len(nums) is a valid return result due to the behaviour of bisect_right when the element to be inserted is larger than than all elements in the array, or equal to the greatest element in the array.\\n\\n```\\nclass Solution(object):\\n    def bisectLeft(self, nums, target):\\n        \"\"\"\\n        Returns leftmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n    \\n    def bisectRight(self, nums, target):\\n        \"\"\"\\n        Returns rightmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) == 0:\\n            return [-1, -1]\\n        \\n        left_bound = self.bisectLeft(nums, target) # O(logN)\\n        right_bound = self.bisectRight(nums, target) # O(logN)\\n        \\n        return [left_bound, right_bound - 1] if left_bound != right_bound else [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                  # nums[mid] < target, hence move right to mid\\nl/m  r\\n    l/r                          # break, return left\\n```\n```\\n5   7   7   8   8    10\\nl           m         r\\nl    m      r                         # nums[mid] <= target, hence move left = mid + 1. Key difference to find right bound\\n       l/m  r\\n           l/r                          # break, return left\\n```\n```\\nclass Solution(object):\\n    def bisectLeft(self, nums, target):\\n        \"\"\"\\n        Returns leftmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n    \\n    def bisectRight(self, nums, target):\\n        \"\"\"\\n        Returns rightmost insertion point that target should be inserted in the sorted array\\n        \"\"\"\\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = left + (right - left) // 2\\n            \\n            if nums[mid] <= target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n            \\n        return left\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(nums) == 0:\\n            return [-1, -1]\\n        \\n        left_bound = self.bisectLeft(nums, target) # O(logN)\\n        right_bound = self.bisectRight(nums, target) # O(logN)\\n        \\n        return [left_bound, right_bound - 1] if left_bound != right_bound else [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757366,
                "title": "python-clean-binary-search-solution-one-pass-80",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        start = 0; end = len(nums)-1\\n        while start <= end:\\n            mid = (start+end) // 2\\n            if nums[start] == nums[end] == target:\\n                return [start, end]\\n            if nums[mid] < target:\\n                start = mid+1\\n            elif nums[mid] > target:\\n                end = mid-1\\n            else:\\n                if nums[start] != target: start += 1\\n                if nums[end] != target: end -= 1\\n        return [-1,-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        start = 0; end = len(nums)-1\\n        while start <= end:\\n            mid = (start+end) // 2\\n            if nums[start] == nums[end] == target:\\n                return [start, end]\\n            if nums[mid] < target:\\n                start = mid+1\\n            elif nums[mid] > target:\\n                end = mid-1\\n            else:\\n                if nums[start] != target: start += 1\\n                if nums[end] != target: end -= 1\\n        return [-1,-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512879,
                "title": "c-java-python-javascript-iterative-solution-with-two-binary-searches-with-explanation",
                "content": "# Intuition\\nA binary search algorithm to find the starting and ending indices of a target value in a sorted array. It performs two binary searches: one to find the starting index and another to find the ending index.\\n\\n# Approach\\n1. Initialize the answer vector `ans` with [-1, -1] to represent the starting and ending indices of the target value.\\n2. Initialize `start` as 0, `end` as the last index of the `nums` array.\\n3. Calculate `mid` as the floor division of `(start + end) / 2`.\\n4. Run a binary search loop until `start` becomes greater than `end`.\\n   - Check if the target value is equal to the element at the `mid` index of `nums`.\\n     - If true, update `ans[0]` (starting index) with `mid` and move the `end` pointer to `mid - 1` to continue searching for the leftmost occurrence of the target.\\n     - If false, check if the target value is less than the element at the `mid` index of `nums`.\\n       - If true, update `end` to `mid - 1` to narrow down the search range to the left half.\\n       - If false, update `start` to `mid + 1` to narrow down the search range to the right half.\\n5. Reset `start` to 0 and `end` to the last index of the `nums` array.\\n6. Calculate `mid` as the floor division of `(start + end) / 2`.\\n7. Run another binary search loop until `start` becomes greater than `end`.\\n   - Check if the target value is equal to the element at the `mid` index of `nums`.\\n     - If true, update `ans[1]` (ending index) with `mid` and move the `start` pointer to `mid + 1` to continue searching for the rightmost occurrence of the target.\\n     - If false, check if the target value is less than the element at the `mid` index of `nums`.\\n       - If true, update `end` to `mid - 1` to narrow down the search range to the left half.\\n       - If false, update `start` to `mid + 1` to narrow down the search range to the right half.\\n8. Return the `ans` vector containing the starting and ending indices of the target value.\\n\\n# Complexity\\n- Time complexity: O(log N) since it performs two binary searches on the sorted array `nums`, where N is the size of `nums`.\\n- Space complexity: O(1) since only a constant amount of extra space is used to store the variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans={-1,-1};\\n        //First Occurence\\n        int start=0,end=nums.size()-1;\\n        int mid=(start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[0]=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        //last occurence\\n        start=0,end=nums.size()-1;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[1]=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = {-1, -1};\\n        // First Occurrence\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[0] = mid;\\n                end = mid - 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        // Last Occurrence\\n        start = 0;\\n        end = nums.length - 1;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[1] = mid;\\n                start = mid + 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        ans = [-1, -1]\\n        start, end = 0, len(nums) - 1\\n        # First occurrence\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[0] = mid\\n                end = mid - 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        # Last occurrence\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[1] = mid\\n                start = mid + 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```\\nvar searchRange = function(nums, target) {\\n    let ans = [-1, -1];\\n    let start = 0, end = nums.length - 1, mid;\\n    // First occurrence\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[0] = mid;\\n            end = mid - 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    // Last occurrence\\n    start = 0;\\n    end = nums.length - 1;\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[1] = mid;\\n            start = mid + 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans={-1,-1};\\n        //First Occurence\\n        int start=0,end=nums.size()-1;\\n        int mid=(start+end)/2;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[0]=mid;\\n                end=mid-1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        //last occurence\\n        start=0,end=nums.size()-1;\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(target==nums[mid]){\\n                ans[1]=mid;\\n                start=mid+1;\\n            }\\n            else if(target<nums[mid]){\\n                end=mid-1;\\n            }\\n            else if(target>nums[mid]){\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = {-1, -1};\\n        // First Occurrence\\n        int start = 0, end = nums.length - 1;\\n        int mid = (start + end) / 2;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[0] = mid;\\n                end = mid - 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        // Last Occurrence\\n        start = 0;\\n        end = nums.length - 1;\\n        while (start <= end) {\\n            mid = (start + end) / 2;\\n            if (target == nums[mid]) {\\n                ans[1] = mid;\\n                start = mid + 1;\\n            } else if (target < nums[mid]) {\\n                end = mid - 1;\\n            } else if (target > nums[mid]) {\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        ans = [-1, -1]\\n        start, end = 0, len(nums) - 1\\n        # First occurrence\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[0] = mid\\n                end = mid - 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        # Last occurrence\\n        start, end = 0, len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) / 2\\n            if target == nums[mid]:\\n                ans[1] = mid\\n                start = mid + 1\\n            elif target < nums[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return ans\\n\\n```\n```\\nvar searchRange = function(nums, target) {\\n    let ans = [-1, -1];\\n    let start = 0, end = nums.length - 1, mid;\\n    // First occurrence\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[0] = mid;\\n            end = mid - 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    // Last occurrence\\n    start = 0;\\n    end = nums.length - 1;\\n    while (start <= end) {\\n        mid = Math.floor((start + end) / 2);\\n        if (target == nums[mid]) {\\n            ans[1] = mid;\\n            start = mid + 1;\\n        } else if (target < nums[mid]) {\\n            end = mid - 1;\\n        } else {\\n            start = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437150,
                "title": "best-solution-java-in-runtime-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int[] searchRange(int[] nums, int target) {\\n       int left = 0 ;\\n        int right = nums.length -1;\\n        int output [] = new int[2];\\n            while (left <= right){\\n               if (nums[left] == target){\\n                   output[0] = left;\\n                    while (left < right){\\n                        if (nums[right] == target ){\\n                            output[1] = right;\\n                            return output;\\n                        }else {\\n                            right = right - 1;\\n                        }\\n                    }\\n                    output[1] = left;\\n                   return output;\\n               }else if (nums[left] < target){\\n                   left = left + 1;\\n               }else if (nums[right] > target) {\\n                   right = right - 1;\\n               }\\n\\n            }\\n\\n\\n        return new int[] {-1 , -1};\\n    }\\n}\\n\\n```\\n\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/e2a42d89-c9f8-40a3-a1f5-05931328411d_1681972741.4489026.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] searchRange(int[] nums, int target) {\\n       int left = 0 ;\\n        int right = nums.length -1;\\n        int output [] = new int[2];\\n            while (left <= right){\\n               if (nums[left] == target){\\n                   output[0] = left;\\n                    while (left < right){\\n                        if (nums[right] == target ){\\n                            output[1] = right;\\n                            return output;\\n                        }else {\\n                            right = right - 1;\\n                        }\\n                    }\\n                    output[1] = left;\\n                   return output;\\n               }else if (nums[left] < target){\\n                   left = left + 1;\\n               }else if (nums[right] > target) {\\n                   right = right - 1;\\n               }\\n\\n            }\\n\\n\\n        return new int[] {-1 , -1};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142841,
                "title": "c-with-lower-bound-upper-bound-implementation",
                "content": "While this problem can be solved with 5 lines of C++ code using lower/upper bound STL calls, I thought that in an interview, the interviewer may add additional requirement of implementing those calls. So here it is with the implementation. Note that the STL calls return an interator, in order to keep things simple, I am only returning the index from my implementation.\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(!nums.size()) return {-1,-1};\\n        auto pos = lower_bound(nums, target);\\n        if(nums[pos] != target)\\n            return {-1,-1};\\n        int l = pos;\\n        pos = upper_bound(nums, target);\\n        if(nums[pos] != target)\\n            pos--;\\n        int r = pos;\\n        return {l,r};\\n    }\\n    int lower_bound(vector<int> nums, int target){\\n        int l = 0, r = nums.size()-1, m = 0;\\n        while(l < r) {\\n            m = (l+r)/2;\\n            if(nums[m] < target)\\n                l = m+1;\\n            else \\n                r = m;\\n        }\\n        return r;\\n    }\\n    int upper_bound(vector<int> nums, int target){\\n        int l = 0, r = nums.size()-1, m = 0;\\n        while(l < r) {\\n            m = (l+r)/2;\\n            if(nums[m] <= target)\\n                l = m+1;\\n            else \\n                r = m;\\n        }\\n        return r;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(!nums.size()) return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 14877,
                "title": "easy-to-understand-java-ac-solution",
                "content": "I see some of the answers involving two separate methods for finding first index position and last index position. I just combine them into one method and use boolean to check whether it is the last index that we are looking for. \\n\\n\\n    public int[] searchRange(int[] A, int target) {\\n    \\tint start = findPosition(A, target, false);\\n    \\tint end = findPosition(A, target, true);\\n    \\treturn new int[]{start, end};\\n    }\\n\\n    private int findPosition(int[] A, int target, boolean isLast) {\\n    \\tint low = 0, high = A.length-1, index = -1;\\n    \\twhile (low <= high) {\\n    \\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\tif(isLast){\\n    \\t\\t\\tif (A[mid] <= target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t} else{\\n    \\t\\t\\tif (A[mid] < target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t}\\n    \\t\\tif(A[mid] == target) index = mid; /** update index */\\n    \\t}\\n    \\treturn index;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I see some of the answers involving two separate methods for finding first index position and last index position. I just combine them into one method and use boolean to check whether it is the last index that we are looking for. \\n\\n\\n    public int[] searchRange(int[] A, int target) {\\n    \\tint start = findPosition(A, target, false);\\n    \\tint end = findPosition(A, target, true);\\n    \\treturn new int[]{start, end};\\n    }\\n\\n    private int findPosition(int[] A, int target, boolean isLast) {\\n    \\tint low = 0, high = A.length-1, index = -1;\\n    \\twhile (low <= high) {\\n    \\t\\tint mid = low + ((high - low) >> 1);\\n    \\t\\tif(isLast){\\n    \\t\\t\\tif (A[mid] <= target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t} else{\\n    \\t\\t\\tif (A[mid] < target) low = mid + 1;\\n    \\t\\t\\telse high = mid-1;\\n    \\t\\t}\\n    \\t\\tif(A[mid] == target) index = mid; /** update index */\\n    \\t}\\n    \\treturn index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 236386,
                "title": "python-solution",
                "content": "Time complexity: `O(log n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"            \\n        def search_for(nums, target, left = True):\\n            i = 0\\n            j = len(nums) \\n            while i < j:\\n                mid = (i+j) / 2\\n                if nums[mid] == target:\\n                    if left:\\n                        j = mid \\n                    else:\\n                        i = mid + 1\\n                elif nums[mid] < target:\\n                    i = mid + 1\\n                else:\\n                    j = mid \\n            return i\\n        left = search_for(nums, target, True)\\n        right = search_for(nums, target, False)\\n        if not nums:\\n            return[-1,-1]\\n        elif 0 <= left < len(nums) and nums[left] == target:\\n            return [left, right-1]\\n        else:\\n            return [-1,-1]\\n```\\n\\nA more succinct solution using the built-in methods `bisect_left` and `bisect_right` in the `bisect` module.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: \\'List[int]\\', target: \\'int\\') -> \\'List[int]\\':\\n        if not nums:\\n            return [-1, -1]\\n        left = bisect.bisect_left(nums, target)\\n        if left >= len(nums) or nums[left] != target:\\n            return [-1, -1]\\n        right = bisect.bisect_right(nums, target)\\n        return [left, right-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"            \\n        def search_for(nums, target, left = True):\\n            i = 0\\n            j = len(nums) \\n            while i < j:\\n                mid = (i+j) / 2\\n                if nums[mid] == target:\\n                    if left:\\n                        j = mid \\n                    else:\\n                        i = mid + 1\\n                elif nums[mid] < target:\\n                    i = mid + 1\\n                else:\\n                    j = mid \\n            return i\\n        left = search_for(nums, target, True)\\n        right = search_for(nums, target, False)\\n        if not nums:\\n            return[-1,-1]\\n        elif 0 <= left < len(nums) and nums[left] == target:\\n            return [left, right-1]\\n        else:\\n            return [-1,-1]\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: \\'List[int]\\', target: \\'int\\') -> \\'List[int]\\':\\n        if not nums:\\n            return [-1, -1]\\n        left = bisect.bisect_left(nums, target)\\n        if left >= len(nums) or nums[left] != target:\\n            return [-1, -1]\\n        right = bisect.bisect_right(nums, target)\\n        return [left, right-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14713,
                "title": "search-for-the-position-target-0-5-and-target-0-5-a-simple-python-code-with-a-little-trick",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, arr, target):\\n        start = self.binary_search(arr, target-0.5)\\n        if arr[start] != target:\\n            return [-1, -1]\\n        arr.append(0)\\n        end = self.binary_search(arr, target+0.5)-1\\n        return [start, end]\\n\\n    def binary_search(self, arr, target):\\n        start, end = 0, len(arr)-1\\n        while start < end:\\n            mid = (start+end)//2\\n            if target < arr[mid]:\\n                end = mid\\n            else:\\n                start = mid+1\\n        return start\\n\\nfor search the target+0.5 position we add something whatever to the list end\\n to get the right position for the edge case\\n\\ntake ([0,1,2,3,4,5], 5) for example:\\n\\nwe append 0 to the list end\\n\\n[0,1,2,3,4,5,0]\\n\\n[4,5,0]# start now is 4, end is 6, mid is 5,  start = mid+1 = 6, end the while loop\\n\\nfinally we get the 5.5 position == start == 6",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, arr, target):\\n        start = self.binary_search(arr, target-0.5)\\n        if arr[start] != target:\\n            return [-1, -1]\\n        arr.append(0)\\n        end = self.binary_search(arr, target+0.5)-1\\n        return [start, end]\\n\\n    def binary_search(self, arr, target):\\n        start, end = 0, len(arr)-1\\n        while start < end:\\n            mid = (start+end)//2\\n            if target < arr[mid]:\\n                end = mid\\n            else:\\n                start = mid+1\\n        return start\\n\\nfor search the target+0.5 position we add something whatever to the list end\\n to get the right position for the edge case\\n\\ntake ([0,1,2,3,4,5], 5) for example:\\n\\nwe append 0 to the list end\\n\\n[0,1,2,3,4,5,0]\\n\\n[4,5,0]# start now is 4, end is 6, mid is 5,  start = mid+1 = 6, end the while loop\\n\\nfinally we get the 5.5 position == start == 6",
                "codeTag": "Java"
            },
            {
                "id": 1596093,
                "title": "34-find-first-and-last-position-of-element-in-sorted-array-java-solution",
                "content": "Brute Force Approach:\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = new int[2];\\n        int start = -1;\\n        int end = -1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                if(start == -1){\\n                    start = i; \\n                }\\n                end = i;\\n            }\\n            \\n            if(nums[i]>target){\\n                break;\\n            }\\n        }\\n        \\n        \\n        ans[0] = start;\\n        ans[1] = end;\\n        return ans;\\n    }\\n}\\n```\\nOptimal Approach:\\n```\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tans[0] = findFirst(nums, target, 0, nums.length - 1);\\n\\t\\tans[1] = findLast(nums, target, 0, nums.length - 1);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int findFirst(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n\\n\\tprivate int findLast(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] <= target) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n}\\n```\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans = new int[2];\\n        int start = -1;\\n        int end = -1;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                if(start == -1){\\n                    start = i; \\n                }\\n                end = i;\\n            }\\n            \\n            if(nums[i]>target){\\n                break;\\n            }\\n        }\\n        \\n        \\n        ans[0] = start;\\n        ans[1] = end;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tans[0] = findFirst(nums, target, 0, nums.length - 1);\\n\\t\\tans[1] = findLast(nums, target, 0, nums.length - 1);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int findFirst(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n\\n\\tprivate int findLast(int[] nums, int target, int start, int end) {\\n\\t\\tint position = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n            \\n\\t\\t\\tif (nums[mid] <= target) {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] == target){\\n                position = mid;\\n            }\\n\\t\\t}\\n\\t\\treturn position;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716664,
                "title": "javascript-clean-binary-search-o-logn",
                "content": "```javascript\\nvar searchRange = function(nums, target) {\\n    let low = 0, high = nums.length-1, mid;\\n    \\n    // find the start\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] >= target) high = mid-1;\\n        else low = mid+1;\\n    }\\n    \\n    // if target doesn\\'t exist\\n    if(nums[low] !== target) return [-1, -1];\\n    \\n    const start = low;\\n    \\n    // reset low and high\\n    low = 0, high = nums.length-1;\\n    \\n    // find the end\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] <= target) low = mid+1;\\n        else high = mid-1;\\n    }\\n    return [start, high];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```javascript\\nvar searchRange = function(nums, target) {\\n    let low = 0, high = nums.length-1, mid;\\n    \\n    // find the start\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] >= target) high = mid-1;\\n        else low = mid+1;\\n    }\\n    \\n    // if target doesn\\'t exist\\n    if(nums[low] !== target) return [-1, -1];\\n    \\n    const start = low;\\n    \\n    // reset low and high\\n    low = 0, high = nums.length-1;\\n    \\n    // find the end\\n    while(low <= high) {\\n        mid = Math.floor((low+high)/2);\\n        if(nums[mid] <= target) low = mid+1;\\n        else high = mid-1;\\n    }\\n    return [start, high];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15012,
                "title": "python-easy-solution",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, A, target):\\n\\n        lmost = self.leftsearch(A,target)\\n        rmost = self.rightsearch(A,target)\\n        return[lmost,rmost]\\n                        \\n    def leftsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1#target index\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid - 1\\n            elif A[mid] < tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                r = mid - 1\\n        return tarI\\n\\n        \\n    def rightsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid -1\\n            elif A[mid] <tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                l = mid+1\\n        return tarI",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @param target, an integer to be searched\\n    # @return a list of length 2, [index1, index2]\\n    def searchRange(self, A, target):\\n\\n        lmost = self.leftsearch(A,target)\\n        rmost = self.rightsearch(A,target)\\n        return[lmost,rmost]\\n                        \\n    def leftsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1#target index\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid - 1\\n            elif A[mid] < tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                r = mid - 1\\n        return tarI\\n\\n        \\n    def rightsearch(self,A,tar):\\n        l = 0\\n        r = len(A)-1\\n        tarI = -1\\n        while l <= r:\\n            mid = (l+r)/2\\n            if A[mid] > tar:\\n                r = mid -1\\n            elif A[mid] <tar:\\n                l = mid + 1\\n            else:\\n                tarI = mid\\n                l = mid+1\\n        return tarI",
                "codeTag": "Java"
            },
            {
                "id": 1059224,
                "title": "c-super-cool-easy-undersdanding-solution-o-log-n-faster-than-98-19",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tint left = get_first_element_position(nums, target);\\n\\t\\t\\tint right = get_last_element_position(nums, target);\\n\\t\\t\\treturn left <= right ? vector<int>{left, right} : vector<int>(2, -1);\\n\\t\\t}\\n\\tprivate:\\n\\t\\tint get_first_element_position(vector<int>& nums, int target){\\n\\t\\t\\tint left = 0, right = nums.size() - 1, mid;\\n\\t\\t\\twhile ( left <= right )\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] < target) left = mid + 1;\\n\\t\\t\\t\\telse right = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t\\tint get_last_element_position(vector<int>& nums, int target){\\n\\t\\t\\tint left = 0, right = nums.size() - 1, mid;\\n\\t\\t\\twhile ( left <= right )\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid = (right + left) / 2;\\n\\t\\t\\t\\tif ( nums[mid] <= target ) left = mid + 1;\\n\\t\\t\\t\\telse right = mid - 1;\\n\\t\\t\\t}    \\n\\t\\t\\treturn right;\\n\\t\\t}        \\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tint left = get_first_element_position(nums, target);\\n\\t\\t\\tint right = get_last_element_position(nums, target);\\n\\t\\t\\treturn left <= right ? vector<int>{left, right}",
                "codeTag": "Java"
            },
            {
                "id": 3029684,
                "title": "100-faster-c-binary-search",
                "content": "# Intuition\\nfirst thought came was the linear traversal .we will traverse the vector to find the first and the last position .But vector is sorted so i should take advantage of sorted vector and tried to use binary search.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI have used binary search. At first find any index (let say \\'position1\\')of the target value and then solve separately for finding first position and the last position of  taget value.First position will always lie in left of the \\'postion1\\'.so we will again use binary search for range(0 to position -1).And for last index again we will solve for tha range(position1 , n-1),where n is the size of the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums , int l , int r, int target)\\n{\\n    int ans = -1;\\n    while(r >= l){\\n        int mid = (l+r)/2;\\n        if(nums[mid] == target)\\n        {\\n            return mid;\\n        }else{\\n            if(nums[mid] < target){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // int first , last;\\n        //we can solve it in n-time using linear search \\n        // but we can take advantage of sorted array and we will use \\n        //binary search to solve this problem\\n        int n = nums.size();\\n        //finding any position  of target value \\n        int index = solve(nums , 0 , n-1 , target);\\n        int l =index , r = index;\\n        //now solve separately\\n        while(1){\\n            int left = solve(nums,0,l-1,target);\\n            int right = solve(nums,r+1,n-1,target);\\n            if(left == -1 && right == -1){\\n                break;\\n            }\\n            if(left != -1){\\n                l = left;//updating the index that we get from the left side of the index .\\n            }\\n\\n            if(right  != -1){\\n                r = right;//updating the index that we get from the right side of the index\\n            }\\n        }\\n        return {l , r};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums , int l , int r, int target)\\n{\\n    int ans = -1;\\n    while(r >= l){\\n        int mid = (l+r)/2;\\n        if(nums[mid] == target)\\n        {\\n            return mid;\\n        }else{\\n            if(nums[mid] < target){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // int first , last;\\n        //we can solve it in n-time using linear search \\n        // but we can take advantage of sorted array and we will use \\n        //binary search to solve this problem\\n        int n = nums.size();\\n        //finding any position  of target value \\n        int index = solve(nums , 0 , n-1 , target);\\n        int l =index , r = index;\\n        //now solve separately\\n        while(1){\\n            int left = solve(nums,0,l-1,target);\\n            int right = solve(nums,r+1,n-1,target);\\n            if(left == -1 && right == -1){\\n                break;\\n            }\\n            if(left != -1){\\n                l = left;//updating the index that we get from the left side of the index .\\n            }\\n\\n            if(right  != -1){\\n                r = right;//updating the index that we get from the right side of the index\\n            }\\n        }\\n        return {l , r};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386457,
                "title": "c-solution-with-proper-comments-95-62-faster",
                "content": "**Time complexity - O(log N)**\\n**Space complexity - O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans{-1, -1};\\n    //we have to do two binray search operations \\n        //one for 1st index.\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while( low <= high){\\n            int mid = (low+ high) /2;\\n            if(nums[mid] == target){\\n                ans[0] = mid;\\n                //continue searching in left side of the nums to find 1st index of the given target\\n                high = mid-1;\\n            }else if (nums[mid] < target){\\n                //search in right side of the  nums\\n                 low = mid+1;\\n            }else{\\n                //search in left side of the  nums\\n                high = mid-1;\\n            }\\n        }\\n        //second binary search \\n        //to find the last index of the given target\\n        low = 0;\\n        high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            \\n            if(nums[mid] == target){\\n                ans[1] = mid;\\n                //continue searching in right side as we want the last index\\n                low = mid+1;\\n            }else if(nums[mid] < target){\\n                low =  mid+1;\\n            }else high = mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans{-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1181835,
                "title": "find-first-and-last-position-js-python-java-c-easy-binary-search-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem is very nearly the definition of a **binary search**. A binary search allows us to find the insertion index for a target number in a sorted array. It\\'s called a \"binary\" search because in each step it halves the input array and determines in which half the number belongs. Since a binary search is able to eliminate half the remaining array in each iteration, it can accomplish its objective with a **time complexity** of **O(log N)**.\\n\\nIn this case, however, we don\\'t just want to find out where the target number (**T**) would be placed in the nums array (**N**), we want to additionally find out if **T** _actually_ exists in **N**, as well as the starting and end indexes.\\n\\nThe standard implementation of a binary search will find the left-most index in which **T** could be placed, though many languages have functions for both sides. Rather than having to define two sets of functions here, however, we can, with a little creativity, use a single function to find our answer.\\n\\nFirst, we can perform the standard left binary search (**find**) on **T**. Next, we can easily check to see if **T** exists in **N** already by checking the value stored at the result of that first search (**N[Tleft]**). If we don\\'t find **T** at that index, then **T** does not exist in **N** and we should **return [-1, -1]**.\\n\\nOtherwise, we still need to find the right end of the range of **T** values in **N**. To do this, we can just use **find** again, this time with the next integer (**T + 1**). Since this will find the index _after_ the end of the range of **T** values, we can just move back one position to find the end of the **T** range.\\n\\nNow that we have our range, we can **return** it.\\n\\n - _**Time Complexity: O(log N)** for the binary search_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has built-in binary search functions for both sides: **bisect_left()** and **bisect_right()**.\\n\\nThe built-in function for Java, **Arrays.binarySearch()** does not find the left-most insertion point, so it\\'s easier to define our own binary search function.\\n\\nC++ can use the built-in function **equal_range()**, which returns iterator pointers to the range of T values.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n\\n##### ***w/ bisect_left() & bisect_right():***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\\n##### ***w/ Custom Binary Search:***\\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ equal_range():***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\\n##### ***w/ Custom Binary Search:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar searchRange = function(N, T) {\\n    const find = (target, arr, left=0, right=arr.length) => {\\n        while (left <= right) {\\n            let mid = left + right >> 1\\n            if (arr[mid] < target) left = mid + 1\\n            else right = mid - 1\\n        }\\n        return left\\n    } \\n    let Tleft = find(T, N)\\n    if (N[Tleft] !== T) return [-1,-1]\\n    return [Tleft, find(T+1, N, Tleft) - 1]\\n};\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        Tleft = bisect_left(N, T)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, bisect_right(N, T) - 1]\\n```\n```python\\nclass Solution:\\n    def searchRange(self, N: List[int], T: int) -> List[int]:\\n        def find(target, arr, left=0):\\n            right = len(arr) - 1\\n            while left <= right:\\n                mid = left + right >> 1\\n                if arr[mid] < target: left = mid + 1\\n                else: right = mid - 1\\n            return left\\n        Tleft = find(T, N)\\n        if Tleft == len(N) or N[Tleft] != T: return [-1, -1]\\n        return [Tleft, find(T+1, N, Tleft) - 1]\\n```\n```java\\nclass Solution {\\n    public int[] searchRange(int[] N, int T) {\\n        int Tleft = find(T, N, 0);\\n        if (Tleft == N.length || N[Tleft] != T) return new int[] {-1, -1};\\n        return new int[] {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    public int find(int target, int[] arr, int left) {\\n        int right = arr.length - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        pair<vector<int>::iterator,vector<int>::iterator> range;\\n        range = equal_range(N.begin(), N.end(), T);\\n        int Tleft = distance(N.begin(), range.first);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, (int)distance(N.begin(), range.second) - 1};\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& N, int T) {\\n        int Tleft = find(T, N);\\n        if (Tleft == N.size() || N[Tleft] != T) return {-1, -1};\\n        return {Tleft, find(T+1, N, Tleft) - 1};\\n    }\\n    int find(int target, vector<int> arr, int left=0) {\\n        int right = arr.size() - 1;\\n        while (left <= right) {\\n            int mid = left + right >> 1;\\n            if (arr[mid] < target) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495416,
                "title": "java-100-faster-solution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/330c50ec-0973-4531-9790-af5b88e11668_1683436609.7289596.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int[] result = new int[2];\\n        result[0] = searchFirst(nums, target);\\n        result[1] = searchLast(nums, target);\\n\\n        return result;\\n    }\\n\\n    // binary search to find the first occurrence of the target\\n    private int searchFirst(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the first occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the first occurrence\\n                right = mid - 1; // search in the left half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    // binary search to find the last occurrence of the target\\n    private int searchLast(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the last occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the last occurrence\\n                left = mid + 1; // search in the right half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int[] result = new int[2];\\n        result[0] = searchFirst(nums, target);\\n        result[1] = searchLast(nums, target);\\n\\n        return result;\\n    }\\n\\n    // binary search to find the first occurrence of the target\\n    private int searchFirst(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the first occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the first occurrence\\n                right = mid - 1; // search in the left half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    // binary search to find the last occurrence of the target\\n    private int searchLast(int[] nums, int target){\\n        int left = 0; // left index\\n        int right = nums.length - 1; // right index\\n        int index = -1; // index of the last occurrence\\n\\n        while(left <= right){\\n\\n            int mid = left + (right - left) / 2; // calculate the mid index\\n\\n            if(nums[mid] == target){\\n                index = mid; // update index of the last occurrence\\n                left = mid + 1; // search in the right half\\n            }\\n\\n            else if(nums[mid] < target){\\n                left = mid + 1; // search in the right half\\n            }\\n            else{\\n                right = mid - 1; // search in the left half\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330070,
                "title": "c-solution-binary-search-o-log-n-time",
                "content": "if you solve this problem using STL (upper_bound , lower_bound) then traversal may take O(n) time. to make it time efficient we use binary search with writing some extra line of code like when we find the target  , we instantly not return the mid , we search it\\'s left and right occurances to find the first and last occurance of target.\\n```\\nclass Solution {\\n    //find the first position of target.....\\n    int first_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;  \\n            if(nums[mid] == target)\\n            { \\n                result = mid;  //if we find the target at mid position then we store the mid in result variable.\\n                end = mid - 1;  //and continue to find the first occurance in the left of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n    \\n    //find the last position of target.....\\n    int last_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end) \\n        {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target)\\n            {\\n                result = mid;   //if we find the target at mid position then we store the mid in result variable.\\n                start = mid + 1;    //and continue to find the last occurance in the right of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] >= target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0 , end = n - 1;\\n        vector<int>ans(2);\\n        ans[0] = first_pos(start , end , nums , target);\\n        ans[1] = last_pos(start , end , nums , target);\\n        return ans;\\n    }\\n};\\n```\\ni hope you like this solution and upvote it.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //find the first position of target.....\\n    int first_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;  \\n            if(nums[mid] == target)\\n            { \\n                result = mid;  //if we find the target at mid position then we store the mid in result variable.\\n                end = mid - 1;  //and continue to find the first occurance in the left of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n    \\n    //find the last position of target.....\\n    int last_pos(int start , int end , vector<int>& nums , int target)\\n    {\\n        int result = -1;    // make a variable to stroe the index of first occurance.\\n        while(start <= end) \\n        {\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target)\\n            {\\n                result = mid;   //if we find the target at mid position then we store the mid in result variable.\\n                start = mid + 1;    //and continue to find the last occurance in the right of mid and if we find we update the result.\\n            }\\n            else if(nums[mid] >= target)\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int start = 0 , end = n - 1;\\n        vector<int>ans(2);\\n        ans[0] = first_pos(start , end , nums , target);\\n        ans[1] = last_pos(start , end , nums , target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718714,
                "title": "3-lines-c-o-logn-solution",
                "content": "```\\nvector<int> searchRange(vector<int>& nums, int tar) {\\n\\tif(binary_search(nums.begin(),nums.end(),tar)==false)return {-1,-1};\\n    int lb = lower_bound(nums.begin(), nums.end(), tar) - nums.begin(), ub = upper_bound(nums.begin(),nums.end(),tar)-nums.begin()-1;\\n    return {lb, ub};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int tar) {\\n\\tif(binary_search(nums.begin(),nums.end(),tar)==false)return {-1,-1};\\n    int lb = lower_bound(nums.begin(), nums.end(), tar) - nums.begin(), ub = upper_bound(nums.begin(),nums.end(),tar)-nums.begin()-1;\\n    return {lb, ub};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 681690,
                "title": "iterative-java-binary-search-solution-faster-than-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 42.8 MB, less than 49.61% of Java online submissions for Find First and Last Position of Element in Sorted Array.\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=findSidx(nums,target);\\n        res[1]=findEidx(nums,target);\\n        return res;\\n    }\\n    public int findSidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int findEidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>=nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=findSidx(nums,target);\\n        res[1]=findEidx(nums,target);\\n        return res;\\n    }\\n    public int findSidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int findEidx(int[] nums,int target){\\n        int left=0;\\n        int right=nums.length-1;\\n        int idx=-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums[mid]==target)idx=mid;\\n            if(target>=nums[mid]){\\n                left=mid+1;\\n            }\\n            else{\\n                right=mid-1;\\n            }\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14706,
                "title": "beats-100-python-submission",
                "content": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        n = len(nums)\\n        left, right = -1, -1\\n        l, r = 0, n-1\\n        while l < r:\\n            m = (l+r)/2\\n            if nums[m] < target: l = m+1\\n            else: r = m\\n        if nums[l] != target: return -1, -1\\n        left = l\\n        l, r = left, n-1\\n        while l < r:\\n            m = (l+r)/2+1\\n            if nums[m] == target: l = m\\n            else: r = m-1\\n        right = l\\n        return left, right\\n```\\n![0_1473134524961_Screen Shot 2016-09-05 at 11.58.29 PM.png](/uploads/files/1473134525895-screen-shot-2016-09-05-at-11.58.29-pm.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        n = len(nums)\\n        left, right = -1, -1\\n        l, r = 0, n-1\\n        while l < r:\\n            m = (l+r)/2\\n            if nums[m] < target: l = m+1\\n            else: r = m\\n        if nums[l] != target: return -1, -1\\n        left = l\\n        l, r = left, n-1\\n        while l < r:\\n            m = (l+r)/2+1\\n            if nums[m] == target: l = m\\n            else: r = m-1\\n        right = l\\n        return left, right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329232,
                "title": "c-0ms-binary-search",
                "content": "**Time Complexity :- O(Log(n))\\nSpace Complexity :- O(1)**\\n\\n1. \\tFor the first occurrence: Binary search till the element is found. When the element is found, Go to its left side.       Because there could be a duplicate element whose first occurrence will be on its left side.\\n2. \\tFor the last occurrence: Binary search till the element is found.When the element is found, Go to its right side.           Because there could be a duplicate element whose last occurrence will be on its right side.\\n\\nclass Solution {\\npublic:\\n\\n    int getIndex(vector<int>& nums, int target, bool getFirst){\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ans = -1;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            if(nums[mid] == target){\\n                ans = mid;           // storing answer then start searching again \\n                if(getFirst)  e = mid - 1;     // we have to go left side for first position\\n                else\\ts = mid + 1;   //   we have to go right side for last positon                   \\n\\t\\t    }\\n\\t\\t\\telse if(nums[mid] > target) e = mid - 1;\\n            else   s= mid + 1;\\n        }\\n        return ans;   \\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>  v(2 , -1);\\n        \\n        int first = getIndex(nums, target, true);\\n        if(first == -1)  return v;\\n        int last = getIndex(nums, target, false);\\n        v[0] = first;\\n        v[1] = last;\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int getIndex(vector<int>& nums, int target, bool getFirst){\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int ans = -1;\\n        while(s<=e) {\\n            int mid = s + (e-s)/2;\\n            if(nums[mid] == target){\\n                ans = mid;           // storing answer then start searching again \\n                if(getFirst)  e = mid - 1;     // we have to go left side for first position\\n                else\\ts = mid + 1;   //   we have to go right side for last positon                   \\n\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 2329216,
                "title": "daily-leetcoding-challenge-july-day-25",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1667541,
                "title": "java-0ms-100-faster-o-log-n",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length-1;\\n        while(l <= r){\\n            int mid = (l+r)/2;            \\n            if(nums[mid] == target){\\n                if(nums[l] == target && nums[r] == target){\\n                    return new int[]{l,r};\\n                }\\n                if(nums[l] < target){\\n                    l++;\\n                }\\n                if(nums[r] > target){\\n                    r--;\\n                }\\n            } else if(target < nums[mid]){\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return new int[]{-1,-1};   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int l = 0;\\n        int r = nums.length-1;\\n        while(l <= r){\\n            int mid = (l+r)/2;            \\n            if(nums[mid] == target){\\n                if(nums[l] == target && nums[r] == target){\\n                    return new int[]{l,r};\\n                }\\n                if(nums[l] < target){\\n                    l++;\\n                }\\n                if(nums[r] > target){\\n                    r--;\\n                }\\n            } else if(target < nums[mid]){\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        return new int[]{-1,-1};   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855788,
                "title": "most-optimal-solution-using-plain-binary-search-with-few-tweaks-c-and-java-code",
                "content": "\\n\\n# Approach\\nThe first function finds the first occurrence of the target key in the array. It uses a modified binary search, where it updates the ans variable whenever it finds the target and then continues searching in the left half of the array to find the first occurrence.\\n\\nThe last function finds the last occurrence of the target key in the array. Similar to the first function, it uses a modified binary search to update the ans variable whenever it finds the target and then continues searching in the right half of the array to find the last occurrence.\\n\\nFinally, the searchRange function returns a vector containing the results of the first and last functions, representing the range of occurrences of the target key in the sorted array. If the target is not found, the ans variable remains -1, and the function returns {-1, -1} indicating that the target is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n2*O(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int first(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    int last(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {first(nums,target), last(nums,target)};\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int first(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int last(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        return new int[]{first(nums, target), last(nums, target)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int first(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    int last(vector<int>& nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.size()-1;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[mid] == target) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else if(nums[mid]<target) low = mid+1;\\n            else high = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        return {first(nums,target), last(nums,target)};\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int first(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int last(int[] nums, int target) {\\n        int ans = -1;\\n        int low = 0, high = nums.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else if (nums[mid] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        return new int[]{first(nums, target), last(nums, target)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311417,
                "title": "100-easiest-and-systematic-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be optimally solved using Binary Search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is quite easy to understand. The solution that employs Binary Search to solve this particular problem uses the concept of Binary Search ***twice*** - 1st to get the starting index and 2nd to search the ending index.\\n\\n# Complexity\\n- Time complexity: `O(log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int start = -1, end = -1;\\n\\n        // Searching the start index of target\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < target){ low = mid+1; }\\n            else if(nums[mid] > target){ high = mid-1; }\\n            else{   // nums[mid] == target\\n                start = mid;\\n                high = mid-1;\\n            }\\n        }\\n        \\n        // Searching the end index of target\\n        if(start!=-1){\\n            low = 0, high = nums.size()-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid] < target){ low = mid+1; }\\n                else if(nums[mid] > target){ high = mid-1; }\\n                else{   // nums[mid] == target\\n                    end = mid;\\n                    low = mid+1;\\n                }\\n            }\\n        }\\n\\n        return {start, end};\\n    }\\n\\n    // Author - Mufaddal Saifuddin\\n};\\n```\\n# Request\\n\\nPlease upvote my solution if you liked it.\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size()-1;\\n        int start = -1, end = -1;\\n\\n        // Searching the start index of target\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < target){ low = mid+1; }\\n            else if(nums[mid] > target){ high = mid-1; }\\n            else{   // nums[mid] == target\\n                start = mid;\\n                high = mid-1;\\n            }\\n        }\\n        \\n        // Searching the end index of target\\n        if(start!=-1){\\n            low = 0, high = nums.size()-1;\\n            while(low<=high){\\n                int mid = low + (high-low)/2;\\n                if(nums[mid] < target){ low = mid+1; }\\n                else if(nums[mid] > target){ high = mid-1; }\\n                else{   // nums[mid] == target\\n                    end = mid;\\n                    low = mid+1;\\n                }\\n            }\\n        }\\n\\n        return {start, end};\\n    }\\n\\n    // Author - Mufaddal Saifuddin\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163324,
                "title": "best-and-simplest-c-solution-using-only-while-loop-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1; \\n        vector<int>v(2,-1);\\n        //for initial index\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==0 || nums[m]!=nums[m-1]) {v[0]=m; break;}\\n            else r=m-1;\\n            }\\n        }\\n        // for ending index\\n        l=0;r=n-1;\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==n-1 || nums[m]!=nums[m+1]) {v[1]=m; break;}\\n            else l=m+1;\\n            }\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size(),l=0,r=n-1; \\n        vector<int>v(2,-1);\\n        //for initial index\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==0 || nums[m]!=nums[m-1]) {v[0]=m; break;}\\n            else r=m-1;\\n            }\\n        }\\n        // for ending index\\n        l=0;r=n-1;\\n        while(l<=r){\\n            int m=(r+l)/2;\\n            if (nums[m]<target) l=m+1;\\n            else if(nums[m]>target) r=m-1;\\n            else {\\n            if(m==n-1 || nums[m]!=nums[m+1]) {v[1]=m; break;}\\n            else l=m+1;\\n            }\\n        }\\n        return v;\\n\\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004815,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n     int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n    public int findFirst(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                high=mid-1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n      public int findLast(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                low=mid+1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n     int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n    public int findFirst(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                high=mid-1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index;\\n    }\\n      public int findLast(int[] arr,int target){\\n        int index=-1;\\n        int low=0;\\n        int high=arr.length-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]==target){\\n                index=mid;\\n                low=mid+1;\\n            }   \\n            else if(arr[mid]>target)\\n                high=mid-1;\\n             else\\n                low=mid+1;\\n        }\\n        return index; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15046,
                "title": "readable-c-11-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> searchRange(int A[], int n, int target) {\\n            vector<int> ans(2);\\n            ans[0] = lowerBound(A, A + n, target) - A;\\n            ans[1] = upperBound(A, A + n, target) - A - 1;\\n            if (ans[0] > ans[1]) {\\n                ans[0] = ans[1] = -1;\\n            }\\n            return ans;\\n        }\\n        \\n        int *lowerBound(int *a, int *b, int target)\\n        {\\n            return binarySearch(a, b, target, [](int a, int b) { return a < b; });\\n        }\\n        \\n        int *upperBound(int *a, int *b, int target)\\n        {\\n            return binarySearch(a, b, target, [](int a, int b) { return a <= b; });\\n        }\\n        \\n        int *binarySearch(int *a ,int *b, int target, function<bool(int, int) > cmp)\\n        {\\n            int l = 0, r = b - a;\\n            while (l < r) { \\n                int mid = l + ((r - l) >> 1);\\n                if (cmp(a[mid], target)) {\\n                    l = mid + 1;\\n                } else {\\n                    r = mid;\\n                }\\n            }\\n            return a + l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> searchRange(int A[], int n, int target) {\\n            vector<int> ans(2);\\n            ans[0] = lowerBound(A, A + n, target) - A;\\n            ans[1] = upperBound(A, A + n, target) - A - 1;\\n            if (ans[0] > ans[1]) {\\n                ans[0] = ans[1] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4015304,
                "title": "fast-c-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nInitialize two variables, first and last, to store the indices of the first and last occurrences of the target element. Initially, set them to -1, indicating that no occurrences have been found yet.\\n\\nUse binary search to find the first occurrence of the target element:\\n\\nInitialize left to 0 and right to nums.size() - 1.\\nWhile left is less than or equal to right, do the following:\\nCalculate the middle index mid as (left + right) / 2.\\nIf nums[mid] is equal to the target element, update first to mid and search in the left half by setting right = mid - 1.\\nIf nums[mid] is less than the target element, set left = mid + 1.\\nIf nums[mid] is greater than the target element, set right = mid - 1.\\nUse binary search to find the last occurrence of the target element:\\n\\nReset left to 0 and right to nums.size() - 1.\\nWhile left is less than or equal to right, do the following:\\nCalculate the middle index mid as (left + right) / 2.\\nIf nums[mid] is equal to the target element, update last to mid and search in the right half by setting left = mid + 1.\\nIf nums[mid] is less than the target element, set left = mid + 1.\\nIf nums[mid] is greater than the target element, set right = mid - 1.\\nAfter both binary searches are complete, first and last will hold the indices of the first and last occurrences of the target element, respectively.\\n\\nReturn the pair [first, last] as the result.\\n\\nThis approach ensures that you efficiently find the first and last occurrences of the target element in the sorted array using binary search.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(log n) EVEN IN WORST TIME \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result = {-1, -1};\\n\\n        // Find the first occurrence of target\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[0] = mid;\\n                right = mid - 1;  // Continue searching on the left side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        // Find the last occurrence of target\\n        left = 0;\\n        right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[1] = mid;\\n                left = mid + 1;   // Continue searching on the right side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result = {-1, -1};\\n\\n        // Find the first occurrence of target\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[0] = mid;\\n                right = mid - 1;  // Continue searching on the left side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        // Find the last occurrence of target\\n        left = 0;\\n        right = nums.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) {\\n                result[1] = mid;\\n                left = mid + 1;   // Continue searching on the right side\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329548,
                "title": "java-easy-solution-100-faster-code",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int start=0,end=nums.length-1,fi=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                fi=mid;\\n                end=mid-1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        start=0;end=nums.length-1;\\n        int ei=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           if(nums[mid]==target){\\n                ei=mid;\\n                start=mid+1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return new int[]{fi,ei};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int start=0,end=nums.length-1,fi=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(nums[mid]==target){\\n                fi=mid;\\n                end=mid-1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        start=0;end=nums.length-1;\\n        int ei=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n           if(nums[mid]==target){\\n                ei=mid;\\n                start=mid+1;\\n            }\\n            else if(nums[mid]>target){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return new int[]{fi,ei};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020403,
                "title": "binary-search-lower-bound-upper-bound-c-stl",
                "content": "**Lower_bound returns an iterator pointing to the 1st element which is greater than equal to the given number (say x)\\nUpper_bound returns an iterator pointing to the 1st element which is just greater than the given number (say x)**\\n\\n**to convert the iterator to index we subtract 1st iterator from them\\n(for vector we do minus vector_name.begin() and for array we do minus array_name)**\\n\\n**example ->\\nvector v1{5, 7, 7, 8, 8, 10};\\ngiven number x=7**\\n\\n**lowerbound - v1.begin() will return 1 (1st elemnt which is not less then 7 which is 7 it self) --> v1[1] = 7\\nupperbound - v1.begin() while return 3 (1st element which is just greater then 7 which is 8) --> v1[3] = 8\\nthats why we did upperbound - v1.begin() - 1 (to get last index of given number) --> v1[2] = 7\\nanswer for the example will be {1,2}**\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(!binary_search(nums.begin(),nums.end(),target))    return {-1,-1};       // If target is not present in the array\\n        \\n        int rock = low - nums.begin();\\n        int lee = up - nums.begin()-1;\\n        \\n        return {rock,lee};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto low = lower_bound(nums.begin(),nums.end(),target);\\n        auto up = upper_bound(nums.begin(),nums.end(),target);\\n        \\n        if(!binary_search(nums.begin(),nums.end(),target))    return {-1,-1};       // If target is not present in the array\\n        \\n        int rock = low - nums.begin();\\n        int lee = up - nums.begin()-1;\\n        \\n        return {rock,lee};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905772,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\\n        var index = -1\\n        var lower = 0\\n        var upper = nums.count - 1\\n        var mid = (lower + upper) / 2\\n\\n        while upper >= lower {\\n            if nums[mid] == target { index = mid; break }\\n            if mid == lower {\\n                if nums[upper] == target { index = upper }\\n                break\\n            }\\n            if nums[mid] > target {\\n                upper = mid\\n            } else {\\n                lower = mid\\n            }\\n            mid = (lower + upper) / 2\\n        }\\n        \\n        if index == -1 {\\n            return [-1, -1]\\n        } else {\\n            var i = index\\n            var j = index\\n            while i > 0 {\\n                if nums[i] == nums[i-1] { i -= 1 } else { break }\\n            }\\n            while j < nums.count - 1 {\\n                if nums[j] == nums[j+1] { j += 1 } else { break }\\n            }\\n            return [i, j]\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func searchRange(_ nums: [Int], _ target: Int) -> [Int] {\\n        var index = -1\\n        var lower = 0\\n        var upper = nums.count - 1\\n        var mid = (lower + upper) / 2\\n\\n        while upper >= lower {\\n            if nums[mid] == target { index = mid; break }\\n            if mid == lower {\\n                if nums[upper] == target { index = upper }\\n                break\\n            }\\n            if nums[mid] > target {\\n                upper = mid\\n            } else {\\n                lower = mid\\n            }\\n            mid = (lower + upper) / 2\\n        }\\n        \\n        if index == -1 {\\n            return [-1, -1]\\n        } else {\\n            var i = index\\n            var j = index\\n            while i > 0 {\\n                if nums[i] == nums[i-1] { i -= 1 } else { break }\\n            }\\n            while j < nums.count - 1 {\\n                if nums[j] == nums[j+1] { j += 1 } else { break }\\n            }\\n            return [i, j]\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687573,
                "title": "c-using-lower-bound-and-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {      \\n        auto lb = lower_bound(nums.begin(), nums.end(), target);\\n        // checks if the lower bound of target in vector is the target itself otherwise target does not exist in vector\\n        if(lb-nums.begin() == nums.size() || *lb != target)    return {-1, -1};\\n        \\n        auto ub = upper_bound(nums.begin(), nums.end(), target);\\n        int l = lb-nums.begin(), r = (ub-1)-nums.begin();\\n        return {l, r};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {      \\n        auto lb = lower_bound(nums.begin(), nums.end(), target);\\n        // checks if the lower bound of target in vector is the target itself otherwise target does not exist in vector\\n        if(lb-nums.begin() == nums.size() || *lb != target)    return {-1, -1};\\n        \\n        auto ub = upper_bound(nums.begin(), nums.end(), target);\\n        int l = lb-nums.begin(), r = (ub-1)-nums.begin();\\n        return {l, r};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345172,
                "title": "c-binary-search-o-log-n",
                "content": "Binary search is evaluated agains a predicate for which the given array has this results\\n```\\n  5     7     7    8     8    10\\nfalse false false true true true\\n```\\nand we are looking for the first true in order to find first occurrence.\\n\\nFor finding the last occurrence then the evaluated predicate will give this \\n```\\n 5    7     7    8    8    10\\ntrue true true true true false\\n```\\nAnd we are looking for the last true element.\\n\\n\\n```\\nclass Solution {\\npublic:\\n  \\n    int first_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n    \\n    int last_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l + 1) / 2;\\n            if(nums[mid] <= target)\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n  \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res = {-1, -1};\\n        if(nums.empty())\\n            return res;\\n        res[0] = first_occurrence(nums, target);\\n        res[1] = last_occurrence(nums, target);            \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n  5     7     7    8     8    10\\nfalse false false true true true\\n```\n```\\n 5    7     7    8    8    10\\ntrue true true true true false\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int first_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l) / 2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n    \\n    int last_occurrence(vector<int>& nums, int target) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = l + (r - l + 1) / 2;\\n            if(nums[mid] <= target)\\n                l = mid;\\n            else\\n                r = mid - 1;\\n        }\\n        if(nums[l] != target)\\n            return -1;\\n        return l;\\n    }\\n  \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res = {-1, -1};\\n        if(nums.empty())\\n            return res;\\n        res[0] = first_occurrence(nums, target);\\n        res[1] = last_occurrence(nums, target);            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130083,
                "title": "python-solutions-from-11-lines-o-n-to-8-lines-o-logn-to-2-lines-o-logn",
                "content": "* 11 lines O(N) \\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                l = r = mid\\n                while l > 0 and nums[l - 1] == nums[l]: l -= 1\\n                while r + 1 < n and nums[r + 1] == nums[r]: r += 1\\n                return [l, r]\\n        return [-1, -1]\\n```\\n* 8 lines O(logN)\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [l + bisect.bisect_left(nums[l:mid + 1], target), mid + bisect.bisect_right(nums[mid:r + 1], target) - 1]\\n        return [-1, -1]\\n```\\n* 2 lines O(logN)\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target) - 1\\n        return [l, r] if 0 <= l <= r else [-1, -1]\\n```\\n* Bonus for those not to mess with bisect module\\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        def searchleft(l, r):\\n            while l < r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: r = mid\\n                else: l = mid + 1\\n            return l\\n        def searchright(l, r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: l = mid + 1\\n                else: r = mid - 1\\n            return r\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [searchleft(l, mid), searchright(mid, r)]\\n        return [-1, -1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                l = r = mid\\n                while l > 0 and nums[l - 1] == nums[l]: l -= 1\\n                while r + 1 < n and nums[r + 1] == nums[r]: r += 1\\n                return [l, r]\\n        return [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [l + bisect.bisect_left(nums[l:mid + 1], target), mid + bisect.bisect_right(nums[mid:r + 1], target) - 1]\\n        return [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        l, r = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target) - 1\\n        return [l, r] if 0 <= l <= r else [-1, -1]\\n```\n```\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        def searchleft(l, r):\\n            while l < r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: r = mid\\n                else: l = mid + 1\\n            return l\\n        def searchright(l, r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                if nums[mid] == target: l = mid + 1\\n                else: r = mid - 1\\n            return r\\n        l, r, n = 0, len(nums) - 1, len(nums)\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] > target: r = mid - 1\\n            elif nums[mid] < target: l = mid + 1\\n            else:\\n                return [searchleft(l, mid), searchright(mid, r)]\\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777981,
                "title": "easy-cpp-soln-using-upper-and-lower-bound",
                "content": "# please upvote if u like the solution \\n<!-- -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int index=(upper_bound(nums.begin(),nums.end(),target)-nums.begin());\\n        int index1=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        vector<int> ans;\\n        ans.push_back(index1);\\n       \\n       if(index1!=index){\\n           ans.push_back(index-1);\\n           return ans;\\n\\n       }\\n       else return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int index=(upper_bound(nums.begin(),nums.end(),target)-nums.begin());\\n        int index1=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        vector<int> ans;\\n        ans.push_back(index1);\\n       \\n       if(index1!=index){\\n           ans.push_back(index-1);\\n           return ans;\\n\\n       }\\n       else return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773851,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\nVideo link for question:\\nhttps://youtu.be/4nVAqaM-j1Q\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0){\\n            return {-1,-1};\\n        }\\n        int l1=0;\\n        int r1= nums.size()-1;\\n        while(l1<r1){\\n            int m1= l1+ (r1-l1)/2;\\n            if(nums[m1]>=target){\\n                r1=m1;\\n            }\\n            else{\\n                l1=m1+1;\\n            }\\n        }\\n\\n        int l2=0;\\n        int r2= nums.size();\\n        while(l2<r2){\\n            int m2= l2+ (r2-l2)/2;\\n            if(nums[m2]>target){\\n                r2=m2;\\n            }\\n            else{\\n                l2=m2+1;\\n            }\\n        }\\n\\n        if(nums[l1]!=target){\\n            return {-1,-1};\\n        }\\n        if(l1==l2){\\n            return{l1,l2};\\n        }\\n        return {l1, l2-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0){\\n            return {-1,-1};\\n        }\\n        int l1=0;\\n        int r1= nums.size()-1;\\n        while(l1<r1){\\n            int m1= l1+ (r1-l1)/2;\\n            if(nums[m1]>=target){\\n                r1=m1;\\n            }\\n            else{\\n                l1=m1+1;\\n            }\\n        }\\n\\n        int l2=0;\\n        int r2= nums.size();\\n        while(l2<r2){\\n            int m2= l2+ (r2-l2)/2;\\n            if(nums[m2]>target){\\n                r2=m2;\\n            }\\n            else{\\n                l2=m2+1;\\n            }\\n        }\\n\\n        if(nums[l1]!=target){\\n            return {-1,-1};\\n        }\\n        if(l1==l2){\\n            return{l1,l2};\\n        }\\n        return {l1, l2-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261378,
                "title": "java-0ms-faster-than-100-beginner-friendly-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n      int[] ans = {-1,-1};\\n      int s = search(nums,target,true);\\n      int e = search(nums,target,false);\\n      ans[0] = s;\\n      ans[1] = e;\\n      return ans;\\n        \\n    }\\n    public int search(int[] nums , int target , boolean FindFirst){\\n        int s = 0;\\n        int e = nums.length-1;\\n        int ans = -1;\\n        while(s<=e){\\n        int mid = s+(e-s)/2;\\n        if(nums[mid] < target) s = mid +1;\\n        else if(nums[mid] > target) e = mid - 1;\\n        else {\\n            ans = mid;\\n            if(FindFirst==true) e = mid -1;\\n            else s = mid+1;  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n      int[] ans = {-1,-1};\\n      int s = search(nums,target,true);\\n      int e = search(nums,target,false);\\n      ans[0] = s;\\n      ans[1] = e;\\n      return ans;\\n        \\n    }\\n    public int search(int[] nums , int target , boolean FindFirst){\\n        int s = 0;\\n        int e = nums.length-1;\\n        int ans = -1;\\n        while(s<=e){\\n        int mid = s+(e-s)/2;\\n        if(nums[mid] < target) s = mid +1;\\n        else if(nums[mid] > target) e = mid - 1;\\n        else {\\n            ans = mid;\\n            if(FindFirst==true) e = mid -1;\\n            else s = mid+1;  \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098259,
                "title": "c-easy-solution-binary-search",
                "content": "# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                h=mid-1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    int fs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                l=mid+1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int k=bs(nums,nums.size(),target);\\n        int n=fs(nums,nums.size(),target);\\n        return {k,n};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                h=mid-1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    int fs(vector<int>& arr, int n, int k) {\\n        int l=0,h=n-1;\\n        int res=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(arr[mid]==k){\\n                res=mid;\\n                l=mid+1;\\n            } \\n            else if(arr[mid]<k){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int k=bs(nums,nums.size(),target);\\n        int n=fs(nums,nums.size(),target);\\n        return {k,n};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063513,
                "title": "best-java-solution-binary-search-approach-0-ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sorted Array So Apply Binary Search\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n\\n    public int findFirst(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n            int mid=Start+(End-Start)/2;\\n            \\n            if(arr[mid]<target) {\\n                Start=mid+1;\\n            }   \\n            else if(arr[mid]>target) {\\n                End=mid-1;\\n            }\\n            else {\\n                index=mid;\\n                End=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    public int findLast(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n        int mid=Start+(End-Start)/2;\\n\\n        if(arr[mid]<target) {\\n            Start=mid+1;\\n        }   \\n        else if(arr[mid]>target) {\\n            End=mid-1;\\n        } \\n        else {\\n            index=mid;\\n            Start=mid+1;\\n        }\\n    }\\n    return index; \\n  }\\n}\\n```\\n\\n# Complexity\\n- Time complexity : O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr=new int[2];\\n        arr[0]=findFirst(nums,target);\\n        arr[1]=findLast(nums,target);\\n        return arr;\\n    }\\n\\n    public int findFirst(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n            int mid=Start+(End-Start)/2;\\n            \\n            if(arr[mid]<target) {\\n                Start=mid+1;\\n            }   \\n            else if(arr[mid]>target) {\\n                End=mid-1;\\n            }\\n            else {\\n                index=mid;\\n                End=mid-1;\\n            }\\n        }\\n        return index;\\n    }\\n\\n    public int findLast(int[] arr,int target){\\n        int Start=0;\\n        int End=arr.length-1;\\n\\n        int index=-1;\\n\\n        while(Start<=End) {\\n\\n        int mid=Start+(End-Start)/2;\\n\\n        if(arr[mid]<target) {\\n            Start=mid+1;\\n        }   \\n        else if(arr[mid]>target) {\\n            End=mid-1;\\n        } \\n        else {\\n            index=mid;\\n            Start=mid+1;\\n        }\\n    }\\n    return index; \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821321,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]: # nums = [5,7,7,8,8,8,8,10], target = 8\\n        unique = sorted(tuple(set(nums))) # [5, 7, 8, 10]\\n        if target not in unique:\\n            return [-1,-1]\\n        first = nums.index(target) # 3\\n        target_index = unique.index(target) # 2 \\n        if target_index == len(unique)-1:\\n            return [first,len(nums)-1]\\n        last = nums.index(unique[target_index+1]) # 7\\n        return [first,last-1] # [3,6]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]: # nums = [5,7,7,8,8,8,8,10], target = 8\\n        unique = sorted(tuple(set(nums))) # [5, 7, 8, 10]\\n        if target not in unique:\\n            return [-1,-1]\\n        first = nums.index(target) # 3\\n        target_index = unique.index(target) # 2 \\n        if target_index == len(unique)-1:\\n            return [first,len(nums)-1]\\n        last = nums.index(unique[target_index+1]) # 7\\n        return [first,last-1] # [3,6]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790269,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int start=bs(nums,target,true);\\n        int end=bs(nums,target,false);\\n        int ans[]={start,end};\\n        \\n        return ans;\\n    }\\n    \\n    private int bs(int[] nums,int target,boolean firstIndex)\\n    {\\n        int ans=-1;\\n        int lo=0,hi=nums.length-1;\\n        \\n        while(lo<=hi)\\n        {\\n            int mid=lo+(hi-lo)/2;\\n            \\n            if(nums[mid]>target)\\n            {\\n                hi=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                lo=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(firstIndex)\\n                    hi=mid-1;\\n                else\\n                    lo=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n\\n        int start=bs(nums,target,true);\\n        int end=bs(nums,target,false);\\n        int ans[]={start,end}",
                "codeTag": "Java"
            },
            {
                "id": 2767072,
                "title": "simplest-java-code",
                "content": "# Intuition\\n## <!-- Describe your first thoughts on how to solve this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Using binary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  Better than **100%**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> Better than 27.59%\\n\\n# Code\\n```\\nclass Solution{\\npublic int[] searchRange(int[] nums, int target) {\\n    int l = binarySearch(nums, target);\\n    // target does not exist. No need to look for the last position.\\n    if (l == nums.length || nums[l] != target) return new int[] { -1, -1 };\\n    // look for the index of target + 1\\n    int r = binarySearch(nums, target + 1);\\n    // last position is r - 1.\\n    return new int[] { l, r - 1 };\\n}\\nprivate int binarySearch(int[] nums, int target) {\\n    int l = 0, r = nums.length;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (nums[m] < target) l = m + 1;\\n        else r = m ;\\n    }\\n    return l;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic int[] searchRange(int[] nums, int target) {\\n    int l = binarySearch(nums, target);\\n    // target does not exist. No need to look for the last position.\\n    if (l == nums.length || nums[l] != target) return new int[] { -1, -1 };\\n    // look for the index of target + 1\\n    int r = binarySearch(nums, target + 1);\\n    // last position is r - 1.\\n    return new int[] { l, r - 1 };\\n}\\nprivate int binarySearch(int[] nums, int target) {\\n    int l = 0, r = nums.length;\\n    while (l < r) {\\n        int m = (l + r) / 2;\\n        if (nums[m] < target) l = m + 1;\\n        else r = m ;\\n    }\\n    return l;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681299,
                "title": "c-two-times-binary-search-for-start-and-end",
                "content": "```\\nclass Solution {\\n public:\\n  vector<int> searchRange(vector<int>& nums, int target) {\\n    int start = bs(nums, target, true);\\n    int end = bs(nums, target, false);\\n\\n    return vector<int>({start, end});\\n  }\\n\\n  int bs(vector<int>& nums, int target, bool firstindex) {\\n    int ans = -1;\\n    int l = 0, r = nums.size() - 1;\\n\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n\\n      if (target > nums[m])\\n        l = m + 1;\\n      else if (target < nums[m])\\n        r = m - 1;\\n      else {\\n        ans = m;\\n        if (firstindex)\\n          r = m - 1;\\n        else\\n          l = m + 1;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> searchRange(vector<int>& nums, int target) {\\n    int start = bs(nums, target, true);\\n    int end = bs(nums, target, false);\\n\\n    return vector<int>({start, end});\\n  }\\n\\n  int bs(vector<int>& nums, int target, bool firstindex) {\\n    int ans = -1;\\n    int l = 0, r = nums.size() - 1;\\n\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n\\n      if (target > nums[m])\\n        l = m + 1;\\n      else if (target < nums[m])\\n        r = m - 1;\\n      else {\\n        ans = m;\\n        if (firstindex)\\n          r = m - 1;\\n        else\\n          l = m + 1;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180677,
                "title": "call-binary-search-twice-python3-solution",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        def search(x):\\n            lo, hi = 0, len(nums)           \\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                if nums[mid] < x:\\n                    lo = mid+1\\n                else:\\n                    hi = mid                    \\n            return lo\\n        \\n        lo = search(target)\\n        hi = search(target+1)-1\\n        \\n        if lo <= hi:\\n            return [lo, hi]\\n                \\n        return [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439181,
                "title": "c-only-one-simple-binary-search-function-explanation",
                "content": "Let\\'s the example array be [1,2,3,3,3,5] and target is 3\\nSo lets p1 = first occurence of number greater than (target -1=3-1=2)in this case as 3 > 2 and 3 comes at index 2 for the first time\\nand lets p2 = first occurence of number greater than (target=3)which is  5 in this case as 5>3 and 5 comes at index 5 for the first time\\nif p1 == p2 that means our target number is not in the array\\nfor ex array is [1,2,4,4,5] and target = 3\\np1 = 3 as number greater than (3-1=2)  is 4 and first occurence of 4 is at 3rd index\\np2 = 3 as number greater than (3) is 4 and first occurence of 4 is at 3rd index\\nso p1 == p2 that means number is not present\\nif p1 == p2 return [-1,-1]\\nelse return [p1,p2-1] \\nWhy p2-1 because p2 is the index of the first occurence of the number greater than our target so p2-1 will be the last occurence of our target\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int bSearch(vector<int> &nums, int target)\\n    {\\n        int low = 0, high = nums.size();\\n        while (low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int p2 = bSearch(nums, target);\\n        int p1 = bSearch(nums, target - 1);\\n        if (p1 == p2 )// That means element is not present hence return [-1,-1]\\n            return {-1, -1};\\n        return {p1, p2-1}; //element is present \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int bSearch(vector<int> &nums, int target)\\n    {\\n        int low = 0, high = nums.size();\\n        while (low < high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] > target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        return low;\\n    }\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int p2 = bSearch(nums, target);\\n        int p1 = bSearch(nums, target - 1);\\n        if (p1 == p2 )// That means element is not present hence return [-1,-1]\\n            return {-1, -1};\\n        return {p1, p2-1}; //element is present \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184156,
                "title": "java-3-approaches-explained-o-n-to-o-log-n-all-accepted",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**APPROACH 1 -** 2 Pointers - Time Complexity = **O(N)**:\\n\\n*Take an array of size 2 **`res []`** to store the result and initialize both the cells with **-1**.*\\n\\n1. Take 2 pointers - **ptr1** and **ptr2** starting from **0** and **N-1** respectively.\\n2. Iterate until **`ptr1 <= ptr2`**.\\n3. If **`nums [ptr1] == target`**:  set **`res [0] = ptr1`**, else increment **ptr1**.\\n4. If **`nums [ptr2] == target`**:  set **`res [1] = ptr2`**, else decrement **ptr2**.\\n5. If **`res [0] > -1`** and **`res [1] > -1`**, means we have found the indices, so break and return **res**.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        int ptr1 = 0, ptr2 = nums.length - 1;\\n        while (ptr1 <= ptr2) {\\n            if (nums [ptr1] == target)\\n                res [0] = ptr1;\\n            else\\n                ptr1++;\\n            if (nums [ptr2] == target)\\n                res [1] = ptr2;\\n            else\\n                ptr2--;\\n            if (res [0] > -1 && res [1] > -1)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**APPROACH 2 -** Binary Search + Iteration - Time Complexity = **O(N)**:\\n\\n*Take an array of size 2 **`res []`** to store the result and initialize both the cells with **-1**.*\\n\\n1. Apply binary search and find a **possible** index of **target**.\\n2. Start from this index towards the left of the array and find the final index containing **target**. Set **res [0]** to this index.\\n3. Start from this index towards the right of the array and find the final index containing **target**. Set **res [1]** to this index.\\n4. If the target was not found in the initial Binary Search, return **res** as it is.\\n5. Return **res**.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        return BinarySearch (nums, target);\\n    }\\n    \\n    public int [] BinarySearch (int arr [], int target) {\\n        int l = 0, r = arr.length - 1, mid = -1;\\n        boolean flag = false;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (arr [mid] == target) {\\n                flag = true;\\n                break;\\n            }\\n            if (arr [mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        int res [] = new int [2];\\n        if (flag == false) {\\n            res [0] = -1;\\n            res [1] = -1;\\n        }\\n        else {\\n            int i = mid;\\n            while (i > 0 && arr [i-1] == arr [i])\\n                i--;\\n            res [0] = i;\\n            i = mid;\\n            while (i < arr.length - 1 && arr [i] == arr [i+1])\\n                i++;\\n            res [1] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**APPROACH 3 -** Binary Search - Time Complexity = **O(log N)**:\\n\\n`Credit: Mazhar_MIK\\'s solution - https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1181941/C%2B%2B-(Two-approaches-O(logn)-with-comments)`\\n\\nBasically, we will do the iteration part of Approach 2 in the Binary Search function itself.\\n\\n1. Find first position of **target** using Binary Search. After finding target, **keep going towards left** until you find the final index. See the comments in the code.\\n2. Find last position of **target** using Binary Search. After finding target, **keep going towards right** until you find the final index. See the comments in the code.\\n3. Return **res** with these indices.\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)\\n            return new int [] {-1, -1};\\n        int first = findFirst (nums, target);\\n        int last = findLast (nums, target);\\n        return new int [] {first, last};\\n    }\\n    \\n    public int findFirst (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n                res = mid;                 // Possibly our solution\\n                right = mid - 1;           // But, still keep looking towards the left\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int findLast (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n               res = mid;                 // Possibly our solution\\n               left = mid + 1;            // But, still keep looking towards the right\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nAgain, if you like the solutions, please **upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        int ptr1 = 0, ptr2 = nums.length - 1;\\n        while (ptr1 <= ptr2) {\\n            if (nums [ptr1] == target)\\n                res [0] = ptr1;\\n            else\\n                ptr1++;\\n            if (nums [ptr2] == target)\\n                res [1] = ptr2;\\n            else\\n                ptr2--;\\n            if (res [0] > -1 && res [1] > -1)\\n                break;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int res [] = new int [2];\\n        res [0] = -1;\\n        res [1] = -1;\\n        if (nums.length == 0)\\n            return res;\\n        return BinarySearch (nums, target);\\n    }\\n    \\n    public int [] BinarySearch (int arr [], int target) {\\n        int l = 0, r = arr.length - 1, mid = -1;\\n        boolean flag = false;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (arr [mid] == target) {\\n                flag = true;\\n                break;\\n            }\\n            if (arr [mid] < target)\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        int res [] = new int [2];\\n        if (flag == false) {\\n            res [0] = -1;\\n            res [1] = -1;\\n        }\\n        else {\\n            int i = mid;\\n            while (i > 0 && arr [i-1] == arr [i])\\n                i--;\\n            res [0] = i;\\n            i = mid;\\n            while (i < arr.length - 1 && arr [i] == arr [i+1])\\n                i++;\\n            res [1] = i;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)\\n            return new int [] {-1, -1};\\n        int first = findFirst (nums, target);\\n        int last = findLast (nums, target);\\n        return new int [] {first, last};\\n    }\\n    \\n    public int findFirst (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n                res = mid;                 // Possibly our solution\\n                right = mid - 1;           // But, still keep looking towards the left\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int findLast (int arr [], int target) {\\n        int left = 0, right = arr.length - 1, mid = 0, res = -1;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (arr [mid] == target) {\\n               res = mid;                 // Possibly our solution\\n               left = mid + 1;            // But, still keep looking towards the right\\n            }\\n            else if (target > arr [mid])\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181943,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int> & nums,int l,int h,int tar,bool uff)\\n    {\\n        int res=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(nums[mid]==tar)\\n            {\\n                res=mid;\\n                if(uff)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            else if(nums[mid]>tar)\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> res(2);\\n        int n=nums.size();\\n        res[0]=bs(nums,0,n-1,target,false);\\n        res[1]=bs(nums,0,n-1,target,true);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int bs(vector<int> & nums,int l,int h,int tar,bool uff)\\n    {\\n        int res=-1;\\n        while(l<=h)\\n        {\\n            int mid=(l+h)/2;\\n            \\n            if(nums[mid]==tar)\\n            {\\n                res=mid;\\n                if(uff)\\n                    l=mid+1;\\n                else\\n                    h=mid-1;\\n            }\\n            else if(nums[mid]>tar)\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> res(2);\\n        int n=nums.size();\\n        res[0]=bs(nums,0,n-1,target,false);\\n        res[1]=bs(nums,0,n-1,target,true);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575702,
                "title": "solution-using-template-3-of-bs-by-leetcode",
                "content": "I am doing topic wise problems and this problem was under BS for the card under explore section. It fell into Template 3 where you need to keep check of the left and the right elements during search. Hence I designed a solution likewise. \\nLong solution but simple to understand.\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int ans[] = {-1,-1};\\n        if(nums == null || nums.length == 0)\\n            return ans;\\n        ans[0] = findLeft(nums, target);\\n        ans[1] = findRight(nums, target);\\n        return ans;\\n    }\\n    \\n    public int findLeft(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length -1;\\n        while(low+1<high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid]<target){\\n                low = mid+1;\\n            } else \\n                high = mid;\\n            }\\n        if(nums[low] == target) return low;\\n        if(nums[high] == target) return high;\\n        return -1;\\n        }\\n\\n    public int findRight(int[] nums, int target){\\n            int low = 0;\\n            int high = nums.length -1;\\n            while(low+1<high){\\n                int mid = (high-low)/2 + low;\\n                if(nums[mid]<=target){\\n                    low = mid;\\n                } else \\n                    high = mid-1;\\n                }\\n            if(nums[high] == target) return high;\\n             if(nums[low] == target) return low;\\n            return -1;\\n            }\\n        \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int ans[] = {-1,-1};\\n        if(nums == null || nums.length == 0)\\n            return ans;\\n        ans[0] = findLeft(nums, target);\\n        ans[1] = findRight(nums, target);\\n        return ans;\\n    }\\n    \\n    public int findLeft(int[] nums, int target){\\n        int low = 0;\\n        int high = nums.length -1;\\n        while(low+1<high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid]<target){\\n                low = mid+1;\\n            } else \\n                high = mid;\\n            }\\n        if(nums[low] == target) return low;\\n        if(nums[high] == target) return high;\\n        return -1;\\n        }\\n\\n    public int findRight(int[] nums, int target){\\n            int low = 0;\\n            int high = nums.length -1;\\n            while(low+1<high){\\n                int mid = (high-low)/2 + low;\\n                if(nums[mid]<=target){\\n                    low = mid;\\n                } else \\n                    high = mid-1;\\n                }\\n            if(nums[high] == target) return high;\\n             if(nums[low] == target) return low;\\n            return -1;\\n            }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423966,
                "title": "java-binary-search-solution-with-easy-explanation-and-common-mistake",
                "content": "Three line explanation for iterviews\\n\\n1. We can do separate binary search for first and last elements. Why?\\n2. Because for finding first occurence we keep doing binary search in left half when we encounter mid that is same as mid-1 element.\\n3. We should not iterate linearly towards left and right after finding mid that is equal to target. If we do a linear search then asymptotic time complexity will again become O(n). Although O(n) solution will work on leetcode but won\\'t be good solution for interviews.\\n\\nTime Complexity: log(n) Space: O(1)\\nYou can follow me on https://twitter.com/Jaspind07199761 for DS and Algo tips\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n```\\nclass Solution {\\n    public int first(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if( mid == low ||  nums[mid - 1] < nums[mid]) return mid;\\n                // still go left\\n                else high = mid - 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    \\n    public int second(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if(mid == high || nums[mid + 1] > target) return mid;\\n                // still go right\\n                else low = mid + 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = first(nums, 0, nums.length - 1, target);\\n        int right = second(nums, 0, nums.length - 1, target);\\n        return new int[] {left,right};\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int first(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if( mid == low ||  nums[mid - 1] < nums[mid]) return mid;\\n                // still go left\\n                else high = mid - 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    \\n    public int second(int[] nums, int low, int high, int target)\\n    {\\n        while (low <= high){\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] == target){\\n                if(mid == high || nums[mid + 1] > target) return mid;\\n                // still go right\\n                else low = mid + 1;\\n            } else if(nums[mid] > target){\\n                high = mid - 1;\\n            } else low = mid + 1; \\n        }\\n        return -1; \\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = first(nums, 0, nums.length - 1, target);\\n        int right = second(nums, 0, nums.length - 1, target);\\n        return new int[] {left,right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14869,
                "title": "python-easy-solution-with-explanation",
                "content": "The first while give bias towards the left and the second while gives bias towards the right.\\nExample:\\n    \\n                          First While[start,end]     Second While[start,end]\\n    nums = [2,2] target=0     [0,-1]                     [0,-1]\\n    nums = [2,2] target=3     [2,1]                      [2,1]\\n    nums = [2,2] target=2     [0,-1]                     [2,1]\\n\\nThe code is as below:\\n\\n  \\n\\n    def searchRange(self, nums, target):\\n        start = 0\\n        end = len(nums)-1\\n        result = []\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        result.append(start)\\n        \\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid]  > target:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n        result.append(end)\\n        \\n        if result[0] > result[1]:\\n            return [-1, -1]\\n        else:\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "The first while give bias towards the left and the second while gives bias towards the right.\\nExample:\\n    \\n                          First While[start,end]     Second While[start,end]\\n    nums = [2,2] target=0     [0,-1]                     [0,-1]\\n    nums = [2,2] target=3     [2,1]                      [2,1]\\n    nums = [2,2] target=2     [0,-1]                     [2,1]\\n\\nThe code is as below:\\n\\n  \\n\\n    def searchRange(self, nums, target):\\n        start = 0\\n        end = len(nums)-1\\n        result = []\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        result.append(start)\\n        \\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = start + (end-start)/2\\n            if nums[mid]  > target:\\n                end = mid -1\\n            else:\\n                start = mid + 1\\n        result.append(end)\\n        \\n        if result[0] > result[1]:\\n            return [-1, -1]\\n        else:\\n            return result",
                "codeTag": "Python3"
            },
            {
                "id": 3140796,
                "title": "easy-c-solution-for-beginners-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        int first =-1, last=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                first=i;\\n                \\n                break;\\n            }\\n        }\\n        for(int i=nums.size()-1; i>=0; i--)\\n        {\\n            if(nums[i]==target)\\n            {\\n                last=i;\\n                \\n                break;\\n            }\\n        }\\n        v.push_back(first);\\n        v.push_back(last);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        int first =-1, last=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                first=i;\\n                \\n                break;\\n            }\\n        }\\n        for(int i=nums.size()-1; i>=0; i--)\\n        {\\n            if(nums[i]==target)\\n            {\\n                last=i;\\n                \\n                break;\\n            }\\n        }\\n        v.push_back(first);\\n        v.push_back(last);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713029,
                "title": "java-fast-solution",
                "content": "//search element according to binary search\\nclass Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        int si=0;\\n        int ei=nums.length-1;\\n        int[] ans=new int[]{-1,-1};\\n    while(si<=ei){\\n        int mid=si+(ei-si)/2;\\n        if(nums[mid]==target){\\n            si=mid-1;ei=mid+1;\\n\\t\\t\\t// search for first index with while loop in -ve  direction\\n            while(si>=0&&nums[si]==target){si--;}\\n            ans[0]=si+1;\\n\\t\\t\\t// search for ending index in +ve direction\\n            while(ei<nums.length&&nums[ei]==target){ei++;}\\n            ans[1]=ei-1;\\n            return ans;\\n        }\\n        else if(target>nums[mid]){\\n            si=mid+1;\\n        }\\n       \\n        else ei=mid-1;\\n    }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        int si=0;\\n        int ei=nums.length-1;\\n        int[] ans=new int[]{-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2256973,
                "title": "c-simple-fast-solution-first-and-last-position-of-element-in-sorted-array",
                "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1;\\n        int end = -1;\\n        vector<int> ans;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                start = i;\\n                break;\\n            }\\n        }\\n        for(int i = nums.size()-1;i>=0;i--){\\n            if(nums[i]==target){\\n                end = i;\\n                break;\\n            }\\n        }\\n        \\n        ans.push_back(start);\\n        ans.push_back(end);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1;\\n        int end = -1;\\n        vector<int> ans;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                start = i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2177406,
                "title": "python-2-liner-no-loop-no-library-simple-and-easy",
                "content": "**Give it a upvote if you like the solution :)**\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        if target not in nums: return [-1,-1]\\n        else : return [nums.index(target),nums.index(target) + nums.count(target) - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        \\n        if target not in nums: return [-1,-1]\\n        else : return [nums.index(target),nums.index(target) + nums.count(target) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154474,
                "title": "python-binary-search-easily-explained",
                "content": "# Python Binary Search.\\n```\\nclass Solution:\\n# for this solution we need to modify our binary search since we can\\'t return\\n# mid here.\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        # searching from left and then from right\\n        left = self.binSearch(nums, target, True)\\n        right = self.binSearch(nums, target, False)\\n        return [left, right]\\n\\n    # if leftBias=True, we search for left side\\n\\t# if False, we seach for right side\\n    def binSearch(self, nums, target, leftBias):\\n        l, r = 0, len(nums) - 1\\n        i = -1\\n        while l <= r:\\n            m = (l+r) // 2\\n            if nums[m] < target:\\n                l = m + 1\\n            elif nums[m] > target:\\n                r = m - 1\\n            else: # if nums[m] == target\\n                i = m\\n                if leftBias: # if I\\'m searching from left-side\\n                    r = m - 1 \\n                else: # if I\\'m searching from right-side\\n                    l = m + 1\\n        return i\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n# for this solution we need to modify our binary search since we can\\'t return\\n# mid here.\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        # searching from left and then from right\\n        left = self.binSearch(nums, target, True)\\n        right = self.binSearch(nums, target, False)\\n        return [left, right]\\n\\n    # if leftBias=True, we search for left side\\n\\t# if False, we seach for right side\\n    def binSearch(self, nums, target, leftBias):\\n        l, r = 0, len(nums) - 1\\n        i = -1\\n        while l <= r:\\n            m = (l+r) // 2\\n            if nums[m] < target:\\n                l = m + 1\\n            elif nums[m] > target:\\n                r = m - 1\\n            else: # if nums[m] == target\\n                i = m\\n                if leftBias: # if I\\'m searching from left-side\\n                    r = m - 1 \\n                else: # if I\\'m searching from right-side\\n                    l = m + 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007640,
                "title": "using-binary-search-o-logn-lower-bound-upper-bound-concept",
                "content": "By Using **Binary Search**  we can able to achieve this solution in logn time ( it is given that array already sorted) \\n\\nSo by the technique of calculation of **lower bound and upper bound** we calculate the index of target in lower bound area and similarly in upper bound area.\\n\\n* runs two separate loop for both.\\n* store the index of target whenever it got.  \\n![image](https://assets.leetcode.com/users/images/663e1b29-ae8d-4e38-9953-c0ec3aef464f_1651669334.2044718.png)\\n \\n**Time complexity - O(nlogn)\\nSpace complexity - O(1)**\\n\\n\\n****\\n**JAVA Code** \\n\\n```\\n\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\n\\t\\tint[] ans = { -1, -1 };\\n\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[0] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\t\\ti = 0;\\n\\t\\tj = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[1] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] > target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic int[] searchRange(int[] nums, int target) {\\n\\n\\t\\tint[] ans = { -1, -1 };\\n\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[0] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] >= target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\t\\ti = 0;\\n\\t\\tj = nums.length - 1;\\n\\n\\t\\twhile (i <= j) {\\n\\t\\t\\tint mid = (i + j) / 2;\\n\\n\\t\\t\\tif (nums[mid] == target) {\\n\\t\\t\\t\\tans[1] = mid;\\n\\t\\t\\t}\\n\\t\\t\\tif (nums[mid] > target) {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599591,
                "title": "lower-bound-upper-bound-binary-search",
                "content": "lower bound + upper bound binary search with closed intervals, i.e [l,r]\\n\\nfor intervals with the open end, i.e [l,r)\\nyou can refer to \\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/discuss/1543638/lower-bound-%2B-upper-bound-binary-search-O(logn)\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        //lower bound binary search\\n        int l = 0, r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                r = m - 1;\\n        }\\n                \\n        if(l== nums.length || nums[l] !=target) return new int[] {-1,-1};\\n        int lowerBound = l; \\n        \\n        //upper bound binary search\\n        l = 0; r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                l = m + 1;\\n        }\\n        return new int[] {lowerBound, r};\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        //lower bound binary search\\n        int l = 0, r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                r = m - 1;\\n        }\\n                \\n        if(l== nums.length || nums[l] !=target) return new int[] {-1,-1};\\n        int lowerBound = l; \\n        \\n        //upper bound binary search\\n        l = 0; r = nums.length-1;\\n        while(l<=r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] < target) \\n                l = m + 1;\\n            else if (nums[m] > target) \\n                r = m - 1;\\n            else if (nums[m] == target) \\n                l = m + 1;\\n        }\\n        return new int[] {lowerBound, r};\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409980,
                "title": "clean-commented-code-0ms-run-time-100-faster-log-n-complexity-take-a-look",
                "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n       \\n\\t   int lo =0; int hi=nums.length-1; int r=-1;\\n        \\n       //Simple Binary Search Algo to find first Occurence;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                r=mid;hi=mid-1;\\n            }else if(nums[mid]>target){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        //If element doesn\\'t found return -1 for both ;\\n        if(r==-1) return new int[] {-1,-1};\\n        \\n        int[] arr = new int[2];//Create a array of size 2;\\n        arr[0]=r;//put value of 1st Occurence\\n        \\n       //Simple Binary Search Algo to find last Occurence;\\n        lo=r;hi=nums.length-1;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                lo=mid+1;r=mid;\\n            }else if(nums[mid]>target){\\n                hi=mid-1;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        arr[1]=r;//put value of last Occurence\\n        return arr;\\n        \\n      //Time Complexity O(log n)+O(log n) i.e. O(log n)\\n      // Space Complexity O(1);\\n    }\\n}\\n\\n//Do upvote if you like\\n//Comment if you want to suggest some changes",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n       \\n\\t   int lo =0; int hi=nums.length-1; int r=-1;\\n        \\n       //Simple Binary Search Algo to find first Occurence;\\n        while(lo<=hi){\\n            int mid =lo+(hi-lo)/2;\\n            if(nums[mid]==target){\\n                r=mid;hi=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 634098,
                "title": "python-bisect",
                "content": "I know in a real world interview you would probably not use this, as it doesn\\'t demonstrate any knowledge of binary search in itself. Still, funny how easy python makes this.\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1, -1]\\n        \\n        left,right = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)\\n                \\n        return [left, right - 1] if left < right else [-1, -1]\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1, -1]\\n        \\n        left,right = bisect.bisect_left(nums, target), bisect.bisect_right(nums, target)\\n                \\n        return [left, right - 1] if left < right else [-1, -1]\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584784,
                "title": "python-solution-faster-than-99-10-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums: return (-1, -1)\\n        \\n        # finding left most index (1st occurence) of target\\n        # when this function is called, r is already at the target (may not be the left most)\\n        # l is at the 1st index (0) and in this range all values are <= target\\n        def find_left(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] < target: l = mid + 1\\n                # As all values are <= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is preceded by a smaller\\n                # Number, then that is the left most ocuurence of target\\n                elif nums[mid-1] < target: return mid\\n                # We are in the midst of target values\\n                # Reduce r to mid\\n                else: r = mid - 1\\n            return l\\n        \\n        # Finding right most index (last occurence) of target\\n        # When this function is called, l is already at the target (may not be the right most)\\n        # r is at the last index (len(nums)-1) and in this range all values are >= target\\n        def find_right(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] > target: r = mid - 1\\n                # As all values are >= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is followe by a greater\\n                # number, then that is the right most ocuurence of target\\n                elif nums[mid+1] > target: return mid\\n                # We are in the midst of target values\\n                # Increase l to mid\\n                else: l = mid + 1\\n            return r\\n        \\n\\t\\t# Binary search on whole array to find a random index of target\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] < target: l = mid + 1\\n            elif nums[mid] > target: r = mid - 1\\n            else: \\n\\t\\t\\t\\t# A random index of target is found\\n                return [find_left(nums, 0, mid, target), find_right(nums, mid, len(nums)-1, target)]\\n        return (-1, -1)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums: return (-1, -1)\\n        \\n        # finding left most index (1st occurence) of target\\n        # when this function is called, r is already at the target (may not be the left most)\\n        # l is at the 1st index (0) and in this range all values are <= target\\n        def find_left(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] < target: l = mid + 1\\n                # As all values are <= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is preceded by a smaller\\n                # Number, then that is the left most ocuurence of target\\n                elif nums[mid-1] < target: return mid\\n                # We are in the midst of target values\\n                # Reduce r to mid\\n                else: r = mid - 1\\n            return l\\n        \\n        # Finding right most index (last occurence) of target\\n        # When this function is called, l is already at the target (may not be the right most)\\n        # r is at the last index (len(nums)-1) and in this range all values are >= target\\n        def find_right(nums, l, r, target):\\n            while l < r:\\n                mid = l + (r - l) // 2\\n                if nums[mid] > target: r = mid - 1\\n                # As all values are >= target and previous if is is not entered,\\n                # That means nums[mid] == target now.\\n                # So, now if we find that nums[mid] is followe by a greater\\n                # number, then that is the right most ocuurence of target\\n                elif nums[mid+1] > target: return mid\\n                # We are in the midst of target values\\n                # Increase l to mid\\n                else: l = mid + 1\\n            return r\\n        \\n\\t\\t# Binary search on whole array to find a random index of target\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] < target: l = mid + 1\\n            elif nums[mid] > target: r = mid - 1\\n            else: \\n\\t\\t\\t\\t# A random index of target is found\\n                return [find_left(nums, 0, mid, target), find_right(nums, mid, len(nums)-1, target)]\\n        return (-1, -1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 418998,
                "title": "javascript-binary-search-98",
                "content": "First stab at it. It\\'s pretty ugly but also just a typical binary search implementation. The approach comes in two major steps.\\n \\n**First, find the value**\\n1. Create range of indicies.\\n2. Find the middle of that range.\\n3. Compare middle with target.\\n\\t- If the middle value is greater than target, assign (center index - 1) to the end index and go back to step 2.\\n\\t- If the middle value is less than the target, assign (center index + 1) to the start index and got back to step 2.\\n\\t- If the middle value is target, break and go to the next step.\\n\\n**Second, find the edges**\\n1. Reassign the center index to the start and end indicies.\\n2. Increment the end index value until the next value does not equal the target.\\n3. Decrement the start index value until the next value does not equal the target.\\n\\n```js\\n\\nvar searchRange = function(nums, target) {\\n    const length = nums.length - 1;\\n    let start = 0;\\n    let end = length;\\n    let center;\\n    \\n    // get the center\\n    while (start <= end) {\\n        center = Math.floor((start + end) / 2);\\n        if (nums[center] === target) {\\n            start = center;\\n            end = center;\\n            break;\\n        }\\n        else if (nums[center] < target) start = center + 1;\\n        else end = center - 1;\\n    }\\n\\n    if (start > end) return [-1, -1];\\n    \\n    // find the edges\\n    while (nums[start - 1] === target) start--;\\n    while (nums[end + 1] === target) end++;\\n    return [start, end];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```js\\n\\nvar searchRange = function(nums, target) {\\n    const length = nums.length - 1;\\n    let start = 0;\\n    let end = length;\\n    let center;\\n    \\n    // get the center\\n    while (start <= end) {\\n        center = Math.floor((start + end) / 2);\\n        if (nums[center] === target) {\\n            start = center;\\n            end = center;\\n            break;\\n        }\\n        else if (nums[center] < target) start = center + 1;\\n        else end = center - 1;\\n    }\\n\\n    if (start > end) return [-1, -1];\\n    \\n    // find the edges\\n    while (nums[start - 1] === target) start--;\\n    while (nums[end + 1] === target) end++;\\n    return [start, end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14910,
                "title": "the-insert-position-trick",
                "content": "Just imagine where we should insert target+0.5 and target-0.5 into this array.\\n\\n    class Solution {\\n    public:\\n        vector<int> searchRange(vector<int>& nums, int target) {\\n            int t = insertPosition(nums, target - 0.5);\\n            if (target != nums[t]) {\\n                return {-1, -1};\\n            }\\n            return {t, insertPosition(nums, target + 0.5) - 1};\\n        }\\n    private:\\n        int insertPosition(vector<int>& nums, double target) {\\n            int l = 0;\\n            int r = nums.size() - 1;\\n            while (l <= r) {\\n                int mid = l + ((r - l) >> 1);\\n                if (target < nums[mid]) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1;\\n                }\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> searchRange(vector<int>& nums, int target) {\\n            int t = insertPosition(nums, target - 0.5);\\n            if (target != nums[t]) {\\n                return {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 3649422,
                "title": "cpp-binary-search-upper-bound-lower-bound",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int low = lower_bound(nums.begin() , nums.end() , target) - nums.begin();    \\n        int high = upper_bound(nums.begin() , nums.end() , target) - nums.begin();\\n        if(low<nums.size() && nums[low]==target)\\n        {\\n            return {low,high-1};\\n        }\\n        return {-1,-1};\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int low = lower_bound(nums.begin() , nums.end() , target) - nums.begin();    \\n        int high = upper_bound(nums.begin() , nums.end() , target) - nums.begin();\\n        if(low<nums.size() && nums[low]==target)\\n        {\\n            return {low,high-1};\\n        }\\n        return {-1,-1};\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542485,
                "title": "simple-easy-to-understand-solution-using-upper-lower-bounds",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We can find upper bound & lower bound to find last & first index of target respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the inbuilt upper & lower bound functions.\\nAs lower bound will return the index of target appearing first time(because this is used for finding a number which is just less than the target) and upper bound will return the index of target appearing for last time(because this is used for finding a number which is just greater than the target) in the array. \\n\\n# Complexity\\n- Time complexity:O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int x,y;\\n        if(binary_search (nums.begin(), nums.end(), target))\\n        {\\n            x = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n            y = upper_bound(nums.begin(), nums.end(), target) - nums.begin()-1;\\n        }\\n        else \\n        {\\n            return{-1,-1};\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        int x,y;\\n        if(binary_search (nums.begin(), nums.end(), target))\\n        {\\n            x = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n            y = upper_bound(nums.begin(), nums.end(), target) - nums.begin()-1;\\n        }\\n        else \\n        {\\n            return{-1,-1};\\n        }\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176028,
                "title": "shocking-logic-python3",
                "content": "\\n# First find target index and Traverse reverse Again\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list2=[-1,-1]\\n        list1=[]\\n        if nums.count(target)>0:\\n            list1.append(nums.index(target))\\n            for i in range(len(nums)-1,-1,-1):\\n                if nums[i]== target:\\n                    list1.append(i)\\n                    break\\n        else:\\n            return list2\\n        return list1\\n//please upvote me it would encourage me alot\\n\\n```\\n# Binary Search Logic---->O(LogN)\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list1=[]\\n        def search(target):\\n            left,right=0,len(nums)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            return left\\n        l=search(target)\\n        r=search(target+1)-1\\n        if l<=r:\\n            return [l,r]\\n        return [-1,-1]\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list2=[-1,-1]\\n        list1=[]\\n        if nums.count(target)>0:\\n            list1.append(nums.index(target))\\n            for i in range(len(nums)-1,-1,-1):\\n                if nums[i]== target:\\n                    list1.append(i)\\n                    break\\n        else:\\n            return list2\\n        return list1\\n//please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        list1=[]\\n        def search(target):\\n            left,right=0,len(nums)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if nums[mid]<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            return left\\n        l=search(target)\\n        r=search(target+1)-1\\n        if l<=r:\\n            return [l,r]\\n        return [-1,-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117795,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[0]=mid;\\n               end=mid-1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n          \\n        }\\n         st=0;end=nums.size()-1;\\n         while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[1]=mid;\\n               st=mid+1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n        }\\n        return v;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        int st=0;int end=nums.size()-1;\\n        while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[0]=mid;\\n               end=mid-1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n          \\n        }\\n         st=0;end=nums.size()-1;\\n         while(st<=end){\\n           int mid=(st+end)/2;\\n           if(nums[mid]==target){\\n               v[1]=mid;\\n               st=mid+1;\\n           }else if(nums[mid]<target){\\n               st=mid+1;\\n           }else{\\n               end=mid-1;\\n           }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098375,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n\\n        // Finding index of first occurrence\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == target) {\\n                ans[0] = i;\\n                break;\\n            }\\n        }\\n\\n        // Finding index of last occurrence\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i] == target) {\\n                ans[1] = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n        int n = nums.size();\\n\\n        // Finding index of first occurrence\\n        int low = 0, high = n - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == 0 || nums[mid] != nums[mid - 1]) {\\n                    ans[0] = mid;\\n                    break;\\n                } else {\\n                    high = mid - 1;\\n                }    \\n            }          \\n        }\\n\\n        // Finding index of last occurrence\\n        low = 0, high = n - 1;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == n - 1 || nums[mid] != nums[mid + 1]) {\\n                    ans[1] = mid;\\n                    break;\\n                } else {\\n                    low = mid + 1;\\n                }    \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n\\n        // Finding index of first occurrence\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == target) {\\n                ans[0] = i;\\n                break;\\n            }\\n        }\\n\\n        // Finding index of last occurrence\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums[i] == target) {\\n                ans[1] = i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector <int> ans(2, -1);\\n        int n = nums.size();\\n\\n        // Finding index of first occurrence\\n        int low = 0, high = n - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == 0 || nums[mid] != nums[mid - 1]) {\\n                    ans[0] = mid;\\n                    break;\\n                } else {\\n                    high = mid - 1;\\n                }    \\n            }          \\n        }\\n\\n        // Finding index of last occurrence\\n        low = 0, high = n - 1;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] > target)\\n                high = mid - 1;\\n            else if (nums[mid] < target)\\n                low = mid + 1;  \\n            else {\\n                if (mid == n - 1 || nums[mid] != nums[mid + 1]) {\\n                    ans[1] = mid;\\n                    break;\\n                } else {\\n                    low = mid + 1;\\n                }    \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949964,
                "title": "100-faster-java-c-easy-solution-with-explanation",
                "content": "-> first by binary search we see element is present in array or not.\\n\\n-> if element not present so first and last index is -1,-1.\\n\\n-> if element present in array than search using while loop go till first index and last index.\\n\\n\\n# Approach\\nBinary Search and Linear Search both\\n\\n# Complexity\\n- Time complexity:\\n- best case O(log n)\\n    - when element not present in array than binary search gives return -1 so answer becomes {-1,-1}\\n-Avearge && Worst case\\n    -Time compexity of binary search + Time complexity of linear search=O(log n)+O(n)=O(n)\\n\\n\\n# JAVA Code\\n```\\nclass Solution {\\n    \\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int[] ans={-1,-1};\\n        int n=nums.length;\\n\\n        int index=find(nums,0,n-1,target); \\n        //Checking element is present or not in array.\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n                ans[0]=--index;\\n\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n                ans[1]=++index;\\n            \\n        }\\n\\n        return ans;\\n    }\\n\\n    public int find(int[] nums,int s,int e,int target) //binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n# C++ Code\\nclass Solution {\\npublic:\\n   \\n    vector<int> searchRange(vector<int>& nums, int target) \\n    {\\n        vector<int> ans={-1,-1};\\n        int n=nums.size();\\n    \\n        int index=find(nums,0,n-1,target);\\n        //Checking element is present or not in array.\\n\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n            {\\n                ans[0]=--index;\\n            }\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n            {\\n                ans[1]=++index;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n    int find(vector<int>& nums,int s,int e,int target)//binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int[] ans={-1,-1};\\n        int n=nums.length;\\n\\n        int index=find(nums,0,n-1,target); \\n        //Checking element is present or not in array.\\n\\n\\n        if(index!=-1)\\n        {\\n            ans[0]=index;\\n            ans[1]=index;\\n\\n            while(index-1>=0 && nums[index-1]==target)//move back till first index\\n                ans[0]=--index;\\n\\n            while(index+1<n && nums[index+1]==target)//move forward till last index\\n                ans[1]=++index;\\n            \\n        }\\n\\n        return ans;\\n    }\\n\\n    public int find(int[] nums,int s,int e,int target) //binary search function\\n    {\\n        if(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(target>nums[mid])\\n                return find(nums,mid+1,e,target);\\n            else\\n                return find(nums,s,mid-1,target);            \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666452,
                "title": "o-n-single-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> ans;\\n        int st = -1,en = -1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == t && st == -1){\\n                // cout<<\"1st if : \"<<i<<endl;\\n                st = i;\\n                en = i;\\n            }\\n            else if(arr[i] == t){\\n                // cout<<\"2nd if : \"<<i<<endl;\\n                en = i;\\n            }\\n        }\\n        ans.emplace_back(st);\\n        ans.emplace_back(en);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> ans;\\n        int st = -1,en = -1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] == t && st == -1){\\n                // cout<<\"1st if : \"<<i<<endl;\\n                st = i;\\n                en = i;\\n            }\\n            else if(arr[i] == t){\\n                // cout<<\"2nd if : \"<<i<<endl;\\n                en = i;\\n            }\\n        }\\n        ans.emplace_back(st);\\n        ans.emplace_back(en);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2641673,
                "title": "accepted-c-solution-o-log-n",
                "content": "C++ Solution : \\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)\\n    {\\n        vector<int> res(2,-1);\\n        int start=0,mid=0,end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]<target)\\n                start=mid+1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[0]=mid;\\n                end=mid-1;\\n            }\\n        }\\n        start=0,end=nums.size()-1;\\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]>target)\\n                end=mid-1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[1]=mid;\\n                start=mid+1;\\n            }\\n        }\\n     return res;   \\n    }\\n};\\n```\\nTime complexity : O(log n)\\nSpace compexity : O(1)\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)\\n    {\\n        vector<int> res(2,-1);\\n        int start=0,mid=0,end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]<target)\\n                start=mid+1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[0]=mid;\\n                end=mid-1;\\n            }\\n        }\\n        start=0,end=nums.size()-1;\\n        while(start<=end)\\n        {\\n            mid=start+(end-start)/2;\\n            if(nums[mid]>target)\\n                end=mid-1;\\n            else\\n            {\\n                if(nums[mid]==target)\\n                    res[1]=mid;\\n                start=mid+1;\\n            }\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329946,
                "title": "clean-c-solution-with-two-binary-searches-beats-100",
                "content": "The solution clearly implements Binary Search approach by modifying the search space and storing the current position of the target element (if found). \\n\\nIt uses two seperate private functions for getting the First and Last positions which are then called by the searchRange() function.\\n\\nprivate:\\n\\n    int firstPos(vector<int> arr, int target)  //function for first position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                r=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    }\\n    \\n    int lastPos(vector<int> arr, int target)  //function for last position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                l=mid+1;        \\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    } \\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        ans.push_back(firstPos(nums,target));\\n        ans.push_back(lastPos(nums,target));\\n        return ans;\\n    }\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "The solution clearly implements Binary Search approach by modifying the search space and storing the current position of the target element (if found). \\n\\nIt uses two seperate private functions for getting the First and Last positions which are then called by the searchRange() function.\\n\\nprivate:\\n\\n    int firstPos(vector<int> arr, int target)  //function for first position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                r=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    }\\n    \\n    int lastPos(vector<int> arr, int target)  //function for last position of the target\\n    {\\n        int l=0;\\n        int r=arr.size()-1;\\n        int mid = l + (r-l)/2;\\n        int pos=-1;\\n        \\n        while(l<=r)\\n        {\\n            if(arr[mid]==target)\\n            {\\n                pos=mid;\\n                l=mid+1;        \\n            }\\n            else if(target>arr[mid])\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n            mid = l + (r-l)/2;\\n        }\\n        return pos;\\n    } \\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        ans.push_back(firstPos(nums,target));\\n        ans.push_back(lastPos(nums,target));\\n        return ans;\\n    }\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2329756,
                "title": "by-using-stl-easy-understanding-5-line-code",
                "content": "```\\n//please upvote if u like\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v{-1,-1};\\n        int low = lower_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        int high = upper_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        if(!binary_search(nums.begin(),nums.end(),target)) return v;\\n        v[0] = low, v[1] = high-1;\\n        return v;\\n    }\\n// please upvote if u like :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n//please upvote if u like\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v{-1,-1};\\n        int low = lower_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        int high = upper_bound(nums.begin(),nums.end(),target) - nums.begin();\\n        if(!binary_search(nums.begin(),nums.end(),target)) return v;\\n        v[0] = low, v[1] = high-1;\\n        return v;\\n    }\\n// please upvote if u like :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329477,
                "title": "c-binary-search-o-logn-concise-clear-code-easy-to-understand-solution",
                "content": "### UPVOTE IF YOU LIKE\\n\\n### ***C++ Code :***\\n```\\nclass Solution {\\npublic:\\n    int bsf(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]<target)l=mid+1;\\n            else r=mid-1;\\n        }\\n        if(l==nums.size() || nums[l]!=target)return -1;\\n        return l;\\n    }\\n    int bsl(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]>target)r=mid-1;\\n            else l=mid+1;\\n        }\\n        if(r<0 || nums[r]!=target)return -1;\\n        return r;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2);\\n        ans[0] = bsf(nums, target);\\n        ans[1] = bsl(nums, target);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int bsf(vector<int>& nums, int target){\\n        int l=0, r=nums.size()-1, mid;\\n        while(l<=r){\\n            mid = (r-l)/2+l;\\n            if(nums[mid]<target)l=mid+1;\\n            else r=mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1684808,
                "title": "beats-97-modified-binary-search-in-python",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        #Time: O(log n)\\n        #Space: O(1)\\n        \\n\\t\\t#Essentially a modified binary search\\n\\t\\t#To find the first occurence of a number, scan the remaining left part\\n\\t\\t#To find the last occurence of a number, scan the remaining right part\\n\\t\\t\\n        def binarySearch(find):\\n            left, right = 0, len(nums) - 1\\n            output = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid] > target:\\n                    right = mid - 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    output = mid\\n                    \\n\\t\\t\\t\\t\\t#This is the only modification to a standard binary search\\n                    if find == \\'first\\': #To find the first occurence, look to the left\\n                        right = mid - 1\\n                    elif find == \\'last\\': #To find the last occurence, look to the right\\n                        left = mid + 1\\n            \\n            return output\\n            \\n        return [binarySearch(\\'first\\'), binarySearch(\\'last\\')]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        #Time: O(log n)\\n        #Space: O(1)\\n        \\n\\t\\t#Essentially a modified binary search\\n\\t\\t#To find the first occurence of a number, scan the remaining left part\\n\\t\\t#To find the last occurence of a number, scan the remaining right part\\n\\t\\t\\n        def binarySearch(find):\\n            left, right = 0, len(nums) - 1\\n            output = -1\\n            \\n            while left <= right:\\n                mid = (left + right) // 2\\n                \\n                if nums[mid] > target:\\n                    right = mid - 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    output = mid\\n                    \\n\\t\\t\\t\\t\\t#This is the only modification to a standard binary search\\n                    if find == \\'first\\': #To find the first occurence, look to the left\\n                        right = mid - 1\\n                    elif find == \\'last\\': #To find the last occurence, look to the right\\n                        left = mid + 1\\n            \\n            return output\\n            \\n        return [binarySearch(\\'first\\'), binarySearch(\\'last\\')]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592917,
                "title": "go-binary",
                "content": "```\\nfunc searchRange(nums []int, target int) []int {\\n    if len(nums) == 0 {\\n        return []int{-1, -1}\\n    }\\n    return []int{binaryLeft(nums, target), binaryRight(nums, target)}\\n}\\n\\n\\nfunc binaryLeft(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2\\n        if nums[mid] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n\\n\\nfunc binaryRight(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2 + 1\\n        if nums[mid] > target {\\n            right = mid - 1\\n        } else if nums[mid] <= target {\\n            left = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchRange(nums []int, target int) []int {\\n    if len(nums) == 0 {\\n        return []int{-1, -1}\\n    }\\n    return []int{binaryLeft(nums, target), binaryRight(nums, target)}\\n}\\n\\n\\nfunc binaryLeft(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2\\n        if nums[mid] < target {\\n            left = mid + 1\\n        } else {\\n            right = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n\\n\\nfunc binaryRight(nums []int, target int) int {\\n    left, right := 0, len(nums)-1\\n    \\n    for left < right {\\n        mid := (right + left)/2 + 1\\n        if nums[mid] > target {\\n            right = mid - 1\\n        } else if nums[mid] <= target {\\n            left = mid\\n        }\\n    }\\n    if nums[left] == target {\\n        return left\\n    } \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527418,
                "title": "simple-bs-approach-java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] ans = {-1,-1};\\n        \\n        ans[0] = search(nums,target,true);\\n        ans[1] = search(nums,target,false);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int search(int[] nums,int target, boolean isFirstOccurence){\\n        int index = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid =start + (end - start)/2;\\n            \\n            if(target>nums[mid]){\\n                start = mid+1;\\n            }else if(target < nums[mid]){\\n                end = mid -1;\\n            }else{\\n                index=mid;\\n                if(isFirstOccurence){\\n                    end=mid-1;\\n                }else{\\n                    start=mid+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] ans = {-1,-1};\\n        \\n        ans[0] = search(nums,target,true);\\n        ans[1] = search(nums,target,false);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int search(int[] nums,int target, boolean isFirstOccurence){\\n        int index = -1;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        \\n        while(start <= end){\\n            int mid =start + (end - start)/2;\\n            \\n            if(target>nums[mid]){\\n                start = mid+1;\\n            }else if(target < nums[mid]){\\n                end = mid -1;\\n            }else{\\n                index=mid;\\n                if(isFirstOccurence){\\n                    end=mid-1;\\n                }else{\\n                    start=mid+1;\\n                }\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203511,
                "title": "step-by-step-commentary-two-binary-search-logn-complexity-js-es6",
                "content": "`Algorithm:`\\n> - Start with a classic Binary search solution\\n> - Do not stop at the target rather continue traversing to the left side of the list. \\n> - Pay close attention to code difference between two binary search: \\n\\t\\t\\t> First-Position Vs Last-Position \\n\\t\\t\\t> Notice the difference in equality \"=\" sign\\n> - At the end of first binary search, if the number wasn\\'t found, terminate early and return [-1,-1]\\n> - Perform second binary search for Last-Position\\n\\t> Return results\\n```\\nconst searchRange = function(nums, target) {\\n    let firstPosition = -1, lastPosition = -1;\\n    let lo = 0, hi=nums.length-1; \\n    \\n    // Search firstPosition\\n    while(lo<=hi){\\n        let mid = Math.floor((lo+hi)/2);\\n        if(nums[mid] >= target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    \\n    // Check if number exists\\n    if(nums[lo] !== target) return [-1, -1];\\n    firstPosition = lo;\\n    \\n    // Reset pointers\\n    let lo =0, hi=nums.length-1; \\n    \\n    // Search lastPosition\\n    while(lo<=hi){\\n        let mid =  Math.floor((lo+hi)/2);\\n        if(nums[mid] > target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    lastPosition=hi;\\n    \\n    return [firstPosition, lastPosition]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nconst searchRange = function(nums, target) {\\n    let firstPosition = -1, lastPosition = -1;\\n    let lo = 0, hi=nums.length-1; \\n    \\n    // Search firstPosition\\n    while(lo<=hi){\\n        let mid = Math.floor((lo+hi)/2);\\n        if(nums[mid] >= target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    \\n    // Check if number exists\\n    if(nums[lo] !== target) return [-1, -1];\\n    firstPosition = lo;\\n    \\n    // Reset pointers\\n    let lo =0, hi=nums.length-1; \\n    \\n    // Search lastPosition\\n    while(lo<=hi){\\n        let mid =  Math.floor((lo+hi)/2);\\n        if(nums[mid] > target) hi = mid-1;\\n        else lo=mid+1;\\n    }\\n    lastPosition=hi;\\n    \\n    return [firstPosition, lastPosition]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181940,
                "title": "c-short-std-equal-range-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto [l, r] = equal_range(begin(nums), end(nums), target);\\n        if (l == end(nums) || *l != target)\\n            return {-1, -1};\\n\\n        int i = l - begin(nums), j = r - 1 - begin(nums);\\n        return {i, j};\\n    }\\n};\\n```\\n\\n[See `std::equal_range()`](https://en.cppreference.com/w/cpp/algorithm/equal_range) (it performs both a `std::lower_bound()` and `std::upper_bound()` in one call).",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        auto [l, r] = equal_range(begin(nums), end(nums), target);\\n        if (l == end(nums) || *l != target)\\n            return {-1, -1};\\n\\n        int i = l - begin(nums), j = r - 1 - begin(nums);\\n        return {i, j};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181869,
                "title": "find-first-and-last-position-of-element-in-sorted-array-simple-solution-explained",
                "content": "**DO UPVOTE if you find it helpful!!**\\n\\n**Approach-1 : Brute force**: We have to just iterate the nums array and find the first and last position of target. This solution got accepted since the constraints are small (10^5). I wonder why the constraints for this question are such small, because this is not the efficient way for this problem!! \\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                if(res[0] == -1)\\n                    res[0] = i,res[1]=i;\\n                else\\n                    res[1] =i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Time Complexity**:O(n)\\n**Space Complexity**:O(1)\\n\\n**Approach-2: Binary Search**: Here we use two binary searches to find first and last occurance of target.\\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        if(nums.size()==0) return res;\\n        int i=0, j= nums.size()-1;\\n        // finding the first occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] < target)\\n                i=mid+1;\\n            else \\n                j = mid;\\n        }\\n        if(nums[j] == target) res[0] =j;    \\n        else return res;                // If there is no first occurance, then we directly return res\\n        j=nums.size()-1;                //again we dont have to initialize i from beginning\\n        // Finding last occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2+1;        // To make sure that mid is biased towards right, \\n            if(nums[mid]<=target)       // so that, it wont stuck at a particular case.\\n                i = mid;\\n            else \\n                j = mid-1;\\n        }\\n        res[1] =j;\\n        return res;\\n    }\\n```\\n**Time Complexity**:O(log(n))\\n**Space Complexity**:O(1)\\n\\n**Note:** There is other approach using STL, making use of inbuilt functions like `lower_bound` and `upper_bound`. But, this is not an ideal way to solve for this problem, many interviewers expect to solve this problem using binary search approach.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                if(res[0] == -1)\\n                    res[0] = i,res[1]=i;\\n                else\\n                    res[1] =i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>res = {-1,-1};\\n        if(nums.size()==0) return res;\\n        int i=0, j= nums.size()-1;\\n        // finding the first occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] < target)\\n                i=mid+1;\\n            else \\n                j = mid;\\n        }\\n        if(nums[j] == target) res[0] =j;    \\n        else return res;                // If there is no first occurance, then we directly return res\\n        j=nums.size()-1;                //again we dont have to initialize i from beginning\\n        // Finding last occurance of target in nums array\\n        while(i<j){\\n            int mid = (i+j)/2+1;        // To make sure that mid is biased towards right, \\n            if(nums[mid]<=target)       // so that, it wont stuck at a particular case.\\n                i = mid;\\n            else \\n                j = mid-1;\\n        }\\n        res[1] =j;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935218,
                "title": "c-two-solutions",
                "content": "# Solution 1\\n\\n```\\nclass Solution {\\nprivate:\\n    int m_findLow(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance low only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    int m_findHigh(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance high only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\t\\npublic:\\n\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int size = nums.size(), low = 0, high = size - 1, mid;\\n        vector<int> pos(2, -1);\\n\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//First check if the target is present in the list at all\\n            if (nums[mid] == target) {\\n                if (nums[low] != target) {\\n\\t\\t\\t\\t\\t//Low should be in the lower half\\n                    low = m_findLow(nums, target, low, mid);\\n                }\\n                if (nums[high] != target) {\\n\\t\\t\\t\\t\\t//High should be in the upper half\\n                    high = m_findHigh(nums, target, mid, high);\\n                }\\n                pos[0] = low;\\n                pos[1] = high;\\n                break;\\n            }\\n            else if (nums[mid] > target && nums[high] != target) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid] < target && nums[low] != target) {\\n                low = mid + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\\n\\n# Solution 2\\nRuntime: 4 ms, faster than 95.75% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\nMemory Usage: 13.7 MB, less than 12.23% of C++ online submissions for Find First and Last Position of Element in Sorted Array.\\n\\n```\\nclass Solution {\\n\\tint findLow(const vector<int>& nums, int target) {\\n\\t\\tint low = 0, high = nums.size() - 1, mid = 0, lowPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlowPos = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn lowPos;\\n\\t}\\n\\n\\tint findHigh(const vector<int>& nums, int target, int l) {\\n\\t\\tint low = l, high = nums.size() - 1, mid = 0, highPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\thighPos = mid;\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn highPos;\\n\\t}\\npublic:\\n\\tvector<int> searchRange(vector<int>& nums, int target)\\n\\t{\\n\\t\\tint low = findLow(nums, target);\\n\\t\\tint high = -1;\\n\\t\\tif (low >= 0)\\n\\t\\t\\thigh = findHigh(nums, target, low);\\n\\t\\treturn vector<int>({ low, high });\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int m_findLow(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance low only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                high = mid - 1;\\n            }\\n            else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n\\n    int m_findHigh(vector<int> &nums, int target, int low, int high)\\n    {\\n        int mid;\\n        while (low <= high) {\\n            mid = low + (high-low)/2;\\n\\t\\t\\t//Advance high only if it is not pointing to target\\n            if( nums[mid] == target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\t\\npublic:\\n\\n    vector<int> searchRange(vector<int> &nums, int target)\\n    {\\n        int size = nums.size(), low = 0, high = size - 1, mid;\\n        vector<int> pos(2, -1);\\n\\n        while (low <= high) {\\n            mid = low + (high - low) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//First check if the target is present in the list at all\\n            if (nums[mid] == target) {\\n                if (nums[low] != target) {\\n\\t\\t\\t\\t\\t//Low should be in the lower half\\n                    low = m_findLow(nums, target, low, mid);\\n                }\\n                if (nums[high] != target) {\\n\\t\\t\\t\\t\\t//High should be in the upper half\\n                    high = m_findHigh(nums, target, mid, high);\\n                }\\n                pos[0] = low;\\n                pos[1] = high;\\n                break;\\n            }\\n            else if (nums[mid] > target && nums[high] != target) {\\n                high = mid - 1;\\n            }\\n            else if (nums[mid] < target && nums[low] != target) {\\n                low = mid + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tint findLow(const vector<int>& nums, int target) {\\n\\t\\tint low = 0, high = nums.size() - 1, mid = 0, lowPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tlowPos = mid;\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn lowPos;\\n\\t}\\n\\n\\tint findHigh(const vector<int>& nums, int target, int l) {\\n\\t\\tint low = l, high = nums.size() - 1, mid = 0, highPos = -1;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tmid = low + (high - low) / 2;\\n\\t\\t\\tif (target < nums[mid]) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (target > nums[mid]) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\thighPos = mid;\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn highPos;\\n\\t}\\npublic:\\n\\tvector<int> searchRange(vector<int>& nums, int target)\\n\\t{\\n\\t\\tint low = findLow(nums, target);\\n\\t\\tint high = -1;\\n\\t\\tif (low >= 0)\\n\\t\\t\\thigh = findHigh(nums, target, low);\\n\\t\\treturn vector<int>({ low, high });\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769254,
                "title": "c-solution-o-log-n",
                "content": "```\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int l=0, r=numsSize-1, mid = r/2;\\n    *returnSize = 2;\\n    int* res = malloc(sizeof(int)*2);\\n    res[0] = -1; res[1] = -1;\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (target == nums[mid]) // might be in both sides\\n        {\\n            int mid2 = mid;\\n            while (l < mid)\\n            {\\n                int l_mid = (mid+l)/2;\\n                if (nums[l_mid] < target)\\n                    l = l_mid+1;\\n                \\n                else\\n                    mid = l_mid;\\n            }\\n            while (mid2 < r)\\n            {\\n                int r_mid = (mid2+r+1)/2;\\n                if (nums[r_mid] >  target)\\n                    r = r_mid-1;\\n\\n                else\\n                    mid2 = r_mid;\\n            \\n            }\\n            res[0] = l; res[1] = r;\\n            return res;\\n        }\\n        else if (target < nums[mid]) // not in right side\\n            r = mid-1;\\n\\n        else if (target > nums[mid]) // not in left side\\n            l = mid+1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int l=0, r=numsSize-1, mid = r/2;\\n    *returnSize = 2;\\n    int* res = malloc(sizeof(int)*2);\\n    res[0] = -1; res[1] = -1;\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (target == nums[mid]) // might be in both sides\\n        {\\n            int mid2 = mid;\\n            while (l < mid)\\n            {\\n                int l_mid = (mid+l)/2;\\n                if (nums[l_mid] < target)\\n                    l = l_mid+1;\\n                \\n                else\\n                    mid = l_mid;\\n            }\\n            while (mid2 < r)\\n            {\\n                int r_mid = (mid2+r+1)/2;\\n                if (nums[r_mid] >  target)\\n                    r = r_mid-1;\\n\\n                else\\n                    mid2 = r_mid;\\n            \\n            }\\n            res[0] = l; res[1] = r;\\n            return res;\\n        }\\n        else if (target < nums[mid]) // not in right side\\n            r = mid-1;\\n\\n        else if (target > nums[mid]) // not in left side\\n            l = mid+1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561766,
                "title": "java-template-iii-solution",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int x) {\\n        if (nums.length == 0) return new int[]{-1,-1};\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < x) start = mid;\\n            else end = mid;\\n        }\\n        int left = nums[start] == x ? start : end;\\n        if (nums[left] != x) return new int[]{-1,-1};\\n        start = left;\\n        end = nums.length - 1;\\n        while(start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= x) start = mid;\\n            else end = mid;\\n        }\\n        int right = nums[end] == x ? end : start;\\n        return new int[]{left,right};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int x) {\\n        if (nums.length == 0) return new int[]{-1,-1};\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < x) start = mid;\\n            else end = mid;\\n        }\\n        int left = nums[start] == x ? start : end;\\n        if (nums[left] != x) return new int[]{-1,-1};\\n        start = left;\\n        end = nums.length - 1;\\n        while(start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= x) start = mid;\\n            else end = mid;\\n        }\\n        int right = nums[end] == x ? end : start;\\n        return new int[]{left,right};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392634,
                "title": "inspired-by-the-solution-in-book-elements-of-programming-interview",
                "content": "This is inspired by the solution of `Elements of Programming Interview`. Off all the solutions, this was the most intutive approach to me.\\n\\nWe do the binary search twice. Once to find the first occurance and another to find the last occurance.\\n\\n##### Find the first occurance\\n\\nWe do the normal binary search. Once we find the target, we know that *nothing to it\\'s right* can be the first occurance.\\nMaybe the mid is the first occurance, maybe not. So we keep doing the search , but narrow the search range from [0...mid-1].\\n\\n##### Find the last occurance\\n\\nWe do the normal binary search. Once we find the target, we know that *nothing to it\\'s left* can be the last occurance.\\nMaybe the mid is the last occurance, maybe not. So we keep doing the search , but narrow the search range from [mid +1...high].\\n\\n\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] result = new int[2];\\n        result[0] = findFirst(nums,target);\\n        result[1] = findLast(nums,target);\\n        return result;\\n        \\n    }\\n    \\n    public int findFirst(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n\\n        while(low <= high){\\n            int mid = low + ((high-low)/2);\\n\\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n\\n                // because nothing after mid\\n                // can be the first occurance of target.\\n                //maybe mid is the first occurance , maybe not\\n                //so let\\'s narrow the target for [0...mid-1] and find out\\n                high = mid - 1; \\n   \\n            }\\n        }\\n\\n        return result;\\n  \\n    }\\n    \\n        public int findLast(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n                // because nothing before mid\\n                // can be the last occurance of target.\\n                //maybe mid is the last occurance , maybe not\\n                //so let\\'s narrow the target for [mid+1...high] and find                   // out\\n                low = mid + 1;\\n   \\n            }\\n        }\\n\\n        return result;\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] result = new int[2];\\n        result[0] = findFirst(nums,target);\\n        result[1] = findLast(nums,target);\\n        return result;\\n        \\n    }\\n    \\n    public int findFirst(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n\\n        while(low <= high){\\n            int mid = low + ((high-low)/2);\\n\\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n\\n                // because nothing after mid\\n                // can be the first occurance of target.\\n                //maybe mid is the first occurance , maybe not\\n                //so let\\'s narrow the target for [0...mid-1] and find out\\n                high = mid - 1; \\n   \\n            }\\n        }\\n\\n        return result;\\n  \\n    }\\n    \\n        public int findLast(int[] nums, int target){\\n        \\n        int result = -1;\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n            if (nums[mid] < target){\\n                low = mid +1;\\n            } else if (nums[mid] > target){\\n                high = mid - 1;\\n            } else { // nums[mid] == target\\n                result = mid;\\n                // because nothing before mid\\n                // can be the last occurance of target.\\n                //maybe mid is the last occurance , maybe not\\n                //so let\\'s narrow the target for [mid+1...high] and find                   // out\\n                low = mid + 1;\\n   \\n            }\\n        }\\n\\n        return result;\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14781,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Search for a Range** https://leetcode.com/problems/search-for-a-range/\\n\\n**Algorithm**\\n* Use binary search to find the lower and upper bound\\n\\n```\\nclass Solution(object):\\n    def get_lower_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                high = mid-1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n    \\n    def get_upper_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                low = mid+1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        lower_bound = self.get_lower_bound(nums, target)\\n        upper_bound = self.get_upper_bound(nums, target)\\n        return [lower_bound, upper_bound]        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def get_lower_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                high = mid-1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n    \\n    def get_upper_bound(self, nums, target):\\n        low, high = 0, len(nums)-1\\n        ans = -1\\n        while low <= high:\\n            mid = low + (high-low)//2\\n            if nums[mid] == target:\\n                ans = mid\\n                low = mid+1\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n        \\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        lower_bound = self.get_lower_bound(nums, target)\\n        upper_bound = self.get_upper_bound(nums, target)\\n        return [lower_bound, upper_bound]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 14945,
                "title": "java-1ms-solution-recursive-binary-search-structure-clear-and-simple-code-style-better",
                "content": "    public int[] searchRange(int[] nums, int target) {\\n        if(nums==null || nums.length==0){\\n            return new int[]{-1,-1};\\n        }\\n        else{\\n            return new int[]{\\n                getLeftBoundary(nums,0, nums.length-1,target),\\n                getRightBoundary(nums,0, nums.length-1,target)\\n            };\\n        }\\n    }\\n    private int getLeftBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n        int mid = (start+end)/2;\\n        if(nums[mid]<target){\\n            return getLeftBoundary(nums, mid+1, end, target);\\n        }\\n        else{\\n            return getLeftBoundary(nums, start, mid, target);\\n        }\\n    }\\n    private int getRightBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n\\n        int mid = end-(end-start)/2;\\n        if(nums[mid]>target){\\n            return getRightBoundary(nums, start, mid-1, target);\\n        }\\n        else{\\n            return getRightBoundary(nums, mid, end, target);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "    public int[] searchRange(int[] nums, int target) {\\n        if(nums==null || nums.length==0){\\n            return new int[]{-1,-1};\\n        }\\n        else{\\n            return new int[]{\\n                getLeftBoundary(nums,0, nums.length-1,target),\\n                getRightBoundary(nums,0, nums.length-1,target)\\n            };\\n        }\\n    }\\n    private int getLeftBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n        int mid = (start+end)/2;\\n        if(nums[mid]<target){\\n            return getLeftBoundary(nums, mid+1, end, target);\\n        }\\n        else{\\n            return getLeftBoundary(nums, start, mid, target);\\n        }\\n    }\\n    private int getRightBoundary(int[] nums, int start, int end, int target){\\n        if(start==end){\\n            if(nums[start]==target){\\n                return start;\\n            }\\n            return -1;\\n        }\\n\\n        int mid = end-(end-start)/2;\\n        if(nums[mid]>target){\\n            return getRightBoundary(nums, start, mid-1, target);\\n        }\\n        else{\\n            return getRightBoundary(nums, mid, end, target);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3827753,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we need to find the starting and ending index of the given target and return an array of {startidx,endidx} and if target is not present return {-1,-1} array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExplained in the code.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        Arrays.fill(arr,-1);\\n        //elements set to -1 by default\\n        if(nums.length==1 && nums[0]==target){\\n            /*if length of given array is 1 and the target is present at\\n            the 0th index then return {0,0} array.*/\\n            Arrays.fill(arr,0);\\n            return arr;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            //finding the starting index of the target\\n            if(nums[i]==target){\\n                arr[0] = i;\\n                break;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--){\\n            //finding the last index of the target\\n            if(nums[i]==target){\\n                arr[1] = i;\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/49c89904-af56-4280-862f-9a43e750a6c0_1690533080.951863.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        Arrays.fill(arr,-1);\\n        //elements set to -1 by default\\n        if(nums.length==1 && nums[0]==target){\\n            /*if length of given array is 1 and the target is present at\\n            the 0th index then return {0,0} array.*/\\n            Arrays.fill(arr,0);\\n            return arr;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            //finding the starting index of the target\\n            if(nums[i]==target){\\n                arr[0] = i;\\n                break;\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--){\\n            //finding the last index of the target\\n            if(nums[i]==target){\\n                arr[1] = i;\\n                break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808512,
                "title": "python-solution-using-bisect-module",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        import bisect\\n        start=bisect.bisect_left(nums,target)      \\n        end=bisect.bisect_right(nums,target)\\n        if start>end-1:\\n            return [-1,-1]\\n        return [start,end-1]\\n```\\n**Steps:**\\n1. Import the \\'bisect\\' module for efficient binary search operations.\\n2. Find the leftmost index where \\'target\\' could be inserted in \\'nums\\' while maintaining sorted order.\\n3. Find the rightmost index where \\'target\\' could be inserted in \\'nums\\' while maintaining sorted order.\\n4. If \\'start\\' is greater than \\'end-1\\', it means \\'target\\' is not found in \\'nums\\'.\\n\\tReturn [-1, -1] to indicate that the target is not present.\\n5. Return the leftmost and rightmost indices of \\'target\\' in \\'nums\\'.\\n\\n**Time Complexity:** O(log n)\\n**Space Complexity:** O(1) \\n\\nReference: https://docs.python.org/3/library/bisect.html \\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        import bisect\\n        start=bisect.bisect_left(nums,target)      \\n        end=bisect.bisect_right(nums,target)\\n        if start>end-1:\\n            return [-1,-1]\\n        return [start,end-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774390,
                "title": "binary-search-java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int ans[]=new int[2];\\n        ans[0]=searchFirst(nums,target);\\n        ans[1]=searchLast(nums,target);\\n        return ans;\\n    }\\n\\n    public int searchFirst(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int searchLast(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                low=mid+1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n        int ans[]=new int[2];\\n        ans[0]=searchFirst(nums,target);\\n        ans[1]=searchLast(nums,target);\\n        return ans;\\n    }\\n\\n    public int searchFirst(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                high=mid-1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int searchLast(int[] nums, int target){\\n        int low=0;\\n        int high=nums.length-1;\\n        int res=-1;\\n        while(low<=high){\\n            int mid=(low+(high-low)/2);\\n            \\n            if(nums[mid]==target){\\n                res=mid;\\n                low=mid+1;\\n            }\\n            \\n            else if(target>nums[mid]){             \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432042,
                "title": "runtime-0s-beats-100-and-in-memory-beats-90-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans={-1,-1};\\n        int start=search(nums,target,true);\\n        int end=search(nums,target,false);\\n        ans[0]=start;\\n        ans[1]=end;\\n        return ans;\\n    }\\n    public int search(int[] arr,int target,boolean findStartIndex)\\n    {\\n        int ans=-1;\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target<arr[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(findStartIndex)\\n                {\\n                    end=mid-1;\\n                }\\n                else start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] ans={-1,-1};\\n        int start=search(nums,target,true);\\n        int end=search(nums,target,false);\\n        ans[0]=start;\\n        ans[1]=end;\\n        return ans;\\n    }\\n    public int search(int[] arr,int target,boolean findStartIndex)\\n    {\\n        int ans=-1;\\n        int start=0;\\n        int end=arr.length-1;\\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            if(target<arr[mid])\\n            {\\n                end=mid-1;\\n            }\\n            else if(target>arr[mid])\\n            {\\n                start=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                if(findStartIndex)\\n                {\\n                    end=mid-1;\\n                }\\n                else start=mid+1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244584,
                "title": "solution-using-binary-search-in-just-o-logn-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int firstOccur(int []nums,int target)\\n    {\\n       int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               end=mid-1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n    \\n       return index; \\n    }\\n     public static int lastOccur(int []nums,int target)\\n    {\\n        int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               start=mid+1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n       \\n       return index;  \\n    }\\n    public int[] searchRange(int[] nums, int target) \\n            {\\n                int []ans=new int [2];\\n          ans[0]=  firstOccur(nums,target);\\n            ans[1]=lastOccur(nums,target);\\n            return ans;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int firstOccur(int []nums,int target)\\n    {\\n       int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               end=mid-1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n    \\n       return index; \\n    }\\n     public static int lastOccur(int []nums,int target)\\n    {\\n        int start=0;\\n       int end=nums.length-1;\\n       int index=-1;\\n       while(start<=end)\\n       {\\n           int mid=start+(end-start)/2;\\n           if(nums[mid]==target)\\n           {\\n               index=mid;\\n               start=mid+1;\\n           }\\n           else if(nums[mid]>target)\\n           {\\n               end=mid-1;\\n           }\\n           else\\n           {\\n               start=mid+1;\\n           }\\n       }\\n       \\n       return index;  \\n    }\\n    public int[] searchRange(int[] nums, int target) \\n            {\\n                int []ans=new int [2];\\n          ans[0]=  firstOccur(nums,target);\\n            ans[1]=lastOccur(nums,target);\\n            return ans;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240027,
                "title": "python3-beats-88-99-easy-solution",
                "content": "# **I request you guys to please upvote if you find the solution helpful.**\\n![image.png](https://assets.leetcode.com/users/images/5e5843ec-e655-4431-88b3-0bcea1515997_1677590304.8684895.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        pos = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                pos.append(i)\\n        if len(pos) == 0:\\n            pos.append(-1)\\n            pos.append(-1)\\n            return pos\\n        else:\\n            pos1 = []\\n            pos1.append(min(pos))\\n            pos1.append(max(pos))\\n            return pos1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        pos = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                pos.append(i)\\n        if len(pos) == 0:\\n            pos.append(-1)\\n            pos.append(-1)\\n            return pos\\n        else:\\n            pos1 = []\\n            pos1.append(min(pos))\\n            pos1.append(max(pos))\\n            return pos1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080147,
                "title": "c-java-clear-simple-basic-binary-search-tc-log-n-sc-o-1",
                "content": "\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void lowerBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    void higherBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public static void lowerBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public static void higherBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int []ans=new int[2];\\n        Arrays.fill(ans,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n}\\n```\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void lowerBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    void higherBound(vector<int>&nums,int target,vector<int>&ans){\\n        int low=0,high=nums.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>ans(2,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public static void lowerBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[0]=mid;\\n                // search left side to find the first occurrence\\n                high=mid-1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public static void higherBound(int []nums,int target,int []ans){\\n        int low=0,high=nums.length-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(nums[mid]==target){\\n                ans[1]=mid;\\n                //search right side to find the last occurrence\\n                low=mid+1;\\n            }\\n            else if(nums[mid]<target)   low=mid+1;\\n            else high=mid-1;\\n        }\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int []ans=new int[2];\\n        Arrays.fill(ans,-1);\\n        lowerBound(nums,target,ans);\\n        higherBound(nums,target,ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028659,
                "title": "fast-two-binary-search-approach",
                "content": "# Intuition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1,-1]\\n        l = 0\\n        r = len(nums) - 1\\n        while l<r:\\n            mid = (l+r) // 2\\n            if nums[mid] < target:\\n                l = mid +1\\n            elif nums[mid] == target:\\n                r = mid \\n            else:\\n                r = mid - 1\\n        \\n        if nums[l] != target:\\n            return [-1,-1]\\n        else:\\n            \\n            end = start = l\\n            r = len(nums) - 1\\n            while l<=r:\\n                \\n                mid = (l+r) // 2\\n                if nums[mid] == target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            end = r        \\n            return [start,end]\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if not nums:\\n            return [-1,-1]\\n        l = 0\\n        r = len(nums) - 1\\n        while l<r:\\n            mid = (l+r) // 2\\n            if nums[mid] < target:\\n                l = mid +1\\n            elif nums[mid] == target:\\n                r = mid \\n            else:\\n                r = mid - 1\\n        \\n        if nums[l] != target:\\n            return [-1,-1]\\n        else:\\n            \\n            end = start = l\\n            r = len(nums) - 1\\n            while l<=r:\\n                \\n                mid = (l+r) // 2\\n                if nums[mid] == target:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            end = r        \\n            return [start,end]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904660,
                "title": "java-solution-using-binary-search",
                "content": "\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] res = new int[2];\\n\\n        int x = -1;\\n        int y = -1;\\n\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n\\n        while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                x = mid;\\n                end = mid-1;\\n\\n            }else if (nums[mid] < target){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n\\n        }\\n\\n         start = 0;\\n         end = nums.length-1;\\n       \\n         while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                y = mid;\\n                start = mid+1;\\n                \\n            }else if (nums[mid] < target){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n\\n        }\\n   \\n\\n            res[0] = x;\\n            res[1] = y;\\n   \\n\\n            return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int[] res = new int[2];\\n\\n        int x = -1;\\n        int y = -1;\\n\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n\\n        while( start <= end ){\\n\\n            int mid = (start+end)/2;\\n            \\n            if( nums[mid] == target ){\\n                \\n                x = mid;\\n                end = mid-1;\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2810980,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint start=0, end=n-1, start1=0, end1=n-1, first=-1, last=-1;\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tfirst=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(target>nums[mid]){\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target<nums[mid]){\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(first==-1){\\n\\t\\t\\t\\tv.push_back(-1);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tv.push_back(first);\\n\\t\\t\\t}\\n\\t\\t\\twhile(start1<=end1){\\n\\t\\t\\t\\tint mid=start1+(end1-start1)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tlast=mid;\\n\\t\\t\\t\\t\\tstart1=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target>nums[mid]){\\n\\t\\t\\t\\t\\tstart1=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(target<nums[mid]){\\n\\t\\t\\t\\t\\tend1=mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(last==-1){\\n\\t\\t\\t\\tv.push_back(-1);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tv.push_back(last);\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint start=0, end=n-1, start1=0, end1=n-1, first=-1, last=-1;\\n\\t\\t\\twhile(start<=end){\\n\\t\\t\\t\\tint mid=start+(end-start)/2;\\n\\t\\t\\t\\tif(target==nums[mid]){\\n\\t\\t\\t\\t\\tfirst=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2751170,
                "title": "c-easiest-and-clean-code-with-binary-search-explanation-fast-runtime",
                "content": "Here, basically we are trying to reduce our search space in our interested side, we will reduce search space left side if we want first index (as array is already sorted) .Similarily , we can say for last index will lie on right side of array\\n\\nCondition:- \\n-->end = mid-1; \\nhelping us to reduce search space in left side of array , as our interested side if first index\\n\\n-->start = mid+1\\nhelping us to reduce search space in right side of array , as our interested side if last index\\n\\n**Make Sure To Dry Run This Code, For Better Understanding**\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tDo Upvote If You Like This\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\n\\t//Finding First Occurrence Of Target\\n        int start = 0,end = nums.size()-1;\\n        int mid,str = -1,last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;          \\n            \\n            if(nums[mid] == target){\\n                str = mid;                       //storing index if our target element is found\\n                end = mid-1;                     //condition for first occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n\\t\\t\\n        //Finding Last Occurence Of Target\\n        start = 0,end = nums.size()-1;\\n        last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target){\\n                last = mid;                    //storing index if our target element is found\\n                start = mid+1;                 //condition for last occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        \\n        return {str,last};                return first and last index of element\\n        \\n    }\\n};\\n```\\n**Time Complexity :- O(logN)\\nSpace Complexity :- O(1)**\\n",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\t\\n\\t//Finding First Occurrence Of Target\\n        int start = 0,end = nums.size()-1;\\n        int mid,str = -1,last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;          \\n            \\n            if(nums[mid] == target){\\n                str = mid;                       //storing index if our target element is found\\n                end = mid-1;                     //condition for first occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n\\t\\t\\n        //Finding Last Occurence Of Target\\n        start = 0,end = nums.size()-1;\\n        last = -1;\\n        \\n        while(start <= end){\\n            mid = start + (end-start)/2;\\n            \\n            if(nums[mid] == target){\\n                last = mid;                    //storing index if our target element is found\\n                start = mid+1;                 //condition for last occurence\\n            }\\n            \\n            else if(nums[mid] < target){\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        \\n        return {str,last};                return first and last index of element\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686811,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution \\n{\\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int low,high,mid,ans1=-1;\\n        low = 0;\\n        high = nums.length-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans1 = mid;\\n                high = mid-1; // To get the first occurence of the element \\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        low = 0;\\n        high = nums.length-1;\\n        int ans2=-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans2 = mid;\\n                low = mid+1; // To get the last occurence of the element\\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return new int[]{ans1,ans2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] searchRange(int[] nums, int target) \\n    {\\n        int low,high,mid,ans1=-1;\\n        low = 0;\\n        high = nums.length-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans1 = mid;\\n                high = mid-1; // To get the first occurence of the element \\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        low = 0;\\n        high = nums.length-1;\\n        int ans2=-1;\\n        \\n        while(low<=high)\\n        {\\n            mid = (low+high)/2;\\n            if(nums[mid] == target)\\n            {\\n                ans2 = mid;\\n                low = mid+1; // To get the last occurence of the element\\n            }\\n            else if(nums[mid]<target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return new int[]{ans1,ans2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435482,
                "title": "c-solution-binary-search-better-than-99-26-3ms-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int t) {\\n        int n = nums.size();\\n        vector<int> ans(2, -1);\\n\\t\\t\\n\\t\\t// if there are no elements in nums\\n        if(n==0)    return ans;\\n        \\n\\t\\t// initialized low(l), and high(r)\\n        int l=0, r = n-1, m;\\n        while(l<=r){\\n            m = l + (r-l)/2;\\n            if(nums[m]>=t)   r = m-1;\\n            else    l = m+1;\\n        }\\n\\t\\t\\n\\t\\t// here are three cases:\\n\\t\\t// if 1st element is smaller than target, then l =0, r=-1, so we exit.\\n\\t\\t// if last element is smaller than target, then l=n, and r=n-1, so we exit.\\n\\t\\t// if first element is greater than target, then r=-1, and l =0, but first element is not target, so we exit.\\n        if((l!=0 && r==-1) || (l>=n && r==n-1) || nums[r+1]!=t)   return ans;\\n\\t\\t\\n\\t\\t// else the next index after r, is the first element for first occurence.\\n        ans[0] = r+1;\\n        \\n        l = 0, r = n-1;\\n        while(l<=r){\\n            m = l+(r-l)/2;\\n            if(nums[m]<=t)   l = m+1;\\n            else    r = m-1;            \\n        }\\n\\t\\t\\n\\t\\t// the last occurence may be the same as the first occurence or the last occurence.\\n        ans[1] = l-1;\\n        return ans;\\n\\t}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2042d3c9-56a7-45ec-a44e-1d47a951b012_1660672717.4123282.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int t) {\\n        int n = nums.size();\\n        vector<int> ans(2, -1);\\n\\t\\t\\n\\t\\t// if there are no elements in nums\\n        if(n==0)    return ans;\\n        \\n\\t\\t// initialized low(l), and high(r)\\n        int l=0, r = n-1, m;\\n        while(l<=r){\\n            m = l + (r-l)/2;\\n            if(nums[m]>=t)   r = m-1;\\n            else    l = m+1;\\n        }\\n\\t\\t\\n\\t\\t// here are three cases:\\n\\t\\t// if 1st element is smaller than target, then l =0, r=-1, so we exit.\\n\\t\\t// if last element is smaller than target, then l=n, and r=n-1, so we exit.\\n\\t\\t// if first element is greater than target, then r=-1, and l =0, but first element is not target, so we exit.\\n        if((l!=0 && r==-1) || (l>=n && r==n-1) || nums[r+1]!=t)   return ans;\\n\\t\\t\\n\\t\\t// else the next index after r, is the first element for first occurence.\\n        ans[0] = r+1;\\n        \\n        l = 0, r = n-1;\\n        while(l<=r){\\n            m = l+(r-l)/2;\\n            if(nums[m]<=t)   l = m+1;\\n            else    r = m-1;            \\n        }\\n\\t\\t\\n\\t\\t// the last occurence may be the same as the first occurence or the last occurence.\\n        ans[1] = l-1;\\n        return ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333076,
                "title": "c-solution-easy-approach-comments-fast-than-92",
                "content": "```\\nvector<int> searchRange(vector<int>& nums, int t) {\\n\\tint n = nums.size();\\n\\tvector<int> ans(2, -1);\\n\\t// To check if the array is empty\\n\\tif(n==0)    return ans;\\n\\t// To check if array has only one element\\n\\telse if(nums.size()==1){\\n\\t\\tif(nums[0]==t)\\t\\t\\treturn {0, 0};\\n\\t\\treturn ans;\\n\\t}\\n\\t// If first element of array is our target\\n\\tif(t==nums[0])  ans[0] = 0;\\n\\t// Else we do binary search for the first element in array\\n\\telse{\\n\\t\\tint low =0, high = n-1;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid-1]<nums[mid]){\\n\\t\\t\\t\\tans[0] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]>=t)   high = mid;\\n\\t\\t\\telse                    low = mid+1;\\n\\t\\t}\\n\\t}\\n\\t// If last element if our target\\n\\tif(t==nums[n-1])  ans[1] = n-1;\\n\\t// Else we do binary search for the last element in array\\n\\telse{\\n\\t\\tint low =0, high = n;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid]<nums[mid+1] && ans[0]!=mid){\\n\\t\\t\\t\\tans[1] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]<=t)   low = mid+1;\\n\\t\\t\\telse                    high = mid;\\n\\t\\t}\\n\\t}\\n\\t// Checking the boundary cases\\n\\tif(ans[0]!=-1 && ans[1]==-1) \\t\\tans[1]=ans[0];\\n\\telse if(ans[1]!=-1 && ans[0]==-1)\\t\\tans[0]=ans[1];\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int t) {\\n\\tint n = nums.size();\\n\\tvector<int> ans(2, -1);\\n\\t// To check if the array is empty\\n\\tif(n==0)    return ans;\\n\\t// To check if array has only one element\\n\\telse if(nums.size()==1){\\n\\t\\tif(nums[0]==t)\\t\\t\\treturn {0, 0};\\n\\t\\treturn ans;\\n\\t}\\n\\t// If first element of array is our target\\n\\tif(t==nums[0])  ans[0] = 0;\\n\\t// Else we do binary search for the first element in array\\n\\telse{\\n\\t\\tint low =0, high = n-1;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid-1]<nums[mid]){\\n\\t\\t\\t\\tans[0] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]>=t)   high = mid;\\n\\t\\t\\telse                    low = mid+1;\\n\\t\\t}\\n\\t}\\n\\t// If last element if our target\\n\\tif(t==nums[n-1])  ans[1] = n-1;\\n\\t// Else we do binary search for the last element in array\\n\\telse{\\n\\t\\tint low =0, high = n;\\n\\t\\twhile(low<high){\\n\\t\\t\\tint mid = (low+high)/2;\\n\\t\\t\\tif(nums[mid]==t && nums[mid]<nums[mid+1] && ans[0]!=mid){\\n\\t\\t\\t\\tans[1] = mid; break;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[mid]<=t)   low = mid+1;\\n\\t\\t\\telse                    high = mid;\\n\\t\\t}\\n\\t}\\n\\t// Checking the boundary cases\\n\\tif(ans[0]!=-1 && ans[1]==-1) \\t\\tans[1]=ans[0];\\n\\telse if(ans[1]!=-1 && ans[0]==-1)\\t\\tans[0]=ans[1];\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330367,
                "title": "easy-to-understand-binary-search-solution-with-explanation",
                "content": "Easy solution using binary search since list is already sorted. In this solution even if number is not in the list will take atleast O(log n) time.\\n\\nSteps:\\n\\n1.  If length of nums is zero or length of nums is 1 and that element too is not equal to target then in both these cases we return [-1,-1].\\n2.  If  in case when whole list consist only target element Ex. [3,3,3,3,3,3,3,3,3,3], then in this case we return [0, len(nums)-1].\\n3.  Now if both the cases above don\\'t work then we start the binary search. we calculate mid of the list nums then:\\n a)\\tIf  nums[mid] is equal to target:\\n \\n\\t we check on left and right side of the mid to determine begining and ending index, since list is            sorted all same elements will be side by side.\\n\\t\\n\\ta1) we check left side of the mid for beginning index:\\n\\t   To reduce the runtime for list like [3,3,3,4,5] I check if zero element of the list is equal to target if it is equal then we already found our left most index that is zero and no need to go in the while loop.\\n\\t   If target element is not at zero then we go in while loop and find the left most index.\\n\\t\\n\\ta2) we check right side of mid for ending index:\\n\\tsimilarly here for list like [1,2,3,3,3] I check the last elemnt for the right most index and we dont need go in the while loop.\\n\\tIf target element is not at last then we go in while loop and find the right most index.\\n\\t\\n\\t\\n\\tAfter that we return the lst containg both the values.\\nb) if nums[mid] is less than target then set low  to mid+1 and continue loop\\nc) if num[mid] is greater than target then set high to mid-1 and continue loop\\n\\n4. Now if elemnt is not found we end up here and return lst containg the default value we assigned to it in the start that is [-1,-1].\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        lst = [-1,-1]\\n        length = len(nums)\\n        low = 0\\n        high = length-1\\n        \\n        if (length == 0) or (length == 1 and nums[0] != target):\\n            return lst\\n        \\n        if nums[0] == target and nums[-1] == target:\\n            return [0,high]\\n        \\n        \\n        while low<=high:\\n            mid = low + (high-low)//2\\n            \\n            if nums[mid] == target:\\n                # checking on left side of the mid\\n                temp = mid\\n                if nums[0] == target:\\n                    lst[0] = 0 \\n                else:\\n                    lst[0] = mid\\n\\n                    while mid>-1:\\n                        if nums[mid-1] != target:\\n                            lst[0] = mid\\n                            break\\n                        mid -= 1\\n                # checking on the right side of the mid\\n                mid = temp\\n                if nums[-1] == target:\\n                    lst[1] = length-1\\n                    return lst\\n                else:\\n                    lst[1] = mid\\n                    while mid<length:\\n                        if nums[mid] != target:\\n                            lst[1] = mid-1\\n                            break\\n                        mid += 1\\n                    \\n                return lst\\n            \\n            elif nums[mid] < target:\\n                low = mid+1\\n                \\n            elif nums[mid] > target:\\n                high = mid-1\\n                    \\n        return lst\\n```\\n\\n***If you liked the solution please do upvote. Thanks!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        lst = [-1,-1]\\n        length = len(nums)\\n        low = 0\\n        high = length-1\\n        \\n        if (length == 0) or (length == 1 and nums[0] != target):\\n            return lst\\n        \\n        if nums[0] == target and nums[-1] == target:\\n            return [0,high]\\n        \\n        \\n        while low<=high:\\n            mid = low + (high-low)//2\\n            \\n            if nums[mid] == target:\\n                # checking on left side of the mid\\n                temp = mid\\n                if nums[0] == target:\\n                    lst[0] = 0 \\n                else:\\n                    lst[0] = mid\\n\\n                    while mid>-1:\\n                        if nums[mid-1] != target:\\n                            lst[0] = mid\\n                            break\\n                        mid -= 1\\n                # checking on the right side of the mid\\n                mid = temp\\n                if nums[-1] == target:\\n                    lst[1] = length-1\\n                    return lst\\n                else:\\n                    lst[1] = mid\\n                    while mid<length:\\n                        if nums[mid] != target:\\n                            lst[1] = mid-1\\n                            break\\n                        mid += 1\\n                    \\n                return lst\\n            \\n            elif nums[mid] < target:\\n                low = mid+1\\n                \\n            elif nums[mid] > target:\\n                high = mid-1\\n                    \\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329914,
                "title": "rust-using-binary-search-and-partition-point",
                "content": "Rust already has plenty of decent ways to do a binary search on a slice without having to reinvent the wheel, so why not take advantage of that? \\n\\nNote that you can use partition_point alone to handle the case where the target is not in nums, but I prefer the error handling via the Result returned from binary_search, so I went with that since it doesn\\'t influence the big-O runtime. \\n\\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        // Find if target in nums\\n        if let Ok(index) = nums.binary_search(&target) {\\n            // Target present\\n            vec![nums.partition_point(|&i| i < target) as i32, nums.partition_point(|&i| i <= target) as i32 - 1]\\n        } else {\\n            // Error, not found\\n            vec![-1, -1]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        // Find if target in nums\\n        if let Ok(index) = nums.binary_search(&target) {\\n            // Target present\\n            vec![nums.partition_point(|&i| i < target) as i32, nums.partition_point(|&i| i <= target) as i32 - 1]\\n        } else {\\n            // Error, not found\\n            vec![-1, -1]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329454,
                "title": "python-simplest-solution-beats-87-67-submissions",
                "content": "![image](https://assets.leetcode.com/users/images/71f23449-43ee-4e3d-8299-da34b2f61610_1658714981.117612.png)\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        if(nums.count(target)==0):\\n            return [-1,-1]\\n        res.append(nums.index(target))\\n        for x in range(len(nums)-1,-1,-1):\\n            if(nums[x]== target ):\\n                res.append(x)\\n                break\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/71f23449-43ee-4e3d-8299-da34b2f61610_1658714981.117612.png)\\n\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        res=[]\\n        if(nums.count(target)==0):\\n            return [-1,-1]\\n        res.append(nums.index(target))\\n        for x in range(len(nums)-1,-1,-1):\\n            if(nums[x]== target ):\\n                res.append(x)\\n                break\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2329430,
                "title": "python3-easy-simple-and-easy-to-understand-code-binarysearch",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        ans=[-1, -1]\\n        ans[0] = self.find_index(nums, target, \\'l\\')\\n        ans[1] = self.find_index(nums, target, \\'r\\')\\n        return ans\\n        \\n    def find_index(self, nums, target, method):    # method: leftmost or rightmost\\n        index, low, high = -1, 0, len(nums)-1\\n        while low <= high:\\n            mid = low + (high - low)//2\\n            if nums[mid] == target:\\n                index = mid\\n                if method == \\'r\\':           # if the selected method is rightmost\\n                    low = mid + 1\\n                elif method == \\'l\\':         # if the selected method is leftmost\\n                    high = mid - 1\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return index\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        ans=[-1, -1]\\n        ans[0] = self.find_index(nums, target, \\'l\\')\\n        ans[1] = self.find_index(nums, target, \\'r\\')\\n        return ans\\n        \\n    def find_index(self, nums, target, method):    # method: leftmost or rightmost\\n        index, low, high = -1, 0, len(nums)-1\\n        while low <= high:\\n            mid = low + (high - low)//2\\n            if nums[mid] == target:\\n                index = mid\\n                if method == \\'r\\':           # if the selected method is rightmost\\n                    low = mid + 1\\n                elif method == \\'l\\':         # if the selected method is leftmost\\n                    high = mid - 1\\n            elif nums[mid] > target: \\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188885,
                "title": "c-o-log-n-binary-search",
                "content": "**Logic is pretty simple:** Just perform Binary Search from left to right to find **FIRST** index and right to left to find **LAST** index\\n\\nTime: O(log n)\\n\\n**Upvote** my solution if you liked my approach :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        int first_index = bs(nums, target);    // O(log n)\\n        int last_index = mod_bs(nums, target); // O(log n)\\n        \\n        return vector<int>{first_index, last_index};\\n    }\\n    \\n    // Modified Binary Search that searches in reverse direction\\n    int mod_bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = nums.size()-1;\\n        high = 0;\\n        ind = -1;\\n        while (high <= low) \\n        {\\n            int mid = high + (low - high)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target) \\n                ind = mid;\\n            \\n            if (current <= target) \\n                high = mid + 1;\\n            else\\n                low = mid - 1;\\n        }\\n        \\n        return ind;\\n    }\\n    \\n    // Normal Binary Search\\n    int bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = 0;\\n        high = nums.size()-1;\\n        ind = -1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target)\\n                ind = mid;\\n            \\n            if (current < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        int first_index = bs(nums, target);    // O(log n)\\n        int last_index = mod_bs(nums, target); // O(log n)\\n        \\n        return vector<int>{first_index, last_index};\\n    }\\n    \\n    // Modified Binary Search that searches in reverse direction\\n    int mod_bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = nums.size()-1;\\n        high = 0;\\n        ind = -1;\\n        while (high <= low) \\n        {\\n            int mid = high + (low - high)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target) \\n                ind = mid;\\n            \\n            if (current <= target) \\n                high = mid + 1;\\n            else\\n                low = mid - 1;\\n        }\\n        \\n        return ind;\\n    }\\n    \\n    // Normal Binary Search\\n    int bs(vector<int>& nums, int target)\\n    {\\n        int low, high, ind;\\n        low = 0;\\n        high = nums.size()-1;\\n        ind = -1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            \\n            int current = nums[mid];\\n            \\n            if (current == target)\\n                ind = mid;\\n            \\n            if (current < target)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913135,
                "title": "simple-o-logn-java-solution-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int firstOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid == 0 || nums[mid] != nums[mid-1]) {\\n                    return mid;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int lastOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid ==  nums.length-1 || nums[mid] != nums[mid+1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        \\n        int first = firstOccurance(nums,target);\\n        if(first == -1) {\\n            arr[0] = -1;\\n            arr[1] = -1;\\n        }\\n        else {\\n            int second = lastOccurance(nums,target);\\n            arr[0] = first;\\n            arr[1] = second;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int firstOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid == 0 || nums[mid] != nums[mid-1]) {\\n                    return mid;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int lastOccurance(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        while(high >= low) {\\n            int mid = (low + high) / 2;\\n            if(nums[mid] > target) {\\n                high = mid - 1;\\n            }\\n            else if(nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if(mid ==  nums.length-1 || nums[mid] != nums[mid+1]) {\\n                    return mid;\\n                }\\n                else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr = new int[2];\\n        \\n        int first = firstOccurance(nums,target);\\n        if(first == -1) {\\n            arr[0] = -1;\\n            arr[1] = -1;\\n        }\\n        else {\\n            int second = lastOccurance(nums,target);\\n            arr[0] = first;\\n            arr[1] = second;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897855,
                "title": "easy-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target){\\n        int[] ans = {1, -1};\\n        ans[0] = search(nums, target, true);\\n        if(ans[0]!=-1)\\n            ans[1] = search(nums, target, false);\\n        return ans;\\n      }\\n    \\n    int search(int[] nums, int target, boolean findStartIndex){\\n        int start = 0;\\n        int end = nums.length-1;\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target<nums[mid])\\n                end = mid - 1;\\n            else if(target>nums[mid])\\n                start = mid + 1;\\n            else{\\n                ans = mid;\\n                if(findStartIndex)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target){\\n        int[] ans = {1, -1};\\n        ans[0] = search(nums, target, true);\\n        if(ans[0]!=-1)\\n            ans[1] = search(nums, target, false);\\n        return ans;\\n      }\\n    \\n    int search(int[] nums, int target, boolean findStartIndex){\\n        int start = 0;\\n        int end = nums.length-1;\\n        int ans = -1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(target<nums[mid])\\n                end = mid - 1;\\n            else if(target>nums[mid])\\n                start = mid + 1;\\n            else{\\n                ans = mid;\\n                if(findStartIndex)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705289,
                "title": "rust-binary-search-by-or-partition-point",
                "content": "I reckon this problem isn\\'t really about how to implement binary search, but rather how to wield it. This problem is a good opportunity to use [binary_search_by](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search_by).\\n\\n```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.binary_search_by(|n| if n < &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.binary_search_by(|n| if n <= &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```\\n\\nWith [partition_point](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.partition_point) instead:\\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.partition_point(|n| n < &target);\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.partition_point(|n| n <= &target);\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.binary_search_by(|n| if n < &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.binary_search_by(|n| if n <= &target { Ordering::Less } else { Ordering::Greater }).unwrap_err();\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn search_range(nums: Vec<i32>, target: i32) -> Vec<i32> {\\n        let i = nums.partition_point(|n| n < &target);\\n        \\n        if i == nums.len() || nums[i] != target {\\n            return vec![-1, -1];   \\n        }\\n        \\n        let j = nums.partition_point(|n| n <= &target);\\n        \\n        vec![i as i32, (j - 1) as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638626,
                "title": "simple-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res(2, -1);\\n        res[0] = _searchRange(nums, target, true);\\n        res[1] = _searchRange(nums, target, false);\\n        return res;\\n    }\\n    \\n    int _searchRange(vector<int>& nums, int target, bool first) {\\n        int ans = -1, l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            \\n            if(nums[mid] > target) {\\n                r = mid - 1;\\n            } else if(nums[mid] < target) {\\n                l = mid + 1;\\n            } else {\\n                ans = mid;\\n                // find first index => search left\\n                if(first) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1; // find last index => search right\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res(2, -1);\\n        res[0] = _searchRange(nums, target, true);\\n        res[1] = _searchRange(nums, target, false);\\n        return res;\\n    }\\n    \\n    int _searchRange(vector<int>& nums, int target, bool first) {\\n        int ans = -1, l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) >> 1;\\n            \\n            if(nums[mid] > target) {\\n                r = mid - 1;\\n            } else if(nums[mid] < target) {\\n                l = mid + 1;\\n            } else {\\n                ans = mid;\\n                // find first index => search left\\n                if(first) {\\n                    r = mid - 1;\\n                } else {\\n                    l = mid + 1; // find last index => search right\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604013,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        r=nums[::-1]\\n        if target in nums:\\n            l.append(nums.index(target))\\n            a=r.index(target)+1\\n            l.append(len(nums)-a)\\n                \\n        else:\\n            l.append(-1)\\n            l.append(-1)\\n        return l\\n```\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        l=[]\\n        r=nums[::-1]\\n        if target in nums:\\n            l.append(nums.index(target))\\n            a=r.index(target)+1\\n            l.append(len(nums)-a)\\n                \\n        else:\\n            l.append(-1)\\n            l.append(-1)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520358,
                "title": "c-o-log-n-runtime-4-ms-faster-than-95-68",
                "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int x )\\n    {\\n        int n = arr.size();\\n        int start = 0;\\n        int first = -1;\\n        int last = -1;\\n        int end = n-1;\\n        int mid;\\n        vector<int> ans;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid]==x)\\n            {\\n                first = mid;\\n                end = mid-1;\\n            }\\n            else if(arr[mid]>x)\\n            {\\n                end = mid-1;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n        start = 0;\\n        last = -1;\\n        end = n-1;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid] == x)\\n            {\\n                start = mid +1;\\n                last = mid ;\\n            }\\n            else if(arr[mid]<x)\\n            {\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(first!=-1 && last!=-1)\\n        {\\n            ans.push_back(first);\\n            ans.push_back(last);\\n        }\\n        else\\n        {\\n            ans.push_back(first);\\n            ans.push_back(last);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& arr, int x )\\n    {\\n        int n = arr.size();\\n        int start = 0;\\n        int first = -1;\\n        int last = -1;\\n        int end = n-1;\\n        int mid;\\n        vector<int> ans;\\n        while(start<=end)\\n        {\\n            mid = start + (end-start)/2;\\n            if(arr[mid]==x)\\n            {\\n                first = mid;\\n                end = mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1379125,
                "title": "c-8-ms-faster-than-86-45",
                "content": "```\\nint findFirstIndex(int *nums, int target, int numsSize){\\n    int start = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] < target)\\n            l = mid+1;\\n        else\\n            h = mid-1;\\n        if(nums[mid]==target)\\n            start = mid;\\n    }\\n    \\n    return start;\\n}//findFirstIndex\\n\\nint findLastIndex(int *nums, int target, int numsSize){\\n    int end = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] <= target)\\n            l = mid+1;\\n        else\\n            h = mid-1; \\n        \\n        if(nums[mid] == target)\\n            end = mid;\\n    }\\n    \\n    return end;\\n}\\n\\n\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int *res = (int *)malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n    \\n    res[0] = findFirstIndex(nums, target, numsSize);\\n    res[1] = findLastIndex(nums, target, numsSize);\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findFirstIndex(int *nums, int target, int numsSize){\\n    int start = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] < target)\\n            l = mid+1;\\n        else\\n            h = mid-1;\\n        if(nums[mid]==target)\\n            start = mid;\\n    }\\n    \\n    return start;\\n}//findFirstIndex\\n\\nint findLastIndex(int *nums, int target, int numsSize){\\n    int end = -1;\\n    \\n    int l=0, h = numsSize-1, mid = 0;\\n    \\n    while(l<=h){\\n        mid = l+(h-l)/2;\\n        if(nums[mid] <= target)\\n            l = mid+1;\\n        else\\n            h = mid-1; \\n        \\n        if(nums[mid] == target)\\n            end = mid;\\n    }\\n    \\n    return end;\\n}\\n\\n\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int *res = (int *)malloc(sizeof(int) * 2);\\n    *returnSize = 2;\\n    \\n    res[0] = findFirstIndex(nums, target, numsSize);\\n    res[1] = findLastIndex(nums, target, numsSize);\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181941,
                "title": "c-two-approaches-o-logn-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_first_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                r = mid-1;     //but lets look at left more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int find_last_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                l = mid+1;   //but lets look at right more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //Approach-1\\n    vector<int> search(vector<int>& nums, int target) {\\n        int l = find_first_position(nums, target);\\n        int r = find_last_position(nums, target);\\n        \\n        return {l, r};\\n    }\\n    \\n    //Approach-2\\n    vector<int> search_stl(vector<int>& nums, int target) {\\n        //first element equal to or greater than target\\n        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //first element greater than target\\n        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //Why do we need this (nums[l] != target) ? \\n        //Because lower_bound returns first element which is equal or GREATER THAN target.\\n        //So, in case the target is not in the list, it will return first greater element than target which will be wrong\\n        if(l == nums.size() || nums[l] != target)\\n            return {-1, -1};\\n        \\n        return {l, r-1};\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        return search(nums, target);     //Approach - 1\\n        \\n        return search_stl(nums, target); //Approach - 2\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_first_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                r = mid-1;     //but lets look at left more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    int find_last_position(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size()-1;\\n        int result = -1;\\n        while(l <= r) {\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target) {\\n                result = mid; //possibly my answer\\n                l = mid+1;   //but lets look at right more\\n            } else if(nums[mid] > target) {\\n                r = mid-1;\\n            } else {\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    //Approach-1\\n    vector<int> search(vector<int>& nums, int target) {\\n        int l = find_first_position(nums, target);\\n        int r = find_last_position(nums, target);\\n        \\n        return {l, r};\\n    }\\n    \\n    //Approach-2\\n    vector<int> search_stl(vector<int>& nums, int target) {\\n        //first element equal to or greater than target\\n        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //first element greater than target\\n        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\\n        \\n        //Why do we need this (nums[l] != target) ? \\n        //Because lower_bound returns first element which is equal or GREATER THAN target.\\n        //So, in case the target is not in the list, it will return first greater element than target which will be wrong\\n        if(l == nums.size() || nums[l] != target)\\n            return {-1, -1};\\n        \\n        return {l, r-1};\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        return search(nums, target);     //Approach - 1\\n        \\n        return search_stl(nums, target); //Approach - 2\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630187,
                "title": "c-solution-with-different-solutions",
                "content": "**Solution 1:- O(n)**\\n```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(nums.size()==0)return {-1,-1};\\n        int l=0,r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            if(nums[l]==target && nums[r]==target)\\n            {\\n                ans.push_back(l);\\n                ans.push_back(r);\\n                return ans;\\n            }\\n            else if(nums[l]!=target && nums[r]!=target)\\n                l++,r--;\\n            else if(nums[l]==target && nums[r]!=target)\\n                r--;\\n            else\\n                l++;\\n        }\\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n```\\n**Solution 2:-O(logn)**\\n```\\n vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,r=nums.size()-1,result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                r=m-1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        l=0,r=nums.size()-1;\\n        result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                l=m+1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        return ans;\\n    }\\n```\\n If you want to learn stl there are a good number of stl functions that this problem can be solved with.\\n **Solution 3:-**\\n ```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0||binary_search(nums.begin(),nums.end(),target)==0)return {-1,-1};\\n        int left=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int right=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        return {left,right-1};\\n    }\\n ```\\n **Solution 4:-**\\n ```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(find(nums.begin(),nums.end(),target)-nums.begin());\\n        reverse(nums.begin(),nums.end());\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(nums.size()-1-(find(nums.begin(),nums.end(),target)-nums.begin()));\\n        return ans;\\n    }\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(nums.size()==0)return {-1,-1};\\n        int l=0,r=nums.size()-1;\\n        while(l<=r)\\n        {\\n            if(nums[l]==target && nums[r]==target)\\n            {\\n                ans.push_back(l);\\n                ans.push_back(r);\\n                return ans;\\n            }\\n            else if(nums[l]!=target && nums[r]!=target)\\n                l++,r--;\\n            else if(nums[l]==target && nums[r]!=target)\\n                r--;\\n            else\\n                l++;\\n        }\\n        ans.push_back(-1);\\n        ans.push_back(-1);\\n        return ans;\\n    }\\n```\n```\\n vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l=0,r=nums.size()-1,result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                r=m-1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        l=0,r=nums.size()-1;\\n        result=INT_MAX;\\n        while(l<=r)\\n        {\\n            int m=l+(r-l)/2;\\n            if(nums[m]==target)\\n            {\\n                result=m;\\n                l=m+1;\\n            }\\n            else if(nums[m]<target) l=m+1;\\n            else r=m-1;\\n        }\\n        ans.push_back(result!=INT_MAX?result:-1);\\n        return ans;\\n    }\\n```\n```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        if(nums.size()==0||binary_search(nums.begin(),nums.end(),target)==0)return {-1,-1};\\n        int left=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int right=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        return {left,right-1};\\n    }\\n ```\n```\\n         vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(find(nums.begin(),nums.end(),target)-nums.begin());\\n        reverse(nums.begin(),nums.end());\\n        if(find(nums.begin(),nums.end(),target)-nums.begin()>=nums.size())ans.push_back(-1);\\n        else\\n            ans.push_back(nums.size()-1-(find(nums.begin(),nums.end(),target)-nums.begin()));\\n        return ans;\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 421199,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] SearchRange(int[] nums, int target) \\n    {\\n        return new int[] {FindFirstIndex(nums, target), FindLastIndex(nums, target)};\\n    }\\n    \\n    private int FindFirstIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start) / 2;\\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start] == target ? start : -1;\\n    }\\n    \\n    private int FindLastIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start + 1) / 2;\\n            if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid;\\n        }\\n        \\n        return nums[start] == target ? start : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] SearchRange(int[] nums, int target) \\n    {\\n        return new int[] {FindFirstIndex(nums, target), FindLastIndex(nums, target)};\\n    }\\n    \\n    private int FindFirstIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start) / 2;\\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start] == target ? start : -1;\\n    }\\n    \\n    private int FindLastIndex(int[] nums, int target)\\n    {\\n        if(nums.Length == 0) return -1;\\n        int start = 0, end = nums.Length - 1;\\n        while(start < end)\\n        {\\n            var mid = start + (end  - start + 1) / 2;\\n            if(nums[mid] > target)\\n                end = mid - 1;\\n            else\\n                start = mid;\\n        }\\n        \\n        return nums[start] == target ? start : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334345,
                "title": "c-concise-binary-search",
                "content": "##### Using lower_bound and upper_bound:\\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto first = lower_bound(begin(nums), end(nums), target);\\n\\tif(first == end(nums) || *first != target) return {-1, -1};\\n\\tauto last = --(upper_bound(begin(nums), end(nums), target));\\n\\treturn {first - begin(nums), last - begin(nums)};\\n}\\n```\\n\\n---\\n##### Using equal_range:\\n\\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto range = equal_range(begin(nums), end(nums), target);\\n\\tif(range.first == range.second) return {-1, -1};\\n\\treturn {range.first - begin(nums), range.second - begin(nums) - 1};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto first = lower_bound(begin(nums), end(nums), target);\\n\\tif(first == end(nums) || *first != target) return {-1, -1};\\n\\tauto last = --(upper_bound(begin(nums), end(nums), target));\\n\\treturn {first - begin(nums), last - begin(nums)};\\n}\\n```\n```cpp\\nvector<int> searchRange(vector<int>& nums, int target) {\\n\\tauto range = equal_range(begin(nums), end(nums), target);\\n\\tif(range.first == range.second) return {-1, -1};\\n\\treturn {range.first - begin(nums), range.second - begin(nums) - 1};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139587,
                "title": "clean-javascript-binary-search-solution",
                "content": "```js\\nfunction searchRange(nums, target) {\\n  let res = [-1, -1];\\n\\n  // find the left\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);  // note using Math.floor\\n    \\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid;\\n  }\\n\\n  if (nums[l] !== target) return res;\\n  else res[0] = l;\\n\\n  // find the right\\n  r = nums.length - 1;  // no need to set l to 0\\n\\n  while (l < r) {\\n    const mid = Math.ceil((l + r) / 2);   // note using Math.ceil\\n    \\n    if (nums[mid] > target) r = mid - 1;\\n    else l = mid;\\n  }\\n\\n  res[1] = r;\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction searchRange(nums, target) {\\n  let res = [-1, -1];\\n\\n  // find the left\\n  let l = 0;\\n  let r = nums.length - 1;\\n\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);  // note using Math.floor\\n    \\n    if (nums[mid] < target) l = mid + 1;\\n    else r = mid;\\n  }\\n\\n  if (nums[l] !== target) return res;\\n  else res[0] = l;\\n\\n  // find the right\\n  r = nums.length - 1;  // no need to set l to 0\\n\\n  while (l < r) {\\n    const mid = Math.ceil((l + r) / 2);   // note using Math.ceil\\n    \\n    if (nums[mid] > target) r = mid - 1;\\n    else l = mid;\\n  }\\n\\n  res[1] = r;\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 110692,
                "title": "python-99-99-easy-solution-two-scans-with-min-max-and-global-variables-logn-bhasha",
                "content": "\\nI see that we can avoid calling subroutines by using int.min and int.max values.The idea is to find the first occurring index in one pass and then do the same for the second pass.\\n\\n```\\n\\t\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        first = float(\"inf\")\\n        second = float(\"-inf\")\\n        \\n        low = 0\\n        high = len(nums)-1\\n        \\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                first = min(first,mid)\\n                high = mid-1 # Search left to get min index\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n                  \\n        low = 0\\n        high = len(nums)-1\\n\\n        # Reset the variables low and high\\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                second = max(second,mid)\\n                low = mid+1 #Search right to get the max index.\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        first = first if first!=float(\"inf\") else -1\\n        second = second if second!=float(\"-inf\") else -1\\n            \\n        return [first,second]\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\t\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        first = float(\"inf\")\\n        second = float(\"-inf\")\\n        \\n        low = 0\\n        high = len(nums)-1\\n        \\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                first = min(first,mid)\\n                high = mid-1 # Search left to get min index\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n                  \\n        low = 0\\n        high = len(nums)-1\\n\\n        # Reset the variables low and high\\n        while(low<=high):\\n            mid = (low+high)/2\\n            if nums[mid] == target:\\n                second = max(second,mid)\\n                low = mid+1 #Search right to get the max index.\\n            elif nums[mid]>target:\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        first = first if first!=float(\"inf\") else -1\\n        second = second if second!=float(\"-inf\") else -1\\n            \\n        return [first,second]\\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 14761,
                "title": "simple-o-log-n-java-solution",
                "content": "````\\npublic class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] == target){\\n                if(nums[left] == target && nums[right] == target)\\n                    return new int[]{left, right};\\n                else if(nums[left] != target)\\n                    left++;\\n                else\\n                    right--;\\n            }else if(nums[mid] < target)\\n                left = mid + 1;\\n            else \\n                right = mid - 1;\\n        }\\n        \\n        return new int[]{-1, -1};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(nums[mid] == target){\\n                if(nums[left] == target && nums[right] == target)\\n                    return new int[]{left, right}",
                "codeTag": "Java"
            },
            {
                "id": 3950949,
                "title": "simple-java-solution-beats-100-with-java-beginner-friendly-beats-99-67-in-memory",
                "content": "# Intuition\\nwe have to find the target element and then keep on updating the left and right pointers till we reach the border of the repeating sequence.\\n\\n# Approach\\nMake a seperate function which performs normal binary search. but we will call it two times. one for left boundary and one for right boundary. It will accept a boolean variable which will tell the function to search for left boundary or right boundary. \\n\\n1. FOR LEFT Boundary -\\n    - set boolean to true.\\n    - initialise left and right pointers on boundaries of array.\\n    - initialise mid pointer inside while loop.\\n    - initialise a pointer i which will give you the boundary value.\\n    - perform a simple binary search but when you find the element set i=mid and then keep on updating the right pointer as right=mid-1.\\n    - then return i.\\n\\n\\n2. FOR RIGHT boundary - \\n    - set boolean to false.\\n    - initialise left and right pointers on boundaries of array.\\n    - initialise mid pointer inside while loop.\\n    - initialise a pointer i which will give you the boundary value.\\n    - perform a simple binary search but when you find the element set i=mid and then keep on updating the left pointer as left=mid+1.\\n    - then return i. \\n\\n# Complexity\\n- Time complexity:\\nlog(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr={-1,-1};\\n\\n        arr[0]=findInd(nums,target,true);\\n        arr[1]=findInd(nums,target,false);\\n\\n        return arr;\\n    }\\n\\n    public int findInd(int[] nums,int target,boolean flag)\\n    {\\n        int left=0;\\n        int right=nums.length-1;\\n        int i=-1;\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }else if(nums[mid]==target)\\n            {\\n                i=mid;\\n                if(flag){\\n                  right=mid-1;;\\n                }else{\\n                   left=mid+1;\\n                }\\n            }\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] arr={-1,-1};\\n\\n        arr[0]=findInd(nums,target,true);\\n        arr[1]=findInd(nums,target,false);\\n\\n        return arr;\\n    }\\n\\n    public int findInd(int[] nums,int target,boolean flag)\\n    {\\n        int left=0;\\n        int right=nums.length-1;\\n        int i=-1;\\n\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }else if(nums[mid]==target)\\n            {\\n                i=mid;\\n                if(flag){\\n                  right=mid-1;;\\n                }else{\\n                   left=mid+1;\\n                }\\n            }\\n        }\\n\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614466,
                "title": "easy-approach-by-using-pure-binary-search-algorithm",
                "content": "# Intuition\\nTo return a vector containing first occurance of K and last occurance of K\\n\\n# Approach\\nApproach to solve this problem is just by using simple binary search.\\n- Putting a start variable at start of the given vector and end variable at the last element of vector and a variable ans initialized with -1(to return if element is not present).\\n\\n ********* First occurance of target*******************\\n- Ccreate a while loop running till s<=e.\\n- Create a mid variable by using the formula s+(e-s)/2 which eventually statisfies the constraint of integer.\\n- 3 conditions in while loop \\n            1 if(nums[mid]==target){\\n                int ans=mid;\\n                    e=mid-1;// to get the first element as the first occurance of rarget will be in left side of the mid.\\n            }\\n            2 else if (nums[mid] > target) {\\n                e = mid - 1;\\n            }\\n            3  else {\\n                s = mid + 1;\\n            }\\n            return ans; //if not found, will return -1\\n    \\n   ** Last occurance of target**\\n     same as first occurance of target \\n     just change the 1st condition with s=mid+1; //as last occurance will be at right side of  mid.\\n\\n Now just return the vector by saving firstOccurance and lastOccurance. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nSpace Complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int s = 0,ansA = -1;\\n    int firstOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                e = mid - 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ansA;\\n    }\\n\\n    int LastOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                s = mid + 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ansA;\\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v(2);\\n        v[0] = firstOcr(nums, target);\\n        v[1] = LastOcr(nums, target);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int s = 0,ansA = -1;\\n    int firstOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                e = mid - 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ansA;\\n    }\\n\\n    int LastOcr(vector<int>& nums, int target) {\\n        int e = nums.size() - 1 ;\\n\\n        while (s <= e) {\\n            int mid = s + (e - s) / 2;\\n\\n            if (nums[mid] == target) {\\n                ansA = mid;\\n                s = mid + 1;\\n            } else if (nums[mid] > target) {\\n                e = mid - 1;\\n            } else {\\n                s = mid + 1;\\n            }\\n        }\\n        return ansA;\\n    }\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v(2);\\n        v[0] = firstOcr(nums, target);\\n        v[1] = LastOcr(nums, target);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424638,
                "title": "binary-search-pure-c-beats-97",
                "content": "# Intuition\\nWhen searching for something in a sorted array a binary search is often the best tool to use. The requirement of O(logn) time complexity is also a big hint to this end.\\n\\n# Approach\\nThe solution will amount to a modified binary search to find the first occurrence of the target value, then a second binary search to find the last occurrence.\\n\\nInstead of stopping immediately when a target value is found, we have to determine whether that value is the starting occurrence or if its in the middle of a range of those values and adjust the range accordingly.\\n\\nOnce the first occurrence is found, we use that as the start of the range for the 2nd binary search where we look for the last occurrence.\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int start = 0;\\n    int mid;\\n    int end = numsSize;\\n\\n    /* initialize the return data structure */\\n    int *result = (int *)malloc(2*sizeof(int));\\n    result[0] = -1;\\n    result[1] = -1;\\n    *returnSize = 2;\\n\\n    /* don\\'t bother doing anything if numsSize is 0 */\\n    if (numsSize == 0) {\\n        return result;\\n    }\\n\\n    /* find the start index */\\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == 0 || nums[mid-1] != target) {\\n                result[0] = mid;\\n                break;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        else if (nums[mid] < target) {\\n            start = mid + 1;\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    /* if no start index found, return */\\n    if (result[0] == -1) {\\n        return result;\\n    }\\n\\n    /* find the end index */\\n    start = result[0];\\n    end = numsSize; \\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == (numsSize - 1) || nums[mid + 1] != target) {\\n                result[1] = mid;\\n                break;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\\n    int start = 0;\\n    int mid;\\n    int end = numsSize;\\n\\n    /* initialize the return data structure */\\n    int *result = (int *)malloc(2*sizeof(int));\\n    result[0] = -1;\\n    result[1] = -1;\\n    *returnSize = 2;\\n\\n    /* don\\'t bother doing anything if numsSize is 0 */\\n    if (numsSize == 0) {\\n        return result;\\n    }\\n\\n    /* find the start index */\\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == 0 || nums[mid-1] != target) {\\n                result[0] = mid;\\n                break;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        else if (nums[mid] < target) {\\n            start = mid + 1;\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    /* if no start index found, return */\\n    if (result[0] == -1) {\\n        return result;\\n    }\\n\\n    /* find the end index */\\n    start = result[0];\\n    end = numsSize; \\n    while(start < end) {\\n        mid = (start + end) / 2;\\n        if (nums[mid] == target) {\\n            if (mid == (numsSize - 1) || nums[mid + 1] != target) {\\n                result[1] = mid;\\n                break;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        else {\\n            end = mid;\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3346340,
                "title": "java-easy-and-understandable-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int c=-1,d=-1;;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                c=i;\\n                break;\\n            }\\n        }\\n         for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==target){\\n                d=i;\\n                break;\\n            }\\n        }\\n        int a[]=new int[2];\\n        for(int i=0;i<2-1;i++){\\n            a[i]=c;\\n            a[i+1]=d;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int c=-1,d=-1;;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                c=i;\\n                break;\\n            }\\n        }\\n         for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]==target){\\n                d=i;\\n                break;\\n            }\\n        }\\n        int a[]=new int[2];\\n        for(int i=0;i<2-1;i++){\\n            a[i]=c;\\n            a[i+1]=d;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318820,
                "title": "java-easy-binary-search-beats-100-binary-search-using-recursion",
                "content": "# Intuition\\nfor Binary Search through Recursion understanding purpose \\nBinary Search through recursion\\n\\n# Approach\\nBasically we have applied binary search \\n\\nfor 1st element we have to move from low towards high (left to right)\\nfor last element we have to move from high to log (right to left)\\n\\n* in first function our recursion calls will stat the lower bound \\n ie. start to mid because we want first element and it will be always found in lower bound \\nex -\\narr = 1 1 1 1 1\\nind = 0 1 2 3 4\\n\\nsearching dry run for start index -:\\n\\nmid = 0+4/2 = 2;\\n \\narr = 1 1 1\\nind = 0 1 2\\n_____________\\n\\nmid = 0+2/2 =1;\\n \\narr = 1 1\\nind = 0 1\\n_____________\\n\\nmid = 0+1/2 = 0;\\n\\narr = 1\\nind = 0\\n\\nreturn 0 that is first occurance\\n\\n* same goes for last index but change is we will call upper bound index first\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n- Space complexity:\\nO(log N) == heap {else O(1)}\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int n = nums.length;\\n        start(nums,target,0,n-1);\\n        end(nums,target,0,n-1);\\n        int arr[] = new int[2];\\n        arr[0] =str;\\n        arr[1] =en;\\n        return arr;\\n    }\\n    int str =-1;\\n    public void start(int[] a , int t , int s , int e){\\n    if(s>e){\\n    return;\\n    }\\n\\n    int mid = (s+e)/2;\\n\\n    if(a[mid]==t)\\n    str =mid;\\n\\n    if(a[mid]>=t){\\n    start(a,t,s,mid-1);\\n    }\\n    else{\\n    start(a,t,mid+1,e);\\n        }\\n    }\\n    int en =-1;\\n    public void end(int[] a , int t , int s , int e){\\n        if(s>e){\\n        return;\\n        }\\n\\n        int mid = (s+e)/2;\\n\\n        if(a[mid]==t)\\n    en = mid;\\n\\n        if(a[mid]<=t){\\n            end(a,t,mid+1,e);\\n        }else{\\n            end(a,t,s,mid-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int n = nums.length;\\n        start(nums,target,0,n-1);\\n        end(nums,target,0,n-1);\\n        int arr[] = new int[2];\\n        arr[0] =str;\\n        arr[1] =en;\\n        return arr;\\n    }\\n    int str =-1;\\n    public void start(int[] a , int t , int s , int e){\\n    if(s>e){\\n    return;\\n    }\\n\\n    int mid = (s+e)/2;\\n\\n    if(a[mid]==t)\\n    str =mid;\\n\\n    if(a[mid]>=t){\\n    start(a,t,s,mid-1);\\n    }\\n    else{\\n    start(a,t,mid+1,e);\\n        }\\n    }\\n    int en =-1;\\n    public void end(int[] a , int t , int s , int e){\\n        if(s>e){\\n        return;\\n        }\\n\\n        int mid = (s+e)/2;\\n\\n        if(a[mid]==t)\\n    en = mid;\\n\\n        if(a[mid]<=t){\\n            end(a,t,mid+1,e);\\n        }else{\\n            end(a,t,s,mid-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240778,
                "title": "c-brute-force-o-n-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1 ; \\n        int end = -1 ; \\n        int n = nums.size() ; \\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                start = i ; \\n                break ; \\n            }\\n        }\\n\\n        for (int i = n - 1 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] == target)\\n            {\\n                end = i ; \\n                break ;\\n            }\\n        }\\n        vector<int> ans ; \\n        ans = {start , end} ; \\n        return ans ; \\n    } \\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/fabf8b98-b984-4510-b551-a6b972c155b5_1677603180.1534393.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int start = -1 ; \\n        int end = -1 ; \\n        int n = nums.size() ; \\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            if (nums[i] == target)\\n            {\\n                start = i ; \\n                break ; \\n            }\\n        }\\n\\n        for (int i = n - 1 ; i >= 0 ; i --)\\n        {\\n            if (nums[i] == target)\\n            {\\n                end = i ; \\n                break ;\\n            }\\n        }\\n        vector<int> ans ; \\n        ans = {start , end} ; \\n        return ans ; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222767,
                "title": "simple-solution-in-three-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if target in nums:\\n            return[nums.index(target),len(nums)-nums[::-1].index(target)-1]\\n        else: return [-1,-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        if target in nums:\\n            return[nums.index(target),len(nums)-nums[::-1].index(target)-1]\\n        else: return [-1,-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565827,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1763959,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576241,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1708352,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1969648,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1569572,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1859759,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1692595,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1866946,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576517,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1565827,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1763959,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576241,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1708352,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1969648,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1569572,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1859759,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1692595,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1866946,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1576517,
                "content": [
                    {
                        "username": "shimaozheng",
                        "content": "If the elements of the whole array is the same as the target, can we do it in a O(logn) time?"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "mng48301",
                        "content": "since this is a sorted array, checking if the first and last indices of the array are the same would be an efficient way to check if the whole array is the same as the target. I believe that this could be done in O(1) time. "
                    },
                    {
                        "username": "hossain6857",
                        "content": "[@StrawhatLuffy2502](/StrawhatLuffy2502) why the following test case is not valid? please explain. \\n[1 2 10 13 13]"
                    },
                    {
                        "username": "minhajul-im",
                        "content": "yes possible, but two normal binary searches and find two indexes.\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Yes we can two normal binary searches to find the start and end index is fine "
                    },
                    {
                        "username": "Prathvik",
                        "content": "yes it can be done"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    },
                    {
                        "username": "mahbubul_shafi",
                        "content": "At first use binary search. When your mid value will be equal to the target, then use two different binary search on the left part and right part of the mid."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@user4630kl](/user4630kl) bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "[@AshutoshPatel028](/AshutoshPatel028) I used 1 while loop. beats 92% time."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Hell yeah and It can be made recursive!!"
                    },
                    {
                        "username": "user4630kl",
                        "content": "yo bruh... thats cool... did help a lot and made me feel confident... lots ah love n support"
                    },
                    {
                        "username": "JoeNg_03",
                        "content": "I sometimes get 5th percentile speed from a submission, then a 95th percentile speed on the next with the exact same code."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I never worry about runtimes if it is in <100 ms range for most of the submissions since the variation is huge for small runtimes. But if we get 200ms and somebody has a 100 ms, then that is a coding induced difference."
                    },
                    {
                        "username": "Ultron03",
                        "content": "[@janhs](/janhs) +1"
                    },
                    {
                        "username": "janhs",
                        "content": "Same here"
                    },
                    {
                        "username": "Wizel",
                        "content": "Why in the case the nums is [1] , target is 1, the search result should be [0, 0] ?"
                    },
                    {
                        "username": "sarashs",
                        "content": "because it starts at zero and ends at zero."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Because the starting and ending position of the target both lies on the 0th index. We first saw the appearance of target \\'1\\' on the 0th index and since it occurs in a singular position only, it is ending at 0th index also. The answer will be the same had the array been [1,2,3,4] and target = 1. Hence the length of array doesn\\'t matter in this condition."
                    },
                    {
                        "username": "Yugo1885",
                        "content": "same here, I don\\'t get it."
                    },
                    {
                        "username": "shrey802",
                        "content": "I got the same error while submitting"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "Because the element is unique and is at index 0 hence result is [0,0]"
                    },
                    {
                        "username": "nestor2502",
                        "content": "Because nums[0] = 1, and as it\\'s the unique element, starts at index 0 and ends at index 0, thus the result is [0, 0]"
                    },
                    {
                        "username": "nikhillaad12",
                        "content": "same here"
                    },
                    {
                        "username": "nerdstv",
                        "content": "After attempting this binary search is running through my veins."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int s=0, e=nums.size()-1, mid=(s+e)/2;\\n        int i=-1,j=-1;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            i=mid;\\n            e=mid-1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if (target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n\\n         s=0, e=nums.size()-1, mid=(s+e)/2;\\n\\n        while(s<=e){\\n          if(nums[mid]==target){\\n            j=mid;\\n            s=mid+1;\\n          }\\n          else if(target> nums[mid]){\\n            s=mid+1;\\n          }\\n          else if(target< nums[mid]){\\n            e=mid-1;\\n          }\\n          mid=(s+e)/2;\\n        }\\n        ans.push_back(i);\\n        ans.push_back(j);\\n        return ans;\\n        \\n\\n    } \\nThe corrected one ..\\nIs this code can be optimezed any more?"
                    },
                    {
                        "username": "valkm1",
                        "content": "Please find the URL\\nhttps://leetcode.com/explore/learn/card/binary-search/135/template-iii/936/\\n\\nCode problem:\\nSearch for a Range\\n\\nI see multiple people having python code, but none found to be close to template\\n\\nPS: Leetcode Admin please assist in answering\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "jayambe36",
                        "content": "thank you so much for give this link here, sir"
                    },
                    {
                        "username": "jaskaran_singh0606",
                        "content": "since i am using binary search for this code but im getting time limit exceeds\\n"
                    },
                    {
                        "username": "luvsharma105",
                        "content": "I think that you have not updated the mid value."
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "it is because you might be stuck in infinite while loop, check the conditions again and try to re execute the code, if still faces same issue, i can share the whole logic "
                    },
                    {
                        "username": "shubhi4",
                        "content": "It may be because of your while loop if running infinite times. You should check for values of i and j in the end are they stuck to some value? May be because of that your while loop in always true.\n\nlike for \nwhile(i<j){\n            int m= (i+j)/2;\n            if(nums[m]<target) i=m;\n            else j=m;\n  }\nhere i will always be less then j, so your loop ill run infinitely. \nif you change i=m => i=m+1\nthen the loop will come to an end"
                    },
                    {
                        "username": "sjha92865",
                        "content": "previous UI was much handy"
                    },
                    {
                        "username": "Harsh_Balwani",
                        "content": "I am used to this one and feeling better with this UI"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "I\\'m sorry. What is \"sorted in non-decreasing order\"? Isn\\'t that just sorted in ascending order?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "non-decreasing means that there could be duplicate values at the same spot (1, 2, 2, 3..), but ascending order is stritcly increasing (1, 2, 3, 4...), hope that answers your question"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "same no. may be possible>>>"
                    },
                    {
                        "username": "Abhinav_0561",
                        "content": "My code is running perfectly on my IDE but it is showing this runtime error mentioned below-\\n\\nWARNING: A command line option has enabled the Security Manager\\nWARNING: The Security Manager is deprecated and will be removed in a future release\\njava.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1\\n  at line 30, Solution.lastOccurrence\\n  at line 5, Solution.searchRange\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\n  \\n  Q-34 Find First and Last Position of Element in Sorted Array\\n"
                    }
                ]
            },
            {
                "id": 1724737,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 1575113,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2066577,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2066081,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2065499,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2051913,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2049667,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2048936,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2039494,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2036050,
                "content": [
                    {
                        "username": "kbn456",
                        "content": "Description says we should write solution in O(log n) but how come tests are passed with O(n/2) or little greater then O(log n) complexity solutions ?"
                    },
                    {
                        "username": "dattran1232003",
                        "content": "Can\\'t. O(log n) & O(n/2) have much difference when the length of array is 1.000.000.000 elements"
                    },
                    {
                        "username": "AGPCR7",
                        "content": "var searchRange = function(nums, target) {\\n return [nums.indexOf(target),nums.lastIndexOf(target)]\\n};"
                    },
                    {
                        "username": "bbaymistery",
                        "content": "Sir it should be binary search algorithm "
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Approach:\\nFor this particular solution we solve the problem with Binary search. The first step will be to find the target number (be it in any index) and store its location in a variable called temp. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector ans and the final positions are returned.\\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned.\\n\\nFor Code, Refer to my blog link:\\nhttps://dsafordummies.digitalpress.blog/binary-search-leetcode-series-2/\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "Saswat_Sharma",
                        "content": "Just try to use simple binary search to find out the ceiling value and floor value of the target."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good job lil nigga"
                    },
                    {
                        "username": "siddharth133",
                        "content": "Can anyone check what is wrong with my code it is giving me TLE even in the test cases ????\\nI ma using simple binary search approach\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> result(2,-1);\\n        int left = 0;\\n        int right = nums.size()-1;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                if(result[0] != -1){\\n                    result[1] = mid;\\n                }\\n                else{\\n                result[0] = mid;\\n                }\\n\\n            }\\n            else if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n        if(result[1] == -1 && result[0] != -1){\\n            result[1] = result[0];\\n        }\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "donno"
                    },
                    {
                        "username": "abhiHegde28",
                        "content": "class Solution:\\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\\n        s = 0\\n        e = len(nums) - 1\\n\\n        while(s <= e):\\n            mid = (s+e) // 2 \\n            if(target < nums[mid]):\\n                e = mid - 1 \\n            elif(target > nums[mid]):\\n                s = mid+1\\n            elif(target == nums[mid]):\\n                if(nums[mid] == nums[mid - 1]):\\n                    return [mid-1 , mid]\\n                elif(nums[mid] == nums[mid + 1]):\\n                    return [mid , mid+1]\\n                else:\\n                    return [mid , mid]\\n        return [-1,-1]\\n\\n        this was my solution but i am getting an error can somebody pls help why i am getting error?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "try using two binary searches with two while loops, but before second while loop write s = 0, e = len(nums) - 1"
                    },
                    {
                        "username": "paink1ller",
                        "content": "I think this is too easy to be medium problem imho"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "For GigaChads like us every problem is easy "
                    },
                    {
                        "username": "dasrakesh",
                        "content": "This is a facebook interview question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Not getting how to do  O(logn) will leetcode accept me :-("
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "[@DamianIvanochko](/DamianIvanochko) i want to try something different :-)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Well, bro if you know what is binary search you can use it, this algorithm runs at O(logn), hope this answers your guestion"
                    },
                    {
                        "username": "bakdominik",
                        "content": "why Im getting \"Line 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\" error whenever trying to get nums[i] value? \\n\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "These might be problems:\\n\\nUninitialized Vector: If you\\'re using a std::vector and haven\\'t properly initialized it before accessing its elements, it could lead to a null pointer reference.\\n\\nOut of Bounds Access: If the value of i is outside the valid range of indices for the vector nums, you might end up trying to access an element that doesn\\'t exist, causing undefined behavior.\\n\\nPointer Instead of Vector: If nums is declared as a pointer to a vector (std::vector<int>* nums) and not properly assigned to an actual vector object, then accessing nums[i] could result in a null pointer reference."
                    }
                ]
            },
            {
                "id": 2016101,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1990139,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1922787,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1809463,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 1571991,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2042422,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2033940,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2024302,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2024052,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2020535,
                "content": [
                    {
                        "username": "DraculeMihawk",
                        "content": "break into two pieces(lower bound and upper bound)  :P"
                    },
                    {
                        "username": "eduard92",
                        "content": "Going for 3 days binary search haul, I think I am gonna dream mid formula and while loop"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I love this question"
                    },
                    {
                        "username": "Mirro0w0",
                        "content": "So I used one binary search to find the target, and after finding that target then I use another two binary search within it to find the start and end of the target.\n\nSo does the time complexity of that still be O(log n) or something else? Even though it took 0ms but I'm still confused.\n\nThanks :D"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "[@shubhi4](/shubhi4)  as she said  same for the last target also"
                    },
                    {
                        "username": "shubhi4",
                        "content": "yes it will be O(logn) . But you dont need to find the target. you can just search for the minimum index of target first, if not found that means the target is not present in the array."
                    },
                    {
                        "username": "Yurii-Predborskyi",
                        "content": "I have a gut feel that Template III doesn\\'t really fit the range search. Yes, to find a range in a collection you need to check next and previous elements for finish and start. But in order to find both start and finish you will have to use binary search template III twice - for a start and then for a finish, which makes it no better than using any other templates.\\n\\nIf anyone knows a way to search for both start and finish while using template III, please share."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "Best solution with tricky method with 99.59% beats || Biggners friendly||line by line explanation\\n--------------------------------------------------------------------------------------------------------------\\n\\n\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3996615/best-solution-with-tricky-method-with-99-59-beats-biggners-friendly-line-by-line-explanation/"
                    },
                    {
                        "username": "gmanan3222",
                        "content": "Getting TLE . Used Binary Search. What\\'s the problem??\\n\\nclass Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        int[] ans = {-1, -1};\\n        int mid = low + high/2 - low/2;\\n\\n        while(low <= high){\\n\\n            mid = low + high/2 - low/2;\\n            if(nums[mid] < target) mid = low+1;\\n            else if(nums[mid] > target) mid = high-1;\\n            else break;\\n        }\\n        if(low > high) return ans;\\n\\n        int lowerbound = mid-1;\\n        int upperbound = mid+1;\\n        \\n        \\n        while(low <= lowerbound){\\n            int middle = low/2 + lowerbound/2 ;\\n            if(nums[middle] == target){\\n                lowerbound = middle -1;\\n                \\n            } \\n            else low = middle+1;\\n        }\\n\\n        while(upperbound <= high){\\n            int middle = upperbound/2 + high/2;\\n            if(nums[middle] == target) upperbound = middle+1;\\n            else high = middle-1;\\n        }\\n\\n        ans[0] = lowerbound+1;\\n        ans[1] = upperbound-1;\\n\\n        return ans;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "I wonder if anyone solved this question with \"Template III\" mentioned on Learning Card"
                    },
                    {
                        "username": "hp68",
                        "content": "Can someone tell me why my code is not accepting [1] test case.  \\nERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x0000003558cb bp 0x7ffc0282cc70 sp 0x7ffc0282cc68\\n\\n `class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int l=0, r=nums.size()-1,mid;\\n\\n        while(l<=r){\\n            mid=(l+r)/2;\\n\\n            if(nums[mid]==target){\\n                l=0;\\n                while(l<=mid){\\n                    if(nums[l]==nums[mid]) break;\\n                    else l++;\\n                }\\n                ans.push_back(l);\\n                mid=l;\\n                int initial_mid=mid;\\n                while(nums[mid]==target){\\n                    mid++;\\n                }\\n                if(initial_mid!=mid) ans.push_back(mid-1);\\n                break;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n\\n        if(ans.size()<2){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n\\n        return ans;\\n    }\\n};\\'"
                    },
                    {
                        "username": "jeremyjkievit",
                        "content": "I'm getting a really strange index out of range error:\n\n```\nIndexError: list index out of range\n    if (nums[mid] == target):\nLine 22 in getRange (Solution.py)\n    return getRange(0, length, nums)\nLine 38 in searchRange (Solution.py)\n    ret = Solution().searchRange(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)\n```\n\n\nIt highlights line 22 as the problem. That is this line:\n\n`if (nums[mid] == target):`\n\nI don't understand why nums[mid] is out of range. The calculation for mid is a simple (left + right)/2, so for a list in non-decreasing order it should be imppossible for mid to go out of range. I have traced the iterations carefully with leetcode's input values and the program behaves exactly as I expect it to on paper.\n\nAt first I used the global variable for nums, and I thought that maybe the compiler was creating a new subsection of the nums array for every recursive call of the binary search algorithm, so I passed the original nums array into each recursive call. Unfortunately that did nothing to fix the problem. "
                    },
                    {
                        "username": "fatihemreyildiz",
                        "content": "try instead \\n\"mid=(left + right) // 2\"\\nor\\n\"mid=left + (right - left) / 2\""
                    }
                ]
            },
            {
                "id": 2017536,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2013516,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2010351,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2009814,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2004590,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 2003095,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1998096,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1986288,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1975915,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1975758,
                "content": [
                    {
                        "username": "rahulkasula23",
                        "content": "I\\'ve done in O(n) time but still my solution is accepting."
                    },
                    {
                        "username": "yashgaud15",
                        "content": "i dont know why is this showing up on leetcode, i am not facing any problem in my IDE\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      int[] ret = new Solution().searchRange(param_1, param_2);\\n                      ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\ni dont know why is this showing up on leetcode, i am not facing any problem in my IDE"
                    },
                    {
                        "username": "harshjainsk531",
                        "content": "\n        \n\n        int first_occurence = -1;\n        int last_occurence  = - 1;\n        int start = 0;\n        int end = nums.size() -1;\n        int mid = start + (end - start) / 2;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                first_occurence = mid;\n                end = mid - 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        start = 0;\n        end = nums.size() -1;\n\n        while(start <= end){\n            if(nums[mid] == target){\n                last_occurence = mid;\n                start = mid + 1;\n            }\n            else if(nums[mid] > target){\n                end = mid - 1;\n            }\n            else{\n                start = mid + 1;\n            }\n\n            mid = start + (end - start)/ 2;\n        }\n\n        vector<int> ans {first_occurence, last_occurence};\n\n        return ans;\n\n\nCan anyone help me understand why y code is not working for input array [2, 2] and target = 3?"
                    },
                    {
                        "username": "sarashs",
                        "content": "Two binary searches for the left and the right side"
                    },
                    {
                        "username": "Nayab_Rasool",
                        "content": "I used binary search, its run time is accepted but it shows memory limit exceeded error what should i do?\\n"
                    },
                    {
                        "username": "kamalmodi",
                        "content": "class Solution {\\npublic:\\n    vector<int> firstsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                e=mid-1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n  return ans ;\\n    }\\n}\\n\\n\\nvector<int> lastsearchRange(vector<int>& nums, int target,int n) {\\n        int s=0;\\n        int e=n-1;\\n        int mid = s+ (e-s)/2;\\n           int ans= -1;\\n        while (s<=e){\\n            if (nums[mid]==target){\\n                ans= mid;\\n                s=mid+1;\\n            }\\n            else if (target>nums[mid]) {\\n                       s=mid+1;\\n            }\\n            else {\\n                e=mid-1;\\n            }\\n            mid= s+ (e-s)/2;\\n        }\\n return ans;\\n    }\\n\\n   \\n\\n\\nint main(){\\n    vector<int> nums= {5,7,7,8,8,10};\\n\\n    int firstOccurrence = firstsearchRange(nums, 8, 6);\\n    int lastOccurrence = lastsearchRange(nums, 8, 6);\\n\\n    cout << \" First occurence is\" << firstsearchRange(nums, 8, 6) << endl ;\\n    cout << \" last occurence is\" << lastsearchRange(nums, 8, 6) << endl ;\\n    return 0;\\n}\\n\\nGuys  this is my code   im getting this error.. pls resolve \\nLine 7: Char 24: error: no viable conversion from \\'int\\' to \\'vector<int>\\'\\n          vector <int> ans= -1;"
                    },
                    {
                        "username": "hossain6857",
                        "content": "why the following test case is not valid? please explain.\\n[1 2 10 13 13]"
                    },
                    {
                        "username": "shivam_XDD",
                        "content": "this is my code it is throwing error \\nLine 1034: Char 9: runtime error: reference binding to null pointer of type \\'int\\' (stl_vector.h)\\n please check and tell hwere i am wrong:)\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n    int start=0;\\n    int end=nums.size()-1;\\n   \\n  int firstpos=-1;\\n    while(nums.size()<=end)\\n    { int mid=start - (start+end)/2;\\n        if(nums[mid]==target)\\n        {\\n            firstpos=mid;\\n            end=mid-1;\\n\\n        }\\n\\n        else if(target>nums[mid])\\n        {\\n            start=mid+1;\\n        }\\n        else if (target<nums[mid])\\n        {\\n            end=mid-1;\\n        }\\n\\n      \\n    }\\n\\n      int s=0;\\n    int e=nums.size()-1;\\n   \\n   int secondpos=-1;\\n    while(nums.size()<=e)\\n    {\\n         int m=s - (s+e)/2;\\n        if(nums[m]==target)\\n        {\\n            secondpos=m;\\n            s=m+1;\\n\\n        }\\n\\n        else if(target>nums[m])\\n        {\\n            s=m+1;\\n        }\\n        else if (target<nums[m])\\n        {\\n            e=m-1;\\n        }\\n\\n      \\n    }\\n    return {firstpos , secondpos};\\n\\n    }\\n}; "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n       \\n        int s = 0,e = nums.size()-1 , firstpos = -1,lastpos = -1;\\n        while(s<=e){\\n              int mid = s+(e-s)/2;\\n            if(nums[mid] == target){\\n                firstpos = mid;\\n                e = mid-1;\\n            }\\n              else if(nums[mid] >target)\\n               e = mid-1;\\n            \\n            else\\n                s = mid+1;\\n            \\n            \\n        }\\n         int  start = 0, end =nums.size()-1;\\n          while(start<=end){\\n              int mid = start+(end-start)/2;\\n              if(nums[mid] == target){\\n                  lastpos = mid;\\n                  start = mid+1;\\n              }\\n\\n                  else if(nums[mid]<  target)\\n                      start = mid+1;\\n            \\n                  else\\n                      end = mid-1;\\n                  \\n              }\\n              return{firstpos , lastpos};\\nthis is my code"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "For this particular solution we solve the problem with **Binary search**. The first step will be to find the target number (be it in any index) and store its location in a variable called **temp**. For this we will apply basic binary search. If mid == target condition is satisfied, we will apply two seperate loops from position of mid to increment and decrement it in both direction and find the upper and lower bound indexes respectively. We will then store both these value in the vector<int> ans and the final positions are returned. \\n\\nIf the target is not found, we will simply come out of the loop and [-1,-1] is returned. "
                    }
                ]
            },
            {
                "id": 1963886,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1945172,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1943867,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1941237,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1933372,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1920938,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1878564,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1869035,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1866146,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1843263,
                "content": [
                    {
                        "username": "md_irfan_pr",
                        "content": "First we can solve with the help of linear search and time complexity will be O(n)\\nbut when wo apply the concept of binary search and solve with the better time complexity than previous one time complexity will be O(logn)."
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "Whats wrong with this code ?? Can anyone suggest me...???\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target)  {\\n      vector<int> ans, no;\\n      no.push_back(-1);\\n      no.push_back(-1);\\n\\n      int start= 0;\\n      int end= nums.size();\\n      int mid= (start + end)/2;\\n      while(start<= end){\\n          if(nums[mid]==target){\\n              if(nums[mid+1]==target){\\n                  ans.push_back(mid);\\n                  ans.push_back(mid+1);\\n                  return ans;\\n              }\\n              else{\\n                  ans.push_back(mid);\\n                  ans.push_back(mid-1);\\n                  return ans;\\n              }\\n          }\\n          if(nums[mid]<target){\\n              start= mid+1;\\n          }\\n          else{\\n              end=mid-1;\\n          }\\n          mid= (start+end)/2;\\n      }\\n      return no;  \\n    }\\n\\n};"
                    },
                    {
                        "username": "priyanshu__07",
                        "content": "[@userkaaname](/userkaaname)  \\nThanks buddy!, for figuring out my mistake . I modified the code and got correct answer.  "
                    },
                    {
                        "username": "userkaaname",
                        "content": "you are assuming that target number is only present in the array two times, however it is not written anywhere.\\nSo, let\\'s assume an array,\\n{1,2,4,4,4,5}\\nAccording to your solution, it will return position {2,3} but actual answer is {2,4}\\nKindly, Modify your code accordingly."
                    },
                    {
                        "username": "luvsharma105",
                        "content": "CAN SOMEBODY TELL ME WHAT IS THIS ERROR ABOUT.\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000003d0 overflowed to 0x6020000003cc (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "yashseth391",
                        "content": "I think they have given less information in question ."
                    },
                    {
                        "username": "akarshnayak",
                        "content": "Why am i getting a TLE?? my code is in O(logn) \\n `your inline code...your inline code...`\\nclass Solution {\\n    int searchStart(int[] nums,int target){\\n        int s=0;\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                e=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n    int searchEnd(int[] nums,int target,int s){\\n        int e=nums.length-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(nums[mid]==target){\\n                s=mid;\\n            }\\n            else if(nums[mid]>target){\\n                e=mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return e;\\n    }\\n    public int[] searchRange(int[] nums, int target) {\\n        int[] res=new int[2];\\n        res[0]=searchStart(nums,target);\\n        res[1]=searchEnd(nums,target,res[0]);\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditisharma37",
                        "content": "Can anyone tell me why is it not running ?\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> a;\\n        int start =0;\\n        int end = size(nums) -1;\\n        while(start <= end){\\n            int mid= (start + end)/2 ; \\n            if(nums[mid]== target ){\\n                int s=mid ,e=mid  ;\\n                while( nums[e] == target){\\n                    e++;\\n                }\\n                \\n                while( nums[s] == target){\\n                    s--;\\n                }\\n                a.push_back(s+1);\\n                a.push_back(e-1);\\n                return a;\\n            }\\n            else if( nums[mid] > target){\\n                end = mid -1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        a.push_back(-1);\\n        a.push_back(-1);\\n        return a;\\n    }\\n};\\n\\nIt\\'s giving Runtime Error \\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000434 at pc 0x00000034caab bp 0x7ffec3562630 sp 0x7ffec3562628\\nREAD of size 4 at 0x602000000434 thread T0\\n    #2 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000434 is located 0 bytes to the right of 4-byte region [0x602000000430,0x602000000434)\\nallocated by thread T0 here:\\n    #6 0x7f8bc5463082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff8030: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n  0x0c047fff8040: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n=>0x0c047fff8080: fa fa fd fa fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):"
                    },
                    {
                        "username": "userkaaname",
                        "content": "when target is matched with mid and then you find value of s & e, assume mid =0, then you are doing s-- that will decrease s value to -1 even if you are pushing s+1 in a, it will already generate overflow error because you can't compare nums[-1]==target in next iteration.\nhope you understand ;)"
                    },
                    {
                        "username": "aakashy810",
                        "content": "i write solution in O(n) time complexity and leetcode accepted this "
                    },
                    {
                        "username": "cjatherton19",
                        "content": "Would checking for nums[mid+1] and nums[mid-1] still be logn? Since its sorted we can check the targets neighbor."
                    },
                    {
                        "username": "Anoop0522",
                        "content": "Can someone tell why does my lastIndexOf function giving me a wrong value for the index of \"0\" in the following question.... rest of the cases seems fine to me. Any explanation for my issue would be appreciated.\\n `class Solution {\\n\\n    public int[] searchRange(int[] nums, int target) {\\n        StringBuilder r = new StringBuilder();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            r.append(nums[i]);\\n        }\\n        String w=r.toString();\\n        String y=\"\";\\n        y+=target;\\n        int a[]=new int[2];\\n         a[0]=w.indexOf(y);\\n         a[1]=w.lastIndexOf(y);\\n        return a;\\n    }\\n}`\\noutput console\\nnums[] = [0,0,0,0,1,2,3,3,4,5,6,6,7,8,8,8,9,9,10,10,11,11]\\ntarget = 0\\nexpected output = [0,3]\\nmy output = [0,21]\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey Everyone, Need your help and input on the following test case:\\nnums =\\n[3,3,3]\\ntarget =\\n3\\nMy output is [0,1,2] but expected output is [0,2]. Why?\\nThanks in advance\\nKeep Coding :)"
                    },
                    {
                        "username": "xolotl2",
                        "content": "it only needs starting and ending indices of the target. 1 and any other middle value should be ignored "
                    }
                ]
            },
            {
                "id": 1839995,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1838240,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1837229,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1828142,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1827454,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1827274,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1820459,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1813057,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1810734,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1809925,
                "content": [
                    {
                        "username": "TatianaTt",
                        "content": "Why this code does not work in LeetCode, but it works on my IDE:\\n\\n# LeetCode 34. Find First and Last Position of Element in Sorted Array\\nclass Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Main Function\\n        left = self.first_tar(nums, target)\\n        right = self.last_tar(nums, target)\\n        return [left, right]\\n\\n    def last_tar(self, nums,target):\\n        last_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l+1 < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the last position of the target value           \\n                l = mid\\n        if nums[r] == target:\\n            last_target = r\\n        if nums[l] == target:\\n            last_target = l\\n        return last_target \\n    \\n    def first_tar(self, nums, target):\\n        first_target = -1 \\n        l = 0 \\n        r = len(nums)-1\\n        while l < r:\\n            mid = l + (r-l)//2\\n            if nums[mid] > target:\\n                r = mid\\n            elif nums[mid] < target:\\n                l = mid\\n            else: # nums[mid] == target\\n                # because it is to find the first position of the target value           \\n                r = mid  \\n        if nums[l] == target:\\n            first_target = l\\n        if nums[r] == target:\\n            first_target = r\\n        return first_target\\n        \\n\\n\\n"
                    },
                    {
                        "username": "deepak_kaushik",
                        "content": "try doing l =  mid+1 and r=mid-1"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int left = 0,right = nums.size()-1;\\n        int n = nums.size();\\n        vector<int>ans;\\n        int point;\\n        bool flage = false;\\n        while(left<=right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target){\\n                point = mid;\\n                // ans.push_back(mid);\\n                flage = true;\\n                break;\\n\\n            }else if(nums[mid]>target){\\n                right = mid-1;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        if(flage){\\n            // cout<<point;\\n            while(point != 0 && nums[point]==target){\\n                ans[0] = point;\\n                point--;\\n            }\\n            while(point != n-1 && nums[point]==target){\\n                ans[1] = point;\\n                point++;\\n            }\\n        }else{\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\nPlease find error"
                    },
                    {
                        "username": "jaindarshan295",
                        "content": "in case the whole list is of target it would take order of n time so rather than traversing every value besides \"point\" you can again apply binary search on both sides"
                    },
                    {
                        "username": "DP0307",
                        "content": "class Solution {\\npublic:\\n  int first(vector<int>& nums, int target){\\n    int ans =-1;\\n        for(int i =0;i<nums.size();i++){\\n              if(nums[i] == target ){\\n                ans = i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\nint second(vector<int>& nums, int target){\\n  int ans =-1;\\n        for(int i =nums.size()-1;i>=0;i--){\\n              if(nums[i] == target ){\\n                ans =i;\\n                break;\\n              }\\n        }\\n        return ans;\\n}\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n      \\n       int a = first(nums,target);\\n       int b = second(nums,target);\\n        \\n      \\n      return {a,b};\\n    }\\n};"
                    },
                    {
                        "username": "Swakshan",
                        "content": "HOW MY CODE IS ACCEPTED Even after using O(n) time complexity\\n"
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Anyone solved this question using binary search template 3? Please let me know about it.\\nThanks!"
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "This is a pretty good problem."
                    },
                    {
                        "username": "adrianP",
                        "content": "How to be extra: \"non-decreasing order\" (\\u25D1\\u203F\\u25D0)"
                    },
                    {
                        "username": "papaidebnath5690",
                        "content": "if the target will be there 2 times in the nums array or not??"
                    },
                    {
                        "username": "shubhi4",
                        "content": "target element can be 0 times, 1 times or more times\\nif its 0 times then answer ->[-1,-1]\\nif its 1 times then index of target elemnt is i \\n     then answer ->[ i, i ]\\nif its >=2 times then i is index of first index of target and j is last index of target \\n     then answer ->[ i, j ]"
                    },
                    {
                        "username": "krapirastogi2329",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> res;\\n        int foc=-1,loc=-1;    \\n        int l=0,h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n                foc=mid;\\n                h=mid-1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n         l=0;h=nums.size()-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(target==nums[mid])\\n            {\\n               loc=mid;\\n                h=mid+1;\\n            }\\n            else if(target<nums[mid])\\n            {\\n                h=mid-1;\\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        res.push_back(foc);\\n        res.push_back(loc);\\n        return res;\\n    }\\n};\\n\\n\\nwhy does this show tle?\\n"
                    },
                    {
                        "username": "Sohoom_418",
                        "content": "same"
                    },
                    {
                        "username": "guptapiyush264",
                        "content": "i tried some new and efficient approach|| binary_search ||c++ ||must see||\\noptimized approch\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> v;\\n        \\n        int starting=lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        int ending= lower_bound(nums.begin(),nums.end(),target+1)-nums.begin()-1;\\n        if(binary_search(nums.begin(),nums.end(),target))\\n          {\\n            return {starting,ending};\\n          }\\n          else\\n          return {-1,-1};\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1799871,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1799192,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1798389,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1797716,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1797006,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1796821,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1795347,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1794574,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1792832,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1787070,
                "content": [
                    {
                        "username": "HUGE_0000",
                        "content": "If I used v.push_back(mid) here instead of v[0] =mid or v[1]=mid (as i comment out)  ,It didn\\'t pass case 2 and case3.  Plz help me how can I fix it.\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n = nums.size() , l = 0, h = n-1;\\n        vector<int>v;\\n        //  vector<int>v(2,-1);\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==0 || nums[mid]!= nums[mid-1])\\n                {\\n                    // v[0]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    h = mid-1;\\n                }\\n            }\\n\\n        }\\n        l = 0; h = n-1;\\n        while(l<=h)\\n        {\\n            int mid = (l+h)/2;\\n            if(target > nums[mid])\\n            {\\n                l = mid +1;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                h =  mid -1;\\n            }\\n            else\\n            {\\n                if(mid==n-1 || nums[mid]!= nums[mid+1])\\n                {\\n                    // v[1]=mid;\\n                    v.push_back(mid);\\n                    break;\\n                }\\n                else\\n                {\\n                    l = mid+1;\\n                }\\n            }\\n\\n        }\\n        return v;\\n        \\n\\n        \\n    }\\n    \\n};\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "O(n logn) for this is easy, not medium."
                    },
                    {
                        "username": "RitikRaj18",
                        "content": "I am getting runtime error with my code. `your inline code...your inline code...`\\nVisible Test Cases are correct but on submitting getting error with this input:-\\nnums = [2,2]\\ntarget = 2\\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int> ans;\\n        int l = 0, r = nums.size() - 1, mid;\\n        int flag = 0;\\n        while( l <= r ){\\n            mid = l + (r - l) / 2;\\n            if( nums[mid] == target ){\\n                flag = 1;\\n                break;\\n            }    \\n            if( nums[mid] < target ){\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n        if( flag == 0){\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else{\\n            int i=mid;\\n            while( nums[i] == nums[i-1] && i !=0 ) i--;\\n            ans.push_back(i);\\n\\n            i = mid;\\n            while( nums[i] == nums[i+1] && i != nums.size()-1) i++;\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\nError:-\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000070 overflowed to 0x60200000006c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "monikachand714",
                        "content": "\\n\\n`class Solution {\\npublic:\\n\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n\\n\\n        vector<int>result;\\n        int start=firstPos(nums,target);\\n        int last=lastPos(nums,target);\\n        result.push_back(start);\\n        result.push_back(last);\\n\\n        return result;\\n        \\n    }\\n    int firstPos(vector<int>& nums, int target) {\\n     int ans=-1;  \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target <nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            high=mid-1;\\n        }\\n     }\\n     return ans;\\n    }\\n\\n\\n    int lastPos(vector<int>& nums, int target){\\n     int ans=-1; \\n     int high=nums.size()-1;\\n     int low=0;\\n\\n     while(low<=high)\\n     {\\n        int mid = low+(high-low)/2;\\n        if( target > nums[mid])\\n        {\\n           low= mid+1;\\n        }\\n        else if( target < nums[mid])\\n        {\\n            high=mid-1;\\n        \\n        }\\n        else{\\n            ans=mid;\\n            low=mid+1;\\n        }\\n     }\\n     return ans;\\n\\n    }\\n\\n};`"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Find the mid-pointer of array. If the value at mid-pointer is greater than target, then it means that range of target lies on left of mid, if value at mid-pointer is lesser than target, then target lies on the right side, otherwise target lies on both the sides. "
                    },
                    {
                        "username": "sarthi_",
                        "content": "What is wrong with this code I can't understand...\n\nclass Solution {\npublic:\n    int firstIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            e = mid - 1;\n            s = 0;\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\nint lastIndex(vector<int> &nums, int target)\n{\n    int s = 0, e = nums.size() - 1;\n    int mid = s + (e - s) / 2;\n    int ans = -1;\n    while (s <= e)\n    {\n        if (nums[mid] == target)\n        {\n            ans = mid;\n            s = mid + 1;\n            e = nums.size();\n        }\n        else if (nums[mid] > target)\n        {\n            e = mid - 1;\n        }\n        else\n        {\n            s = mid + 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return ans;\n}\n\nvector<int> searchRange(vector<int> &nums, int target)\n{\n    vector<int> ans;\n    ans.push_back(firstIndex(nums, target));\n    ans.push_back(lastIndex(nums, target));\n    return ans;\n}\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\n    int first_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int f= INT_MAX;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            f = min(f,mid);\\n            e= mid -1;\\n        }\\n        else if(v[mid] > key)\\n        { \\n            e  = mid-1;\\n\\n        }else\\n        {\\n                 s = mid+1;\\n        }\\n    }\\n    if( f == INT_MAX)\\n         f = -1; \\n    return f;\\n\\n}\\nint last_index(vector<int>&v,int key)\\n{\\n    int s=0;\\n    int e = v.size()-1;\\n    int l= INT_MIN;\\n\\n    while(s<=e)\\n    {\\n        int mid  =(s+e)/2;\\n        if(v[mid] == key)\\n        {\\n            l = max(l,mid);\\n            s= mid +1;\\n        }\\n        else if(v[mid] > key)\\n        { e  = mid-1;\\n        }\\n        else\\n        {\\n             s = mid+1;\\n        }\\n    }\\n    if( l == INT_MIN)\\n    { \\n        l = -1; \\n    }\\n    return l;\\n\\n}\\npublic:\\nvector<int> searchRange(vector<int>&arr,int key)\\n{\\n    int n = arr.size();\\n    \\n    int ans1 = first_index(arr,key);\\n    int ans2 = last_index(arr,key);\\n\\n    vector<int>v;\\n    v.push_back(ans1);\\n    v.push_back(ans2);\\n    return v;\\n\\n}\\n};"
                    },
                    {
                        "username": "spriyanka2244",
                        "content": "            [0,1,2,3,4,5,6]\\nnums =[5,7,7,8,8,8,10]   target =8  Output =[3,5]\\n\\nif  nums[mid] < x:   ((( if target (x) exit and mid value (4)  is less than target value (x) (8)  ))) \\n                    lo = mid+1 ((than it return left most lower value ))\\n                else:\\n                    hi = mid    (((   if target (x) exit and mid value (4)  is greater than target value (x) (2)  )))             \\n            return lo             (( than it return index value which is equal to target value of index  ))\\n\\nlo = search(target)  it return the  index value eg 3\\n\\nhi = search(target+1)-1   the arr start with 0,1,2,3,4 when we say search(target+1) it will return which         _                                      is high index value 6 that  will count from 1,2,3 so only we -1  to get 5 index\\n"
                    },
                    {
                        "username": "ritikumra",
                        "content": "Heyy! I have used this approach of binary search and then finding the element and returning it\\'s start and ending index. Only 4 test cases have been passed can anyone help me optimize it and find the error. \\n\\nclass Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int s=0;\\n        int n= nums.size();\\n        int e=n-1;\\n        int arr[2]={-1,-1};\\n\\n        while(s<=e){\\n\\n            int mid= s+(e-s)/2;\\n            if(nums[mid]==target){\\n                if(nums[mid]==nums[mid-1]){\\n                    arr[0]=mid-1;\\n                    arr[1]=mid;\\n                }\\n                if(nums[mid]==nums[mid+1]){\\n                    arr[0]=mid;\\n                    arr[1]=mid+1;\\n                }\\n            }\\n\\n            if(nums[mid]>target){\\n                e=mid+1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n            if(nums[mid]<target){\\n                s=mid+1;\\n            }\\n            else{\\n                e=mid-1;\\n            }\\n        }\\n        return {arr[0],arr[1]};\\n        \\n    }\\n};"
                    },
                    {
                        "username": "prabaltripathi",
                        "content": "i am solving it through java and with O(log n ) complexity probably 2log n .....yet it is showing Time Limit ecxeeded"
                    }
                ]
            },
            {
                "id": 1783464,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1781286,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1777542,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771722,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1767722,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1762515,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755686,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1752602,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1750006,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1744750,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n   int Fstarting_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n   int Fending_index_target_element(vector<int>&nums,int target,int n){\\n        int low=0,high=n-1,ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low) / 2;\\n            if(nums[mid]>target){\\n                 high=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                 low=mid+1;\\n            }\\n            else{\\n                low=mid+1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        int lmi=Fstarting_index_target_element(nums,target,n);\\n        int rmi=Fending_index_target_element(nums,target,n);\\n            temp.push_back(lmi);\\n            temp.push_back(rmi);\\n            return temp;\\n    }\\n};"
                    },
                    {
                        "username": "mminyngy",
                        "content": " `class Solution(object):\\n    def searchRange(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start = 0\\n        end = len(nums) - 1\\n        index = end\\n        result = []\\n\\n        if target in nums:\\n            start = nums.index(target)\\n            for num in reversed(nums):\\n                if num == target:\\n                    end = index\\n                    break\\n                index -= 1\\n        else:\\n            start = -1\\n            end = -1\\n            \\n        result[:] = [start, end]\\n        return result`\\n\\nwill it be accepted? I tryna make it look easy tho"
                    },
                    {
                        "username": "rahulraj17",
                        "content": "These codes give TLE, what should i do ?\\n\\nclass Solution {\\npublic:\\n    int firstOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    \\n    int lastOccurance(vector<int> arr, int n, int k) {\\n        \\n        int start = 0; \\n        int end = n-1;\\n        int mid = start + (end - start)/2;\\n        int ans = -1;\\n        while(start <= end) {\\n            if(k == arr[mid]) {\\n                ans = mid;\\n                int start = mid + 1;\\n            }\\n            else if(k > arr[mid]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            mid = start + (end - start)/2;\\n        }\\n        return ans;\\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        // return{firstOccurance(nums,nums.size(),target), lastOccurance(nums,nums.size(),target)};\\n    }\\n};"
                    },
                    {
                        "username": "Ultron03",
                        "content": "check for which testcase it is giving tle and then solve the testcase in the paper according to your code .. hop it works."
                    },
                    {
                        "username": "user4474EC",
                        "content": "class Solution {\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        if( nums.size()==0)return{-1,-1};\\n        if(nums.size()==1 && nums[0]==target)return {0,0};\\n        int s=0,e=nums.size()-1;\\n        vector<int>ans;\\n        while(s<=e){\\n            int mid=(s+e)/2;\\n            if(nums[mid]==target){\\n                int l=mid,r=mid;\\n                if( nums[mid]!=nums[mid-1]&&nums[mid]!=nums[mid+1] ){\\n                    ans.push_back(mid);\\n                    ans.push_back(mid);break;\\n                }\\n                else\\n                {\\n                    while( nums[l]==nums[mid])l--;\\n                    ans.push_back(l+1); \\n                    while( nums[r]==nums[mid])r++;\\n                    ans.push_back(r-1);\\n                }\\n\\n                break;\\n                \\n            }\\n            else if(nums[mid]>target ){\\n                e=mid-1;\\n\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n        }\\n        if( ans.size()==0){\\n            if( nums.size()==1&& target==nums[0])return {0,0};\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else if ( ans.size()==1){\\n            if( nums.size()==1 && nums[0]==ans[0])ans.push_back(0);\\n            ans.push_back( ans[0]);\\n        }\\n            \\n\\n        return ans;\\n    }\\n}; \\n\\nthis is my code i am not getting why this is getting run time error for values.\\n"
                    },
                    {
                        "username": "adityapaluskar",
                        "content": "how do i return arrays in output as shown in example... need help"
                    },
                    {
                        "username": "Ultron03",
                        "content": "just make a vector of size two and initialize them with -1 and change if  the target indices found..\\n "
                    },
                    {
                        "username": "kimkass",
                        "content": "What does the description has to be so ambiguous instead  of saying sorted in non decreasing order it can say sorted in increasing order."
                    },
                    {
                        "username": "MissRobot",
                        "content": "Non-decreasing and increasing orders are not the same thing, since the same element can be repeated as in 8 8 8 ... it is non-decreasing order, can\\'t be increasing order."
                    },
                    {
                        "username": "mahak_22",
                        "content": "class Solution {\\npublic:\\nint firstoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            r=mid-1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n    }\\n    return result;\\n}\\nint lastoccurence(vector<int>& arr,int n,int x)\\n{\\n    int l=0,r=n-1;\\n    int result=-1;\\n    while(l<=r)\\n    {\\n        int mid=l+(r-l)/2;\\n        if(arr[mid]==x)\\n        {\\n            result=mid;\\n            l=mid+1;\\n        }\\n        else if(arr[mid]>x)\\n        {\\n            r=mid-1;\\n        }\\n        else\\n        {\\n            l=mid+1;\\n        }\\n        \\n    }\\n    return result;\\n    \\n}\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        \\n    vector<int>v;\\n    \\n    int f=firstoccurence(nums,nums.size(),target);\\n    int last=lastoccurence(nums,nums.size(),target);\\n    return v={f,last};\\n    }\\n\\n};"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "mukulbhardwaj947",
                        "content": "I have debugged my code  but it still shows TLE.What should i do? "
                    },
                    {
                        "username": "ram_singhal17",
                        "content": "PLEASE HELP ME OUT!! \\n\\nclass Solution {\\npublic:\\n    void search(vector<int>&nums,vector<int>&v,int low,int high,int target,bool flag){\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target && nums[mid-1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,mid,high,target,flag);\\n            }\\n            else if(nums[mid]==target && nums[mid+1]!=target){\\n                v.push_back(mid);\\n                flag=true;\\n                if(v.size()==2) break;\\n                search(nums,v,low,mid,target,flag);\\n            }\\n            else if(nums[mid]<target){\\n                  search(nums,v,mid+1,high,target,flag);\\n            }\\n            else{\\n                search(nums,v,low,mid-1,target,flag);\\n            }\\n        }\\n        \\n        \\n    }\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        vector<int>v;bool flag=false;\\n        int low=0;int high=nums.size()-1;\\n        search(nums,v,low,high,target,flag);\\n        if(flag==false){\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739944,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1733541,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1731070,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1729988,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1721249,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1720491,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1716400,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1716051,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1699048,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            },
            {
                "id": 1685644,
                "content": [
                    {
                        "username": "anirudh9801",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int low =0;\\n        int ans =-1;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n            if(nums[mid]>target){\\n                high=mid-1;\\n            }else if(nums[mid]<target){\\n                low=mid+1;\\n            }else{\\n                if(mid==0){\\n                    return mid;\\n                }else if(nums[mid-1]!=target){\\n                    return mid;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }\\n\\n        }\\n            return ans;\\n\\n    \\n\\n        // int ans=-1;\\n        while(low<=high){\\n            int mid =(low+high)/2;\\n                   if(nums[mid]>target){\\n            high=mid-1;\\n        }else if(nums[mid]<target){\\n            low=mid+1;\\n        }else{\\n            if(mid==high){\\n                return mid;\\n            }else if(nums[mid+1]!=target){\\n                return mid;\\n            }else{\\n                low=mid+1;\\n            }\\n        }\\n    \\n    \\n}\\n        return ans;\\n\\n}\\n}\\n\\ncan anyone help me out? please??"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Igmazahmad",
                        "content": "nums.size() function does not work, what should i do?"
                    },
                    {
                        "username": "raunak_wick",
                        "content": "use nums.length"
                    },
                    {
                        "username": "chandraparkash421",
                        "content": "java solution\\n `your inline code...your inline code...`\\npublic class Solution {\\n   public int[] searchRange(int[] A, int target) {\\n    int index = binarySearch(A, 0, A.length-1, target);\\n    int[] result = {-1, -1};\\n    if (index != -1) {\\n        int left  = index;\\n        int right = index;\\n        while (left != -1){           \\n            result[0] = left;\\n            left = binarySearch(A, 0, left-1, target);\\n        }\\n        while (right != -1){ \\n            result[1] = right;\\n            right = binarySearch(A, right+1, A.length-1, target);\\n        }\\n    }\\n    return result;\\n}\\n\\nprivate int binarySearch(int[] A, int lo, int hi, int target) {\\n    while (lo <= hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if      (A[mid] < target) lo = mid + 1;\\n        else if (A[mid] > target) hi = mid - 1;\\n        else return mid;            \\n    }\\n    return -1;\\n  }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/34_first_and_last_pos.cpp"
                    },
                    {
                        "username": "anujkumar61",
                        "content": " vector<int>ans= {-1,-1};\\n      int s=0;\\n      int e=nums.size()-1;\\n\\n      while(s<=e){\\n          \\n          int mid =s+(e-s)/2;\\n         \\n         \\n          if(nums[mid] == target && nums[mid] >= 0 ){\\n              ans[0] = mid;\\n              e = mid-1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid -1;\\n          }\\n          \\n      }\\n      \\n    \\n        s = 0;\\n        e = nums.size() - 1;\\n\\n      while(s<=e){\\n          int mid = s+(e-s)/2;\\n\\n          if(nums[mid] == target){\\n              ans[1] = mid;\\n              s = mid+1;\\n          }if(nums[mid] < target){\\n              s = mid+1;\\n\\n          }else{\\n              e = mid-1;\\n          }\\n      }\\n      return ans;\\n    }\\n\\n\\nI don\\'t know what did i do wrong but only 49/88 testcases are passed \\ncan anyone know?\\n"
                    },
                    {
                        "username": "fardinalam2112",
                        "content": "but we have to do that code in log(n) time if use 2 loop then it will be still in log(n)?\n"
                    },
                    {
                        "username": "Prathvik",
                        "content": "[@anujkumar61](/anujkumar61)  replace \" if(nums[mid]<target) \" with else \" if(nums[mid]<target) \"thats where the error is"
                    },
                    {
                        "username": "anujkumar61",
                        "content": "[@Prathvik](/Prathvik) still getting error after submitting"
                    },
                    {
                        "username": "Prathvik",
                        "content": "remove the && nums[mid]>= 0 condition and it should be fine"
                    },
                    {
                        "username": "sam_chirayu",
                        "content": "Why we need to iterate two times... can\\'t we iterate only one time and if yes then how ???"
                    },
                    {
                        "username": "DURGA_SAI11",
                        "content": "class Solution {\\n    public int[] searchRange(int[] nums, int target) {\\n        int arr[]=new int[2],j=0;\\n        int flag=0;\\n            for(int i=0;i<nums.length;i++)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n            for(int i=nums.length-1;i>=0;i--)\\n            {\\n                if(target==nums[i])\\n                    {arr[j]=i;j++;flag=1;break;}\\n            }\\n                if(flag==0)\\n                {arr[0]=-1;arr[1]=-1;}\\n            return arr;\\n    }\\n}"
                    },
                    {
                        "username": "user54893210",
                        "content": "Isn\\'t finding length of an array for the right pointer in a binary search o(n) cost?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDD30Easy logN FAANG \\uD83D\\uDE33 Interview Optimized Clean CODE \\uD83D\\uDE28\\nhttps://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/2270647/easy-logn-faang-interview-optimized-clean-code/"
                    }
                ]
            }
        ]
    }
]