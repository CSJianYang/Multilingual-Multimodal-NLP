[
    {
        "title": "Partition Array into Disjoint Intervals",
        "question_content": "Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\n\n\tEvery element in left is less than or equal to every element in right.\n\tleft and right are non-empty.\n\tleft has the smallest possible size.\n\nReturn the length of left after such a partitioning.\nTest cases are generated such that partitioning exists.\n&nbsp;\nExample 1:\n\nInput: nums = [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\nExample 2:\n\nInput: nums = [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t0 <= nums[i] <= 106\n\tThere is at least one valid answer for the given input.",
        "solutions": [
            {
                "id": 175945,
                "title": "java-one-pass-7-lines",
                "content": "```java\\npublic int partitionDisjoint(int[] a) {\\n        int localMax = a[0], partitionIdx = 0, max = localMax;\\n        for (int i = 1; i < a.length; i++)\\n            if (localMax > a[i]) {\\n                localMax = max;\\n                partitionIdx = i;\\n            } else max = Math.max(max, a[i]);\\n        return partitionIdx + 1;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic int partitionDisjoint(int[] a) {\\n        int localMax = a[0], partitionIdx = 0, max = localMax;\\n        for (int i = 1; i < a.length; i++)\\n            if (localMax > a[i]) {\\n                localMax = max;\\n                partitionIdx = i;\\n            } else max = Math.max(max, a[i]);\\n        return partitionIdx + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 175904,
                "title": "explained-python-simple-o-n-time-o-1-space",
                "content": "Looping through each element  `A[i]` we will keep track of the `max_so_far` and `disjoint` index. If we see a value `A[i] < max_so_far` we know that value must be in the left partition, so we update the `disjoint` location and check if we have a new  `max_so_far` in the left partition. Once we go through the list, every element on the right side of `disjoint` is guarenteed to be larger than elements left of `disjoint`\n\n```  \ndef partitionDisjoint(self, A):\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n            if A[i] < v: \n                disjoint = i\n                v = max_so_far\n        return disjoint + 1\n\t\t\t",
                "solutionTags": [],
                "code": "def partitionDisjoint(self, A):\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n                disjoint = i\n                v = max_so_far",
                "codeTag": "Python3"
            },
            {
                "id": 1122368,
                "title": "java-2-solutions",
                "content": "**GOAL:** We have to find length of left array so basically have to find idx such that if we make a partition at that idx .All values in left array are less than from values of right array.\\n\\n**OBSERVATION:** If the maximum from left array is less than minimum from right array then we can make a split at that idx.\\n\\n**CODE:**\\n```\\npublic int partitionDisjoint(int[] A) {\\n        int[] lmax=new int[A.length]; //lmax :left maximum\\n        int[] rmin=new int[A.length]; //rmin : right minimum\\n        \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<A.length;i++){\\n            max=Math.max(max,A[i]);\\n            lmax[i]=max;\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=A.length-1;i>=0;i--){\\n            min=Math.min(min,A[i]);\\n            rmin[i]=min;\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            if(lmax[i-1]<=rmin[i]) return i;\\n        }\\n        return A.length;\\n    }\\n```\\n\\n**Dry Run:**\\n arr  :     [5,0,3,8,6]\\nlmax: [5,5,**5**,8,8]\\nrMin: [0,0,3,**6**,6]\\nwe will make a split at after index 2 . i.e length of left array is 3. we are handling that thing through code.\\n\\n**Complexity :**\\n`Time : O(n) and Space:O(n)`\\n\\n**Follow UP:** `Can you Optimise Space?`\\n\\n**IDEA:**\\nwhile iterating if we keep comparing maximum from left to idx value . \\n-> we will make a answer initial at 0. assuming that till 0 left array exist.\\n-> then we will iterate and compare idx  value to maximum from left. \\n -> if value is less than maximum of left means this value belong to left array . \\n      So we need to make a next maximum variable also because now left array is till given idx at which we currently are. (value<leftmax) . So we need maximum of this new left array. which basically equal to nextMax. \\nCode will clear all your doubts.\\n\\n**CODE:**\\n```\\n public int partitionDisjoint(int[] A) {\\n        int cmax=A[0]; //cmax:current maximum\\n        int nmax=A[0];//nmax: next maximum\\n        int ans=0;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int val=A[i];\\n          nmax=Math.max(val,nmax); //next max for case if i exist in left Part\\n            \\n            if(val<cmax){\\n                ans=i;         //now left Part is till here\\n                cmax=nmax; //maximum of left array is nmax(as we are maintaining maximum for split Part)\\n            }\\n        }\\n        return ans+1; // we have to return length not idx so ans+1.\\n    }\\n```\\t\\n\\n**COMPLEXITY:**\\n` TIME : O(N) and Space:O(1)`\\n\\nPlease **upvote** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int[] lmax=new int[A.length]; //lmax :left maximum\\n        int[] rmin=new int[A.length]; //rmin : right minimum\\n        \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<A.length;i++){\\n            max=Math.max(max,A[i]);\\n            lmax[i]=max;\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=A.length-1;i>=0;i--){\\n            min=Math.min(min,A[i]);\\n            rmin[i]=min;\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            if(lmax[i-1]<=rmin[i]) return i;\\n        }\\n        return A.length;\\n    }\\n```\n```\\n public int partitionDisjoint(int[] A) {\\n        int cmax=A[0]; //cmax:current maximum\\n        int nmax=A[0];//nmax: next maximum\\n        int ans=0;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int val=A[i];\\n          nmax=Math.max(val,nmax); //next max for case if i exist in left Part\\n            \\n            if(val<cmax){\\n                ans=i;         //now left Part is till here\\n                cmax=nmax; //maximum of left array is nmax(as we are maintaining maximum for split Part)\\n            }\\n        }\\n        return ans+1; // we have to return length not idx so ans+1.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354458,
                "title": "python-two-accumulates-explained",
                "content": "Let us look more carefully at the phrase: `every element in left is less than or equal to every element in right`. Actually it means that maximum of the left part is less or equal than minimum of the right part. So, let us calculate the following arrays:\\n1. `t1` is accumulate maximum, starting from the left side.\\n2. `t2` is accumulate minimum, starting from the right side.\\n3. Iterate throught these two arrays and find the first `i`, where `t1[i-1] <= t2[i]`: it will mean that we found exaclty the correct place.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        t1 = list(accumulate(A, max)) \\n        t2 = list(accumulate(A[::-1], min))[::-1]\\n        for i in range(1, len(A)):\\n            if t1[i-1] <= t2[i]: return i\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        t1 = list(accumulate(A, max)) \\n        t2 = list(accumulate(A[::-1], min))[::-1]\\n        for i in range(1, len(A)):\\n            if t1[i-1] <= t2[i]: return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354687,
                "title": "c-easy-clean-solution",
                "content": "**Solution:**\\n\\n1. Establish the maximum `max_1` as `nums[0]`, i.e., the lowest element in the beginning.\\n2. If we find something lower than our current maximum `max_1`, that element must be included in the left partition.\\n3. Otherwise, if we find something greater than our overall maximum `curr` change its value.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1, curr, ans = 1;\\n        max_1 = curr = nums[0];\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < max_1){\\n                max_1 = curr;\\n                ans = i + 1;\\n            }\\n            else if(nums[i] > curr){\\n                curr = nums[i];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**`Time Complexity`**: **`O(n)`**\\n**`Space Complexity`**: **`O(1)`**\\nwhere **n** is the size of array **nums**.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1, curr, ans = 1;\\n        max_1 = curr = nums[0];\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < max_1){\\n                max_1 = curr;\\n                ans = i + 1;\\n            }\\n            else if(nums[i] > curr){\\n                curr = nums[i];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354396,
                "title": "python-from-o-n-space-to-o-1-space-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Build LeftMaxSoFar, RightMinSoFar**\\n- We need to partion `nums` into two subarrays `left` and `right` so that all elements in `left` subarray <= all elements in `right` subarray. It also mean we partition so that the maximum element in `left` subarray is always <= the minimum element in `right` subarray.\\n- We just need to build right min so far, let `minRight[i]` is the minimum element between elements `nums[i..n-1]`.\\n- Then we iterate `i` in range `[1..n]`, try to partion it into 2 subarrays: leftSubArr = `nums[0..i-1]`, rightSubArr = `nums[i..n-1]`. If `maxLeft <= minRight[i]` then we can partition, and now `i` is the smallest size of the left subarray, return `i` as the result.\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minRight = [0] * n\\n        minRight[n - 1] = nums[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            minRight[i] = min(nums[i], minRight[i + 1])\\n\\n        maxLeft = nums[0]\\n        for i in range(1, n):\\n            if maxLeft <= minRight[i]:\\n                return i\\n            maxLeft = max(maxLeft, nums[i])\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 30000` is number of elements in array `nums`.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: One passing**\\n- The process divide `nums` array into 3 parts:\\n\\t- Left part: `nums[0..partition]`, with the maximum number is `leftMax`.\\n\\t- Middle part: `nums[parition+1..i-1]`, where all elements are greater than or equal to elements in the left part.\\n\\t- The right part: `nums[i..n-1]`, where elements are to be processed.\\n- We keep `globalMax` as the maximum number from `nums[0...i-1]`.\\n- When iterating `i` from `[1...n-1]`, if `nums[i] < leftMax` then:\\n\\t- `nums[i]` can\\'t belong to the right subarray (because all elements in the right array must >=`maxLeft`), so `nums[i]` belong to the left subarray.\\n\\t- We re-partition, by set `partion = i`.\\n\\t- Update `leftMax = globalMax`.\\n- Finally, we return `parition + 1` as the smallest length of the left subarray which has all elements <= elements in the right subarray.\\n\\n![image](https://assets.leetcode.com/users/images/c5248a36-4521-403d-bdd9-31023d62db73_1626947567.8115952.png)\\n\\n\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = globalMax = nums[0]\\n        partition = 0\\n        for i in range(1, len(nums)):\\n            globalMax = max(globalMax, nums[i])\\n            if nums[i] < leftMax:  # If nums[i] < leftMax then nums[i] belong to left subarray, re-partition leftSubArr = nums[0..i]\\n                partition = i\\n                leftMax = globalMax\\n        return partition + 1\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 30000` is number of elements in array `nums`.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minRight = [0] * n\\n        minRight[n - 1] = nums[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            minRight[i] = min(nums[i], minRight[i + 1])\\n\\n        maxLeft = nums[0]\\n        for i in range(1, n):\\n            if maxLeft <= minRight[i]:\\n                return i\\n            maxLeft = max(maxLeft, nums[i])\\n```\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = globalMax = nums[0]\\n        partition = 0\\n        for i in range(1, len(nums)):\\n            globalMax = max(globalMax, nums[i])\\n            if nums[i] < leftMax:  # If nums[i] < leftMax then nums[i] belong to left subarray, re-partition leftSubArr = nums[0..i]\\n                partition = i\\n                leftMax = globalMax\\n        return partition + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197987,
                "title": "python-solutions-3-passes-2-passes-1-pass-straight-forward",
                "content": "**3 passes solution:**\\n first pass: use an array to keep the maximun of all left element,\\n second pass:  use an array to keep the minimun of all right element,\\n third pass: find where the maxleft <= minright:\\n ```\\n     def partitionDisjoint(self, A):\\n        maxleft = [A[0]]*len(A)\\n        for i in range(1,len(A)):\\n            maxleft[i] = max(maxleft[i-1], A[i])\\n            \\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n        \\n        for i in range(len(A)-1):\\n            if maxleft[i] <= minright[i+1]:\\n                return i+1\\n ```\\n \\n **2 passes solution:**\\n skip the first maxleft pass, keep only the minright array,  and use maxleft as a variable:\\n ```\\n     def partitionDisjoint(self, A):\\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n\\n        maxleft = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            maxleft = max(maxleft, A[i])  \\n            if maxleft <= minright[i+1]:\\n                return i+1\\n```\\t\\t\\t\\t\\n \\n **1 pass solution:**\\n use one more variable leftmax to moniter:\\n ```\\n     def partitionDisjoint(self, A):\\n        disjoint = 0\\n        curmax = leftmax = A[0]\\n        for i,num in enumerate(A):\\n            curmax = max(curmax, num)\\n            if num < leftmax:\\n                leftmax = curmax\\n                disjoint = i\\n        return disjoint + 1 \\n ```",
                "solutionTags": [],
                "code": "```\\n     def partitionDisjoint(self, A):\\n        maxleft = [A[0]]*len(A)\\n        for i in range(1,len(A)):\\n            maxleft[i] = max(maxleft[i-1], A[i])\\n            \\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n        \\n        for i in range(len(A)-1):\\n            if maxleft[i] <= minright[i+1]:\\n                return i+1\\n ```\n```\\n     def partitionDisjoint(self, A):\\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n\\n        maxleft = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            maxleft = max(maxleft, A[i])  \\n            if maxleft <= minright[i+1]:\\n                return i+1\\n```\n```\\n     def partitionDisjoint(self, A):\\n        disjoint = 0\\n        curmax = leftmax = A[0]\\n        for i,num in enumerate(A):\\n            curmax = max(curmax, num)\\n            if num < leftmax:\\n                leftmax = curmax\\n                disjoint = i\\n        return disjoint + 1 \\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1150150,
                "title": "c-solution-o-n-time-o-1-space-single-traversal",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0];\\n        int index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                index=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0];\\n        int index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                index=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355198,
                "title": "partition-array-into-disjoint-intervals-detailed-explaination-java",
                "content": "**Intuition**\\n* We need to divide the array into 2 parts such that max element on the left side is smaller or equal to every element on the right\\n* We can maintain a `maxLeft` to keep track of this.\\n* Now if we come across any number `num[i]` which is smaller than the `maxLeft`, this  number cannot be part of the right side.\\n* Thus we need to update the `maxLeft` and the index of our partition `p`\\n* Regarding updating our index, its straight forward to update to `i` since the ith element has to be part of left side.\\n* Now what would be the updated `maxLeft`. This has to simply be the value of the maximum element encountered so far since this element was present before ith index so has to be the `maxLeft` now.\\n* Thus we will keep track of a `max` and update `maxLeft` to this value whenever we encounter a smaller number than `maxLeft`\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```\\nPlease upvote this solution if it helps you in understanding so it can reach others as well.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724809,
                "title": "o-n-solution-with-explanation",
                "content": "I find that many people post similar solutions as below but without a clear explanation.\\nThe key point is that we maintain two max values: 1. the global max till current element. 2. the max value of the `left part`. Each time when we check a new element `A[i]`, if `A[i]` is smaller than the max value of the current left part (defined by [0, leftEnd]), A[i] should be included into the left part and therefore, i becomes the new `leftEnd`. For the same reason, the new max value of the left part is the current max value `max`. Furthermore, we update the global max value each time when we check a new element A[i].\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int maxLeft = A[0], max = A[0], leftEnd = 0;    \\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < maxLeft) {\\n                leftEnd = i;\\n                maxLeft = max;\\n            }\\n            max = Math.max(max, A[i]);\\n        }\\n        return leftEnd+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int maxLeft = A[0], max = A[0], leftEnd = 0;    \\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < maxLeft) {\\n                leftEnd = i;\\n                maxLeft = max;\\n            }\\n            max = Math.max(max, A[i]);\\n        }\\n        return leftEnd+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175842,
                "title": "java-easiest-simplest",
                "content": "```\\n    public int partitionDisjoint(int[] A) {\\n        int num=A[0];\\n        int size=0;\\n        int max=num;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            max=Math.max(max,A[i]);\\n            if(A[i]<num)\\n            {\\n                num=max;\\n                size=i;\\n            }\\n        }\\n        return size+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int partitionDisjoint(int[] A) {\\n        int num=A[0];\\n        int size=0;\\n        int max=num;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            max=Math.max(max,A[i]);\\n            if(A[i]<num)\\n            {\\n                num=max;\\n                size=i;\\n            }\\n        }\\n        return size+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1354475,
                "title": "partition-array-into-disjoint-intervals-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }\\n            maxi =max(nums[i],maxi); \\n        }\\n        return ptr+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1359686,
                "title": "python-best-solution-yet-explained-with-comments-to-make-life-easier-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Intuition(logic) is to find two maximums.\\n        One maximum is for left array and other maximum is for right array.\\n        \\n        But the condition is that, the right maximum should be such that, \\n        no element after that right maximum should be less than the left maximum. \\n        \\n        If there is any element after right maximum which is less than left maximum,\\n        that means there is another right maximum possible and therefore in that case assign\\n        left maximum to right maximum and keep searching the array for correct right\\n        maximum till the end.\\n        \"\"\"\\n        #start with both left maximum and right maximum with first element.\\n        left_max = right_max = nums[0]\\n        # our current index\\n        partition_ind = 0\\n        # Iterate from 1 to end of the array\\n        for i in range(1,len(nums)):\\n            #update right_max always after comparing with each nums\\n            #in order to find our correct right maximum\\n            right_max = max(nums[i], right_max)\\n            \"\"\"\\n\\t\\t\\tif current element is less than left maximum, that means this \\n            element must belong to the left subarray. \\n              * so our partition index will be updated to current index \\n              * and left maximum will be updated to right maximum. \\n             Why left maximum updated to right maximum ?\\n              Because when we find any element less than left_maximum, that \\n              means the right maximum which we had till now is not valid and we have\\n              to find the valid right maximum again while iterating through the end of the loop.\\n\\t\\t\\t\"\"\"\\n            if nums[i] < left_max:\\n                left_max = right_max\\n                partition_ind = i\\n        \\n        return partition_ind+1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Intuition(logic) is to find two maximums.\\n        One maximum is for left array and other maximum is for right array.\\n        \\n        But the condition is that, the right maximum should be such that, \\n        no element after that right maximum should be less than the left maximum. \\n        \\n        If there is any element after right maximum which is less than left maximum,\\n        that means there is another right maximum possible and therefore in that case assign\\n        left maximum to right maximum and keep searching the array for correct right\\n        maximum till the end.\\n        \"\"\"\\n        #start with both left maximum and right maximum with first element.\\n        left_max = right_max = nums[0]\\n        # our current index\\n        partition_ind = 0\\n        # Iterate from 1 to end of the array\\n        for i in range(1,len(nums)):\\n            #update right_max always after comparing with each nums\\n            #in order to find our correct right maximum\\n            right_max = max(nums[i], right_max)\\n            \"\"\"\\n\\t\\t\\tif current element is less than left maximum, that means this \\n            element must belong to the left subarray. \\n              * so our partition index will be updated to current index \\n              * and left maximum will be updated to right maximum. \\n             Why left maximum updated to right maximum ?\\n              Because when we find any element less than left_maximum, that \\n              means the right maximum which we had till now is not valid and we have\\n              to find the valid right maximum again while iterating through the end of the loop.\\n\\t\\t\\t\"\"\"\\n            if nums[i] < left_max:\\n                left_max = right_max\\n                partition_ind = i\\n        \\n        return partition_ind+1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354395,
                "title": "partition-array-into-disjoint-intervals-c-with-approach",
                "content": "# **APPROACH:**\\nSuppose we have an array A, we have to partition it into two subarrays left and right such that \\u2212\\n1. Every element in left subarray is `less than or equal` to every element in right subarray.\\n2. Left and right subarrays are `non-empty`.\\n3. Left subarray has the `smallest possible size`.\\n\\nWe have to find the `length of left` after such a partitioning. It is guaranteed that such a partitioning exists.\\n# TEST CASE\\n* If the input is like `[5,0,3,8,6]` \\n* The output will be 3\\n\\t* left array will be [5,0,3] \\n\\t* Right subarray will be [8,6].\\n# **ALGORITHM**\\nTo solve this, we will follow these steps \\u2212\\n* n := size of A, create an array mx of size n\\n* minVal := last element of A\\n* mx[0] := A[0]\\n* for i in range 1 to n \\u2013 1\\n\\t* mx[i] := max of A[i] and A[i \\u2013 1]\\n* ans := size of A \\u2013 1\\n* for i in range n \\u2013 1 down to 1\\n\\t* minVal := minimum of minVal and A[i]\\n\\t* if minVal >= mx[i \\u2013 1], then ans := i\\n* return ans\\n\\n# **SOLUTION:**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n)\\nSPACE COMPLEXITY: O(1)**\\nI\\'ll try different approaches too and update this.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535475,
                "title": "super-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        vector<int> mx(A.size()), mi(A.size());\\n        mx[0]=A[0]; mi[A.size()-1]=A.back();\\n        for(int i=1; i<A.size(); i++)\\n            mx[i]=max(A[i], mx[i-1]);\\n        for(int i=A.size()-2; i>=0; i--)\\n            mi[i]=min(A[i], mi[i+1]);\\n        int i;\\n        for(i=0; i<A.size()-1; i++)\\n            if(mx[i]<=mi[i+1])\\n                break;\\n        return i+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        vector<int> mx(A.size()), mi(A.size());\\n        mx[0]=A[0]; mi[A.size()-1]=A.back();\\n        for(int i=1; i<A.size(); i++)\\n            mx[i]=max(A[i], mx[i-1]);\\n        for(int i=A.size()-2; i>=0; i--)\\n            mi[i]=min(A[i], mi[i+1]);\\n        int i;\\n        for(i=0; i<A.size()-1; i++)\\n            if(mx[i]<=mi[i+1])\\n                break;\\n        return i+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120556,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Two Extra arrays***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        vector<int> left_max(n, 0);\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the left_max array\\n        \\n        left_max[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            left_max[i] = max(left_max[i - 1], nums[i]);\\n        }\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max[i - 1] > right_min[i])\\n            {\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 2 : Using Single Extra Array***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        int left_max = nums[0];\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max > right_min[i])\\n            {\\n                count++;\\n                \\n                left_max = max(left_max, nums[i]);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 3 : Without Using Any Extra Array***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int ans = 0;\\n        \\n        int curr_max = nums[0];\\n        \\n        int possible_max = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] < curr_max)\\n            {\\n                ans = i;\\n                \\n                curr_max = possible_max;\\n            }\\n            else\\n            {\\n                possible_max = max(possible_max, nums[i]);\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        vector<int> left_max(n, 0);\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the left_max array\\n        \\n        left_max[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            left_max[i] = max(left_max[i - 1], nums[i]);\\n        }\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max[i - 1] > right_min[i])\\n            {\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        int left_max = nums[0];\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max > right_min[i])\\n            {\\n                count++;\\n                \\n                left_max = max(left_max, nums[i]);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int ans = 0;\\n        \\n        int curr_max = nums[0];\\n        \\n        int possible_max = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] < curr_max)\\n            {\\n                ans = i;\\n                \\n                curr_max = possible_max;\\n            }\\n            else\\n            {\\n                possible_max = max(possible_max, nums[i]);\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354844,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> maxl(n),minr(n);\\n        int maxll=-1;\\n        for(int i=0;i<n;i++){\\n            maxll=max(maxll,nums[i]);\\n            maxl[i]=maxll;\\n        }\\n        int minrr = INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            minrr=min(minrr,nums[i]);\\n            minr[i]=minrr;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            if(maxl[i]<=minr[i+1]){\\n                return (i+1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> maxl(n),minr(n);\\n        int maxll=-1;\\n        for(int i=0;i<n;i++){\\n            maxll=max(maxll,nums[i]);\\n            maxl[i]=maxll;\\n        }\\n        int minrr = INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            minrr=min(minrr,nums[i]);\\n            minr[i]=minrr;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            if(maxl[i]<=minr[i+1]){\\n                return (i+1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354704,
                "title": "partition-array-into-disjoint-intervals-brute-force-thinking-commented-c",
                "content": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums);\\n        //let\\'s intialsise ans = n , and minele in right subarray which is empty right now to be INF.\\n        int ans = n ,i = n-1,j =n-1,minele = 10000000;\\n        \\n        //will try reduce left array up to size 1\\n        while(i > 0){\\n            //reduce size of left array by 1 and now ith ele will be part of right\\n            // update minele\\n            minele = min(nums[i],minele);\\n            \\n            //now traverse and check the condition\\n            int tempele = minele , rc =-1,rcmin; j = i-1;\\n            \\n            while(j >= 0){\\n                //if found some ele greater we need to reduce left subarray up to that, so rc the index\\n                if(nums[j] > minele){\\n                    rc = j;\\n                    minele = tempele;\\n                }\\n                tempele = min(nums[j--],tempele);\\n            }\\n            \\n            //if condition satisfied dec ans by 1 and continue\\n            if(rc == -1){\\n                ans--;\\n                i--;\\n                continue;\\n            }\\n            //if left array reduce to zero break\\n            else if(rc == 0){\\n                break;\\n            }\\n            //o.w. include the array in right up to recorded index \\n            ans = ans-(i-rc);\\n            i = rc;\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n**Update(optimized approach)**\\nInstead of traversing from back reducing the size, actually we can start from very left and , \\nas we would getting first the minimum size we don\\'t need to worry about any other possible \\nmin size, just we need to check the condition and update the ans.\\n\\n\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums) , ans = 1;\\n        \\n        //let\\'s have a maxm which store left array max element\\n        // and tempmax which will store curr max of traversing array.\\n        int tempMax = nums[0];\\n        int maxm = tempMax;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //if someone is less than maxm , means we need to include in our left subarray\\n            //let\\'s include and update the ans\\n            if(maxm > nums[i]){\\n                maxm = tempMax;\\n                ans = i+1;\\n            }\\n            //update curr max;\\n            tempMax = max(tempMax, nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums);\\n        //let\\'s intialsise ans = n , and minele in right subarray which is empty right now to be INF.\\n        int ans = n ,i = n-1,j =n-1,minele = 10000000;\\n        \\n        //will try reduce left array up to size 1\\n        while(i > 0){\\n            //reduce size of left array by 1 and now ith ele will be part of right\\n            // update minele\\n            minele = min(nums[i],minele);\\n            \\n            //now traverse and check the condition\\n            int tempele = minele , rc =-1,rcmin; j = i-1;\\n            \\n            while(j >= 0){\\n                //if found some ele greater we need to reduce left subarray up to that, so rc the index\\n                if(nums[j] > minele){\\n                    rc = j;\\n                    minele = tempele;\\n                }\\n                tempele = min(nums[j--],tempele);\\n            }\\n            \\n            //if condition satisfied dec ans by 1 and continue\\n            if(rc == -1){\\n                ans--;\\n                i--;\\n                continue;\\n            }\\n            //if left array reduce to zero break\\n            else if(rc == 0){\\n                break;\\n            }\\n            //o.w. include the array in right up to recorded index \\n            ans = ans-(i-rc);\\n            i = rc;\\n        }\\n        return ans;\\n    }\\n```\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums) , ans = 1;\\n        \\n        //let\\'s have a maxm which store left array max element\\n        // and tempmax which will store curr max of traversing array.\\n        int tempMax = nums[0];\\n        int maxm = tempMax;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //if someone is less than maxm , means we need to include in our left subarray\\n            //let\\'s include and update the ans\\n            if(maxm > nums[i]){\\n                maxm = tempMax;\\n                ans = i+1;\\n            }\\n            //update curr max;\\n            tempMax = max(tempMax, nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833302,
                "title": "python-short-and-simple-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        min_ = A.index(min(A))\\n        # min of list is first - we can leave only it in the left\\n        if min_ == 0:\\n            return 1\\n        \\n        # find minimum index to end first partition\\n        max_before_min = A.index(max(A[:min_]))\\n        while len(A[min_+1:])>0 and min(A[min_+1:]) < A[max_before_min]:\\n            min_ = len(A) - A[::-1].index( min(A[min_+1:])) - 1\\n            max_before_min = A.index(max(A[:min_]))\\n\\n        # get right index to return\\n        i = len(A)-1\\n        while i >= max_before_min and A[i] >= A[max_before_min]:\\n            i-=1\\n        \\n        return i+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        min_ = A.index(min(A))\\n        # min of list is first - we can leave only it in the left\\n        if min_ == 0:\\n            return 1\\n        \\n        # find minimum index to end first partition\\n        max_before_min = A.index(max(A[:min_]))\\n        while len(A[min_+1:])>0 and min(A[min_+1:]) < A[max_before_min]:\\n            min_ = len(A) - A[::-1].index( min(A[min_+1:])) - 1\\n            max_before_min = A.index(max(A[:min_]))\\n\\n        # get right index to return\\n        i = len(A)-1\\n        while i >= max_before_min and A[i] >= A[max_before_min]:\\n            i-=1\\n        \\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341951,
                "title": "really-a-medium-level-simple-code-c",
                "content": "```\\n int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n=nums.size(),left[n],right[n];\\n        \\n// Step 1 left se maximum nikalo .left[i]=max from left till i\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=max(left[i-1],nums[i]);\\n        \\n// Step 2 right se min nikalo .right[i]=min from end to ith index   \\n        right[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=min(right[i+1],nums[i]);\\n     \\n// Step 3 kaunsa i esa jaha tk ka max chota hai (i+1) wale minimum se vo hi answer hai \\n        for(int i=0;i<n-1;i++)\\n            if(left[i]<=right[i+1])\\n                return i+1;\\n        \\n        return -1;  //this never gets executed as partition is guaranteed\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n=nums.size(),left[n],right[n];\\n        \\n// Step 1 left se maximum nikalo .left[i]=max from left till i\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=max(left[i-1],nums[i]);\\n        \\n// Step 2 right se min nikalo .right[i]=min from end to ith index   \\n        right[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=min(right[i+1],nums[i]);\\n     \\n// Step 3 kaunsa i esa jaha tk ka max chota hai (i+1) wale minimum se vo hi answer hai \\n        for(int i=0;i<n-1;i++)\\n            if(left[i]<=right[i+1])\\n                return i+1;\\n        \\n        return -1;  //this never gets executed as partition is guaranteed\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1356198,
                "title": "c-easy-solution-s-c-o-1-t-c-o-n",
                "content": "```\\nclass Solution { \\n\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int leftSize = 1, n=nums.size();\\n        int maxLeft = nums[0], mx = nums[0];\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i] < maxLeft){\\n                leftSize = i+1;\\n                maxLeft = mx;\\n            }\\n              mx = max(mx,nums[i]);\\n        }\\n        return leftSize;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution { \\n\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int leftSize = 1, n=nums.size();\\n        int maxLeft = nums[0], mx = nums[0];\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i] < maxLeft){\\n                leftSize = i+1;\\n                maxLeft = mx;\\n            }\\n              mx = max(mx,nums[i]);\\n        }\\n        return leftSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354779,
                "title": "partition-array-into-disjoint-intervals-java-solution-o-n",
                "content": "```\\npublic static int partitionDisjoint(int[] nums) {\\n\\t\\tint comparisonItem = nums[0];\\n\\t\\t// within this variable we will keep track of the largest number we found so far\\n\\t\\tint localMax = comparisonItem;\\n\\t\\t// result index\\n\\t\\tint partitionIdx = 0;\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\t// when we find lower item in an array we update partitionIdx to reflect it\\n\\t\\t\\t// and also set out comparisonItem to the highest item we found prior to this item\\n\\t\\t\\tif (nums[i] < comparisonItem) {\\n\\t\\t\\t\\tpartitionIdx = i;\\n\\t\\t\\t\\tcomparisonItem = localMax;\\n\\t\\t\\t}\\n\\t\\t\\t// keep track of the largest item we seen so far\\n\\t\\t\\telse localMax = Math.max(localMax, nums[i]);\\n\\t\\t}\\n\\t\\t// as we are storing an index of the last item that belongs to the partition\\n\\t\\t// and arrays are indexed from 0 we need to increment the value\\n\\t\\treturn partitionIdx + 1;\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int partitionDisjoint(int[] nums) {\\n\\t\\tint comparisonItem = nums[0];\\n\\t\\t// within this variable we will keep track of the largest number we found so far\\n\\t\\tint localMax = comparisonItem;\\n\\t\\t// result index\\n\\t\\tint partitionIdx = 0;\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\t// when we find lower item in an array we update partitionIdx to reflect it\\n\\t\\t\\t// and also set out comparisonItem to the highest item we found prior to this item\\n\\t\\t\\tif (nums[i] < comparisonItem) {\\n\\t\\t\\t\\tpartitionIdx = i;\\n\\t\\t\\t\\tcomparisonItem = localMax;\\n\\t\\t\\t}\\n\\t\\t\\t// keep track of the largest item we seen so far\\n\\t\\t\\telse localMax = Math.max(localMax, nums[i]);\\n\\t\\t}\\n\\t\\t// as we are storing an index of the last item that belongs to the partition\\n\\t\\t// and arrays are indexed from 0 we need to increment the value\\n\\t\\treturn partitionIdx + 1;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354707,
                "title": "c-solutions-using-fenwick-trees-and-greedy",
                "content": "**Method 1**\\n**Intuition and Approach:** We have to find the index where maximum element of the left half has to be less than or equal the minimum element of the right half. Basically, for current maximal element of the left half `curr`, if there exist elements greater than or equal to `curr` and the the count of these elements is equal to the size of the right half, the index you are at will always be the last element of the left half. Thus, simply return this index+1.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fenw;\\n    int sum(int ind) {\\n        int sum=0;\\n        while(ind>0) {\\n            sum+=fenw[ind];\\n            ind-=ind&(-ind);\\n        }\\n        return sum;\\n    }\\n    void upd(int ind, int val) {\\n        while(ind<fenw.size()) {\\n            fenw[ind]+=val;\\n            ind+=ind&(-ind);\\n        }\\n    }\\n    int partitionDisjoint(vector<int>& nums) {\\n        fenw=vector<int>(1000007,0);\\n        int n=nums.size();\\n                \\n        int ref=-1;\\n        \\n        for(int i=0;i<n;i++) upd(nums[i]+1,1);\\n        \\n        int curr=0;\\n        for(int i=0;i<n;i++) {\\n            curr=max(curr,nums[i]);\\n            \\n            upd(nums[i]+1,-1);\\n            \\n            int ref=sum(1000006)-sum(curr);\\n            if(ref==n-i-1) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Time Complexity:** O(NLogN)\\n**Space Complexity:** O(N)\\n\\n**Method 2**\\n**Intuition and Approach:** We have to find the index where maximum element of the left half has to be less than or equal the minimum element of the right half. So this can be done greedily.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> mn(n);\\n        \\n        mn.back()=nums.back();\\n        \\n        for(int i=n-2;i>=0;i--) {\\n            mn[i]=min(mn[i+1], nums[i]);\\n        }\\n        \\n        int curr=0;    \\n        for(int i=0;i<n-1;i++) {\\n            curr=max(curr,nums[i]);\\n            if(curr<=mn[i+1]) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(N)\\n\\n**Ask your queries in the comment section.**\\n**Upvote if you liked!!**",
                "solutionTags": [
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fenw;\\n    int sum(int ind) {\\n        int sum=0;\\n        while(ind>0) {\\n            sum+=fenw[ind];\\n            ind-=ind&(-ind);\\n        }\\n        return sum;\\n    }\\n    void upd(int ind, int val) {\\n        while(ind<fenw.size()) {\\n            fenw[ind]+=val;\\n            ind+=ind&(-ind);\\n        }\\n    }\\n    int partitionDisjoint(vector<int>& nums) {\\n        fenw=vector<int>(1000007,0);\\n        int n=nums.size();\\n                \\n        int ref=-1;\\n        \\n        for(int i=0;i<n;i++) upd(nums[i]+1,1);\\n        \\n        int curr=0;\\n        for(int i=0;i<n;i++) {\\n            curr=max(curr,nums[i]);\\n            \\n            upd(nums[i]+1,-1);\\n            \\n            int ref=sum(1000006)-sum(curr);\\n            if(ref==n-i-1) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> mn(n);\\n        \\n        mn.back()=nums.back();\\n        \\n        for(int i=n-2;i>=0;i--) {\\n            mn[i]=min(mn[i+1], nums[i]);\\n        }\\n        \\n        int curr=0;    \\n        for(int i=0;i<n-1;i++) {\\n            curr=max(curr,nums[i]);\\n            if(curr<=mn[i+1]) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354639,
                "title": "java-solution-explained-with-comments",
                "content": "Basically the approach is to find the first position in the array such that the maximum element in the array to its left should be greater than or equal to the minimum element in the array to its right.\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n]; //this array is used to maintain the maximum till now from left and minimum till now from right while traversing from left and right respectively\\n        arr[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) { //finding the minimum till this position from right\\n            arr[i] = (nums[i] < arr[i+1]) ? nums[i] : arr[i+1]; \\n        }\\n        arr[0] = nums[0];\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {            \\n            if(arr[i] >= arr[i-1]) { //checking whether the maximum to i\\'s left is greater than or equal to minimum to i\\'s right\\n                res = i; \\n                break; //break if found since we need to find the smallest partition possible\\n            }\\n            arr[i] = (nums[i] > arr[i-1]) ? nums[i] : arr[i-1]; //update the maximum till this position from left\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n]; //this array is used to maintain the maximum till now from left and minimum till now from right while traversing from left and right respectively\\n        arr[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) { //finding the minimum till this position from right\\n            arr[i] = (nums[i] < arr[i+1]) ? nums[i] : arr[i+1]; \\n        }\\n        arr[0] = nums[0];\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {            \\n            if(arr[i] >= arr[i-1]) { //checking whether the maximum to i\\'s left is greater than or equal to minimum to i\\'s right\\n                res = i; \\n                break; //break if found since we need to find the smallest partition possible\\n            }\\n            arr[i] = (nums[i] > arr[i-1]) ? nums[i] : arr[i-1]; //update the maximum till this position from left\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800421,
                "title": "c-solution-three-pass-two-pass-one-pass",
                "content": "three pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        vector<int> from_right_min(len, A[len-1]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n        for (int i = len-2; i >= 0; i--) {\\n            from_right_min[i] = min(from_right_min[i+1], A[i]);\\n        }\\n        for (int i = 0; i < len; i++) {\\n            if (from_left_max[i] <= from_right_min[i+1]) {\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\ntwo pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n       int right_min = A[len-1];\\n        int res = -1;\\n        for (int i = len-1; i > 0; i--) {\\n            right_min = min(right_min, A[i]);\\n            res = from_left_max[i-1]<=right_min ? i : res;\\n        }\\n        return res;\\n    }\\n};\\n```\\none pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int local_max = A[0], global_max = A[0];\\n        int partition = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < local_max) {\\n                partition = i;\\n                local_max = global_max;\\n            } else {\\n                global_max = max(global_max, A[i]);\\n            }\\n        }\\n        return partition+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        vector<int> from_right_min(len, A[len-1]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n        for (int i = len-2; i >= 0; i--) {\\n            from_right_min[i] = min(from_right_min[i+1], A[i]);\\n        }\\n        for (int i = 0; i < len; i++) {\\n            if (from_left_max[i] <= from_right_min[i+1]) {\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n       int right_min = A[len-1];\\n        int res = -1;\\n        for (int i = len-1; i > 0; i--) {\\n            right_min = min(right_min, A[i]);\\n            res = from_left_max[i-1]<=right_min ? i : res;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int local_max = A[0], global_max = A[0];\\n        int partition = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < local_max) {\\n                partition = i;\\n                local_max = global_max;\\n            } else {\\n                global_max = max(global_max, A[i]);\\n            }\\n        }\\n        return partition+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424357,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        int splitIndex = 0, maxAtSplitIndex = nums[0], maxSoFar = nums[0];    \\n        for (int i=0; i<nums.Length; i++) \\n        {\\n            if (nums[i] < maxAtSplitIndex) \\n            {   \\n                splitIndex = i;    \\n                maxAtSplitIndex = maxSoFar; \\n            } \\n            \\n            maxSoFar = Math.Max(maxSoFar, nums[i]);\\n        }\\n        \\n        return splitIndex + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        int splitIndex = 0, maxAtSplitIndex = nums[0], maxSoFar = nums[0];    \\n        for (int i=0; i<nums.Length; i++) \\n        {\\n            if (nums[i] < maxAtSplitIndex) \\n            {   \\n                splitIndex = i;    \\n                maxAtSplitIndex = maxSoFar; \\n            } \\n            \\n            maxSoFar = Math.Max(maxSoFar, nums[i]);\\n        }\\n        \\n        return splitIndex + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175907,
                "title": "o-n-one-pass-solution",
                "content": "endIndex is the leftmost index of left part\\nmaxIndex is max number\\'s we encountered so far\\nmaxCurrIndex is the max number\\'s index in the left part\\n\\n```\\npublic class Solution {\\n    public int PartitionDisjoint(int[] A) {\\n        \\n        int maxCurrIndex = 0;\\n        int maxIndex = 0;\\n        int endIndex = 0;\\n        \\n        \\n        for(int i=1;i<A.Length;i++){\\n            \\n            if(A[i] < A[maxCurrIndex]){\\n                maxCurrIndex = maxIndex;\\n                endIndex = i;\\n            }else if(A[i] > A[maxIndex]){\\n                maxIndex = i;\\n            }\\n            \\n        }\\n        return endIndex+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int PartitionDisjoint(int[] A) {\\n        \\n        int maxCurrIndex = 0;\\n        int maxIndex = 0;\\n        int endIndex = 0;\\n        \\n        \\n        for(int i=1;i<A.Length;i++){\\n            \\n            if(A[i] < A[maxCurrIndex]){\\n                maxCurrIndex = maxIndex;\\n                endIndex = i;\\n            }else if(A[i] > A[maxIndex]){\\n                maxIndex = i;\\n            }\\n            \\n        }\\n        return endIndex+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705193,
                "title": "easy-c-solution-beginner-friendly-approach-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0], index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){ \\n                index=i;\\n                minNum=maxNum;  \\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0], index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){ \\n                index=i;\\n                minNum=maxNum;  \\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700023,
                "title": "very-simple-c",
                "content": "\\n# if it Helps You. Please Upvote Me...\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the **suffix array with the minimum value** and count the number of indexes from the left side **while maximum(0 to ind) > suffix minimum at ind**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n\\n        int n = arr.size(),mx = INT_MIN,mn = INT_MAX;\\n        vector<int> suffmin(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n             suffmin[i] = mn;\\n             mn = min(mn,arr[i]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            mx = max(mx,arr[i]);\\n            if(mx<=suffmin[i]) return i+1;\\n        }\\n        return n;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/69735656-2a4f-4ead-95a7-b0ad3739a7d1_1688120016.445156.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n\\n        int n = arr.size(),mx = INT_MIN,mn = INT_MAX;\\n        vector<int> suffmin(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n             suffmin[i] = mn;\\n             mn = min(mn,arr[i]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            mx = max(mx,arr[i]);\\n            if(mx<=suffmin[i]) return i+1;\\n        }\\n        return n;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496228,
                "title": "java-tc-o-n-sc-o-1-with-comments-on-every-line",
                "content": "Ok, this problem was harder than I expected it to be! (or maybe I\\'m dumb)\\nAdded lots of comments so anyone can read it and understand it in one go.\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408556,
                "title": "java-linear-traversal-solution-o-n-time-and-space-in-1ms",
                "content": "```\\nclass Solution {\\n    int max, size;\\n    int[] nums;\\n    public int partitionDisjoint(int[] nums) {\\n        int partition = 1;\\n        size = nums.length;\\n        this.nums = nums;\\n        max = nums[0];\\n        int index = findGreaterIndex(max, 0), i = index;\\n        while(i < size) {\\n            if(rightPartitionCheck(i)) \\n                return i;\\n            max = nums[i];\\n            i = findGreaterIndex(max, i);\\n        }\\n        return 1;\\n    }\\n    // Check if right partition contains some smaller elements than the max value in left partition.\\n    public boolean rightPartitionCheck(int partition) {\\n        for(int i = partition; i<size; i++) {\\n            if(nums[i] < max) \\n                return false;\\n        }\\n        return true;\\n    }\\n    // Find the next greater integer than current value starting from index.\\n    public int findGreaterIndex(int val, int index) {\\n        for(int i = index+1; i<size; i++) {\\n            if(nums[i] >= val)\\n                return i;\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max, size;\\n    int[] nums;\\n    public int partitionDisjoint(int[] nums) {\\n        int partition = 1;\\n        size = nums.length;\\n        this.nums = nums;\\n        max = nums[0];\\n        int index = findGreaterIndex(max, 0), i = index;\\n        while(i < size) {\\n            if(rightPartitionCheck(i)) \\n                return i;\\n            max = nums[i];\\n            i = findGreaterIndex(max, i);\\n        }\\n        return 1;\\n    }\\n    // Check if right partition contains some smaller elements than the max value in left partition.\\n    public boolean rightPartitionCheck(int partition) {\\n        for(int i = partition; i<size; i++) {\\n            if(nums[i] < max) \\n                return false;\\n        }\\n        return true;\\n    }\\n    // Find the next greater integer than current value starting from index.\\n    public int findGreaterIndex(int val, int index) {\\n        for(int i = index+1; i<size; i++) {\\n            if(nums[i] >= val)\\n                return i;\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363481,
                "title": "python-easy-solution-with-o-n-time-complexity",
                "content": "**Code**:\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        overall_max = nums[0]\\n        pivot = 0\\n        for i,n in enumerate(nums):\\n            if n<left_max:\\n                pivot = i\\n                left_max = overall_max\\n            elif n>overall_max:\\n                overall_max = n\\n        return pivot+1\\n```\\n\\nHere, I will explain all three variables.\\nleft_max: It is the maximum number of the left array.\\noverall_max: It is the maximum number of input array.\\npivot: It indicates the rightmost index of left array.\\n\\nIf you do not understand anything then comment below.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        overall_max = nums[0]\\n        pivot = 0\\n        for i,n in enumerate(nums):\\n            if n<left_max:\\n                pivot = i\\n                left_max = overall_max\\n            elif n>overall_max:\\n                overall_max = n\\n        return pivot+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355933,
                "title": "python-o-n-o-1-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = nums[0]\\n        curMax = nums[0]\\n        ans = 1\\n        for i, num in enumerate(nums):\\n\\t\\t\\t# If current number is smaller than left maximum, the answer is no longer valid.\\n\\t\\t\\t# Now the current index is the last index of left and the maximum is now left maximum.\\n            if num < leftMax:\\n                ans = i+1  \\n                leftMax = curMax\\n\\t\\t\\t# Update the current maximum\\n            curMax = max(curMax, num)\\n\\n        return ans\\n```\\nTime complexity O(n)\\nSpace compexity O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = nums[0]\\n        curMax = nums[0]\\n        ans = 1\\n        for i, num in enumerate(nums):\\n\\t\\t\\t# If current number is smaller than left maximum, the answer is no longer valid.\\n\\t\\t\\t# Now the current index is the last index of left and the maximum is now left maximum.\\n            if num < leftMax:\\n                ans = i+1  \\n                leftMax = curMax\\n\\t\\t\\t# Update the current maximum\\n            curMax = max(curMax, num)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355922,
                "title": "c-o-n-faster-than-99-74",
                "content": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//minr[i] will contain minimum element from i to n\\n        vector<int> minr(n);\\n        int MIN=INT_MAX;\\n        minr[n-1]=nums[n-1];\\n\\t\\t// To calculate minr values\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(MIN>nums[i]) MIN=nums[i];\\n            minr[i]=MIN;\\n        }\\n        int flag=0,count=0;\\n        int MAX=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(flag!=0) break;\\n            if(MAX<nums[i]) MAX=nums[i];\\n            if(MAX<=minr[i+1]) flag=1;\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//minr[i] will contain minimum element from i to n\\n        vector<int> minr(n);\\n        int MIN=INT_MAX;\\n        minr[n-1]=nums[n-1];\\n\\t\\t// To calculate minr values\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(MIN>nums[i]) MIN=nums[i];\\n            minr[i]=MIN;\\n        }\\n        int flag=0,count=0;\\n        int MAX=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(flag!=0) break;\\n            if(MAX<nums[i]) MAX=nums[i];\\n            if(MAX<=minr[i+1]) flag=1;\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355501,
                "title": "java-easy-to-read-o-n-faster-than-100",
                "content": "We will take two variable - one to track left array maximum(**maxToUpdateIfAnsIndexUpdates**) and one for partion of left and right subarray(**maxToPartition**)\\n\\nconsidering 0th element as current maximum number and iterating as we encounter number less than that we will partition at that element(i index) and update current maximum(maxToPartition) to maximum till now(maxToUpdateIfAnsIndexUpdates)\\n\\nwe will continue above step till end of the array\\n\\nwe will store partion index in ansIndex and return partion index + 1 as answer (as index starts from 0)\\n \\n Hope this helps, please comment if you have any doubt or can improve my solution. Have a nice day!\\n\\n```\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length; \\n        int ansIndex = 0;\\n\\n        int maxToPartition = nums[0];\\n        int maxToUpdateIfAnsIndexUpdates = nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n\\t\\t\\n            maxToUpdateIfAnsIndexUpdates = Math.max(maxToUpdateIfAnsIndexUpdates,nums[i]);\\n            \\n            if(nums[i]<maxToPartition){\\n                ansIndex = i;\\n                maxToPartition = maxToUpdateIfAnsIndexUpdates;\\n            }\\n        }\\n         \\n        return ansIndex + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length; \\n        int ansIndex = 0;\\n\\n        int maxToPartition = nums[0];\\n        int maxToUpdateIfAnsIndexUpdates = nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n\\t\\t\\n            maxToUpdateIfAnsIndexUpdates = Math.max(maxToUpdateIfAnsIndexUpdates,nums[i]);\\n            \\n            if(nums[i]<maxToPartition){\\n                ansIndex = i;\\n                maxToPartition = maxToUpdateIfAnsIndexUpdates;\\n            }\\n        }\\n         \\n        return ansIndex + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355372,
                "title": "c-3-approaches-brute-force-to-optimal-to-one-iteration-using-similar-concept-of-leetcode-768",
                "content": "```\\n/*\\n    If you notice Approach-2 below , it\\'s Similar to Qn (Leetcode 768 - Max Chunks To Make Sorted II)\\n    Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Max%20Chunks%20To%20Make%20Sorted%20II.cpp\\n*/\\n\\n//Approach-1 (Brute Force : O(n^2) time)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int maxE = nums[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            maxE = max(maxE, nums[i]);\\n            int j = i+1;\\n            for(; j<n; j++) {\\n                if(nums[j] < maxE)\\n                    break;\\n            }\\n            if(j == n)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using a very popular concept min-max track from left and right)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        /*\\n            When the maximum of left-partition is less than minimum of right-partition,\\n            that\\'s the point where we draw the line of partition\\n            Similar to Leetcode-768 (Max Chunks To Make Sorted II)\\n        */\\n        \\n        //So calculate minimum from right;\\n        vector<int> minRight(n);\\n        minRight[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            minRight[i] = min(minRight[i+1], nums[i]);\\n        }\\n        \\n        int maxLeft = nums[0];\\n        for(int i = 0; i<n-1; i++) {\\n            maxLeft = max(maxLeft, nums[i]);\\n            \\n            if(maxLeft <= minRight[i+1])\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (One loop solution with explained comments)\\n/*\\n\\tI noticed many people posting this solution with no elaborated comments.\\n\\tSo I have tried to put comments on lines which are really confusing.\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int leftMax  = nums[0];\\n        int currMax  = nums[0];\\n        int len      = 1; //Qn says it is gauranteed that a partitioning exists\\n        \\n        for(int i = 1; i<n; i++) {\\n            if(nums[i] < leftMax) {\\n                /*\\n                    If nums[i] is less than maximum to left, it must go to left partition\\n                    so, increase the length of partition\\n                */\\n                len = i+1;\\n                \\n                leftMax = currMax;\\n                /*\\n                    why this ?\\n                    Exampel : {5, 0, 3, 8, 6, 0, 10}\\n                    Until i = 2, leftMax is 5\\n                    Now, when we reach i = 3, we see that it\\'s not less than leftMax (i.e. 8 > 5)\\n                    So, we don\\'t need to partition BUT we update our currMax = 8\\n                    Now, we go to i = 4, our leftMax is still 5 and currMax = 8\\n                    Now, we reach to i = 5, leftMax is still 5 and nums[i] is less than leftMax i.e. (0 < 5)\\n                    so, we need to update our the partition length to (i+1)\\n                    BUT, here\\'s the catch, After i  = 5, we need to have the leftMax as 8 and not 5 anymore.\\n                    That\\'s why we update leftMax to currMax\\n                    i.e. leftMax = currMax;\\n                */\\n            } else {\\n                currMax = max(currMax, nums[i]); //Explained in above comment\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    If you notice Approach-2 below , it\\'s Similar to Qn (Leetcode 768 - Max Chunks To Make Sorted II)\\n    Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Max%20Chunks%20To%20Make%20Sorted%20II.cpp\\n*/\\n\\n//Approach-1 (Brute Force : O(n^2) time)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int maxE = nums[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            maxE = max(maxE, nums[i]);\\n            int j = i+1;\\n            for(; j<n; j++) {\\n                if(nums[j] < maxE)\\n                    break;\\n            }\\n            if(j == n)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using a very popular concept min-max track from left and right)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        /*\\n            When the maximum of left-partition is less than minimum of right-partition,\\n            that\\'s the point where we draw the line of partition\\n            Similar to Leetcode-768 (Max Chunks To Make Sorted II)\\n        */\\n        \\n        //So calculate minimum from right;\\n        vector<int> minRight(n);\\n        minRight[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            minRight[i] = min(minRight[i+1], nums[i]);\\n        }\\n        \\n        int maxLeft = nums[0];\\n        for(int i = 0; i<n-1; i++) {\\n            maxLeft = max(maxLeft, nums[i]);\\n            \\n            if(maxLeft <= minRight[i+1])\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-3 (One loop solution with explained comments)\\n/*\\n\\tI noticed many people posting this solution with no elaborated comments.\\n\\tSo I have tried to put comments on lines which are really confusing.\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int leftMax  = nums[0];\\n        int currMax  = nums[0];\\n        int len      = 1; //Qn says it is gauranteed that a partitioning exists\\n        \\n        for(int i = 1; i<n; i++) {\\n            if(nums[i] < leftMax) {\\n                /*\\n                    If nums[i] is less than maximum to left, it must go to left partition\\n                    so, increase the length of partition\\n                */\\n                len = i+1;\\n                \\n                leftMax = currMax;\\n                /*\\n                    why this ?\\n                    Exampel : {5, 0, 3, 8, 6, 0, 10}\\n                    Until i = 2, leftMax is 5\\n                    Now, when we reach i = 3, we see that it\\'s not less than leftMax (i.e. 8 > 5)\\n                    So, we don\\'t need to partition BUT we update our currMax = 8\\n                    Now, we go to i = 4, our leftMax is still 5 and currMax = 8\\n                    Now, we reach to i = 5, leftMax is still 5 and nums[i] is less than leftMax i.e. (0 < 5)\\n                    so, we need to update our the partition length to (i+1)\\n                    BUT, here\\'s the catch, After i  = 5, we need to have the leftMax as 8 and not 5 anymore.\\n                    That\\'s why we update leftMax to currMax\\n                    i.e. leftMax = currMax;\\n                */\\n            } else {\\n                currMax = max(currMax, nums[i]); //Explained in above comment\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355086,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ans=0\\n        maxo=nums[0]\\n        maxtn=nums[0]\\n        for i in range(len(nums)):\\n            if nums[i]>=maxtn:\\n                pass\\n            else:\\n                ans=i\\n                maxtn=max(maxtn,nums[i],maxo)\\n            maxo=max(nums[i],maxo)\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ans=0\\n        maxo=nums[0]\\n        maxtn=nums[0]\\n        for i in range(len(nums)):\\n            if nums[i]>=maxtn:\\n                pass\\n            else:\\n                ans=i\\n                maxtn=max(maxtn,nums[i],maxo)\\n            maxo=max(nums[i],maxo)\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354990,
                "title": "python3-easy-explanation-96-faster",
                "content": "First move from right to left and make a note of all the positions where there is a chance of finding our partition, then apply the condition at those noted down indexes (reverse the list first) from left to right so, the first time the conditon is satisfied, that is the smallest possible size for \\'left\\'.\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        index = -1\\n        mini = 1000001\\n        l = len(nums)\\n        if l == 2:\\n            return 1\\n        temp = list()\\n        for i in range(l-1, -1, -1):\\n            if nums[i] < mini:\\n                mini = nums[i]\\n                index = i+1\\n                temp.append(i+1)\\n        temp.reverse()\\n        for i in temp:\\n            if max(nums[:i]) <= min(nums[i:]):\\n                return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        index = -1\\n        mini = 1000001\\n        l = len(nums)\\n        if l == 2:\\n            return 1\\n        temp = list()\\n        for i in range(l-1, -1, -1):\\n            if nums[i] < mini:\\n                mini = nums[i]\\n                index = i+1\\n                temp.append(i+1)\\n        temp.reverse()\\n        for i in temp:\\n            if max(nums[:i]) <= min(nums[i:]):\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354745,
                "title": "scala-functional-620-ms-59-1-mb",
                "content": "The most straightforward solution is to map every array element to the pair consisting of\\n1. the maximum value to its left (including itself), and\\n2. the minimum value to its right (including itself)\\n\\nThen, all we need to do is getting the index of the first element where the maximum to its left is less than or equal to the maximum element to its right.\\n\\n```\\nobject Solution {\\n    def partitionDisjoint(nums: Array[Int]): Int = {\\n        nums.scanLeft(Int.MinValue)(_ max _)\\n            .zip(nums.scanRight(Int.MaxValue)(_ min _))\\n            .zipWithIndex\\n            .tail\\n            .filter(x => x._1._1 <= x._1._2)\\n            .head._2\\n    }\\n}\\n```\\n\\nThe runtime is O(5`n`) = O(`n`): `scanLeft`, `scanRight`, `zip`, `zipWithIndex`, and `filter` all take O(`n`) time.\\nThis solution is most likely not optimal, as of now there is not enough scala submissions to get runtime & memory use charts.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def partitionDisjoint(nums: Array[Int]): Int = {\\n        nums.scanLeft(Int.MinValue)(_ max _)\\n            .zip(nums.scanRight(Int.MaxValue)(_ min _))\\n            .zipWithIndex\\n            .tail\\n            .filter(x => x._1._1 <= x._1._2)\\n            .head._2\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1354488,
                "title": "98-memory-efficient-in-python",
                "content": "left=[]\\n        left.append(nums[0])\\n        for i in range(1,len(nums)):\\n            m=max(left)\\n            if(m<=nums[i] and min(nums[i:])>=m):\\n                return len(left)\\n            else:\\n                left.append(nums[i])\\n        return len(left)",
                "solutionTags": [],
                "code": "left=[]\\n        left.append(nums[0])\\n        for i in range(1,len(nums)):\\n            m=max(left)\\n            if(m<=nums[i] and min(nums[i:])>=m):\\n                return len(left)\\n            else:\\n                left.append(nums[i])\\n        return len(left)",
                "codeTag": "Unknown"
            },
            {
                "id": 1296394,
                "title": "python-o-n-time-o-1-space-fastest-with-explanation",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: list):\\n        left_max = A[0]\\n        next_max = 0\\n        res = 0\\n        \\n        for i in range(1, len(A)):\\n            \\n            # Always update to get the largest we see\\n            if A[i] > next_max:\\n                next_max = A[i]\\n            \\n            # Anything that is smaller than the largest in left part\\n            if A[i] < left_max:\\n                res = i\\n                \\n                # Update the largest in left part\\n                # Why are we able to do this?\\n                # Because question guarantees that there is always a valid partitioning\\n                left_max = max(left_max, next_max)\\n                    \\n        return res + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: list):\\n        left_max = A[0]\\n        next_max = 0\\n        res = 0\\n        \\n        for i in range(1, len(A)):\\n            \\n            # Always update to get the largest we see\\n            if A[i] > next_max:\\n                next_max = A[i]\\n            \\n            # Anything that is smaller than the largest in left part\\n            if A[i] < left_max:\\n                res = i\\n                \\n                # Update the largest in left part\\n                # Why are we able to do this?\\n                # Because question guarantees that there is always a valid partitioning\\n                left_max = max(left_max, next_max)\\n                    \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202731,
                "title": "c-simple-o-n-o-1-solution-with-full-explanation",
                "content": "Concept is pretty easy to understand if we take two auxillary arrays of length of the array.\\narray 1 stores the max number encountered upto that point\\narray 2 stores the min number encounter upto that point from reverse.\\n\\teg: \\n\\t\\t5 0 3 8 6\\na1:   5 5 5 8 8\\na2:   0 0 3 6 6\\n\\nnow we iterate in both loops while a1[i]<a2[j]. This is the length required. \\n\\nNow, we try to do this in the array itself WITHOUT USING ANY EXTRA ARRAY. \\nWe start from the end and change every number to min encountered upto that point until we reach a point which is lower than the first element of array (i.e max  until that point). \\nNow, we start from the beginnig of array and go up to the point such that either i<j or the max encountered is greater than the min of the traversal we were doing from right. \\nIn case of max>min, we simply go right in the traversal from the back(j++) , since min upto that point is stored in each array, we simply iterate it till we reach a point where max<min. \\nThen we again increase the i.\\nwe break the loop only when i>=j and max<min, i.e a partition is achieved.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int max=arr[0];//to store the max element in the left subpart\\n        int min=arr[n-1];//to store the min element in the right subpart\\n        int i, j;\\n        for(i=0,j=n-2; i<j||max>min;)\\n        {\\n            if(max>min)\\n            {\\n                j++;\\n                min=arr[j];//this will give us just next big min in the right subpart\\n            }\\n            else if(arr[j]>=max)\\n            {\\n                if(arr[j]<min)\\n                    min=arr[j];\\n                arr[j]=min;//store the min upto that part from right\\n                j--;\\n            }\\n            else\\n            {\\n               if(arr[i]>max)\\n                    max=arr[i];\\n                arr[i]=max;//store max encountered upto this point\\n                i++; \\n            }\\n        }\\n        return i+1;//since i is index and we need length, i+1\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int max=arr[0];//to store the max element in the left subpart\\n        int min=arr[n-1];//to store the min element in the right subpart\\n        int i, j;\\n        for(i=0,j=n-2; i<j||max>min;)\\n        {\\n            if(max>min)\\n            {\\n                j++;\\n                min=arr[j];//this will give us just next big min in the right subpart\\n            }\\n            else if(arr[j]>=max)\\n            {\\n                if(arr[j]<min)\\n                    min=arr[j];\\n                arr[j]=min;//store the min upto that part from right\\n                j--;\\n            }\\n            else\\n            {\\n               if(arr[i]>max)\\n                    max=arr[i];\\n                arr[i]=max;//store max encountered upto this point\\n                i++; \\n            }\\n        }\\n        return i+1;//since i is index and we need length, i+1\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131928,
                "title": "java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int leftLength = 1;\\n        int leftMax = A[0], max = A[0];\\n        \\n        for (int i = 1; i < A.length; ++i) {\\n            if (leftMax > A[i]) {\\n                leftLength = i + 1;\\n                leftMax = max;\\n            } else {\\n                max = max > A[i] ? max : A[i];\\n            }\\n        }\\n        \\n        return leftLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int leftLength = 1;\\n        int leftMax = A[0], max = A[0];\\n        \\n        for (int i = 1; i < A.length; ++i) {\\n            if (leftMax > A[i]) {\\n                leftLength = i + 1;\\n                leftMax = max;\\n            } else {\\n                max = max > A[i] ? max : A[i];\\n            }\\n        }\\n        \\n        return leftLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551609,
                "title": "simple-ruby-solution",
                "content": "```\\ndef partition_disjoint(a)\\n  left = []\\n    loop do\\n\\t  left << a[0]\\n      a.shift(1)\\n      break if a.min >= left.max\\n    end\\n  left.length\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef partition_disjoint(a)\\n  left = []\\n    loop do\\n\\t  left << a[0]\\n      a.shift(1)\\n      break if a.min >= left.max\\n    end\\n  left.length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526349,
                "title": "o-n-solution-simple-and-clear-explanation-with-example-and-code-beats-100-in-space-complexity",
                "content": "**Intuition:** We have to divide array into two blocks Left and Right such that picking any element from left and right blocks will give *A[left]<=A[right]*\\n\\n1. So, basically if we are at position i, then `max element till i` should be less than `min element from last element till i`\\n\\nSo, we track min element from right in one array **Rmin**\\nAnd track max element from left in another array **LMax**\\n\\n```\\nIndex    0   1   2    3   4    \\nRmin     0   0   3    6   6\\narr      5   0   3    8   6\\nLMax     5   5   5    8   8\\n```\\n\\n\\nAfter then we, traverse the from i=0 to see at which position my` LMax[i] <= Rmin[i+1]` \\nhere, `at index 2 we 5<=3 is true`\\nAnd once this condition is true, we get required position as we reached at place where above point 1. is correct. That is, now The maximum element till that position is less than min from right elements.\\n\\nTo verify correctness, if we move ahead if the position that we got let say `i` , then we may get element maximum than a[i] but we\\'ll never get element less than a[i] because we already calculated the min element from right side that means, once we are at pos `i` we have min till a[i] from right to i and max from 0 to i.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n\\n        int n=a.size();\\n        \\n         \\n        if(is_sorted(a.begin(),a.end()))\\n            return 1;\\n           \\n           \\n        \\n        vector<int> Rmin(n,0),Lmax(n,0);\\n        \\n        Lmax[0]=a[0];\\n        \\n        for(int i=1;i<n;i++)\\n            Lmax[i]=max(Lmax[i-1],a[i]);\\n        \\n        Rmin[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            Rmin[i]=min(Rmin[i+1],a[i]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(Lmax[i]<=Rmin[i+1])\\n                return i+1;\\n        }\\n        \\n        return n;\\n        \\n    }\\n};      \\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nIndex    0   1   2    3   4    \\nRmin     0   0   3    6   6\\narr      5   0   3    8   6\\nLMax     5   5   5    8   8\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n\\n        int n=a.size();\\n        \\n         \\n        if(is_sorted(a.begin(),a.end()))\\n            return 1;\\n           \\n           \\n        \\n        vector<int> Rmin(n,0),Lmax(n,0);\\n        \\n        Lmax[0]=a[0];\\n        \\n        for(int i=1;i<n;i++)\\n            Lmax[i]=max(Lmax[i-1],a[i]);\\n        \\n        Rmin[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            Rmin[i]=min(Rmin[i+1],a[i]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(Lmax[i]<=Rmin[i+1])\\n                return i+1;\\n        }\\n        \\n        return n;\\n        \\n    }\\n};      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 397127,
                "title": "python-easy-o-n-solution-faster-than-97",
                "content": "max_now: current maximum of left\\ncandidate: next max_now if a smaller number occurs\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        max_now = candidate = A[0]\\n        _len = 1\\n        for i in range(1, len(A)):\\n            if A[i] < max_now:\\n                _len = i + 1\\n                max_now = candidate\\n            else:\\n                if A[i] > candidate:\\n                    candidate = A[i]\\n        return _len\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        max_now = candidate = A[0]\\n        _len = 1\\n        for i in range(1, len(A)):\\n            if A[i] < max_now:\\n                _len = i + 1\\n                max_now = candidate\\n            else:\\n                if A[i] > candidate:\\n                    candidate = A[i]\\n        return _len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201785,
                "title": "java-single-pass-o-n-beats-96",
                "content": "I saw this as a variation on questions like SumSubarrayMins and so started with a `LinkedList` to act as a stack (or `Deque`) of the index of previous max values so that when we find we need to move the splice location to the right we can immediately find the new max of the now larger left-hand-side sub-array.\\n\\nThe code itself showed me this simplification as there was never a need to `pop()` from the stack and so saw that it could be replaced with a single variable, `lastMax` in the below. \\n\\n    // Initially coded this using a Deque (aka, a stack), but then realized I was only ever peeking at the topmost\\n    // entry, so replaced the stack with the lastMax variable.  Resulting in a 2x speed improvement.\\n    public int partitionDisjoint(int[] A) {\\n      int max = A[0];      // Size of A is given as at least 1.\\n      int lastMax = max;   // This is the max that may have been encountered after the current split choice.\\n      int splitdex = 0;    // location of the split (index of last element in the left-side)\\n      for (int i=1; i<A.length; ++i) {\\n        if (A[i] < max) {   // less than the left-hand-side\\'s max?\\n          splitdex = i;     // new split location\\n          max = lastMax;    // and we may (also) have a new max\\n        } else if (A[i] > lastMax) {\\n          lastMax = A[i];   // Right-hand side max, which becomes the new nax if we move the split to the right.\\n        }\\n      }\\n\\n      return splitdex + 1;\\n    }\\n",
                "solutionTags": [],
                "code": "I saw this as a variation on questions like SumSubarrayMins and so started with a `LinkedList` to act as a stack (or `Deque`) of the index of previous max values so that when we find we need to move the splice location to the right we can immediately find the new max of the now larger left-hand-side sub-array.\\n\\nThe code itself showed me this simplification as there was never a need to `pop()` from the stack and so saw that it could be replaced with a single variable, `lastMax` in the below. \\n\\n    // Initially coded this using a Deque (aka, a stack), but then realized I was only ever peeking at the topmost\\n    // entry, so replaced the stack with the lastMax variable.  Resulting in a 2x speed improvement.\\n    public int partitionDisjoint(int[] A) {\\n      int max = A[0];      // Size of A is given as at least 1.\\n      int lastMax = max;   // This is the max that may have been encountered after the current split choice.\\n      int splitdex = 0;    // location of the split (index of last element in the left-side)\\n      for (int i=1; i<A.length; ++i) {\\n        if (A[i] < max) {   // less than the left-hand-side\\'s max?\\n          splitdex = i;     // new split location\\n          max = lastMax;    // and we may (also) have a new max\\n        } else if (A[i] > lastMax) {\\n          lastMax = A[i];   // Right-hand side max, which becomes the new nax if we move the split to the right.\\n        }\\n      }\\n\\n      return splitdex + 1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 193178,
                "title": "java-easy-to-understand-solution",
                "content": "Idea is to find the position, whose left\\'s(includ this position) max should be less than whose right\\'s min\\n```\\n public int partitionDisjoint(int[] A) {\\n        int n = A.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int max = -1;\\n        int min = (int)Math.pow(10,6);\\n        for(int i = 0; i < n; i++){\\n           if(max < A[i]) {\\n               max = A[i];\\n           }\\n            left[i] = max;\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            if(min > A[i] ){\\n                min = A[i];\\n            }\\n            right[i] = min;\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            if(left[i] <= right[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }```",
                "solutionTags": [],
                "code": "```\\n public int partitionDisjoint(int[] A) {\\n        int n = A.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int max = -1;\\n        int min = (int)Math.pow(10,6);\\n        for(int i = 0; i < n; i++){\\n           if(max < A[i]) {\\n               max = A[i];\\n           }\\n            left[i] = max;\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            if(min > A[i] ){\\n                min = A[i];\\n            }\\n            right[i] = min;\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            if(left[i] <= right[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 177339,
                "title": "java-simple-solution-o-n-time-and-o-1-space-by-maintaining-two-variables-prevmax-curmax",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int prevMax = A[0];\\n        int curMax = A[0];\\n        int prevMaxIndex = 0;\\n        \\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(A[i] > curMax)\\n            {\\n               curMax =  A[i];\\n            }\\n            else if(A[i] < prevMax)\\n            {\\n                prevMax = curMax;\\n                prevMaxIndex = i;\\n            }\\n        }\\n        return prevMaxIndex+1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int prevMax = A[0];\\n        int curMax = A[0];\\n        int prevMaxIndex = 0;\\n        \\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(A[i] > curMax)\\n            {\\n               curMax =  A[i];\\n            }\\n            else if(A[i] < prevMax)\\n            {\\n                prevMax = curMax;\\n                prevMaxIndex = i;\\n            }\\n        }\\n        return prevMaxIndex+1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175843,
                "title": "modern-c-solution-with-2-multisets-o-nlogn",
                "content": "Idea:\n1. Split values into 2 multisets (left & right) based on the first occurence of minimum element\n2. While greatest value in left is > than smallest value in right, pop that value from right and put it in left\n3. Once done, return the size of left \n```\nint partitionDisjoint(vector<int>& A) {\n    auto mi = min_element(A.begin (), A.end());\n    multiset<int> left (A.begin(), mi + 1);\n    multiset<int> right (mi + 1, A.end()); \n    for (int i = distance(A.begin (), mi + 1); *--left.end() > *right.begin(); ++i) {\n        right.erase(right.find(A[i]));\n        left.insert(A[i]);\n    }\n    return left.size ();\n}",
                "solutionTags": [],
                "code": "1. Split values into 2 multisets (left & right) based on the first occurence of minimum element\nint partitionDisjoint(vector<int>& A) {\n    auto mi = min_element(A.begin (), A.end());\n    multiset<int> left (A.begin(), mi + 1);\n    multiset<int> right (mi + 1, A.end()); \n    for (int i = distance(A.begin (), mi + 1); *--left.end() > *right.begin(); ++i) {\n        right.erase(right.find(A[i]));\n        left.insert(A[i]);\n    }\n    return left.size ();\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4073199,
                "title": "here-is-my-solution-o-n-for-java",
                "content": "# Intuition\\nProblem is easy because we are sure a partition exisits.\\n\\n# Approach\\nAssume the first parition is after 0th index (Between 0th and 1st index). Intialize the LeftMax as arr[0] and RightMax as arr[1].\\n\\nWe have 2 cases here, either leftMax is smaller than rightMax or rightMax is smaller than leftMax. \\n\\nIf rightMax is smaller, we need to traverse the array until we find a value which is larger than leftMax and increase the parition index meaning we are expanding the left array until we come across a value which is larger than all values in left arr.\\n\\nIf leftMax is smaller than we can traverse the array and keep updating RightMax. While traversing we might find a value which is smaller than leftMax. This means we have to expand the left parition till that point and find another value of RightMax. We set leftMax = rightMax as our left array has now expanded to this point and find another value for rightMax. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ //move forward until we find a larger value than leftMax\\n                   partition++;\\n                   rightMax = nums[x];\\n                   x++;\\n            }\\n\\n            if(x<nums.length && nums[x] < leftMax){ //expand left arr till this point\\n                leftMax = rightMax;\\n                rightMax = -1;\\n                partition = x-1;\\n            }\\n            else if(x < nums.length && nums[x] > rightMax){ //update rightMax\\n                rightMax = nums[x];\\n            }\\n        }\\n\\n\\n        return ++partition; //we are tracking last index of left arr so we have to increment for correct size return\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ //move forward until we find a larger value than leftMax\\n                   partition++;\\n                   rightMax = nums[x];\\n                   x++;\\n            }\\n\\n            if(x<nums.length && nums[x] < leftMax){ //expand left arr till this point\\n                leftMax = rightMax;\\n                rightMax = -1;\\n                partition = x-1;\\n            }\\n            else if(x < nums.length && nums[x] > rightMax){ //update rightMax\\n                rightMax = nums[x];\\n            }\\n        }\\n\\n\\n        return ++partition; //we are tracking last index of left arr so we have to increment for correct size return\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514724,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int minNum=a[0],maxNum=a[0];\\n        int ans=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                ans=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ret = 1\\n        cur_max = max_ = nums[0]\\n        for i, n in enumerate(nums):\\n            if n < cur_max:\\n                cur_max = max_\\n                ret = i + 1\\n            if n > max_:\\n                max_ = n\\n        return ret\\n```\\n\\n```Java []\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0];\\n        int max=nums[0];\\n        int length=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){\\n                length=i+1;\\n                leftmax=max;\\n            } else {\\n                max = Math.max(nums[i],max);\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int minNum=a[0],maxNum=a[0];\\n        int ans=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                ans=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ret = 1\\n        cur_max = max_ = nums[0]\\n        for i, n in enumerate(nums):\\n            if n < cur_max:\\n                cur_max = max_\\n                ret = i + 1\\n            if n > max_:\\n                max_ = n\\n        return ret\\n```\n```Java []\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0];\\n        int max=nums[0];\\n        int length=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){\\n                length=i+1;\\n                leftmax=max;\\n            } else {\\n                max = Math.max(nums[i],max);\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379450,
                "title": "c-o-n-solution-using-prefix-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        // 5 5 5 8 8\\n        // 0 0 3 6 6\\n        int n=nums.size();\\n        vector<int> pref(n,0);//largest possible element in left\\n        vector<int> suff(n,0);//smallest possible element in right\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pref[i]=max(pref[i-1],nums[i]);\\n        suff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=min(nums[i],suff[i+1]);\\n        int ind=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pref[i]<=suff[i+1])\\n            {\\n                ind=i;\\n                break;\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        // 5 5 5 8 8\\n        // 0 0 3 6 6\\n        int n=nums.size();\\n        vector<int> pref(n,0);//largest possible element in left\\n        vector<int> suff(n,0);//smallest possible element in right\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pref[i]=max(pref[i-1],nums[i]);\\n        suff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=min(nums[i],suff[i+1]);\\n        int ind=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pref[i]<=suff[i+1])\\n            {\\n                ind=i;\\n                break;\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374894,
                "title": "c-best-solution-one-pass-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int  n = nums.size();\\n        vector<int> pre(n,-1);\\n        vector<int> post(n,-1);\\n        int currMax = nums[0] , currMin = nums[n-1];\\n        for(int i=0;i<n;i++){\\n            currMax = max(currMax,nums[i]);\\n            currMin = min(currMin,nums[n-1-i]);\\n            post[n-1-i] = currMin;\\n            pre[i] = currMax;\\n        }\\n        cout<<n;\\n        int ans = INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i] <= post[i+1]){\\n                return min(ans,i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int  n = nums.size();\\n        vector<int> pre(n,-1);\\n        vector<int> post(n,-1);\\n        int currMax = nums[0] , currMin = nums[n-1];\\n        for(int i=0;i<n;i++){\\n            currMax = max(currMax,nums[i]);\\n            currMin = min(currMin,nums[n-1-i]);\\n            post[n-1-i] = currMin;\\n            pre[i] = currMax;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3241893,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/922e4b9e-26f0-42f7-a5e2-c1668638a1bd_1677636638.9514394.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215164,
                "title": "c-solution-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n),post(n);\\n        for(int i=0,j=n-1;i<n;i++,j--){\\n            if(!i){\\n                pre[i] = nums[i];\\n                post[j] = nums[j];\\n                continue;\\n            }\\n            pre[i] = max(pre[i-1],nums[i]);\\n            post[j] = min(post[j+1],nums[j]);\\n        }\\n        int ans = 1;\\n        for(int j=1,i=0;j<n;i++,j++){\\n            if(pre[i]<=post[j]) return j;\\n        }\\n        return ans;\\n    }\\n};\\n//5 5 5 8 8\\n//0 0 3 6 6\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n),post(n);\\n        for(int i=0,j=n-1;i<n;i++,j--){\\n            if(!i){\\n                pre[i] = nums[i];\\n                post[j] = nums[j];\\n                continue;\\n            }\\n            pre[i] = max(pre[i-1],nums[i]);\\n            post[j] = min(post[j+1],nums[j]);\\n        }\\n        int ans = 1;\\n        for(int j=1,i=0;j<n;i++,j++){\\n            if(pre[i]<=post[j]) return j;\\n        }\\n        return ans;\\n    }\\n};\\n//5 5 5 8 8\\n//0 0 3 6 6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848678,
                "title": "weird-but-working-2-pointer-code-o-n-time-o-1-space",
                "content": "2 pointer solution, we greedily decide when start the splitting point ---\\'index\\', where cur_max represent the left possible max once the internal while loop starts running. The internal while loop also check for condition and initiating another possible largest sum of the \\'potential right subarray\\', if it is violated, it becomes left array and we replace cur_max with second_max, and repeat, the pointer jump to the end of internal while loop, therefore O(n)\\nclass Solution:\\n\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        cur_max = nums[0]\\n        second_max = 0\\n        index = 0\\n        i = 1\\n        while i <= len(nums)-1:\\n            \\n            if nums[i] >= cur_max:\\n                index = i\\n                \\n                j = i\\n                while j <= len(nums)-1:\\n                    \\n                    second_max = max(second_max,nums[j])\\n                    if nums[j] < cur_max:\\n                        cur_max = second_max \\n                        second_max = 0\\n                        i = j+1\\n                        break \\n                    elif j == len(nums)-1:\\n                        \\n                        return index \\n                    j += 1\\n            else:\\n                cur_max = max(cur_max,nums[i])\\n                i += 1\\n        return index",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "2 pointer solution, we greedily decide when start the splitting point ---\\'index\\', where cur_max represent the left possible max once the internal while loop starts running. The internal while loop also check for condition and initiating another possible largest sum of the \\'potential right subarray\\', if it is violated, it becomes left array and we replace cur_max with second_max, and repeat, the pointer jump to the end of internal while loop, therefore O(n)\\nclass Solution:\\n\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        cur_max = nums[0]\\n        second_max = 0\\n        index = 0\\n        i = 1\\n        while i <= len(nums)-1:\\n            \\n            if nums[i] >= cur_max:\\n                index = i\\n                \\n                j = i\\n                while j <= len(nums)-1:\\n                    \\n                    second_max = max(second_max,nums[j])\\n                    if nums[j] < cur_max:\\n                        cur_max = second_max \\n                        second_max = 0\\n                        i = j+1\\n                        break \\n                    elif j == len(nums)-1:\\n                        \\n                        return index \\n                    j += 1\\n            else:\\n                cur_max = max(cur_max,nums[i])\\n                i += 1\\n        return index",
                "codeTag": "Java"
            },
            {
                "id": 2710408,
                "title": "suffix-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        vector<int> sf(nums.size(), nums.back());\\n        for(int i=nums.size()-2; i>=0; i--) sf[i] = min(nums[i], sf[i + 1]);\\n        \\n        int mx = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            mx = max(mx, nums[i]);\\n            if(mx <= sf[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        vector<int> sf(nums.size(), nums.back());\\n        for(int i=nums.size()-2; i>=0; i--) sf[i] = min(nums[i], sf[i + 1]);\\n        \\n        int mx = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            mx = max(mx, nums[i]);\\n            if(mx <= sf[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345496,
                "title": "simple-java-solution-tc-o-n-sc-o-1",
                "content": "Runtime : 2 ms, faster than 100.00%\\nMemory Usage : 52 MB, less than 92.76%\\n\\nPlease upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int mts = nums[0]; // max till scan\\n        int mtp = nums[0]; // max till partition\\n        int idx = 0;\\n        \\n        for(int i=1; i<nums.length; i++) {\\n            int val = nums[i];\\n            if(val < mtp) {\\n                idx = i;\\n                mtp = mts;\\n            }\\n            \\n            mts = Math.max(mts, val);\\n        }\\n        \\n        return idx + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int mts = nums[0]; // max till scan\\n        int mtp = nums[0]; // max till partition\\n        int idx = 0;\\n        \\n        for(int i=1; i<nums.length; i++) {\\n            int val = nums[i];\\n            if(val < mtp) {\\n                idx = i;\\n                mtp = mts;\\n            }\\n            \\n            mts = Math.max(mts, val);\\n        }\\n        \\n        return idx + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200540,
                "title": "c-3-approaches-clean-code-simple-partition",
                "content": "**Approach 1 : \\nUsing Two Extra arrays\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //LeftMax vector\\n        vector<int>leftMax(n+1);\\n        leftMax[0]=nums[0];\\n        \\n        for(int i=1 ; i<nums.size() ; i++)\\n            leftMax[i]=max(leftMax[i-1],nums[i]);\\n        leftMax[n] = leftMax[n-1];\\n        \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        //For checking leftMax and rightMin vectors\\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        \\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            if(leftMax[k] <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n```\\n\\n\\n**Approach 2 : Using Single Extra Array\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n    \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        \\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        int leftMax = INT_MIN;\\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            leftMax = max(leftMax, nums[k]);\\n            if(leftMax <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n\\n```\\n\\n**Approach 3 : Without Using Any Extra Array\\nTime Complexity : O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftMax = nums[0];\\n        //leftMax -> Keeps the track of greatest left element and gets updated if any element wants to come to the left side \\n        int greater = 0;  \\n        //greater -> Keeps the tracks of greatest element till i\\n        int ans = 0;\\n        //7 3 9 5 10 1 15 16 19 14 30\\n        // i \\n        //leftMax = 7 7 9 10 \\n        //greater = 7 9 10 15 16 19 30a\\n        //ans = 0 1 3 5\\n    \\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            greater = max(greater, nums[i]);\\n            if(nums[i] < leftMax){\\n                ans = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```\\n\\n**Please do upvote if this helped you !!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //LeftMax vector\\n        vector<int>leftMax(n+1);\\n        leftMax[0]=nums[0];\\n        \\n        for(int i=1 ; i<nums.size() ; i++)\\n            leftMax[i]=max(leftMax[i-1],nums[i]);\\n        leftMax[n] = leftMax[n-1];\\n        \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        //For checking leftMax and rightMin vectors\\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        \\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            if(leftMax[k] <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n    \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        \\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        int leftMax = INT_MIN;\\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            leftMax = max(leftMax, nums[k]);\\n            if(leftMax <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftMax = nums[0];\\n        //leftMax -> Keeps the track of greatest left element and gets updated if any element wants to come to the left side \\n        int greater = 0;  \\n        //greater -> Keeps the tracks of greatest element till i\\n        int ans = 0;\\n        //7 3 9 5 10 1 15 16 19 14 30\\n        // i \\n        //leftMax = 7 7 9 10 \\n        //greater = 7 9 10 15 16 19 30a\\n        //ans = 0 1 3 5\\n    \\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            greater = max(greater, nums[i]);\\n            if(nums[i] < leftMax){\\n                ans = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2005280,
                "title": "java-easy-fastest-o-n-space",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax = nums[0], greater = nums[0], n = nums.length, ans = 0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > greater){\\n                greater = nums[i];\\n            }\\n            if(nums[i] < leftmax){\\n                ans = i;\\n                leftmax = greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax = nums[0], greater = nums[0], n = nums.length, ans = 0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > greater){\\n                greater = nums[i];\\n            }\\n            if(nums[i] < leftmax){\\n                ans = i;\\n                leftmax = greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791817,
                "title": "java-3ms-o-n-time-o-1-space-solution",
                "content": "# public int partitionDisjoint(int[] nums) {\\n        int res = 0;\\n        int leftMax = nums[0];\\n        int greater = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (greater <= nums[i]) {\\n                greater = nums[i];\\n            } else if (nums[i] < leftMax) {\\n                res = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return res + 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "# public int partitionDisjoint(int[] nums) {\\n        int res = 0;\\n        int leftMax = nums[0];\\n        int greater = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (greater <= nums[i]) {\\n                greater = nums[i];\\n            } else if (nums[i] < leftMax) {\\n                res = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return res + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607880,
                "title": "java-o-1-space-and-o-n-time-easy-and-short-code",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftMax=0;\\n        int greater=0;\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[greater]<nums[i]){\\n                greater=i;\\n            }\\n            if(nums[i]<nums[leftMax]){\\n                ans=i;\\n                leftMax=greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftMax=0;\\n        int greater=0;\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[greater]<nums[i]){\\n                greater=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1580950,
                "title": "c-o-n",
                "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe maximum element of the left side will be less than or equal to the minimum element of the right side. So We iterate the array from both sides to get the maximum from left and the minimum element from right for each element. \\n\\nSince we need to get the smallest possible left length, we iterate from left, and check if the left max is less than or equal to the right min. If it is, then we find a partition.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n       int lmax[nums.size()];\\n        int rmin[nums.size()];\\n        int max_num = 0;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            max_num = max(max_num, nums[i]);\\n            lmax[i] = max_num;\\n        }\\n        int min_num = INT_MAX;\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            min_num = min(min_num, nums[i + 1]);\\n            rmin[i] = min_num;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (lmax[i] <= rmin[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n       int lmax[nums.size()];\\n        int rmin[nums.size()];\\n        int max_num = 0;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            max_num = max(max_num, nums[i]);\\n            lmax[i] = max_num;\\n        }\\n        int min_num = INT_MAX;\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            min_num = min(min_num, nums[i + 1]);\\n            rmin[i] = min_num;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (lmax[i] <= rmin[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580575,
                "title": "java-single-pass-o-n-time-o-1-space",
                "content": "```java\\npublic int partitionDisjoint(int[] nums) {\\n\\tint leftMax = nums[0], max = nums[0], partitionIndex = 0;\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\t\\tif (nums[i] < leftMax) {\\n\\t\\t\\tleftMax = max;\\n\\t\\t\\tpartitionIndex = i;\\n\\t\\t}\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t}    \\n\\treturn partitionIndex + 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int partitionDisjoint(int[] nums) {\\n\\tint leftMax = nums[0], max = nums[0], partitionIndex = 0;\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\t\\tif (nums[i] < leftMax) {\\n\\t\\t\\tleftMax = max;\\n\\t\\t\\tpartitionIndex = i;\\n\\t\\t}\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t}    \\n\\treturn partitionIndex + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361819,
                "title": "java-o-1-space",
                "content": "```\\npublic static int partitionDisjointNewAttempt(int[] nums) {\\n        var maxElementOnLeftSife = nums[0];\\n        var greaterAfterMax = nums[0];\\n        var possibleBorder = 0;\\n\\n        for(var i = 1; i < nums.length; i++) {\\n            // if some element is greater then current maximum on left side\\n            // we need to save it to consider after expanding left partion as it will be max element after it\\n            if(nums[i] > greaterAfterMax) {\\n                greaterAfterMax = nums[i];\\n            } else if(nums[i] < maxElementOnLeftSife) {\\n                maxElementOnLeftSife = greaterAfterMax;\\n                possibleBorder = i;\\n            }\\n        }\\n\\n        // count elements, that + 1, because array start from 0\\n        return possibleBorder + 1;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic static int partitionDisjointNewAttempt(int[] nums) {\\n        var maxElementOnLeftSife = nums[0];\\n        var greaterAfterMax = nums[0];\\n        var possibleBorder = 0;\\n\\n        for(var i = 1; i < nums.length; i++) {\\n            // if some element is greater then current maximum on left side\\n            // we need to save it to consider after expanding left partion as it will be max element after it\\n            if(nums[i] > greaterAfterMax) {\\n                greaterAfterMax = nums[i];\\n            } else if(nums[i] < maxElementOnLeftSife) {\\n                maxElementOnLeftSife = greaterAfterMax;\\n                possibleBorder = i;\\n            }\\n        }\\n\\n        // count elements, that + 1, because array start from 0\\n        return possibleBorder + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359525,
                "title": "partition-array-into-disjoint-intervals",
                "content": "Here is my approach using maps in C++.\\n\\'\\'\\'\\n\\n    void sorting(map<int, int> & list){\\n        int n = list.size();\\n\\n        vector<pair<int, int>> sample;\\n        auto itr = list.begin();\\n\\n        for(auto& itr : list){\\n            sample.push_back(itr);\\n        }\\n\\n        sort(sample.begin(), sample.end());\\n    }\\n\\n    \\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int, int> list;\\n        \\n        for(int i =0; i<n; i++) ++list[nums[i]];\\n        \\n        int maxim = nums[0], i;\\n        sorting(list);\\n    \\n        for(i =0; i<n ; i++){\\n            maxim = max(maxim, nums[i]);\\n\\n            if(list.count(nums[i])) {\\n                --list[nums[i]];\\n                if(list[nums[i]] == 0) {\\n                    list.erase(nums[i]);\\n                }\\n            }\\n\\n            if(maxim <= list.begin()->first) break;\\n        }\\n        \\n        return i+1;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Here is my approach using maps in C++.\\n\\'\\'\\'\\n\\n    void sorting(map<int, int> & list){\\n        int n = list.size();\\n\\n        vector<pair<int, int>> sample;\\n        auto itr = list.begin();\\n\\n        for(auto& itr : list){\\n            sample.push_back(itr);\\n        }\\n\\n        sort(sample.begin(), sample.end());\\n    }\\n\\n    \\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int, int> list;\\n        \\n        for(int i =0; i<n; i++) ++list[nums[i]];\\n        \\n        int maxim = nums[0], i;\\n        sorting(list);\\n    \\n        for(i =0; i<n ; i++){\\n            maxim = max(maxim, nums[i]);\\n\\n            if(list.count(nums[i])) {\\n                --list[nums[i]];\\n                if(list[nums[i]] == 0) {\\n                    list.erase(nums[i]);\\n                }\\n            }\\n\\n            if(maxim <= list.begin()->first) break;\\n        }\\n        \\n        return i+1;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1358452,
                "title": "java-solution-faster-than-100-using-min-array",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[nums.length-1] = nums[nums.length-1];\\n        \\n        int minVal = nums[nums.length-1];\\n        for(int i = nums.length-2;i>=0;i--)\\n        {\\n            minVal = Math.min(minVal, nums[i]);\\n            min[i] = minVal;\\n        }\\n        \\n        int maxVal = nums[0];\\n        for(int i = 0;i<nums.length-1;i++)\\n        {\\n            maxVal = Math.max(maxVal, nums[i]);\\n            if(maxVal <= min[i+1])\\n                return i+1;\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[nums.length-1] = nums[nums.length-1];\\n        \\n        int minVal = nums[nums.length-1];\\n        for(int i = nums.length-2;i>=0;i--)\\n        {\\n            minVal = Math.min(minVal, nums[i]);\\n            min[i] = minVal;\\n        }\\n        \\n        int maxVal = nums[0];\\n        for(int i = 0;i<nums.length-1;i++)\\n        {\\n            maxVal = Math.max(maxVal, nums[i]);\\n            if(maxVal <= min[i+1])\\n                return i+1;\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357213,
                "title": "915-return-i-1-when-if-prefixmax-i-suffixmin-i",
                "content": "---\\n\\nIt looks simple, but a difficult question :)\\n\\n---\\n\\n**Algo**\\n- Move from left to right in the given array\\n  - Find max.. till now..\\n    - Save it another array called `prefixMax`\\n- Now move from right to left\\n  - Find min.. till now..\\n    - Save it another array called `suffixMin`\\n- Now we have both arrays\\n  - Can we get the answer required?\\n   - Yes\\n   - Now come from left to right again\\n     - But this time, dont look into the given array\\n\\t   - But look into `prefixMax` & `suffixMin` arrays, which are of same length of given array\\n\\t   - The key is if `prefixMax` is less than or equal to `suffixMin` we return that as answer\\n  \\t     - Why did we do `+1` below?\\n\\t\\t   - Because it was an index, and we needed length, `length will be index+1`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar partitionDisjoint = function (A) {\\n    let n = A.length;\\n\\n    let prefixMax = [...A];\\n    for (let i = 1; i < n; i++) {\\n        prefixMax[i] = Math.max(A[i], prefixMax[i - 1]);\\n    }\\n\\n    let suffixMin = [...A];\\n    for (let i = n - 2; i >= 0; i--) {\\n        suffixMin[i] = Math.min(A[i], suffixMin[i + 1]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (prefixMax[i] <= suffixMin[i + 1]) {\\n            return i + 1;\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e5b7d41a-f9dc-4c05-8daf-89510d6e4307_1627043377.2498617.png)\\n\\n----------\\n\\nProblem explanation:\\n----------\\n```\\nExample:\\n\\nDivide below \\n[5,0,3,8,6,10] \\ninto 2 sub arrays \\nwith at least one element \\n\\n[5,0,3,8,6,10] \\nbecomes \\n. left subarray and right subarray \\nas \\n. [5] and [0,3,8,6,10] \\n. [5,0] and [3,8,6,10] \\n. [5,0,3] and [8,6,10] \\n. [5,0,3,8] and [6,10] \\n. [5,0,3,8,6] and [10] \\n\\nwhile doing above \\nmake sure \\nall elements on left subarray \\nare less than \\nall elements on right subarray \\n\\n. all elements of [5] are less than all of [0,3,8,6,10]? - No, because 5 in left array < 0 in right array is false \\n. all elements of [5,0] are less than all of [3,8,6,10]? - No, because 5 in left array < 3 in right array is false \\n. all elements of [5,0,3] are less than all of [8,6,10]? - Yes, because 5,0&3 in left array are < all (8,6,10) in right array <------ A \\n. all elements of [5,0,3,8] are less than all of [6,10]? - No, because 8 in left array < 6 in right array is false \\n. all elements of [5,0,3,8,6] are less than all of [10]? - Yes, because 5,0,3,8&6 in left array are < all (10) in right array <------ B \\n\\nIn cases, both A & B (see above, on right)\\nare Yes \\ncomparing both left side subarray: \\n. [5,0,3] and \\n. [5,0,3,8,6] \\n\\nWe would need smallest of above two \\nit is \\n. [5,0,3] \\n\\nthe length of above is 3 \\nso, the answer is 3 \\n```\\n----------\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partitionDisjoint = function (A) {\\n    let n = A.length;\\n\\n    let prefixMax = [...A];\\n    for (let i = 1; i < n; i++) {\\n        prefixMax[i] = Math.max(A[i], prefixMax[i - 1]);\\n    }\\n\\n    let suffixMin = [...A];\\n    for (let i = n - 2; i >= 0; i--) {\\n        suffixMin[i] = Math.min(A[i], suffixMin[i + 1]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (prefixMax[i] <= suffixMin[i + 1]) {\\n            return i + 1;\\n        }\\n    }\\n};\\n```\n```\\nExample:\\n\\nDivide below \\n[5,0,3,8,6,10] \\ninto 2 sub arrays \\nwith at least one element \\n\\n[5,0,3,8,6,10] \\nbecomes \\n. left subarray and right subarray \\nas \\n. [5] and [0,3,8,6,10] \\n. [5,0] and [3,8,6,10] \\n. [5,0,3] and [8,6,10] \\n. [5,0,3,8] and [6,10] \\n. [5,0,3,8,6] and [10] \\n\\nwhile doing above \\nmake sure \\nall elements on left subarray \\nare less than \\nall elements on right subarray \\n\\n. all elements of [5] are less than all of [0,3,8,6,10]? - No, because 5 in left array < 0 in right array is false \\n. all elements of [5,0] are less than all of [3,8,6,10]? - No, because 5 in left array < 3 in right array is false \\n. all elements of [5,0,3] are less than all of [8,6,10]? - Yes, because 5,0&3 in left array are < all (8,6,10) in right array <------ A \\n. all elements of [5,0,3,8] are less than all of [6,10]? - No, because 8 in left array < 6 in right array is false \\n. all elements of [5,0,3,8,6] are less than all of [10]? - Yes, because 5,0,3,8&6 in left array are < all (10) in right array <------ B \\n\\nIn cases, both A & B (see above, on right)\\nare Yes \\ncomparing both left side subarray: \\n. [5,0,3] and \\n. [5,0,3,8,6] \\n\\nWe would need smallest of above two \\nit is \\n. [5,0,3] \\n\\nthe length of above is 3 \\nso, the answer is 3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356608,
                "title": "python-o-n-time-o-1-space-solution",
                "content": "So, we have two buckets left bucket and right bucket\\n\\nIf current ```ele``` happens to be less than the maximum in the left bucket, we have no choice but to add all elements till ele in the left bucket. While updating the size of the left bucket, we update the maximum in the left_bucket as well. \\n\\nThe above logic can be implemented using  ```left_max```, ```current_max``` and ```left_size```. \\n\\nHere\\'s the code. Feel free to comment, if you need any help understanding it. \\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        left_max=nums[0]\\n        current_max=nums[0]\\n        left_size=1\\n        for i in range(1,n):\\n            ele=nums[i]\\n            if(ele<left_max):\\n                #ele has to be in left! \\n                left_size=i+1\\n                left_max=current_max\\n            current_max=max(current_max,ele)\\n        return left_size\\n        \\n```",
                "solutionTags": [],
                "code": "```ele```\n```left_max```\n```current_max```\n```left_size```\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        left_max=nums[0]\\n        current_max=nums[0]\\n        left_size=1\\n        for i in range(1,n):\\n            ele=nums[i]\\n            if(ele<left_max):\\n                #ele has to be in left! \\n                left_size=i+1\\n                left_max=current_max\\n            current_max=max(current_max,ele)\\n        return left_size\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356401,
                "title": "c-o-1-space",
                "content": "```\\n//O(1) space solution algorithm is intresting \\n\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        \\n        int i,n=a.size(),partition=0;\\n        \\n        int left_max=a[0] , global_max=a[0];\\n        \\n        for(i=1;i<n;i++){\\n            global_max = max(global_max, a[i]);\\n            \\n            if(left_max>a[i]){\\n                // then this \\'i\\' qualifies for partition bcz\\n                // we are expecting elements from i+1 to n should be greater than left_max\\n                \\n                left_max = global_max; // global max till now is new left_max incase we got a future \\'i\\' qualifying as potential partition\\n                \\n                partition = i;\\n                \\n            }\\n        }\\n        \\n        return partition+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//O(1) space solution algorithm is intresting \\n\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        \\n        int i,n=a.size(),partition=0;\\n        \\n        int left_max=a[0] , global_max=a[0];\\n        \\n        for(i=1;i<n;i++){\\n            global_max = max(global_max, a[i]);\\n            \\n            if(left_max>a[i]){\\n                // then this \\'i\\' qualifies for partition bcz\\n                // we are expecting elements from i+1 to n should be greater than left_max\\n                \\n                left_max = global_max; // global max till now is new left_max incase we got a future \\'i\\' qualifying as potential partition\\n                \\n                partition = i;\\n                \\n            }\\n        }\\n        \\n        return partition+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356399,
                "title": "c-easy-clean-solution-o-n-time-complexity",
                "content": "**Use comment section if you dont understand the code, try to traverse it**\\n**Upvote this post if you like it**\\n\\n```\\n       int min1=nums[0],len=nums.size(),j=0,max1=nums[0];\\n        for(int i=1;i<len;i++)\\n        {\\n            if(min1<=nums[i])\\n            {\\n                max1=max1<nums[i]?nums[i]:max1;\\n            }\\n            else\\n            {\\n                j=i;\\n                min1=max1;\\n               \\n            }\\n        }\\n        return j+1;  \\n```\\nTime complexity - **O(n)** , Space complexity - **O(1)**\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n       int min1=nums[0],len=nums.size(),j=0,max1=nums[0];\\n        for(int i=1;i<len;i++)\\n        {\\n            if(min1<=nums[i])\\n            {\\n                max1=max1<nums[i]?nums[i]:max1;\\n            }\\n            else\\n            {\\n                j=i;\\n                min1=max1;\\n               \\n            }\\n        }\\n        return j+1;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356159,
                "title": "easy-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n        max_num = nums[0]\\n        res = 0\\n        max_seen_so_far = nums[0]\\n        \\n        i = 1\\n        while i < len(nums):\\n            \\n            if nums[i] > max_seen_so_far:\\n                max_seen_so_far = nums[i]\\n            \\n            elif nums[i] < max_num:\\n                res = i\\n                max_num = max_seen_so_far\\n            \\n            i += 1\\n        return res + 1\\n        \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n        max_num = nums[0]\\n        res = 0\\n        max_seen_so_far = nums[0]\\n        \\n        i = 1\\n        while i < len(nums):\\n            \\n            if nums[i] > max_seen_so_far:\\n                max_seen_so_far = nums[i]\\n            \\n            elif nums[i] < max_num:\\n                res = i\\n                max_num = max_seen_so_far\\n            \\n            i += 1\\n        return res + 1\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355579,
                "title": "c-cpp-java-javascript-easy-solution-fast100-o-n",
                "content": "**CPP**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n      int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count;  \\n    }\\n}\\n```\\n**JAVASCRIPT**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar partitionDisjoint = function(nums) {\\n    let m=nums[0],count=1,max_ele=nums[0];\\n        for(let i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count; \\n};\\n```\\n**C**\\n```\\n\\n\\nint partitionDisjoint(int* nums, int numsSize){\\n    int max(int a,int b)\\n    {\\n        if(a>b)\\n            return a;\\n    return b;\\n    }\\nint m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<numsSize;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n                \\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n      int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count;  \\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar partitionDisjoint = function(nums) {\\n    let m=nums[0],count=1,max_ele=nums[0];\\n        for(let i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count; \\n};\\n```\n```\\n\\n\\nint partitionDisjoint(int* nums, int numsSize){\\n    int max(int a,int b)\\n    {\\n        if(a>b)\\n            return a;\\n    return b;\\n    }\\nint m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<numsSize;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n                \\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355422,
                "title": "easy-solution-python-o-n-time",
                "content": "```\\ndef partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        next_max = 0\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > next_max:\\n                next_max = nums[i]\\n                \\n            if nums[i] < left_max:\\n                ans = i\\n                if next_max > left_max:\\n                    left_max = next_max\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\ndef partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        next_max = 0\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > next_max:\\n                next_max = nums[i]\\n                \\n            if nums[i] < left_max:\\n                ans = i\\n                if next_max > left_max:\\n                    left_max = next_max\\n        return ans + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1355410,
                "title": "simple-o-n-python-beats-98-27-speed-and-92-1-space",
                "content": "\\n        \\nAlgorithm: We pick the first elemet of the list and put it in the left partition (we must have at least one element in left partition). Then we define two variables to solve the question: ```maxleft =``` maximum number that is on the left partition and ```maxtotal =``` maximum number that we have seen until now in the array. \\n        \\n We parse the array and keep track of the ```maxleft``` and ```maxtotal```. If we reach to a number that is smaller than maxleft, we need to add all elements up to that index (inclusive) into the left partition and update the ```maxleft``` with ```maxtotal```. Also we need to increase the ans. \\n        \\nExample: [4, 3, 0, 7, 1 , 8]\\nstart iterating:\\nstep1: left = [4] , maxleft = 4, maxtotal = 4, ans = 1\\nstep2: 3 is smaller than 4 so we have left = [4, 3], maxleft = 4 , maxtotal = 4, ans = 2\\nstep3: left = [4, 3, 0], maxleft = 4, maxtotal = 4, ans = 3\\nstep4: left = [4, 3, 0], maxleft = 4, maxtotal = 7, ans = 3\\nstep5: 1 is less than maxleft so-> left = [4, 3, 0, 7, 1], maxleft = 7, maxtotal = 7, ans = 5\\nstep6: 8 is greater than 7 so we are done. left = [4, 3, 0, 7, 1], right = [8]\\n        \\n\\n        \\n        \\n        \\n```\\n   class Solution:\\n\\t   def partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tans = 1 \\n\\t\\t\\tmaxleft = nums[0] \\n\\n\\t\\t\\tmaxtotal = nums[0] \\n\\n\\t\\t\\tfor n in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[n] > maxtotal:\\n\\t\\t\\t\\t\\tmaxtotal = nums[n]\\n\\t\\t\\t\\telif nums[n] < maxleft:\\n\\t\\t\\t\\t\\tans = n + 1\\n\\t\\t\\t\\t\\tmaxleft = maxtotal\\n\\t\\t\\treturn ans\\n\\n\\n",
                "solutionTags": [],
                "code": "```maxleft =```\n```maxtotal =```\n```maxleft```\n```maxtotal```\n```maxleft```\n```maxtotal```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355377,
                "title": "python3-the-easiest-way-to-solve-this-problem-in-my-opinion",
                "content": "I think this is the most straightforward way to understand this problem:\\nUsing \\'maxx\\' to store the maximum of left array and \\'minn\\' to store the minimum of right array. In the for loop, checking if the minimum of right array needs to be updated and updating the maximum of left array. Once the minn is greater than maxx, return i + 1 as the length of left array.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tlng = len(nums)\\n\\t\\t\\tmaxx, minn = nums[0], min(nums[1:])\\n        \\n\\t\\t\\tfor i in range(lng):\\n\\t\\t\\t\\tmaxx = max(maxx, nums[i])\\n\\t\\t\\t\\tif minn == nums[i]: minn = min(nums[i + 1:])\\n\\t\\t\\t\\tif maxx <= minn: return i + 1\\n\\nThis might not be the best solution, please leave comments and let me know if there\\u2019s blind spot exist and how to improve.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "I think this is the most straightforward way to understand this problem:\\nUsing \\'maxx\\' to store the maximum of left array and \\'minn\\' to store the minimum of right array. In the for loop, checking if the minimum of right array needs to be updated and updating the maximum of left array. Once the minn is greater than maxx, return i + 1 as the length of left array.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tlng = len(nums)\\n\\t\\t\\tmaxx, minn = nums[0], min(nums[1:])\\n        \\n\\t\\t\\tfor i in range(lng):\\n\\t\\t\\t\\tmaxx = max(maxx, nums[i])\\n\\t\\t\\t\\tif minn == nums[i]: minn = min(nums[i + 1:])\\n\\t\\t\\t\\tif maxx <= minn: return i + 1\\n\\nThis might not be the best solution, please leave comments and let me know if there\\u2019s blind spot exist and how to improve.",
                "codeTag": "Java"
            },
            {
                "id": 1355147,
                "title": "c-easy-to-understand-time-o-n-space-o-1",
                "content": "\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n\\n3. Traverse all the elements from 1 to n-1.\\n\\n    - if element is smaller than lmax, increase partition by 1;\\n    \\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1 and max element of new left subarray is max of the right subarray we calculated. \\n\\n```\\n/*\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n3. Traverse all the elements from 1 to n-1.\\n    - if element is smaller than lmax, increase partition by 1;\\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1\\n            and max element of new left subarray is max of the right subarray we calculated. \\n\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int lmax = arr[0]; \\n        int partition = 1;\\n        for(int i=1;i<arr.size();){\\n            if(arr[i] < lmax){\\n                partition++;\\n                i++;\\n            }else{\\n                int j=i;\\n                int rmax = 0;\\n                while(j<arr.size()){\\n                    if(arr[j] < lmax){\\n                        lmax = rmax;\\n                        partition = j + 1;\\n                        break;\\n                    }else{\\n                        rmax = max(rmax,arr[j]);\\n                    }\\n                    j++;\\n                }\\n                i = j+1;\\n            }\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n3. Traverse all the elements from 1 to n-1.\\n    - if element is smaller than lmax, increase partition by 1;\\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1\\n            and max element of new left subarray is max of the right subarray we calculated. \\n\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int lmax = arr[0]; \\n        int partition = 1;\\n        for(int i=1;i<arr.size();){\\n            if(arr[i] < lmax){\\n                partition++;\\n                i++;\\n            }else{\\n                int j=i;\\n                int rmax = 0;\\n                while(j<arr.size()){\\n                    if(arr[j] < lmax){\\n                        lmax = rmax;\\n                        partition = j + 1;\\n                        break;\\n                    }else{\\n                        rmax = max(rmax,arr[j]);\\n                    }\\n                    j++;\\n                }\\n                i = j+1;\\n            }\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354875,
                "title": "simple-c-one-pass-solution-o-n-time-o-1-space",
                "content": "There are 2 cases where we want to update the left subarray:\\n1. We found a number in the right subarray smaller than the minimum of the left subarray.\\n2. We found a number in the right subarray not less than the minimum but it\\'s less than the maximum of the left subarray.\\nIn both cases the end of the left subarray would be the current index -> partition index is current index + 1\\n\\nWe assume that the left subarray consists of the first index only and loop over the array from 1 to array size - 2 since both left and right subarrays can\\'t be empty.\\n* We update the `maximum` with each loop\\n* Whenever we find a new minimum we update the `minimum`, the `partition` index, and the `newMax` which is the maximum of the left subarray. \\n* Whenever we find a number > `minimum` and < `newMax` we update the `partition` index and the `newMax`\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int partition = 1;\\n        int minimum = nums[0], maximum = nums[0], newMax = nums[0];\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            maximum = max(maximum, nums[i]);\\n            if (nums[i] <= minimum) {\\n                minimum = nums[i];\\n                newMax = maximum;\\n                partition = i + 1;\\n            } else if (nums[i] > minimum && nums[i] < newMax) {\\n                partition = i + 1;\\n                newMax = maximum;\\n            }\\n        }\\n        \\n        return partition;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int partition = 1;\\n        int minimum = nums[0], maximum = nums[0], newMax = nums[0];\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            maximum = max(maximum, nums[i]);\\n            if (nums[i] <= minimum) {\\n                minimum = nums[i];\\n                newMax = maximum;\\n                partition = i + 1;\\n            } else if (nums[i] > minimum && nums[i] < newMax) {\\n                partition = i + 1;\\n                newMax = maximum;\\n            }\\n        }\\n        \\n        return partition;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354731,
                "title": "java-o-n-simple-clear",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] maxLeft = new int[n], minRight = new int[n];\\n        maxLeft[0] = nums[0];\\n        for(int i = 1; i < n; i++)\\n            maxLeft[i] = Math.max(nums[i], maxLeft[i - 1]);\\n        minRight[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--)\\n            minRight[i] = Math.min(nums[i], minRight[i + 1]);\\n        for(int i = 1; i < n; i++)\\n            if(maxLeft[i - 1] <= minRight[i])\\n                return i;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] maxLeft = new int[n], minRight = new int[n];\\n        maxLeft[0] = nums[0];\\n        for(int i = 1; i < n; i++)\\n            maxLeft[i] = Math.max(nums[i], maxLeft[i - 1]);\\n        minRight[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--)\\n            minRight[i] = Math.min(nums[i], minRight[i + 1]);\\n        for(int i = 1; i < n; i++)\\n            if(maxLeft[i - 1] <= minRight[i])\\n                return i;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354729,
                "title": "easy-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i] = min(dp[i+1],nums[i]);\\n        }\\n        int len = 1;\\n        int m = -1;\\n        m = nums[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]>=m)\\n                break;\\n            else{\\n                m=max(nums[i],m);\\n                len++;}\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i] = min(dp[i+1],nums[i]);\\n        }\\n        int len = 1;\\n        int m = -1;\\n        m = nums[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]>=m)\\n                break;\\n            else{\\n                m=max(nums[i],m);\\n                len++;}\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354625,
                "title": "easy-and-fast-solution-linear-time-and-constant-space",
                "content": "we will simply maintain the maximum number in the left interval and a running maximum and when ever we found a number less then the maximum in left we move our left to that number and make our left maximum to running maximum.\\n\\nfor eg:\\n\\t\\t\\t5, 4, 8, 6, 4, 9, 7 is the array so we start from 4 here rm(running maximum ) and lm(left maximum) is 4 so we shift our left interval to 4 similarly when we reach at next 4 our left interval is 2 and rm is 8 and lm is 5 now since 5 is greater than 4 so we move our left interval to 5 and now left maximum is 8.\\n\\t\\t\\t\\nhope you understant the logic which i used to solve this quesion.\\n\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],rm=nums[0],res=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            rm=max(nums[i],rm);\\n            if(nums[i]<m)\\n            {\\n                res=i+1;\\n                m=rm;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],rm=nums[0],res=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            rm=max(nums[i],rm);\\n            if(nums[i]<m)\\n            {\\n                res=i+1;\\n                m=rm;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354597,
                "title": "partition-array-into-disjoint-intervals-solution-java-o-n",
                "content": "```\\npublic int partitionDisjoint(int[] nums) {\\n        int[] maxLeftArr = new int[nums.length];\\n        int[] minRightArr = new int[nums.length];\\n        int maxLeft = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxLeft = Math.max(maxLeft, nums[i]);\\n            maxLeftArr[i] = maxLeft;\\n        }\\n\\n        int minRight = Integer.MAX_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            minRight = Math.min(minRight, nums[i]);\\n            minRightArr[i] = minRight;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (maxLeftArr[i] <= minRightArr[i + 1])\\n                return i + 1;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] nums) {\\n        int[] maxLeftArr = new int[nums.length];\\n        int[] minRightArr = new int[nums.length];\\n        int maxLeft = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxLeft = Math.max(maxLeft, nums[i]);\\n            maxLeftArr[i] = maxLeft;\\n        }\\n\\n        int minRight = Integer.MAX_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            minRight = Math.min(minRight, nums[i]);\\n            minRightArr[i] = minRight;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (maxLeftArr[i] <= minRightArr[i + 1])\\n                return i + 1;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354593,
                "title": "java-solution-1ms-100-faster-easy",
                "content": "public int partitionDisjoint(int[] nums) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int flag=1;\\n            if(nums[i]>max)\\n                max=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]<max)\\n                {\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1)\\n                return i+1;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int partitionDisjoint(int[] nums) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int flag=1;\\n            if(nums[i]>max)\\n                max=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]<max)\\n                {\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1)\\n                return i+1;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1354566,
                "title": "python-one-pass-simple-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftmax = nums[0]\\n        currmax = nums[0]\\n        p = 0\\n        for i,n in enumerate(nums):\\n            currmax = max(currmax,n)\\n            if n < leftmax:\\n                leftmax = currmax\\n                p = i\\n        return p+1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftmax = nums[0]\\n        currmax = nums[0]\\n        p = 0\\n        for i,n in enumerate(nums):\\n            currmax = max(currmax,n)\\n            if n < leftmax:\\n                leftmax = currmax\\n                p = i\\n        return p+1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1354528,
                "title": "c-simple-o-n-time-and-o-1-space-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionDisjoint(vector<int>& nums) {\\n\\t\\t\\tint mx1=nums[0],mx2=nums[0],ans=0;\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) {\\n\\t\\t\\t\\tmx2=max(mx2,nums[i]);\\n\\t\\t\\t\\tif(mx1>nums[i]) {\\n\\t\\t\\t\\t\\tmx1=mx2; ans=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionDisjoint(vector<int>& nums) {\\n\\t\\t\\tint mx1=nums[0],mx2=nums[0],ans=0;\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) {\\n\\t\\t\\t\\tmx2=max(mx2,nums[i]);\\n\\t\\t\\t\\tif(mx1>nums[i]) {\\n\\t\\t\\t\\t\\tmx1=mx2; ans=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1354489,
                "title": "partition-array-into-disjoint-intervals-python-easy-solution",
                "content": "# upvote if useful\\n![image](https://assets.leetcode.com/users/images/8b116f05-3166-48e8-8b9f-bf284f519ecf_1626941026.614562.png)\\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        a = list(accumulate(nums, max)) \\n        b = list(accumulate(nums[::-1], min))[::-1]\\n        for i in range(1, len(nums)):\\n            if a[i-1] <= b[i]: \\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        a = list(accumulate(nums, max)) \\n        b = list(accumulate(nums[::-1], min))[::-1]\\n        for i in range(1, len(nums)):\\n            if a[i-1] <= b[i]: \\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354456,
                "title": "o-n-c-very-easy-approach-with-brief-explanation",
                "content": "**If you don\\'t like my solution please comment ,, do not downvote**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        //here we need to find a left subarray where maximum among them is less than the minimum among the right subarray \\n\\t\\t//so we will keep track of min and max elements for each poiny\\n        int min_dp[30001];//keep a count of minimum from end of the array\\n        \\n        int max_dp[30001];//keep a count on the maximum element from the start\\n        \\n        max_dp[0] = nums[0];\\n        int ind =0;\\n       // int ind_2 = 0;\\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>=max_dp[i-1]){\\n                max_dp[i] = nums[i];\\n              //  ind_2 =i;\\n            }\\n            else{\\n                max_dp[i] = max_dp[i-1];\\n                \\n            }\\n            \\n        }\\n        \\n        min_dp[nums.size()-1] = nums[nums.size()-1];\\n        \\n        for(int i=nums.size()-2;i>=0;i--){\\n            \\n            if(nums[i]<=min_dp[i+1]){\\n                min_dp[i] = nums[i];\\n            }\\n            else{\\n                min_dp[i] = min_dp[i+1];\\n            }\\n            \\n        }\\n        \\n        \\n        //we have to select the minimum length of left subarray so we will break at the first matching of conditions\\n        for(int i=1;i<nums.size();i++){\\n            //if max of o...to i-1 is <= to min of i to n then we found our point of intersection\\n            if(max_dp[i-1]<=min_dp[i]){\\n                ind = i;\\n                break;\\n            }\\n            \\n        }\\n      \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        //here we need to find a left subarray where maximum among them is less than the minimum among the right subarray \\n\\t\\t//so we will keep track of min and max elements for each poiny\\n        int min_dp[30001];//keep a count of minimum from end of the array\\n        \\n        int max_dp[30001];//keep a count on the maximum element from the start\\n        \\n        max_dp[0] = nums[0];\\n        int ind =0;\\n       // int ind_2 = 0;\\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>=max_dp[i-1]){\\n                max_dp[i] = nums[i];\\n              //  ind_2 =i;\\n            }\\n            else{\\n                max_dp[i] = max_dp[i-1];\\n                \\n            }\\n            \\n        }\\n        \\n        min_dp[nums.size()-1] = nums[nums.size()-1];\\n        \\n        for(int i=nums.size()-2;i>=0;i--){\\n            \\n            if(nums[i]<=min_dp[i+1]){\\n                min_dp[i] = nums[i];\\n            }\\n            else{\\n                min_dp[i] = min_dp[i+1];\\n            }\\n            \\n        }\\n        \\n        \\n        //we have to select the minimum length of left subarray so we will break at the first matching of conditions\\n        for(int i=1;i<nums.size();i++){\\n            //if max of o...to i-1 is <= to min of i to n then we found our point of intersection\\n            if(max_dp[i-1]<=min_dp[i]){\\n                ind = i;\\n                break;\\n            }\\n            \\n        }\\n      \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354450,
                "title": "partition-array-into-disjoint-intervals-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_length = 1 \\n        left_max = curr_max = nums[0] \\n        for i in range(1, n-1): \\n            if nums[i] < left_max:\\n                left_length = i+1\\n                left_max = curr_max\\n            else:\\n                curr_max = max(curr_max, nums[i])\\n        return left_length\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_length = 1 \\n        left_max = curr_max = nums[0] \\n        for i in range(1, n-1): \\n            if nums[i] < left_max:\\n                left_length = i+1\\n                left_max = curr_max\\n            else:\\n                curr_max = max(curr_max, nums[i])\\n        return left_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354435,
                "title": "python-fast-easy-with-explanation-o-n-152ms-80",
                "content": "**left_max** is the largest number in left subarray.\\n\\n**tmp_max** is the the largest number before idx i.\\n\\nOnly when nums[i] < left_max, which means we should add nums[i] into left subarray, we update left_max with tmp_max. (This is when we actually add number into left subarray.)\\n\\n**ans** mean the idx of the cut, so we return **(ans+1)** as the length of left subarray.\\n\\n```\\nclass Solution(object):\\n    def partitionDisjoint(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums)\\n        \\n        ans = 0\\n        left_max = nums[0]\\n        tmp_max = 0\\n        \\n        for i in range(N):\\n            tmp_max = max(tmp_max, nums[i])\\n            if nums[i] < left_max:\\n                ans = i\\n                left_max = tmp_max\\n                \\n        return ans+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums)\\n        \\n        ans = 0\\n        left_max = nums[0]\\n        tmp_max = 0\\n        \\n        for i in range(N):\\n            tmp_max = max(tmp_max, nums[i])\\n            if nums[i] < left_max:\\n                ans = i\\n                left_max = tmp_max\\n                \\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337414,
                "title": "c-implementation-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                s.push(nums[i]);\\n                continue;\\n            }\\n            s.push(min(s.top(),nums[i]));\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            s.pop();\\n            mx=max(mx,nums[i]);\\n            if(s.top()>=mx)\\n            {\\n                return i+1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                s.push(nums[i]);\\n                continue;\\n            }\\n            s.push(min(s.top(),nums[i]));\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            s.pop();\\n            mx=max(mx,nums[i]);\\n            if(s.top()>=mx)\\n            {\\n                return i+1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335683,
                "title": "java-solution-100-faster-o-1-space-single-iteration",
                "content": "Things to check\\n1. If a number is part of the left partition, all numbers in right partition should be greater than it.\\n\\n\\nIf we find a number which is smaller than the max value in left partition, we include this number in our left partition and also need  to change the max of the left partition. \\n\\nVariables \\n- test : the current max in the left partition\\n- mark : the end index of the left partition\\n- max : the max of all the elements processed till now, we need this max to change our test in case a number smaller than test shows up. We have to include that number in our left partition and thus `test` is not the max value in left partition.\\n\\n\\nReturn `mark` at the end.\\n\\n```\\nclass Solution {\\n    // linear traversal required\\n    public int partitionDisjoint(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int test = nums[0];\\n        int max = nums[0];\\n        int mark = 0;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] < test){\\n                mark = i;\\n                test = max;\\n            }else{\\n                max = nums[i]>max?nums[i]:max;\\n            }\\n        }\\n        return mark+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // linear traversal required\\n    public int partitionDisjoint(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int test = nums[0];\\n        int max = nums[0];\\n        int mark = 0;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] < test){\\n                mark = i;\\n                test = max;\\n            }else{\\n                max = nums[i]>max?nums[i]:max;\\n            }\\n        }\\n        return mark+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195402,
                "title": "java-dp-100-faster",
                "content": "```\\n\\tpublic int partitionDisjoint(int[] A) {\\n        int[] maxFromLeft= new int[A.length];\\n        int max= Integer.MIN_VALUE;\\n        int min= Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++){\\n            if(A[i] > max) max= A[i];\\n            maxFromLeft[i]= max;\\n        }\\n        int index= A.length-1;\\n        for(int i= A.length-1; i>0; i--){\\n            if(min > A[i]) min= A[i];\\n            if(min >= maxFromLeft[i-1]) index= i;\\n        }\\n        return index;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int partitionDisjoint(int[] A) {\\n        int[] maxFromLeft= new int[A.length];\\n        int max= Integer.MIN_VALUE;\\n        int min= Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++){\\n            if(A[i] > max) max= A[i];\\n            maxFromLeft[i]= max;\\n        }\\n        int index= A.length-1;\\n        for(int i= A.length-1; i>0; i--){\\n            if(min > A[i]) min= A[i];\\n            if(min >= maxFromLeft[i-1]) index= i;\\n        }\\n        return index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1162142,
                "title": "c-o-n-short-explanation",
                "content": "* Index i satisfies the condition if the largest element from 0:i <= the smallest element from i+1:end.\\nSo we calculate the largest number at each index i from 0:end, and then calculate the minimum number at each index i from end:0. Once we find an index i such that largest_num[i] <= smallest_num[i+1], we are done.\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int pos, size = A.size(), smallest = A[size - 1];\\n        vector<int> largest(size, A[0]);\\n        for (int i = 1; i < size; ++i)\\n        {\\n            largest[i] = max(largest[i - 1], A[i]);\\n        }\\n        \\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            if (largest[i] <= smallest)\\n            {\\n                pos = i;\\n            }\\n            \\n            smallest = min(smallest, A[i]);\\n        }\\n        \\n        return pos + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int pos, size = A.size(), smallest = A[size - 1];\\n        vector<int> largest(size, A[0]);\\n        for (int i = 1; i < size; ++i)\\n        {\\n            largest[i] = max(largest[i - 1], A[i]);\\n        }\\n        \\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            if (largest[i] <= smallest)\\n            {\\n                pos = i;\\n            }\\n            \\n            smallest = min(smallest, A[i]);\\n        }\\n        \\n        return pos + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152238,
                "title": "java-o-n-100",
                "content": "```\\npublic int partitionDisjoint(int[] A) {\\n        int len = A.length;\\n        int[] mins = new int[len];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = len - 1; i >= 0; i--) {\\n            min = Math.min(min, A[i]);\\n            mins[i] = min;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < len - 1; i++) {\\n            max = Math.max(max, A[i]);\\n            if (max <= mins[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int len = A.length;\\n        int[] mins = new int[len];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = len - 1; i >= 0; i--) {\\n            min = Math.min(min, A[i]);\\n            mins[i] = min;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < len - 1; i++) {\\n            max = Math.max(max, A[i]);\\n            if (max <= mins[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110452,
                "title": "100-faster-100-efficient-time-o-n-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/65e3de30-f760-4c14-a0a4-599f9c4822fd_1615792253.5822365.png)\\n```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int PartitionDisjoint(int[] A) {\\n        int leftMax = A[0], max=A[0], leftLen = 0;\\n        for(int i=1;i<A.Length;i++)\\n        {\\n            if(A[i]<leftMax)\\n            {\\n                leftLen = i;\\n                leftMax = Math.Max(leftMax,max);\\n            }\\n            max = Math.Max(max,A[i]);\\n        }\\n        return leftLen+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int PartitionDisjoint(int[] A) {\\n        int leftMax = A[0], max=A[0], leftLen = 0;\\n        for(int i=1;i<A.Length;i++)\\n        {\\n            if(A[i]<leftMax)\\n            {\\n                leftLen = i;\\n                leftMax = Math.Max(leftMax,max);\\n            }\\n            max = Math.Max(max,A[i]);\\n        }\\n        return leftLen+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079099,
                "title": "java-o-n-time-and-o-1-space-solution-using-2-pointers",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] a) {\\n        if (a.length == 0) return 0;\\n        int lo = 0;\\n        int hi = 1;\\n        int max = a[lo];\\n        \\n        while (hi < a.length) {\\n            while (lo != hi && a[hi] < max) {\\n                max = Math.max(a[lo++], max);\\n            }\\n            ++hi;\\n        }\\n        \\n        return lo+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] a) {\\n        if (a.length == 0) return 0;\\n        int lo = 0;\\n        int hi = 1;\\n        int max = a[lo];\\n        \\n        while (hi < a.length) {\\n            while (lo != hi && a[hi] < max) {\\n                max = Math.max(a[lo++], max);\\n            }\\n            ++hi;\\n        }\\n        \\n        return lo+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011039,
                "title": "python-3-two-pass",
                "content": "In first pass, record the leftmax for each number with index in range [1,n-1] inclusive.\\n\\nIn second pass, start from rightmost number, each time record the minimum number on the right including current number, if the minimum of the right is still no less than leftmost of this number, we take it as a valid count.\\n\\nReturn the length of total array minus maximum length of right hand array in each valid count.\\n```\\ndef partitionDisjoint(A):\\n\\tn=len(A)\\n\\tif n==2:\\n\\t\\treturn 1\\n\\tres,cur=[],A[0]\\n\\tfor idx in range(1,n-1):\\n\\t\\tcur=max(cur,A[idx-1])\\n\\t\\tres.append(cur)\\n\\trmin,ans=A[-1],1\\n\\tfor x in reversed(range(len(res))):\\n\\t\\trmin=min(rmin,A[x+1])\\n\\t\\tif rmin>=res[x]:\\n\\t\\t\\tans=max(ans,n-x-1)\\n\\treturn n-ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef partitionDisjoint(A):\\n\\tn=len(A)\\n\\tif n==2:\\n\\t\\treturn 1\\n\\tres,cur=[],A[0]\\n\\tfor idx in range(1,n-1):\\n\\t\\tcur=max(cur,A[idx-1])\\n\\t\\tres.append(cur)\\n\\trmin,ans=A[-1],1\\n\\tfor x in reversed(range(len(res))):\\n\\t\\trmin=min(rmin,A[x+1])\\n\\t\\tif rmin>=res[x]:\\n\\t\\t\\tans=max(ans,n-x-1)\\n\\treturn n-ans\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 880661,
                "title": "python-98-intuitive-solution",
                "content": "We start with two arrays, a and b.\\na stores the maximum element encountered so far.\\nb stores the minimum element encountered so far on the reversed original array.\\nWe then find the least index i for which a[i]<=b[i+1]\\n\\nWe use the \\'accumulate\\' method from the itertools module.\\nUpvote if you found it useful. :))\\n\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, A: List[int]) -> int:\\n\\t\\t\\tfrom itertools import accumulate\\n\\n\\t\\t\\ta = accumulate(A,func=max)\\n\\t\\t\\ta = list(a)\\n\\t\\t\\tA.reverse()\\n\\t\\t\\tb = accumulate(A,func=min)\\n\\t\\t\\tb = list(b)\\n\\t\\t\\tb.reverse()\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tif a[i]<=b[i+1]:\\n\\t\\t\\t\\t\\treturn i+1",
                "solutionTags": [],
                "code": "We start with two arrays, a and b.\\na stores the maximum element encountered so far.\\nb stores the minimum element encountered so far on the reversed original array.\\nWe then find the least index i for which a[i]<=b[i+1]\\n\\nWe use the \\'accumulate\\' method from the itertools module.\\nUpvote if you found it useful. :))\\n\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, A: List[int]) -> int:\\n\\t\\t\\tfrom itertools import accumulate\\n\\n\\t\\t\\ta = accumulate(A,func=max)\\n\\t\\t\\ta = list(a)\\n\\t\\t\\tA.reverse()\\n\\t\\t\\tb = accumulate(A,func=min)\\n\\t\\t\\tb = list(b)\\n\\t\\t\\tb.reverse()\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tif a[i]<=b[i+1]:\\n\\t\\t\\t\\t\\treturn i+1",
                "codeTag": "Java"
            },
            {
                "id": 871377,
                "title": "python-beats-99",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        ans = 1\\n        mx = A[0]\\n        possible = 0\\n        possible_mx = mx\\n        for i in range(1, len(A)):\\n            if A[i] < mx:\\n                ans += 1\\n                ans += possible\\n                possible = 0\\n                mx = max(possible_mx, mx)\\n            else:\\n                possible += 1\\n                possible_mx = max(possible_mx, A[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        ans = 1\\n        mx = A[0]\\n        possible = 0\\n        possible_mx = mx\\n        for i in range(1, len(A)):\\n            if A[i] < mx:\\n                ans += 1\\n                ans += possible\\n                possible = 0\\n                mx = max(possible_mx, mx)\\n            else:\\n                possible += 1\\n                possible_mx = max(possible_mx, A[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790514,
                "title": "java-solution-beats-100",
                "content": "```java\\npublic int partitionDisjoint(int[] A) {\\n        // greedy\\n        int curMax = A[0];\\n        int globalMax = A[0];\\n        int j = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                j = i;\\n                curMax = globalMax;\\n            }\\n            globalMax = Math.max(globalMax, A[i]);\\n        }\\n        return j + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int partitionDisjoint(int[] A) {\\n        // greedy\\n        int curMax = A[0];\\n        int globalMax = A[0];\\n        int j = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                j = i;\\n                curMax = globalMax;\\n            }\\n            globalMax = Math.max(globalMax, A[i]);\\n        }\\n        return j + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739772,
                "title": "javascript-solution",
                "content": "```\\nconst partitionDisjoint = (A) => {\\n    let res;\\n    for (let i = 1; i < A.length; i++) {\\n        let left = A.slice(0, i);\\n        let right = A.slice(i, A.length);\\n        if (Math.max.apply(Math, left) <= Math.min.apply(Math, right)) {\\n            res = i;\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst partitionDisjoint = (A) => {\\n    let res;\\n    for (let i = 1; i < A.length; i++) {\\n        let left = A.slice(0, i);\\n        let right = A.slice(i, A.length);\\n        if (Math.max.apply(Math, left) <= Math.min.apply(Math, right)) {\\n            res = i;\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 727188,
                "title": "c-concise-o-n-solution",
                "content": "Maximum of left window will be <= Minimum in right window \\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n     int n=A.size();\\n     vector<int>max_left(n);\\n     vector<int>min_right(n);\\n     max_left[0]=A[0];min_right[n-1]=A[n-1];\\n     for(int i=1;i<n;i++) max_left[i]=max(max_left[i-1],A[i]);\\n     for(int i=n-2;i>=0;i--) min_right[i]=min(min_right[i+1],A[i]);\\n     for(int i=0;i<n-1;i++)\\n     {\\n         if(max_left[i]<=min_right[i+1]) return i+1;\\n     }\\n     return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n     int n=A.size();\\n     vector<int>max_left(n);\\n     vector<int>min_right(n);\\n     max_left[0]=A[0];min_right[n-1]=A[n-1];\\n     for(int i=1;i<n;i++) max_left[i]=max(max_left[i-1],A[i]);\\n     for(int i=n-2;i>=0;i--) min_right[i]=min(min_right[i+1],A[i]);\\n     for(int i=0;i<n-1;i++)\\n     {\\n         if(max_left[i]<=min_right[i+1]) return i+1;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 652570,
                "title": "rust-simple-solution-with-explanation-0ms-10-lines",
                "content": "\\nThis problem is actually asking us to find the minimum index `i` such that the **maximum** element of the sub-array `a[:i]` (not including `a[i]`) is less than or equal to the **minimum** element of the right part `a[i:]`. \\n\\nGiven this, we can find the answer in one pass with the help of two auxiliary variables, (1) `pre_max`: the maximum value of `a[:pos]` for an index `pos`, and (2) `total_max`: the current maximum value as we loop over the array.\\n\\nDuring the iteration, when we find the current value `n` is smaller than `pre_max`, we know `pos` can NOT be the answer, since `max(a[:pos] = pre_max > n`. We have to update our index `pos` to current index `i` and `pre_max` to the maximum value of `a[:i]`, which is exactly `total_max`. \\n\\nSince it is guaranteed there is at least one way to partition A as described. We do not need to worry about corner cases where we find no such valid index.\\n\\n### Rust solution\\n\\n```rust\\nimpl Solution {\\n    pub fn partition_disjoint(a: Vec<i32>) -> i32 {\\n        let mut pre_max = a[0]; \\n        let mut total_max = a[0];\\n        let mut pos = 0; \\n        for (i, n) in a.iter().enumerate() {\\n            if pre_max > *n {\\n                pre_max = total_max; \\n                pos = i; \\n            } else if total_max < *n {\\n                total_max = *n ;\\n            }\\n        }\\n        1 + pos as i32 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn partition_disjoint(a: Vec<i32>) -> i32 {\\n        let mut pre_max = a[0]; \\n        let mut total_max = a[0];\\n        let mut pos = 0; \\n        for (i, n) in a.iter().enumerate() {\\n            if pre_max > *n {\\n                pre_max = total_max; \\n                pos = i; \\n            } else if total_max < *n {\\n                total_max = *n ;\\n            }\\n        }\\n        1 + pos as i32 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584223,
                "title": "o-n-time-o-1-space-intuitive-easy-idea-to-follow-explained",
                "content": "**What matters in this problem?**\\n* We keep a maximum number which is largest in left, because that is the number that matters when traversing across the array. All items in the right partition must be equal or greater than all numbers in the left partition.\\n* If any number is smaller than this maximum number, it has to go in the left partition.\\n* With this, it makes sense that if the number is smaller, just keep moving right. Example: [5,0,3,6,7]. The maximum number is 5 so the partition point cannot possibly be 0 or 3 because they are smaller than 5. It has to be 6 or 7.\\n\\nSet the max number to the first number of the array. This makes sense because think of [1,2,3,4,5]. 1 is the first potential max, and it actually is the answer to this problem: [1] and [2,3,4,5]. Because 1 is the max, 2 would be a potential partition point. (It is the correct one.)\\n\\nThere are 2 cases when we find a potential: it is the right one, or it is the wrong one:\\n\\n1. CORRECT CASE: If we encounter a number that is the same or larger, this is a potential partition. When we do, we need to scan from that number to the end of the array. If all numbers after are larger than our current max, then we have found the partition point, so just return end (which marks the size of the array). Example:  [5,0,3,5,6,7]. Max 5. We scan until we hit 5. Because 5 >= max (5) we can consider this the partition point. Scan until end. 5 is equal. (Equal is valid! think of a case like [1,1].) 6 is larger. 7 is larger. And we\\'ve hit the end of the array. Return end.\\n \\n1. INCORRECT CASE: The other case to consider is that this is a false partition point. Think of a case like: [5,0,3,6,7,2,10,11]. 6 is a potential point of partition but it is not correct. The answer is [5,0,3,6,7,2], [10,11]. If we encounter this case what can we do? We need to restart our search for the next candidate. However there can be numbers in our loop that are the new maximums (6, 7) that we are now calling part of our left partition, so in our searching loop we need to update the new maximum. The next candidate must be equal to or larger than 7.\\n\\nRepeat until end of the loop. If we have not found anything yet, the left partition is the entire array, so return the length of A.\\n\\nO(n) time because we never backtrack on our pointer. In the for loop, if we have the wrong partition point, we move end up to where the loop was scanning. If we have the right one we return the answer.\\nO(1) space just using a max variable and pointer.\\n\\nNot the cleanest solution, but I think with the thought process/code explained it is easy to follow or come up with alone.\\n\\n```\\n    public int partitionDisjoint(int[] A) {\\n        if (A.length <= 1) return A.length;\\n\\n        int max = A[0];\\n        int end = 1;\\n\\n        while (end < A.length) {\\n            if (A[end] >= max) { /* we have reached a potential partition point here*/\\n                boolean correct = true; /* end is the correct point unless we find a number in right smaller than max*/\\n                int newMax = max; /*temp variable to find the new max, if exists*/\\n                for (int i = end; i < A.length; ++i) { /*loop through the rest of the array and see if this is the correct partition point or not*/\\n                    newMax = Math.max(newMax, A[i]); /*update new max, if exists */\\n                    if (A[i] < max) { /*there is a smaller number in right of end so this point is not the answer. update end, max and keep scanning.*/\\n                        end = i; /* move end up to the number we just found smaller than max, the next num is the next valid point to check */\\n                        max = newMax; /*new maximum number in left array */\\n                        correct = false; /* there is a smaller number in right, we have not found the correct point */\\n                        break;\\n                    }\\n                }\\n                if (correct) { /*we have reached here without finding any smaller numbers (entering the above for loop), all numbers are larger than max in left. Return end.*/\\n                    return end;\\n                }\\n            }\\n            end++;\\n        }\\n        return A.length;\\n    }",
                "solutionTags": [],
                "code": "**What matters in this problem?**\\n* We keep a maximum number which is largest in left, because that is the number that matters when traversing across the array. All items in the right partition must be equal or greater than all numbers in the left partition.\\n* If any number is smaller than this maximum number, it has to go in the left partition.\\n* With this, it makes sense that if the number is smaller, just keep moving right. Example: [5,0,3,6,7]. The maximum number is 5 so the partition point cannot possibly be 0 or 3 because they are smaller than 5. It has to be 6 or 7.\\n\\nSet the max number to the first number of the array. This makes sense because think of [1,2,3,4,5]. 1 is the first potential max, and it actually is the answer to this problem: [1] and [2,3,4,5]. Because 1 is the max, 2 would be a potential partition point. (It is the correct one.)\\n\\nThere are 2 cases when we find a potential: it is the right one, or it is the wrong one:\\n\\n1. CORRECT CASE: If we encounter a number that is the same or larger, this is a potential partition. When we do, we need to scan from that number to the end of the array. If all numbers after are larger than our current max, then we have found the partition point, so just return end (which marks the size of the array). Example:  [5,0,3,5,6,7]. Max 5. We scan until we hit 5. Because 5 >= max (5) we can consider this the partition point. Scan until end. 5 is equal. (Equal is valid! think of a case like [1,1].) 6 is larger. 7 is larger. And we\\'ve hit the end of the array. Return end.\\n \\n1. INCORRECT CASE: The other case to consider is that this is a false partition point. Think of a case like: [5,0,3,6,7,2,10,11]. 6 is a potential point of partition but it is not correct. The answer is [5,0,3,6,7,2], [10,11]. If we encounter this case what can we do? We need to restart our search for the next candidate. However there can be numbers in our loop that are the new maximums (6, 7) that we are now calling part of our left partition, so in our searching loop we need to update the new maximum. The next candidate must be equal to or larger than 7.\\n\\nRepeat until end of the loop. If we have not found anything yet, the left partition is the entire array, so return the length of A.\\n\\nO(n) time because we never backtrack on our pointer. In the for loop, if we have the wrong partition point, we move end up to where the loop was scanning. If we have the right one we return the answer.\\nO(1) space just using a max variable and pointer.\\n\\nNot the cleanest solution, but I think with the thought process/code explained it is easy to follow or come up with alone.\\n\\n```\\n    public int partitionDisjoint(int[] A) {\\n        if (A.length <= 1) return A.length;\\n\\n        int max = A[0];\\n        int end = 1;\\n\\n        while (end < A.length) {\\n            if (A[end] >= max) { /* we have reached a potential partition point here*/\\n                boolean correct = true; /* end is the correct point unless we find a number in right smaller than max*/\\n                int newMax = max; /*temp variable to find the new max, if exists*/\\n                for (int i = end; i < A.length; ++i) { /*loop through the rest of the array and see if this is the correct partition point or not*/\\n                    newMax = Math.max(newMax, A[i]); /*update new max, if exists */\\n                    if (A[i] < max) { /*there is a smaller number in right of end so this point is not the answer. update end, max and keep scanning.*/\\n                        end = i; /* move end up to the number we just found smaller than max, the next num is the next valid point to check */\\n                        max = newMax; /*new maximum number in left array */\\n                        correct = false; /* there is a smaller number in right, we have not found the correct point */\\n                        break;\\n                    }\\n                }\\n                if (correct) { /*we have reached here without finding any smaller numbers (entering the above for loop), all numbers are larger than max in left. Return end.*/\\n                    return end;\\n                }\\n            }\\n            end++;\\n        }\\n        return A.length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 435454,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "**Explanation**\\n\\nThe idea is to grow the solution from left to right. The left partition starts with a partition of size 1. To grow the partition, we just need to iterate through all the items & check if the current item should be inserted into the left partition. It is important to note that the left partition is not necessarily be `n - 1` (if the current index is `n`). In the code below, the left partition index is stored as `ans`.\\n\\n`dp` is needed here for a fast lookup of the largest value for given left partition. Given a left partition with its right-most index being `n`, `dp[n]` equals the largest value of the partition that ends at index `n`.\\n\\nThe _boxes_ in the diagram below are drawn everytime we update the size of the left partition. Notice that in _eg 2_, we skip two items (denoted with the _x_) before doing the final partition of length `4`. In _eg 2_, when deciding to grow the partition the second time, we compare the largest value of the first _box_ (with one item in it).\\n\\n![image](https://assets.leetcode.com/users/cglotr/image_1574476397.png)\\n\\n**Code**\\n\\n```Java\\nclass Solution {\\n    \\n    public int partitionDisjoint(int[] A) {\\n        int m = A.length;\\n        \\n\\t\\t// if i want to know what is the largest value of\\n\\t\\t// the left partition that ends with index 3, dp[3]\\n\\t\\t// will give me the answer to that\\n        int[] dp = new int[m];\\n        dp[0] = A[0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i] = Math.max(dp[i - 1], A[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (A[i] < dp[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    \\n}\\n\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    \\n    public int partitionDisjoint(int[] A) {\\n        int m = A.length;\\n        \\n\\t\\t// if i want to know what is the largest value of\\n\\t\\t// the left partition that ends with index 3, dp[3]\\n\\t\\t// will give me the answer to that\\n        int[] dp = new int[m];\\n        dp[0] = A[0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i] = Math.max(dp[i - 1], A[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (A[i] < dp[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395196,
                "title": "intuitive-java-solution",
                "content": "```\\npublic int partitionDisjoint(int[] a) {\\n        int n = a.length;\\n        int[] maxFromLeft = new int[n], minFromRight = new int[n];\\n        maxFromLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            maxFromLeft[i] = Math.max(a[i], maxFromLeft[i-1]);\\n        minFromRight[n-1] = a[n-1];\\n        for(int i=n-2; i >= 0; i--)\\n            minFromRight[i] = Math.min(a[i], minFromRight[i+1]);\\n        for(int i=0; i < n-1; i++)\\n            if(maxFromLeft[i] <= minFromRight[i+1])\\n                return i+1;\\n        return 0;\\n    }\\n```\\n**PS** It is not hard to implement the same logic without `maxFromLeft` array completely.\\n",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] a) {\\n        int n = a.length;\\n        int[] maxFromLeft = new int[n], minFromRight = new int[n];\\n        maxFromLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            maxFromLeft[i] = Math.max(a[i], maxFromLeft[i-1]);\\n        minFromRight[n-1] = a[n-1];\\n        for(int i=n-2; i >= 0; i--)\\n            minFromRight[i] = Math.min(a[i], minFromRight[i+1]);\\n        for(int i=0; i < n-1; i++)\\n            if(maxFromLeft[i] <= minFromRight[i+1])\\n                return i+1;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378529,
                "title": "python-3-solution-beats-97-time-o-n-space-o-1",
                "content": "\\n```\\ndef partitionDisjoint(A: list):\\n    left_max = A[0]\\n    next_max = 0\\n    res = 0\\n    for i in range(1, len(A)):\\n        if A[i] > next_max:\\n            next_max = A[i]\\n        if A[i] < left_max:\\n            res = i\\n            if next_max > left_max:\\n                left_max = next_max\\n    return res + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef partitionDisjoint(A: list):\\n    left_max = A[0]\\n    next_max = 0\\n    res = 0\\n    for i in range(1, len(A)):\\n        if A[i] > next_max:\\n            next_max = A[i]\\n        if A[i] < left_max:\\n            res = i\\n            if next_max > left_max:\\n                left_max = next_max\\n    return res + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 273269,
                "title": "java-two-solutions-with-explanation",
                "content": "* scan from left to right and right to left\\n* we just need to make sure the `max` of left part is smaller or equal to `min` of right part\\n\\n```\\npublic int partitionDisjoint(int[] A) {\\n        int n = A.length, ltr[] = new int[n], rtl[] = new int[n], max = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, A[i]);\\n            ltr[i] = max;\\n            min = Math.min(min, A[n - 1 - i]);\\n            rtl[n - 1 - i] = min;\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ltr[i] <= rtl[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```\\n\\n\\n * optimization:\\n * keep track of cur/left max\\n * keep track of the position/index of partition\\n * scan through the array:\\n   *   if max value is larger then cur max, that is good\\n   *   if after that max value, there is an element smaller then cur max, then we should update the cur max as max\\n   *   and that is the reason, we also need to keep track of `max` which means the maximum value of all previous element\\n\\n```\\n    public int partitionDisjoint1(int[] A) {\\n        int curMax = A[0], pos = 0, max = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                pos = i;\\n                curMax = max;\\n            } else if (A[i] > max) {\\n                max = A[i];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int n = A.length, ltr[] = new int[n], rtl[] = new int[n], max = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, A[i]);\\n            ltr[i] = max;\\n            min = Math.min(min, A[n - 1 - i]);\\n            rtl[n - 1 - i] = min;\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ltr[i] <= rtl[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```\n```\\n    public int partitionDisjoint1(int[] A) {\\n        int curMax = A[0], pos = 0, max = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                pos = i;\\n                curMax = max;\\n            } else if (A[i] > max) {\\n                max = A[i];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251736,
                "title": "python-solution-o-n-runtime-o-1-space",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        prevbest = A[0]\\n        best = A[0]\\n        n = len(A)\\n\\n        ans = 0\\n        for i in range(1, n - 1):\\n            best = max(best, A[i])\\n            if A[i] < prevbest:\\n                prevbest = best\\n                ans = i\\n\\n        return ans + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        prevbest = A[0]\\n        best = A[0]\\n        n = len(A)\\n\\n        ans = 0\\n        for i in range(1, n - 1):\\n            best = max(best, A[i])\\n            if A[i] < prevbest:\\n                prevbest = best\\n                ans = i\\n\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187610,
                "title": "javascript-one-pass-solution-explanation-with-example",
                "content": "Explanation with example [1,1,1,0,6,0,5,7,12]\\n1: Initial partition >> [1],[1,1,0,6,0,5,7,12] && leftMaxValue=1\\n2: Once you find a smaller value(0), repartition >> [1,1,1,0], [6,0,5,7,12] && leftMaxValue=1\\n3: Find a smaller value(0), repartition >> [1,1,1,,0,6,0],[5,7,12] && leftMaxValue=6\\n4: Find a smaller value(0), repartition >> [1,1,1,0,6,0],[5,7,12] && leftMaxValue=6 \\n5: Find a smaller value(5), repartition >>  [1,1,1,,0,6,0,5],[7,12] && leftMaxValue=6 \\n6: Final >> left count = 7\\n```\\nvar partitionDisjoint = function(array) {\\n  var lLast = 0, lMaxValue = array[0];\\n  var rMaxValue= null;\\n  for(var i=1; i<array.length; i++) {\\n    var value = array[i];\\n    if(value >= lMaxValue) {\\n      rMaxValue = Math.max(rMaxValue||-Number.MAX_VALUE, value);\\n    } else {\\n      lLast=i;\\n      lMaxValue = Math.max(lMaxValue, rMaxValue||-Number.MAX_VALUE);\\n    }\\n  }\\n  return lLast+1;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar partitionDisjoint = function(array) {\\n  var lLast = 0, lMaxValue = array[0];\\n  var rMaxValue= null;\\n  for(var i=1; i<array.length; i++) {\\n    var value = array[i];\\n    if(value >= lMaxValue) {\\n      rMaxValue = Math.max(rMaxValue||-Number.MAX_VALUE, value);\\n    } else {\\n      lLast=i;\\n      lMaxValue = Math.max(lMaxValue, rMaxValue||-Number.MAX_VALUE);\\n    }\\n  }\\n  return lLast+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178330,
                "title": "simple-java-solution-time-o-n-one-pass-space-o-1",
                "content": "```\\nclass Solution {\\n public int partitionDisjoint(int[] A) {\\n  int globalMax = A[0];\\n  int localMax = A[0];\\n  int left = 1;\\n  for (int i = 1; i < A.length; i++) {\\n   if (A[i] < globalMax) {\\n    left = i + 1;\\n    globalMax = localMax;\\n   } else if (A[i] > localMax) {\\n    localMax = A[i];\\n   }\\n  }\\n  return left;\\n }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public int partitionDisjoint(int[] A) {\\n  int globalMax = A[0];\\n  int localMax = A[0];\\n  int left = 1;\\n  for (int i = 1; i < A.length; i++) {\\n   if (A[i] < globalMax) {\\n    left = i + 1;\\n    globalMax = localMax;\\n   } else if (A[i] > localMax) {\\n    localMax = A[i];\\n   }\\n  }\\n  return left;\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177399,
                "title": "python3-solution-o-n-time-o-1-space-with-explanation",
                "content": "The whole logic is to keep track of possible left set. The way to do is to keep track of the current known left set\\'s ending index and update it as needed. When it needs to get updated is when currently examined number is less than the current possible left set\\'s end or current possible left set\\'s maximum number is greater than the currently examined number. In those cases, possible left set\\'s end index needs to be set as the currently examined number and possible left set\\'s local max needs to be updated with currently known global max. Global max is the max number that is known up to and including the currently examined number.\\n1. Loop through all numbers\\n2. Update global max number if currrent number is greater. \\n3. If number in index is less than the current candidate number where left set ends or number at index is less than the max number of current potential left set, then update current as current index. Also update current local max with global max.\\n4. Return current candidate index + 1. The reason for +1 is to make up for array indices starting from 0.\\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current = (A[0],0)\\n        localMax,globalMax = A[0],A[0]         \\n        \\n        for i in range(1,len(A)):            \\n            value,index = current\\n            if A[i] > globalMax:\\n                globalMax = A[i]            \\n            if A[i] < value or localMax > A[i]:\\n                current = (A[i],i)    \\n                localMax = globalMax\\n                                                     \\n        return current[1] + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current = (A[0],0)\\n        localMax,globalMax = A[0],A[0]         \\n        \\n        for i in range(1,len(A)):            \\n            value,index = current\\n            if A[i] > globalMax:\\n                globalMax = A[i]            \\n            if A[i] < value or localMax > A[i]:\\n                current = (A[i],i)    \\n                localMax = globalMax\\n                                                     \\n        return current[1] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176131,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rmin = [0]*len(A)\\n        currmin = float(\\'inf\\')\\n        for i in range(len(A)-1, -1, -1):\\n            currmin = min(currmin, A[i])\\n            rmin[i] = currmin\\n            \\n        lmax = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            lmax = max(A[i], lmax)\\n            if lmax <= rmin[i+1]:\\n                return i+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rmin = [0]*len(A)\\n        currmin = float(\\'inf\\')\\n        for i in range(len(A)-1, -1, -1):\\n            currmin = min(currmin, A[i])\\n            rmin[i] = currmin\\n            \\n        lmax = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            lmax = max(A[i], lmax)\\n            if lmax <= rmin[i+1]:\\n                return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175985,
                "title": "different-thinking-intuitive-explanation",
                "content": "This is not a one-pass solution and surely with a higher complexity. However, did not find this approach in other solution and though to mention it in the Discuss. \\n\\nAlgorithm : \\n1. Find an element that will always be in the partition and call it `val`\\n2. Mark all the elements in the array that are `less` than the above `val` \\n3. Repeat the process until we have `no gaps` in the partition. \\n\\nObservation 1 : The left most element of the array is always going to be a part of the partition. \\nReasons : It is guaranteed there is at least one way to partition A as described.\\n`Conclusion : The left most element sets as val for our first iteration.`\\n\\nFor e.g. : \\n![image](https://assets.leetcode.com/users/shreyansh94/image_1538291154.png)\\n\\nThus, return `5`, the length of the marked region. \\n\\nCode : \\n\\n```\\nclass Solution {\\n    public int findVal(boolean[] see, int[] A){\\n        for(int i = 0; i<A.length; ++i){\\n            if(!see[i])\\n                return i; \\n        }\\n        return -1; \\n    }\\n    public int partitionDisjoint(int[] A) {\\n        boolean[] see = new boolean[A.length]; \\n        boolean gap = true;  \\n        while(gap){\\n            gap = false; \\n            int ind = findVal(see, A);\\n            if(ind == -1)\\n                break; \\n            int val=A[ind]; \\n            see[ind]=true; \\n            for(int i = 0; i < A.length; ++i){\\n                if(A[i] < val){\\n                    see[i] = true; \\n                    if(i!=0 && see[i-1] == false)gap=true; \\n                }\\n            }\\n        }\\n        int count = 0; \\n        for(int i = 0 ; i < A.length; ++i){\\n            if(see[i])count++; \\n        }\\n        return count; \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findVal(boolean[] see, int[] A){\\n        for(int i = 0; i<A.length; ++i){\\n            if(!see[i])\\n                return i; \\n        }\\n        return -1; \\n    }\\n    public int partitionDisjoint(int[] A) {\\n        boolean[] see = new boolean[A.length]; \\n        boolean gap = true;  \\n        while(gap){\\n            gap = false; \\n            int ind = findVal(see, A);\\n            if(ind == -1)\\n                break; \\n            int val=A[ind]; \\n            see[ind]=true; \\n            for(int i = 0; i < A.length; ++i){\\n                if(A[i] < val){\\n                    see[i] = true; \\n                    if(i!=0 && see[i-1] == false)gap=true; \\n                }\\n            }\\n        }\\n        int count = 0; \\n        for(int i = 0 ; i < A.length; ++i){\\n            if(see[i])count++; \\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175846,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        while True:\\n            left = A[:i]\\n            right = A[i:]\\n            if max(left) > min(right):\\n                i += right.index(min(right)) + 1\\n            else:\\n                return i\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        while True:\\n            left = A[:i]\\n            right = A[i:]\\n            if max(left) > min(right):\\n                i += right.index(min(right)) + 1\\n            else:\\n                return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087480,
                "title": "intuitive-2-pointer-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        c_h, c_l, min_greater, max_smaller=0, 1, math.inf, nums[0]\\n        max_greater= -math.inf\\n        for i, num in enumerate(nums[1:]):\\n            if num<min_greater and num<max_smaller:\\n                c_l+=c_h+1\\n                if c_h:\\n                    max_smaller = max(max_smaller, max_greater)\\n                    c_h =0\\n                    min_greater = max_greater\\n                max_smaller = max(max_smaller, num)\\n            else:\\n                c_h +=1\\n                max_greater= max(max_greater, num)\\n                min_greater = min(min_greater, num)                \\n        return c_l\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        c_h, c_l, min_greater, max_smaller=0, 1, math.inf, nums[0]\\n        max_greater= -math.inf\\n        for i, num in enumerate(nums[1:]):\\n            if num<min_greater and num<max_smaller:\\n                c_l+=c_h+1\\n                if c_h:\\n                    max_smaller = max(max_smaller, max_greater)\\n                    c_h =0\\n                    min_greater = max_greater\\n                max_smaller = max(max_smaller, num)\\n            else:\\n                c_h +=1\\n                max_greater= max(max_greater, num)\\n                min_greater = min(min_greater, num)                \\n        return c_l\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056615,
                "title": "easiest-solution-c-for-sure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int prevelement=nums[0];\\n        int  ans=1;\\n        int maxi=prevelement;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<prevelement)\\n            {\\n                ans=i+1;\\n                prevelement=maxi;\\n            }\\n            maxi=max(maxi,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int prevelement=nums[0];\\n        int  ans=1;\\n        int maxi=prevelement;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<prevelement)\\n            {\\n                ans=i+1;\\n                prevelement=maxi;\\n            }\\n            maxi=max(maxi,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015746,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] rightMin=new int[nums.length+1];\\n        rightMin[nums.length]=Integer.MAX_VALUE;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            rightMin[i]=Math.min(rightMin[i+1],nums[i]);\\n        }\\n        int leftMax=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            leftMax=Math.max(leftMax,nums[i]);\\n            if(leftMax<=rightMin[i+1])\\n            {\\n                ans=i;\\n                break;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] rightMin=new int[nums.length+1];\\n        rightMin[nums.length]=Integer.MAX_VALUE;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            rightMin[i]=Math.min(rightMin[i+1],nums[i]);\\n        }\\n        int leftMax=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            leftMax=Math.max(leftMax,nums[i]);\\n            if(leftMax<=rightMin[i+1])\\n            {\\n                ans=i;\\n                break;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905267,
                "title": "simplest-method-only-by-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlook for the min value .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst compare the lower value then the first value. Then update the max value we get upto that minimum value and now search for the next minimum value and continue the same thing .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0;\\n        int b=nums[0];\\n        int m=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(m<nums[i]){\\n                m=nums[i];\\n            }\\n            if(b>nums[i]){\\n                a=i;\\n                b=m;\\n               \\n            }\\n        }\\n        return a+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0;\\n        int b=nums[0];\\n        int m=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(m<nums[i]){\\n                m=nums[i];\\n            }\\n            if(b>nums[i]){\\n                a=i;\\n                b=m;\\n               \\n            }\\n        }\\n        return a+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881278,
                "title": "cpp-solution-fast-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int mini = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int i = mini + 1;\\n        int ind = mini;\\n        vector<int> v(nums.size(),nums[0]);\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            if(v[j-1] < nums[j])\\n                v[j] = nums[j];\\n            else\\n                v[j] = v[j-1];\\n        }\\n        int maxi = v[mini];\\n        for(;i<nums.size()-1;i++)\\n        {\\n            if(nums[i] < maxi)\\n            {\\n                ind = i;\\n                maxi = v[i];\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n// 2 1 4 0 10 3 9 7 11 \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int mini = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int i = mini + 1;\\n        int ind = mini;\\n        vector<int> v(nums.size(),nums[0]);\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            if(v[j-1] < nums[j])\\n                v[j] = nums[j];\\n            else\\n                v[j] = v[j-1];\\n        }\\n        int maxi = v[mini];\\n        for(;i<nums.size()-1;i++)\\n        {\\n            if(nums[i] < maxi)\\n            {\\n                ind = i;\\n                maxi = v[i];\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n// 2 1 4 0 10 3 9 7 11 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866792,
                "title": "partition-array-into-disjoint-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BRUTE-FORCE- use chaining method intuition , use extra space as array , storing right min ie from back minimum and left max ,storing max from starting i respective array using chaining method . and then traverse array, and check left max value if found <= its next index right min value then that indx is the partition.\\nT-n S-n\\nOPTIMAL- USE 2  var greater and leftmax, greater storing max value during traversing and left max storing that greater vale when parrtitions found, during traversing , if any value found less than leftmax, it indicates that number is also a part of partition and that indx makes the partition. and replace value with greater to find more partition. T-n S-1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BRUTE-FORCE- use chaining method intuition , use extra space as array , storing right min ie from back minimum and left max ,storing max from starting i respective array using chaining method . and then traverse array, and check left max value if found <= its next index right min value then that indx is the partition.\\nT-n S-n\\nOPTIMAL- USE 2  var greater and leftmax, greater storing max value during traversing and left max storing that greater vale when parrtitions found, during traversing , if any value found less than leftmax, it indicates that number is also a part of partition and that indx makes the partition. and replace value with greater to find more partition. T-n S-1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int greater=nums[0];//will store the max value while traversing\\n        int leftmax=nums[0];//will store the value greater when we found a partition , ie num<leftmax, ie we have to add it in partition and , that num index is the partition\\n\\n        int ans=0;\\n\\n        for(int i=1;i<nums.size();i++)//we traverse the array\\n        {\\n            if(nums[i]<leftmax)//if found number less than leftmax ie number should be included in partition ,\\n            //                      then that number indx will be assigned to ans , and greater value to new leftmax\\n            {\\n                leftmax=greater;\\n                ans=i;\\n            }\\n            if(nums[i]>greater)//if found no >greater than assign that value to greater\\n            {\\n                greater=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n\\n// class Solution {                         //using extra space ie S-n using to store right minimum using CHAINING method, \\n//                                            for left max and right min\\n// public:\\n//     int partitionDisjoint(vector<int>& nums) {\\n\\n//         int n=nums.size();\\n//         vector<int>rmn(n+1);\\n       \\n//         rmn[n]=INT_MAX;\\n//         for(int i=n-1;i>=0;i--)\\n//         {\\n//             rmn[i]=min(nums[i],rmn[i+1]);\\n//         }\\n\\n//         int lmx=INT_MIN;\\n//         int ans=0;\\n//         for(int i=0;i<n-1;i++)\\n//         {\\n//             lmx=max(nums[i],lmx);\\n//             if(lmx<=rmn[i+1])\\n//             {\\n//                 ans=i;\\n//                 break;\\n//             }\\n//         }\\n\\n//         return ans+1;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int greater=nums[0];//will store the max value while traversing\\n        int leftmax=nums[0];//will store the value greater when we found a partition , ie num<leftmax, ie we have to add it in partition and , that num index is the partition\\n\\n        int ans=0;\\n\\n        for(int i=1;i<nums.size();i++)//we traverse the array\\n        {\\n            if(nums[i]<leftmax)//if found number less than leftmax ie number should be included in partition ,\\n            //                      then that number indx will be assigned to ans , and greater value to new leftmax\\n            {\\n                leftmax=greater;\\n                ans=i;\\n            }\\n            if(nums[i]>greater)//if found no >greater than assign that value to greater\\n            {\\n                greater=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n\\n// class Solution {                         //using extra space ie S-n using to store right minimum using CHAINING method, \\n//                                            for left max and right min\\n// public:\\n//     int partitionDisjoint(vector<int>& nums) {\\n\\n//         int n=nums.size();\\n//         vector<int>rmn(n+1);\\n       \\n//         rmn[n]=INT_MAX;\\n//         for(int i=n-1;i>=0;i--)\\n//         {\\n//             rmn[i]=min(nums[i],rmn[i+1]);\\n//         }\\n\\n//         int lmx=INT_MIN;\\n//         int ans=0;\\n//         for(int i=0;i<n-1;i++)\\n//         {\\n//             lmx=max(nums[i],lmx);\\n//             if(lmx<=rmn[i+1])\\n//             {\\n//                 ans=i;\\n//                 break;\\n//             }\\n//         }\\n\\n//         return ans+1;\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855653,
                "title": "o-n-solution-using-prefix-and-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n\\n        # max(0 to i) > min(i + 1 :) \\n        n = len(nums)\\n\\n        prefix_max = [nums[i] for i in range(n)]\\n\\n        for i in range(1, n):\\n\\n            if nums[i] > prefix_max[i - 1]:\\n                prefix_max[i] = nums[i] \\n            else:\\n                prefix_max[i] = prefix_max[i - 1] \\n\\n        suffix_min = [nums[i] for i in range(n)] \\n\\n        for i in range(n - 2, -1, -1):\\n\\n            if nums[i] < suffix_min[i + 1]:\\n                suffix_min[i] = nums[i] \\n            else:\\n                suffix_min[i] = suffix_min[i + 1]\\n\\n        for i in range(n - 1):\\n\\n            if prefix_max[i] <= suffix_min[i + 1]:\\n                return i + 1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n\\n        # max(0 to i) > min(i + 1 :) \\n        n = len(nums)\\n\\n        prefix_max = [nums[i] for i in range(n)]\\n\\n        for i in range(1, n):\\n\\n            if nums[i] > prefix_max[i - 1]:\\n                prefix_max[i] = nums[i] \\n            else:\\n                prefix_max[i] = prefix_max[i - 1] \\n\\n        suffix_min = [nums[i] for i in range(n)] \\n\\n        for i in range(n - 2, -1, -1):\\n\\n            if nums[i] < suffix_min[i + 1]:\\n                suffix_min[i] = nums[i] \\n            else:\\n                suffix_min[i] = suffix_min[i + 1]\\n\\n        for i in range(n - 1):\\n\\n            if prefix_max[i] <= suffix_min[i + 1]:\\n                return i + 1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773538,
                "title": "very-easy-c-solution-prefix-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the maximum of the array from left to right in the prefix array and minimum of the array from right to left. \\nNow at any position of prefix[i] < suffix[i+1] then return (i+1) index as answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],nums[i]);\\n        }\\n        // for(auto it:pre) cout<<it<<\" \";cout<<endl;\\n\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=min(suf[i+1],nums[i]);\\n        }\\n        // for(auto it:suf) cout<<it<<\" \";cout<<endl;\\n\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]<=suf[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],nums[i]);\\n        }\\n        // for(auto it:pre) cout<<it<<\" \";cout<<endl;\\n\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=min(suf[i+1],nums[i]);\\n        }\\n        // for(auto it:suf) cout<<it<<\" \";cout<<endl;\\n\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]<=suf[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3755112,
                "title": "interesting-possibilities-for-bayesians-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis one jumps out at me as it is an interesting use case for Bayesians. If we consider the values on the left as those that are of minimal confidence from a set of possible confidences, and we consider the list passed in repeated one shot evaluations without updates and random drops, we can actually utilize this to get a confidence measure of the valuations done at a drop out layer. \\n\\nAs for how the problem works, consider the values in order of nums as a time series of valuations. \\n\\nWe want to get the left hand side, the lesser valuations, to be of minimal size, these corresponding to those that are not currently generating greatest output. (in a more complex version, if we had a mapping of what network composition led to the lesser and greaters that could be used for tuning) \\n\\nTo do this, we keep track of the current maximum valuation, the possible maximum valuation, the left and right array size and a confidence measure. Not all of these are needed for the problem, and will be pointed out in the approach. \\n\\nIf we track the current max and the possible max we can find the valuations where the left and right split at throughout the time series. This let\\'s us partition in one shot in time N. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDuring initializations set up fields for current max, possible max, and left array size (others are outside problem scope) \\n\\nDuring partition of disjoint \\n- set current max to nums at 0 \\n- set possible max to nums at 0 \\n- set left array size to 1 \\n- set nL to length of nums \\n- for nums index n_i in range 1 to nL \\n    - if nums[n_i] lt current max \\n        - left array size is n_i + 1 \\n        - current max is possible max \\n    - otherwise \\n        - possible max is max of self and nums at n_i \\n- at the end return left array size      \\n\\n# Complexity\\n- Time complexity : O(N) \\n\\n- Space complexity : O(1)\\n\\n# Code\\n```\\nclass Solution :\\n    def __init__(self) : \\n        self.current_max = 0 \\n        self.possible_max = 0 \\n        self.left_array_size = 0 \\n        self.right_array_size = 0 \\n        self.confidence = 0 \\n\\n    def partitionDisjoint(self, nums : List[ int ]) -> int :\\n        # init process \\n        self.current_max = nums[0]\\n        self.possible_max = nums[0]\\n        self.left_array_size = 1 \\n        nL = len(nums)\\n\\n        for n_i in range(1, nL) :\\n            if nums[n_i] < self.current_max : \\n                self.left_array_size = n_i + 1 \\n                self.current_max = self.possible_max\\n            else : \\n                self.possible_max = max(self.possible_max, nums[n_i])\\n        self.right_array_size = nL - self.left_array_size\\n        self.confidence = self.right_array_size / nL \\n        return self.left_array_size\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    def __init__(self) : \\n        self.current_max = 0 \\n        self.possible_max = 0 \\n        self.left_array_size = 0 \\n        self.right_array_size = 0 \\n        self.confidence = 0 \\n\\n    def partitionDisjoint(self, nums : List[ int ]) -> int :\\n        # init process \\n        self.current_max = nums[0]\\n        self.possible_max = nums[0]\\n        self.left_array_size = 1 \\n        nL = len(nums)\\n\\n        for n_i in range(1, nL) :\\n            if nums[n_i] < self.current_max : \\n                self.left_array_size = n_i + 1 \\n                self.current_max = self.possible_max\\n            else : \\n                self.possible_max = max(self.possible_max, nums[n_i])\\n        self.right_array_size = nL - self.left_array_size\\n        self.confidence = self.right_array_size / nL \\n        return self.left_array_size\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693524,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-beats-100",
                "content": "\\n# Approach\\nWe know that \\n1. Every element in left is less than or equal to every element in right.\\n2. left and right are non-empty.\\n3. left has the smallest possible size.\\n\\nto meet the condition 1 we need to introduce leftMax so that whichever element is less than the leftMax it becomes a part of the left array.\\n\\nThe leftMax variable should be updated lets take an example:\\n\\n2 , 5 , 6 , 0 , 4 , 3 , 8 , 9\\nans = 6  \\nThe ans is not 4 because every element in left is less than or equal to every element in right. so if the elements 4 and 3  becomes a part of the right array it violates the condition. Hence we need tp update the leftMax.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int LeftMaxCumulative= 0;\\n        int localLeftMaxInsideRange= nums[0];\\n        int ans =1;\\n        int n = nums.length;\\n\\n        while(r<n)\\n        {\\n            if(localLeftMaxInsideRange>nums[r])\\n            {\\n                ans = r+1;\\n//updating left max \\n                localLeftMaxInsideRange = LeftMaxCumulative;\\n            }\\n\\n            if(nums[r]>LeftMaxCumulative)\\n                LeftMaxCumulative =nums[r];\\n\\n            r++;\\n        }\\n//atleast 1 element in left and right should be present.\\n        if(ans == n) return n-1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int LeftMaxCumulative= 0;\\n        int localLeftMaxInsideRange= nums[0];\\n        int ans =1;\\n        int n = nums.length;\\n\\n        while(r<n)\\n        {\\n            if(localLeftMaxInsideRange>nums[r])\\n            {\\n                ans = r+1;\\n//updating left max \\n                localLeftMaxInsideRange = LeftMaxCumulative;\\n            }\\n\\n            if(nums[r]>LeftMaxCumulative)\\n                LeftMaxCumulative =nums[r];\\n\\n            r++;\\n        }\\n//atleast 1 element in left and right should be present.\\n        if(ans == n) return n-1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655688,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int i;\\n        int n=nums.length;\\n        \\n        // finding the minimum element and its index bcs we have to take that much ele in left side\\n        int min=100001;\\n        int pos=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(min>=nums[i])\\n            {\\n                min=nums[i];\\n                pos=i;\\n            }\\n        }\\n        // it means if array is same 1 1 1 1 or 2 2 2\\n        if(pos==n-1)\\n            return 1;\\n        \\n        // finding the max ele from 0 to min idx \\n        int max=0;\\n        for(i=0;i<pos;i++)\\n        {\\n            max=Math.max(nums[i],max);\\n        }\\n        // now comparing the max ele with next indexes of min ele and updating pos1 \\n        int pos1=0;\\n        int max1=0;\\n        for(i=pos+1;i<n;i++)\\n        {\\n            if(max>nums[i])\\n            {\\n                pos1=i;\\n            }\\n        }\\n        // but what if array is like this\\n        // [29,33,6,4,42,0,10,22,62,16,46,75,100,67,70,74,87,69,73,88]\\n        // here pos1 is at 16 ele and max is 62 but we can see we can take 46 also\\n        // finding another maximum from 0 to pos1 index\\n        for(i=0;i<pos1;i++)\\n        {\\n            max1=Math.max(max1,nums[i]);\\n        }\\n        // now after comparing to rest of element after pos1\\n        int ans=pos1;\\n        for(i=pos1+1;i<n;i++)\\n        {\\n            if(max1>nums[i])\\n            {\\n                ans=i;\\n            }\\n        }\\n        // this means there is no element smaller than maxa\\n        if(pos1==0)\\n            return pos+1;\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int i;\\n        int n=nums.length;\\n        \\n        // finding the minimum element and its index bcs we have to take that much ele in left side\\n        int min=100001;\\n        int pos=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(min>=nums[i])\\n            {\\n                min=nums[i];\\n                pos=i;\\n            }\\n        }\\n        // it means if array is same 1 1 1 1 or 2 2 2\\n        if(pos==n-1)\\n            return 1;\\n        \\n        // finding the max ele from 0 to min idx \\n        int max=0;\\n        for(i=0;i<pos;i++)\\n        {\\n            max=Math.max(nums[i],max);\\n        }\\n        // now comparing the max ele with next indexes of min ele and updating pos1 \\n        int pos1=0;\\n        int max1=0;\\n        for(i=pos+1;i<n;i++)\\n        {\\n            if(max>nums[i])\\n            {\\n                pos1=i;\\n            }\\n        }\\n        // but what if array is like this\\n        // [29,33,6,4,42,0,10,22,62,16,46,75,100,67,70,74,87,69,73,88]\\n        // here pos1 is at 16 ele and max is 62 but we can see we can take 46 also\\n        // finding another maximum from 0 to pos1 index\\n        for(i=0;i<pos1;i++)\\n        {\\n            max1=Math.max(max1,nums[i]);\\n        }\\n        // now after comparing to rest of element after pos1\\n        int ans=pos1;\\n        for(i=pos1+1;i<n;i++)\\n        {\\n            if(max1>nums[i])\\n            {\\n                ans=i;\\n            }\\n        }\\n        // this means there is no element smaller than maxa\\n        if(pos1==0)\\n            return pos+1;\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631776,
                "title": "simple-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\nI have taken maxi to store greatest element in left subarray till now keeping in mind we need to keep it as small as possible.\\nI have taken maxi1 to store greatest till now and we replace with maxi whenever we get smaller element then maxi in an array.  \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int maxi=nums[0];\\n        int index=0;\\n        int maxi1=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<maxi)\\n            {\\n                index=i;\\n                maxi=maxi1;\\n            }\\n            if(nums[i]>maxi)\\n            {\\n                maxi1=max(maxi1,nums[i]);\\n            }\\n        }\\n\\n        return index+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int maxi=nums[0];\\n        int index=0;\\n        int maxi1=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<maxi)\\n            {\\n                index=i;\\n                maxi=maxi1;\\n            }\\n            if(nums[i]>maxi)\\n            {\\n                maxi1=max(maxi1,nums[i]);\\n            }\\n        }\\n\\n        return index+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600991,
                "title": "python-explained",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```\\n\\n**Explanation**\\n\\n1. The variables `left` and `right` represent the lengths of the left and right subarrays, respectively. `left` is initially set to 1 because it includes the first element of the array.\\n\\n2. The variables `cur_low` and `next_low` represent the lowest value found in the current subarray and the lowest value found in the next potential subarray, respectively. They are initialized with the first element of the array.\\n\\n3. The loop iterates over the remaining elements in the `nums` array, starting from the second element. For each element `val`, it checks if `val` is greater than or equal to the current lowest value (`cur_low`).\\n\\n4. If `val` is greater than or equal to `cur_low`, it means the element can be included in the right subarray. Therefore, `right` is incremented by 1, and `next_low` is updated to the maximum of its current value and `val` (to keep track of the lowest value in the potential next subarray).\\n\\n5. If `val` is less than `cur_low`, it means a partition needs to be made. The left subarray is extended by the length of the right subarray (`left += right`), and `right` is reset to 0. Additionally, `left` is incremented by 1 to account for the current element, and `cur_low` is updated to `next_low` to reflect the lowest value in the left subarray.\\n\\n6. Finally, the function returns the length of the left subarray (`left`).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558616,
                "title": "partition-array-into-disjoint-intervals",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int mxl = nums[0], i = 1, mx = nums[0];\\n        for(int j = 1; j < nums.size(); j++) {\\n            mx = max(mx, nums[j]);\\n            if(nums[j] < mxl) {\\n                i = j + 1;\\n                mxl = mx;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int mxl = nums[0], i = 1, mx = nums[0];\\n        for(int j = 1; j < nums.size(); j++) {\\n            mx = max(mx, nums[j]);\\n            if(nums[j] < mxl) {\\n                i = j + 1;\\n                mxl = mx;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554218,
                "title": "python3-solution-using-itertools-accumulate",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        prefix_max= list(accumulate(nums, max)) \\n        suffix_min = list(accumulate(nums[::-1], min))[::-1]\\n\\n        for i in range(n):\\n            if prefix_max[i]<=suffix_min[i+1]:\\n                return i+1\\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        prefix_max= list(accumulate(nums, max)) \\n        suffix_min = list(accumulate(nums[::-1], min))[::-1]\\n\\n        for i in range(n):\\n            if prefix_max[i]<=suffix_min[i+1]:\\n                return i+1\\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554207,
                "title": "python3-clean-suffix-min-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        suffix=[nums[-1]]\\n        \\n        for i in range(n-2,-1,-1):\\n            mn=min(nums[i],suffix[-1])\\n            suffix.append(mn)\\n        \\n        suffix.reverse()\\n        \\n        mx=-inf\\n        for i in range(n):\\n            mx=max(mx,nums[i])\\n            if mx<=suffix[i+1]:\\n                return i+1\\n        \\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        suffix=[nums[-1]]\\n        \\n        for i in range(n-2,-1,-1):\\n            mn=min(nums[i],suffix[-1])\\n            suffix.append(mn)\\n        \\n        suffix.reverse()\\n        \\n        mx=-inf\\n        for i in range(n):\\n            mx=max(mx,nums[i])\\n            if mx<=suffix[i+1]:\\n                return i+1\\n        \\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550475,
                "title": "with-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        var min = nums.Min();\\n        int j=0,i=0,max=-1;\\n        for(i=0;i<nums.Length;i++)\\n        {\\n            if(nums[i]==min) break;\\n            max = Math.Max(max,nums[i]);\\n        }\\n        return Find(nums,i,j,max)+1;\\n    }\\n    \\n    public int Find(int[] nums,int i,int j,int max)\\n    {\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        \\n        for(i=i;i<nums.Length;i++)\\n        {\\n            var assign =false;\\n            if(nums[i]<max) \\n            {\\n                j=i; \\n                assign =true;\\n            }\\n            pq.Enqueue(nums[i],nums[i]);\\n            if(assign) max =Math.Max(max,pq.Peek());\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        var min = nums.Min();\\n        int j=0,i=0,max=-1;\\n        for(i=0;i<nums.Length;i++)\\n        {\\n            if(nums[i]==min) break;\\n            max = Math.Max(max,nums[i]);\\n        }\\n        return Find(nums,i,j,max)+1;\\n    }\\n    \\n    public int Find(int[] nums,int i,int j,int max)\\n    {\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        \\n        for(i=i;i<nums.Length;i++)\\n        {\\n            var assign =false;\\n            if(nums[i]<max) \\n            {\\n                j=i; \\n                assign =true;\\n            }\\n            pq.Enqueue(nums[i],nums[i]);\\n            if(assign) max =Math.Max(max,pq.Peek());\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538574,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int max[] = new int[n];\\n        int min[] = new int[n];\\n        int a = nums[0],b=nums[n-1];\\n        for(int i =0 ;i< n;i++){\\n            a=Math.max(a,nums[i]);\\n            max[i]=a;\\n        }\\n        for(int i= n-1;i>=0;i--){\\n            b=Math.min(b,nums[i]);\\n            min[i]=b;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(max[i-1]<=min[i])\\n                return i;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int max[] = new int[n];\\n        int min[] = new int[n];\\n        int a = nums[0],b=nums[n-1];\\n        for(int i =0 ;i< n;i++){\\n            a=Math.max(a,nums[i]);\\n            max[i]=a;\\n        }\\n        for(int i= n-1;i>=0;i--){\\n            b=Math.min(b,nums[i]);\\n            min[i]=b;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(max[i-1]<=min[i])\\n                return i;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516543,
                "title": "optimal-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int local_max=nums[0];\\n        int greater_max=nums[0];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<local_max){\\n                ans=i+1;\\n                local_max=greater_max;\\n            }\\n            else{\\n                greater_max=max(nums[i],greater_max);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int local_max=nums[0];\\n        int greater_max=nums[0];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<local_max){\\n                ans=i+1;\\n                local_max=greater_max;\\n            }\\n            else{\\n                greater_max=max(nums[i],greater_max);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515379,
                "title": "brute-force-one-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using one array\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            maxi=max(nums[i],maxi);\\n            if(maxi<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using one array\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            maxi=max(nums[i],maxi);\\n            if(maxi<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513709,
                "title": "brute-force-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using two arrays\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int> left(n,0);\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            maxi=max(nums[i],maxi);\\n            left[i]=maxi;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(left[i]<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using two arrays\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int> left(n,0);\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            maxi=max(nums[i],maxi);\\n            left[i]=maxi;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(left[i]<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488447,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int max1=nums[0],max2=nums[0],pos=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<max1){\\n                max1=max2;\\n                pos=i;\\n            }\\n            else{\\n                max2=Math.max(max2,nums[i]);\\n            }\\n        }\\n        return pos+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int max1=nums[0],max2=nums[0],pos=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<max1){\\n                max1=max2;\\n                pos=i;\\n            }\\n            else{\\n                max2=Math.max(max2,nums[i]);\\n            }\\n        }\\n        return pos+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484645,
                "title": "beats-96-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint check(vector<int>&nums,int maxi,int k)\\n{   int mini=nums[k+1];\\n    for(int i=k+2;i<nums.size();i++)\\n    {\\n      \\n     if(nums[i]<mini)\\n      mini=nums[i];\\n    }\\n    for(int i=0;i<k;i++)\\n    {\\n        if(nums[i]>mini)\\n         return 0;\\n    }\\n    return 1;\\n}\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int k;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         if(maxi<=nums[i])\\n         {\\n          maxi=nums[i];\\n          if(i>=nums.size()-1)\\n           return i;\\n          if(check(nums,maxi,i))\\n            return i;\\n         }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint check(vector<int>&nums,int maxi,int k)\\n{   int mini=nums[k+1];\\n    for(int i=k+2;i<nums.size();i++)\\n    {\\n      \\n     if(nums[i]<mini)\\n      mini=nums[i];\\n    }\\n    for(int i=0;i<k;i++)\\n    {\\n        if(nums[i]>mini)\\n         return 0;\\n    }\\n    return 1;\\n}\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int k;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         if(maxi<=nums[i])\\n         {\\n          maxi=nums[i];\\n          if(i>=nums.size()-1)\\n           return i;\\n          if(check(nums,maxi,i))\\n            return i;\\n         }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418864,
                "title": "space-complexity-o-1-python-one-pass-solution",
                "content": "\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        last_left=0\\n        maxi=nums[0]\\n        large=0\\n        for i in range(len(nums)):\\n            if nums[i]<maxi:\\n                if large:\\n                    maxi=large\\n                last_left=i\\n                \\n            elif nums[i]>maxi:\\n                large=max(large,nums[i])\\n        return last_left+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        last_left=0\\n        maxi=nums[0]\\n        large=0\\n        for i in range(len(nums)):\\n            if nums[i]<maxi:\\n                if large:\\n                    maxi=large\\n                last_left=i\\n                \\n            elif nums[i]>maxi:\\n                large=max(large,nums[i])\\n        return last_left+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392675,
                "title": "cpp-solution-using-a-max-array-prefix-sum-kind-of-technique-self-explanatory-code",
                "content": "\\n\\n# Approach\\nKeep a max array such that mx[i] contains the maximum element of the array in [0-i]\\nEstablish the minimum min_right as nums[0], i.e., the lowest element in the beginning.\\nIf we find something greater than our current minimum min_right, that element must be included in the right partition.\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\nHere, N = number of elements present in the given array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        vector<int> mx(n);\\n\\n        int min_right = nums[n-1];\\n        mx[0] = nums[0];\\n\\n        for(int i=1;i<n;i++) {\\n            mx[i] = max(nums[i], mx[i-1]);\\n        }\\n        for(int i=n-1;i>=1;i--) {\\n            min_right = min(min_right, nums[i]);\\n            if(min_right >= mx[i-1]) {\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        vector<int> mx(n);\\n\\n        int min_right = nums[n-1];\\n        mx[0] = nums[0];\\n\\n        for(int i=1;i<n;i++) {\\n            mx[i] = max(nums[i], mx[i-1]);\\n        }\\n        for(int i=n-1;i>=1;i--) {\\n            min_right = min(min_right, nums[i]);\\n            if(min_right >= mx[i-1]) {\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389299,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int Ans=0,Max=nums[0];\\n        int minmax=Max;\\n        bool yes=true;\\n        for(int i=1; i<nums.size(); i++) {\\n            minmax=max(nums[i],minmax);\\n            if(nums[i]>=Max && yes) {\\n                Ans=i;\\n                yes=false;\\n            }\\n            if(nums[i]<Max) {\\n                Max=minmax;\\n                yes=true;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int Ans=0,Max=nums[0];\\n        int minmax=Max;\\n        bool yes=true;\\n        for(int i=1; i<nums.size(); i++) {\\n            minmax=max(nums[i],minmax);\\n            if(nums[i]>=Max && yes) {\\n                Ans=i;\\n                yes=false;\\n            }\\n            if(nums[i]<Max) {\\n                Max=minmax;\\n                yes=true;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378628,
                "title": "simple-o-n-traversal-cpp",
                "content": "# Intuition and Approach\\n* initiallize the ans variable with 0, it will keep track of last element of out subarray.\\n* initiallize the maxi variable with nums[0],it will keep track of maximum element present in our sub array.\\n* now whlile traversing check wheather the current element is smaller then our maxi or not:\\n* * if smaller then ans=current index; maxi=maximum of all elements till now.\\n* * else continue.\\n* while traversing store the maximum of all the elements traversed till now including current one to the current position of array.\\n* at the end return ans+1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<maxi){\\n                ans=i;\\n                maxi=max(nums[i],nums[i-1]);\\n            }\\n            nums[i]=max(nums[i-1],nums[i]);\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<maxi){\\n                ans=i;\\n                maxi=max(nums[i],nums[i-1]);\\n            }\\n            nums[i]=max(nums[i-1],nums[i]);\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378366,
                "title": "python3-clean",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        x=len(nums)\\n        lst1=[0]*x\\n        lst2=[0]*x\\n\\n        lst1[0]=nums[0]\\n        for i in range(1,x):\\n            lst1[i]=max(lst1[i-1],nums[i])\\n\\n        lst2[x-1]=nums[x-1]\\n        for i in range(x-2,-1,-1):\\n            lst2[i]=min(lst2[i+1],nums[i])\\n\\n        for i in range(1,x):\\n            if lst1[i-1] <= lst2[i]:\\n                return i\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        x=len(nums)\\n        lst1=[0]*x\\n        lst2=[0]*x\\n\\n        lst1[0]=nums[0]\\n        for i in range(1,x):\\n            lst1[i]=max(lst1[i-1],nums[i])\\n\\n        lst2[x-1]=nums[x-1]\\n        for i in range(x-2,-1,-1):\\n            lst2[i]=min(lst2[i+1],nums[i])\\n\\n        for i in range(1,x):\\n            if lst1[i-1] <= lst2[i]:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378303,
                "title": "c-t-c-o-n-s-c-o-1-well-commented-code",
                "content": "# Intuition\\nThe smallest element in the right subarray has to be greater than or equal to the largest element in the left subarray\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums)\\n    {\\n        int L_Max=nums[0];//denotes the max element in the left subarray\\n        int l=0;//denotes the boundary of the left subarray\\n        int Max=nums[0];//denotes the max element till now(Index which we currently are on)\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            Max=max(Max,nums[i]);\\n            if(nums[i]<L_Max)//If the element is smaller than the max element in the left subarray then it can\\'t be in the right subarray\\n            {\\n                l=i;\\n                L_Max=Max;//The max element till now becomes the max element of left subarray\\n            }\\n        }\\n\\n        return l+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums)\\n    {\\n        int L_Max=nums[0];//denotes the max element in the left subarray\\n        int l=0;//denotes the boundary of the left subarray\\n        int Max=nums[0];//denotes the max element till now(Index which we currently are on)\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            Max=max(Max,nums[i]);\\n            if(nums[i]<L_Max)//If the element is smaller than the max element in the left subarray then it can\\'t be in the right subarray\\n            {\\n                l=i;\\n                L_Max=Max;//The max element till now becomes the max element of left subarray\\n            }\\n        }\\n\\n        return l+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378255,
                "title": "c-o-n-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minInd = -1,maxInd = -1;\\n        int minEle = INT_MAX,maxEle = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minEle>nums[i])\\n            {\\n                minEle = nums[i];\\n                minInd = i;\\n            }\\n            if(maxEle<nums[i])\\n            {\\n                maxEle = nums[i];\\n                maxInd = i;\\n            }\\n        }\\n\\n        int fInd = -1;\\n        maxEle = INT_MIN;\\n        for(int i=0;i<=minInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=minInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        for(int i=minInd+1;i<=fInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=fInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        if(fInd!=-1)\\n        return fInd+1;\\n        return minInd+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minInd = -1,maxInd = -1;\\n        int minEle = INT_MAX,maxEle = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minEle>nums[i])\\n            {\\n                minEle = nums[i];\\n                minInd = i;\\n            }\\n            if(maxEle<nums[i])\\n            {\\n                maxEle = nums[i];\\n                maxInd = i;\\n            }\\n        }\\n\\n        int fInd = -1;\\n        maxEle = INT_MIN;\\n        for(int i=0;i<=minInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=minInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        for(int i=minInd+1;i<=fInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=fInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        if(fInd!=-1)\\n        return fInd+1;\\n        return minInd+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377981,
                "title": "easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans=0;\\n        int x=nums[0],m=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<x){\\n                 ans=i;\\n                 x=m;\\n             }\\n             m=max(nums[i],m);\\n\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans=0;\\n        int x=nums[0],m=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<x){\\n                 ans=i;\\n                 x=m;\\n             }\\n             m=max(nums[i],m);\\n\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377690,
                "title": "o-n-c-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n    vector<int> l, s;\\n    int mn = INT_MAX, mx = INT_MIN, n = nums.size();\\n    s.push_back(0);\\n    for (int i = 0; i < nums.size(); i++){\\n            mx = max(mx, nums[i]);\\n            l.push_back(mx);\\n            mn = min(mn, nums[n - i - 1]);\\n            s.push_back(mn);\\n    }\\n    s.pop_back();\\n    reverse(s.begin(), s.end());\\n    int ind;\\n    for (int i = 0; i < nums.size()-1; i++){\\n        if( l[i]<= s[i])\\n        {\\n            ind = i;\\n        break;\\n        }\\n            \\n    }\\n    // cout << ind << endl;\\n    // for( auto x : l)\\n    //     cout << x << \" \";\\n\\n    return ind+1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n    vector<int> l, s;\\n    int mn = INT_MAX, mx = INT_MIN, n = nums.size();\\n    s.push_back(0);\\n    for (int i = 0; i < nums.size(); i++){\\n            mx = max(mx, nums[i]);\\n            l.push_back(mx);\\n            mn = min(mn, nums[n - i - 1]);\\n            s.push_back(mn);\\n    }\\n    s.pop_back();\\n    reverse(s.begin(), s.end());\\n    int ind;\\n    for (int i = 0; i < nums.size()-1; i++){\\n        if( l[i]<= s[i])\\n        {\\n            ind = i;\\n        break;\\n        }\\n            \\n    }\\n    // cout << ind << endl;\\n    // for( auto x : l)\\n    //     cout << x << \" \";\\n\\n    return ind+1;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3376652,
                "title": "easy-c-solution-using-max-and-min-idea",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n); // max array\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans;\\n        // max value of left side must be lesser than min value of right side\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n); // max array\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans;\\n        // max value of left side must be lesser than min value of right side\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363144,
                "title": "top-85-speed-top-95-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        current = -1\\n        current_in = nums[0]\\n        ans = 1\\n        for i in range(len(nums)-1):\\n            if current < nums[i]:\\n                current = nums[i]\\n            if current_in > nums[i]:\\n                current_in = current\\n                ans = i + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        current = -1\\n        current_in = nums[0]\\n        ans = 1\\n        for i in range(len(nums)-1):\\n            if current < nums[i]:\\n                current = nums[i]\\n            if current_in > nums[i]:\\n                current_in = current\\n                ans = i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569573,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1725380,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1947561,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1573351,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1975690,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1958859,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1904320,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            }
        ]
    }
]